/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function (global, factory) {
  /* global define, require, module */

  /* AMD */ if (typeof define === 'function' && define.amd) define(['protobufjs/minimal'], factory);
  /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
    module.exports = factory(require('protobufjs/minimal'));
})(this, function ($protobuf) {
  'use strict';

  // Common aliases
  var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util;

  // Exported root namespace
  var $root = $protobuf.roots['ununifi-client'] || ($protobuf.roots['ununifi-client'] = {});

  $root.ununifi = (function () {
    /**
     * Namespace ununifi.
     * @exports ununifi
     * @namespace
     */
    var ununifi = {};

    ununifi.auction = (function () {
      /**
       * Namespace auction.
       * @memberof ununifi
       * @namespace
       */
      var auction = {};

      auction.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.auction
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.auction.Query#params}.
         * @memberof ununifi.auction.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.auction.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.auction.Query
         * @instance
         * @param {ununifi.auction.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.auction.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(
              params,
              $root.ununifi.auction.QueryParamsRequest,
              $root.ununifi.auction.QueryParamsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.auction.Query
         * @instance
         * @param {ununifi.auction.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.auction.QueryParamsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.auction.Query#auction}.
         * @memberof ununifi.auction.Query
         * @typedef AuctionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.auction.QueryGetAuctionResponse} [response] QueryGetAuctionResponse
         */

        /**
         * Calls Auction.
         * @function auction
         * @memberof ununifi.auction.Query
         * @instance
         * @param {ununifi.auction.IQueryGetAuctionRequest} request QueryGetAuctionRequest message or plain object
         * @param {ununifi.auction.Query.AuctionCallback} callback Node-style callback called with the error, if any, and QueryGetAuctionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.auction = function auction(request, callback) {
            return this.rpcCall(
              auction,
              $root.ununifi.auction.QueryGetAuctionRequest,
              $root.ununifi.auction.QueryGetAuctionResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Auction' },
        );

        /**
         * Calls Auction.
         * @function auction
         * @memberof ununifi.auction.Query
         * @instance
         * @param {ununifi.auction.IQueryGetAuctionRequest} request QueryGetAuctionRequest message or plain object
         * @returns {Promise<ununifi.auction.QueryGetAuctionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.auction.Query#auctionAll}.
         * @memberof ununifi.auction.Query
         * @typedef AuctionAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.auction.QueryAllAuctionResponse} [response] QueryAllAuctionResponse
         */

        /**
         * Calls AuctionAll.
         * @function auctionAll
         * @memberof ununifi.auction.Query
         * @instance
         * @param {ununifi.auction.IQueryAllAuctionRequest} request QueryAllAuctionRequest message or plain object
         * @param {ununifi.auction.Query.AuctionAllCallback} callback Node-style callback called with the error, if any, and QueryAllAuctionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.auctionAll = function auctionAll(request, callback) {
            return this.rpcCall(
              auctionAll,
              $root.ununifi.auction.QueryAllAuctionRequest,
              $root.ununifi.auction.QueryAllAuctionResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'AuctionAll' },
        );

        /**
         * Calls AuctionAll.
         * @function auctionAll
         * @memberof ununifi.auction.Query
         * @instance
         * @param {ununifi.auction.IQueryAllAuctionRequest} request QueryAllAuctionRequest message or plain object
         * @returns {Promise<ununifi.auction.QueryAllAuctionResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      auction.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.auction
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.auction
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.auction.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.auction.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.QueryParamsRequest
         * @static
         * @param {ununifi.auction.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.auction.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.QueryParamsRequest
         * @static
         * @param {ununifi.auction.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.auction.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.QueryParamsRequest) return object;
          return new $root.ununifi.auction.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.QueryParamsRequest
         * @static
         * @param {ununifi.auction.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.auction.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      auction.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.auction
         * @interface IQueryParamsResponse
         * @property {ununifi.auction.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.auction
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.auction.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.auction.IParams|null|undefined} params
         * @memberof ununifi.auction.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.auction.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.QueryParamsResponse
         * @static
         * @param {ununifi.auction.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.auction.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.auction.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.QueryParamsResponse
         * @static
         * @param {ununifi.auction.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.auction.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.auction.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.auction.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.QueryParamsResponse) return object;
          var message = new $root.ununifi.auction.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.auction.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.auction.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.QueryParamsResponse
         * @static
         * @param {ununifi.auction.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.auction.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.auction.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      auction.QueryGetAuctionRequest = (function () {
        /**
         * Properties of a QueryGetAuctionRequest.
         * @memberof ununifi.auction
         * @interface IQueryGetAuctionRequest
         * @property {Long|null} [id] QueryGetAuctionRequest id
         */

        /**
         * Constructs a new QueryGetAuctionRequest.
         * @memberof ununifi.auction
         * @classdesc Represents a QueryGetAuctionRequest.
         * @implements IQueryGetAuctionRequest
         * @constructor
         * @param {ununifi.auction.IQueryGetAuctionRequest=} [properties] Properties to set
         */
        function QueryGetAuctionRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGetAuctionRequest id.
         * @member {Long} id
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @instance
         */
        QueryGetAuctionRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified QueryGetAuctionRequest message. Does not implicitly {@link ununifi.auction.QueryGetAuctionRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @static
         * @param {ununifi.auction.IQueryGetAuctionRequest} message QueryGetAuctionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetAuctionRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
          return writer;
        };

        /**
         * Encodes the specified QueryGetAuctionRequest message, length delimited. Does not implicitly {@link ununifi.auction.QueryGetAuctionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @static
         * @param {ununifi.auction.IQueryGetAuctionRequest} message QueryGetAuctionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetAuctionRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetAuctionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.QueryGetAuctionRequest} QueryGetAuctionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetAuctionRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.QueryGetAuctionRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.id = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetAuctionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.QueryGetAuctionRequest} QueryGetAuctionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetAuctionRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetAuctionRequest message.
         * @function verify
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetAuctionRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.id != null && message.hasOwnProperty('id'))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
              return 'id: integer|Long expected';
          return null;
        };

        /**
         * Creates a QueryGetAuctionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.QueryGetAuctionRequest} QueryGetAuctionRequest
         */
        QueryGetAuctionRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.QueryGetAuctionRequest) return object;
          var message = new $root.ununifi.auction.QueryGetAuctionRequest();
          if (object.id != null)
            if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
            else if (typeof object.id === 'number') message.id = object.id;
            else if (typeof object.id === 'object')
              message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a QueryGetAuctionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @static
         * @param {ununifi.auction.QueryGetAuctionRequest} message QueryGetAuctionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetAuctionRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults)
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.id = options.longs === String ? '0' : 0;
          if (message.id != null && message.hasOwnProperty('id'))
            if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
            else
              object.id =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.id)
                  : options.longs === Number
                  ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                  : message.id;
          return object;
        };

        /**
         * Converts this QueryGetAuctionRequest to JSON.
         * @function toJSON
         * @memberof ununifi.auction.QueryGetAuctionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetAuctionRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetAuctionRequest;
      })();

      auction.QueryGetAuctionResponse = (function () {
        /**
         * Properties of a QueryGetAuctionResponse.
         * @memberof ununifi.auction
         * @interface IQueryGetAuctionResponse
         * @property {google.protobuf.IAny|null} [auction] QueryGetAuctionResponse auction
         */

        /**
         * Constructs a new QueryGetAuctionResponse.
         * @memberof ununifi.auction
         * @classdesc Represents a QueryGetAuctionResponse.
         * @implements IQueryGetAuctionResponse
         * @constructor
         * @param {ununifi.auction.IQueryGetAuctionResponse=} [properties] Properties to set
         */
        function QueryGetAuctionResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGetAuctionResponse auction.
         * @member {google.protobuf.IAny|null|undefined} auction
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @instance
         */
        QueryGetAuctionResponse.prototype.auction = null;

        /**
         * Encodes the specified QueryGetAuctionResponse message. Does not implicitly {@link ununifi.auction.QueryGetAuctionResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @static
         * @param {ununifi.auction.IQueryGetAuctionResponse} message QueryGetAuctionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetAuctionResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.auction != null && Object.hasOwnProperty.call(message, 'auction'))
            $root.google.protobuf.Any.encode(message.auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryGetAuctionResponse message, length delimited. Does not implicitly {@link ununifi.auction.QueryGetAuctionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @static
         * @param {ununifi.auction.IQueryGetAuctionResponse} message QueryGetAuctionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetAuctionResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetAuctionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.QueryGetAuctionResponse} QueryGetAuctionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetAuctionResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.QueryGetAuctionResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.auction = $root.google.protobuf.Any.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetAuctionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.QueryGetAuctionResponse} QueryGetAuctionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetAuctionResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetAuctionResponse message.
         * @function verify
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetAuctionResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.auction != null && message.hasOwnProperty('auction')) {
            var error = $root.google.protobuf.Any.verify(message.auction);
            if (error) return 'auction.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryGetAuctionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.QueryGetAuctionResponse} QueryGetAuctionResponse
         */
        QueryGetAuctionResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.QueryGetAuctionResponse) return object;
          var message = new $root.ununifi.auction.QueryGetAuctionResponse();
          if (object.auction != null) {
            if (typeof object.auction !== 'object') throw TypeError('.ununifi.auction.QueryGetAuctionResponse.auction: object expected');
            message.auction = $root.google.protobuf.Any.fromObject(object.auction);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryGetAuctionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @static
         * @param {ununifi.auction.QueryGetAuctionResponse} message QueryGetAuctionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetAuctionResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.auction = null;
          if (message.auction != null && message.hasOwnProperty('auction'))
            object.auction = $root.google.protobuf.Any.toObject(message.auction, options);
          return object;
        };

        /**
         * Converts this QueryGetAuctionResponse to JSON.
         * @function toJSON
         * @memberof ununifi.auction.QueryGetAuctionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetAuctionResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetAuctionResponse;
      })();

      auction.QueryAllAuctionRequest = (function () {
        /**
         * Properties of a QueryAllAuctionRequest.
         * @memberof ununifi.auction
         * @interface IQueryAllAuctionRequest
         * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllAuctionRequest pagination
         */

        /**
         * Constructs a new QueryAllAuctionRequest.
         * @memberof ununifi.auction
         * @classdesc Represents a QueryAllAuctionRequest.
         * @implements IQueryAllAuctionRequest
         * @constructor
         * @param {ununifi.auction.IQueryAllAuctionRequest=} [properties] Properties to set
         */
        function QueryAllAuctionRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllAuctionRequest pagination.
         * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @instance
         */
        QueryAllAuctionRequest.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllAuctionRequest message. Does not implicitly {@link ununifi.auction.QueryAllAuctionRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @static
         * @param {ununifi.auction.IQueryAllAuctionRequest} message QueryAllAuctionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAuctionRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageRequest.encode(
              message.pagination,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllAuctionRequest message, length delimited. Does not implicitly {@link ununifi.auction.QueryAllAuctionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @static
         * @param {ununifi.auction.IQueryAllAuctionRequest} message QueryAllAuctionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAuctionRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllAuctionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.QueryAllAuctionRequest} QueryAllAuctionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAuctionRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.QueryAllAuctionRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllAuctionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.QueryAllAuctionRequest} QueryAllAuctionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAuctionRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllAuctionRequest message.
         * @function verify
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllAuctionRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllAuctionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.QueryAllAuctionRequest} QueryAllAuctionRequest
         */
        QueryAllAuctionRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.QueryAllAuctionRequest) return object;
          var message = new $root.ununifi.auction.QueryAllAuctionRequest();
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.auction.QueryAllAuctionRequest.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllAuctionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @static
         * @param {ununifi.auction.QueryAllAuctionRequest} message QueryAllAuctionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllAuctionRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.pagination = null;
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllAuctionRequest to JSON.
         * @function toJSON
         * @memberof ununifi.auction.QueryAllAuctionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllAuctionRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllAuctionRequest;
      })();

      auction.QueryAllAuctionResponse = (function () {
        /**
         * Properties of a QueryAllAuctionResponse.
         * @memberof ununifi.auction
         * @interface IQueryAllAuctionResponse
         * @property {Array.<google.protobuf.IAny>|null} [auctions] QueryAllAuctionResponse auctions
         * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllAuctionResponse pagination
         */

        /**
         * Constructs a new QueryAllAuctionResponse.
         * @memberof ununifi.auction
         * @classdesc Represents a QueryAllAuctionResponse.
         * @implements IQueryAllAuctionResponse
         * @constructor
         * @param {ununifi.auction.IQueryAllAuctionResponse=} [properties] Properties to set
         */
        function QueryAllAuctionResponse(properties) {
          this.auctions = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllAuctionResponse auctions.
         * @member {Array.<google.protobuf.IAny>} auctions
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @instance
         */
        QueryAllAuctionResponse.prototype.auctions = $util.emptyArray;

        /**
         * QueryAllAuctionResponse pagination.
         * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @instance
         */
        QueryAllAuctionResponse.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllAuctionResponse message. Does not implicitly {@link ununifi.auction.QueryAllAuctionResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @static
         * @param {ununifi.auction.IQueryAllAuctionResponse} message QueryAllAuctionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAuctionResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.auctions != null && message.auctions.length)
            for (var i = 0; i < message.auctions.length; ++i)
              $root.google.protobuf.Any.encode(message.auctions[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageResponse.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllAuctionResponse message, length delimited. Does not implicitly {@link ununifi.auction.QueryAllAuctionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @static
         * @param {ununifi.auction.IQueryAllAuctionResponse} message QueryAllAuctionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAuctionResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllAuctionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.QueryAllAuctionResponse} QueryAllAuctionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAuctionResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.QueryAllAuctionResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.auctions && message.auctions.length)) message.auctions = [];
                message.auctions.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllAuctionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.QueryAllAuctionResponse} QueryAllAuctionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAuctionResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllAuctionResponse message.
         * @function verify
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllAuctionResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.auctions != null && message.hasOwnProperty('auctions')) {
            if (!Array.isArray(message.auctions)) return 'auctions: array expected';
            for (var i = 0; i < message.auctions.length; ++i) {
              var error = $root.google.protobuf.Any.verify(message.auctions[i]);
              if (error) return 'auctions.' + error;
            }
          }
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllAuctionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.QueryAllAuctionResponse} QueryAllAuctionResponse
         */
        QueryAllAuctionResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.QueryAllAuctionResponse) return object;
          var message = new $root.ununifi.auction.QueryAllAuctionResponse();
          if (object.auctions) {
            if (!Array.isArray(object.auctions)) throw TypeError('.ununifi.auction.QueryAllAuctionResponse.auctions: array expected');
            message.auctions = [];
            for (var i = 0; i < object.auctions.length; ++i) {
              if (typeof object.auctions[i] !== 'object')
                throw TypeError('.ununifi.auction.QueryAllAuctionResponse.auctions: object expected');
              message.auctions[i] = $root.google.protobuf.Any.fromObject(object.auctions[i]);
            }
          }
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.auction.QueryAllAuctionResponse.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllAuctionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @static
         * @param {ununifi.auction.QueryAllAuctionResponse} message QueryAllAuctionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllAuctionResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.auctions = [];
          if (options.defaults) object.pagination = null;
          if (message.auctions && message.auctions.length) {
            object.auctions = [];
            for (var j = 0; j < message.auctions.length; ++j)
              object.auctions[j] = $root.google.protobuf.Any.toObject(message.auctions[j], options);
          }
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllAuctionResponse to JSON.
         * @function toJSON
         * @memberof ununifi.auction.QueryAllAuctionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllAuctionResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllAuctionResponse;
      })();

      auction.BaseAuction = (function () {
        /**
         * Properties of a BaseAuction.
         * @memberof ununifi.auction
         * @interface IBaseAuction
         * @property {Long|null} [id] BaseAuction id
         * @property {string|null} [initiator] BaseAuction initiator
         * @property {cosmos.base.v1beta1.ICoin|null} [lot] BaseAuction lot
         * @property {string|null} [bidder] BaseAuction bidder
         * @property {cosmos.base.v1beta1.ICoin|null} [bid] BaseAuction bid
         * @property {boolean|null} [has_received_bids] BaseAuction has_received_bids
         * @property {google.protobuf.ITimestamp|null} [end_time] BaseAuction end_time
         * @property {google.protobuf.ITimestamp|null} [max_end_time] BaseAuction max_end_time
         */

        /**
         * Constructs a new BaseAuction.
         * @memberof ununifi.auction
         * @classdesc Represents a BaseAuction.
         * @implements IBaseAuction
         * @constructor
         * @param {ununifi.auction.IBaseAuction=} [properties] Properties to set
         */
        function BaseAuction(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseAuction id.
         * @member {Long} id
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * BaseAuction initiator.
         * @member {string} initiator
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.initiator = '';

        /**
         * BaseAuction lot.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} lot
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.lot = null;

        /**
         * BaseAuction bidder.
         * @member {string} bidder
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.bidder = '';

        /**
         * BaseAuction bid.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} bid
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.bid = null;

        /**
         * BaseAuction has_received_bids.
         * @member {boolean} has_received_bids
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.has_received_bids = false;

        /**
         * BaseAuction end_time.
         * @member {google.protobuf.ITimestamp|null|undefined} end_time
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.end_time = null;

        /**
         * BaseAuction max_end_time.
         * @member {google.protobuf.ITimestamp|null|undefined} max_end_time
         * @memberof ununifi.auction.BaseAuction
         * @instance
         */
        BaseAuction.prototype.max_end_time = null;

        /**
         * Encodes the specified BaseAuction message. Does not implicitly {@link ununifi.auction.BaseAuction.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.BaseAuction
         * @static
         * @param {ununifi.auction.IBaseAuction} message BaseAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseAuction.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
          if (message.initiator != null && Object.hasOwnProperty.call(message, 'initiator'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.initiator);
          if (message.lot != null && Object.hasOwnProperty.call(message, 'lot'))
            $root.cosmos.base.v1beta1.Coin.encode(message.lot, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.bidder);
          if (message.bid != null && Object.hasOwnProperty.call(message, 'bid'))
            $root.cosmos.base.v1beta1.Coin.encode(message.bid, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
          if (message.has_received_bids != null && Object.hasOwnProperty.call(message, 'has_received_bids'))
            writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.has_received_bids);
          if (message.end_time != null && Object.hasOwnProperty.call(message, 'end_time'))
            $root.google.protobuf.Timestamp.encode(message.end_time, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
          if (message.max_end_time != null && Object.hasOwnProperty.call(message, 'max_end_time'))
            $root.google.protobuf.Timestamp.encode(message.max_end_time, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified BaseAuction message, length delimited. Does not implicitly {@link ununifi.auction.BaseAuction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.BaseAuction
         * @static
         * @param {ununifi.auction.IBaseAuction} message BaseAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseAuction.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaseAuction message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.BaseAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.BaseAuction} BaseAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseAuction.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.BaseAuction();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.id = reader.uint64();
                break;
              case 2:
                message.initiator = reader.string();
                break;
              case 3:
                message.lot = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                message.bidder = reader.string();
                break;
              case 5:
                message.bid = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 6:
                message.has_received_bids = reader.bool();
                break;
              case 7:
                message.end_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 8:
                message.max_end_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a BaseAuction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.BaseAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.BaseAuction} BaseAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseAuction.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaseAuction message.
         * @function verify
         * @memberof ununifi.auction.BaseAuction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaseAuction.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.id != null && message.hasOwnProperty('id'))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
              return 'id: integer|Long expected';
          if (message.initiator != null && message.hasOwnProperty('initiator'))
            if (!$util.isString(message.initiator)) return 'initiator: string expected';
          if (message.lot != null && message.hasOwnProperty('lot')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.lot);
            if (error) return 'lot.' + error;
          }
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          if (message.bid != null && message.hasOwnProperty('bid')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.bid);
            if (error) return 'bid.' + error;
          }
          if (message.has_received_bids != null && message.hasOwnProperty('has_received_bids'))
            if (typeof message.has_received_bids !== 'boolean') return 'has_received_bids: boolean expected';
          if (message.end_time != null && message.hasOwnProperty('end_time')) {
            var error = $root.google.protobuf.Timestamp.verify(message.end_time);
            if (error) return 'end_time.' + error;
          }
          if (message.max_end_time != null && message.hasOwnProperty('max_end_time')) {
            var error = $root.google.protobuf.Timestamp.verify(message.max_end_time);
            if (error) return 'max_end_time.' + error;
          }
          return null;
        };

        /**
         * Creates a BaseAuction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.BaseAuction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.BaseAuction} BaseAuction
         */
        BaseAuction.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.BaseAuction) return object;
          var message = new $root.ununifi.auction.BaseAuction();
          if (object.id != null)
            if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
            else if (typeof object.id === 'number') message.id = object.id;
            else if (typeof object.id === 'object')
              message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
          if (object.initiator != null) message.initiator = String(object.initiator);
          if (object.lot != null) {
            if (typeof object.lot !== 'object') throw TypeError('.ununifi.auction.BaseAuction.lot: object expected');
            message.lot = $root.cosmos.base.v1beta1.Coin.fromObject(object.lot);
          }
          if (object.bidder != null) message.bidder = String(object.bidder);
          if (object.bid != null) {
            if (typeof object.bid !== 'object') throw TypeError('.ununifi.auction.BaseAuction.bid: object expected');
            message.bid = $root.cosmos.base.v1beta1.Coin.fromObject(object.bid);
          }
          if (object.has_received_bids != null) message.has_received_bids = Boolean(object.has_received_bids);
          if (object.end_time != null) {
            if (typeof object.end_time !== 'object') throw TypeError('.ununifi.auction.BaseAuction.end_time: object expected');
            message.end_time = $root.google.protobuf.Timestamp.fromObject(object.end_time);
          }
          if (object.max_end_time != null) {
            if (typeof object.max_end_time !== 'object') throw TypeError('.ununifi.auction.BaseAuction.max_end_time: object expected');
            message.max_end_time = $root.google.protobuf.Timestamp.fromObject(object.max_end_time);
          }
          return message;
        };

        /**
         * Creates a plain object from a BaseAuction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.BaseAuction
         * @static
         * @param {ununifi.auction.BaseAuction} message BaseAuction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaseAuction.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.id = options.longs === String ? '0' : 0;
            object.initiator = '';
            object.lot = null;
            object.bidder = '';
            object.bid = null;
            object.has_received_bids = false;
            object.end_time = null;
            object.max_end_time = null;
          }
          if (message.id != null && message.hasOwnProperty('id'))
            if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
            else
              object.id =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.id)
                  : options.longs === Number
                  ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                  : message.id;
          if (message.initiator != null && message.hasOwnProperty('initiator')) object.initiator = message.initiator;
          if (message.lot != null && message.hasOwnProperty('lot'))
            object.lot = $root.cosmos.base.v1beta1.Coin.toObject(message.lot, options);
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          if (message.bid != null && message.hasOwnProperty('bid'))
            object.bid = $root.cosmos.base.v1beta1.Coin.toObject(message.bid, options);
          if (message.has_received_bids != null && message.hasOwnProperty('has_received_bids'))
            object.has_received_bids = message.has_received_bids;
          if (message.end_time != null && message.hasOwnProperty('end_time'))
            object.end_time = $root.google.protobuf.Timestamp.toObject(message.end_time, options);
          if (message.max_end_time != null && message.hasOwnProperty('max_end_time'))
            object.max_end_time = $root.google.protobuf.Timestamp.toObject(message.max_end_time, options);
          return object;
        };

        /**
         * Converts this BaseAuction to JSON.
         * @function toJSON
         * @memberof ununifi.auction.BaseAuction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaseAuction.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BaseAuction;
      })();

      auction.SurplusAuction = (function () {
        /**
         * Properties of a SurplusAuction.
         * @memberof ununifi.auction
         * @interface ISurplusAuction
         * @property {ununifi.auction.IBaseAuction|null} [base_auction] SurplusAuction base_auction
         */

        /**
         * Constructs a new SurplusAuction.
         * @memberof ununifi.auction
         * @classdesc Represents a SurplusAuction.
         * @implements ISurplusAuction
         * @constructor
         * @param {ununifi.auction.ISurplusAuction=} [properties] Properties to set
         */
        function SurplusAuction(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurplusAuction base_auction.
         * @member {ununifi.auction.IBaseAuction|null|undefined} base_auction
         * @memberof ununifi.auction.SurplusAuction
         * @instance
         */
        SurplusAuction.prototype.base_auction = null;

        /**
         * Encodes the specified SurplusAuction message. Does not implicitly {@link ununifi.auction.SurplusAuction.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.SurplusAuction
         * @static
         * @param {ununifi.auction.ISurplusAuction} message SurplusAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurplusAuction.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.base_auction != null && Object.hasOwnProperty.call(message, 'base_auction'))
            $root.ununifi.auction.BaseAuction.encode(message.base_auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified SurplusAuction message, length delimited. Does not implicitly {@link ununifi.auction.SurplusAuction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.SurplusAuction
         * @static
         * @param {ununifi.auction.ISurplusAuction} message SurplusAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurplusAuction.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurplusAuction message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.SurplusAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.SurplusAuction} SurplusAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurplusAuction.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.SurplusAuction();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.base_auction = $root.ununifi.auction.BaseAuction.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SurplusAuction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.SurplusAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.SurplusAuction} SurplusAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurplusAuction.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurplusAuction message.
         * @function verify
         * @memberof ununifi.auction.SurplusAuction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurplusAuction.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.base_auction != null && message.hasOwnProperty('base_auction')) {
            var error = $root.ununifi.auction.BaseAuction.verify(message.base_auction);
            if (error) return 'base_auction.' + error;
          }
          return null;
        };

        /**
         * Creates a SurplusAuction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.SurplusAuction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.SurplusAuction} SurplusAuction
         */
        SurplusAuction.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.SurplusAuction) return object;
          var message = new $root.ununifi.auction.SurplusAuction();
          if (object.base_auction != null) {
            if (typeof object.base_auction !== 'object') throw TypeError('.ununifi.auction.SurplusAuction.base_auction: object expected');
            message.base_auction = $root.ununifi.auction.BaseAuction.fromObject(object.base_auction);
          }
          return message;
        };

        /**
         * Creates a plain object from a SurplusAuction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.SurplusAuction
         * @static
         * @param {ununifi.auction.SurplusAuction} message SurplusAuction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SurplusAuction.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.base_auction = null;
          if (message.base_auction != null && message.hasOwnProperty('base_auction'))
            object.base_auction = $root.ununifi.auction.BaseAuction.toObject(message.base_auction, options);
          return object;
        };

        /**
         * Converts this SurplusAuction to JSON.
         * @function toJSON
         * @memberof ununifi.auction.SurplusAuction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SurplusAuction.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SurplusAuction;
      })();

      auction.DebtAuction = (function () {
        /**
         * Properties of a DebtAuction.
         * @memberof ununifi.auction
         * @interface IDebtAuction
         * @property {ununifi.auction.IBaseAuction|null} [base_auction] DebtAuction base_auction
         * @property {cosmos.base.v1beta1.ICoin|null} [corresponding_debt] DebtAuction corresponding_debt
         */

        /**
         * Constructs a new DebtAuction.
         * @memberof ununifi.auction
         * @classdesc Represents a DebtAuction.
         * @implements IDebtAuction
         * @constructor
         * @param {ununifi.auction.IDebtAuction=} [properties] Properties to set
         */
        function DebtAuction(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebtAuction base_auction.
         * @member {ununifi.auction.IBaseAuction|null|undefined} base_auction
         * @memberof ununifi.auction.DebtAuction
         * @instance
         */
        DebtAuction.prototype.base_auction = null;

        /**
         * DebtAuction corresponding_debt.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} corresponding_debt
         * @memberof ununifi.auction.DebtAuction
         * @instance
         */
        DebtAuction.prototype.corresponding_debt = null;

        /**
         * Encodes the specified DebtAuction message. Does not implicitly {@link ununifi.auction.DebtAuction.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.DebtAuction
         * @static
         * @param {ununifi.auction.IDebtAuction} message DebtAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebtAuction.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.base_auction != null && Object.hasOwnProperty.call(message, 'base_auction'))
            $root.ununifi.auction.BaseAuction.encode(message.base_auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.corresponding_debt != null && Object.hasOwnProperty.call(message, 'corresponding_debt'))
            $root.cosmos.base.v1beta1.Coin.encode(message.corresponding_debt, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified DebtAuction message, length delimited. Does not implicitly {@link ununifi.auction.DebtAuction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.DebtAuction
         * @static
         * @param {ununifi.auction.IDebtAuction} message DebtAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebtAuction.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebtAuction message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.DebtAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.DebtAuction} DebtAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebtAuction.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.DebtAuction();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.base_auction = $root.ununifi.auction.BaseAuction.decode(reader, reader.uint32());
                break;
              case 2:
                message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DebtAuction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.DebtAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.DebtAuction} DebtAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebtAuction.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebtAuction message.
         * @function verify
         * @memberof ununifi.auction.DebtAuction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebtAuction.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.base_auction != null && message.hasOwnProperty('base_auction')) {
            var error = $root.ununifi.auction.BaseAuction.verify(message.base_auction);
            if (error) return 'base_auction.' + error;
          }
          if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.corresponding_debt);
            if (error) return 'corresponding_debt.' + error;
          }
          return null;
        };

        /**
         * Creates a DebtAuction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.DebtAuction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.DebtAuction} DebtAuction
         */
        DebtAuction.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.DebtAuction) return object;
          var message = new $root.ununifi.auction.DebtAuction();
          if (object.base_auction != null) {
            if (typeof object.base_auction !== 'object') throw TypeError('.ununifi.auction.DebtAuction.base_auction: object expected');
            message.base_auction = $root.ununifi.auction.BaseAuction.fromObject(object.base_auction);
          }
          if (object.corresponding_debt != null) {
            if (typeof object.corresponding_debt !== 'object')
              throw TypeError('.ununifi.auction.DebtAuction.corresponding_debt: object expected');
            message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.fromObject(object.corresponding_debt);
          }
          return message;
        };

        /**
         * Creates a plain object from a DebtAuction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.DebtAuction
         * @static
         * @param {ununifi.auction.DebtAuction} message DebtAuction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebtAuction.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.base_auction = null;
            object.corresponding_debt = null;
          }
          if (message.base_auction != null && message.hasOwnProperty('base_auction'))
            object.base_auction = $root.ununifi.auction.BaseAuction.toObject(message.base_auction, options);
          if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt'))
            object.corresponding_debt = $root.cosmos.base.v1beta1.Coin.toObject(message.corresponding_debt, options);
          return object;
        };

        /**
         * Converts this DebtAuction to JSON.
         * @function toJSON
         * @memberof ununifi.auction.DebtAuction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebtAuction.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebtAuction;
      })();

      auction.CollateralAuction = (function () {
        /**
         * Properties of a CollateralAuction.
         * @memberof ununifi.auction
         * @interface ICollateralAuction
         * @property {ununifi.auction.IBaseAuction|null} [base_auction] CollateralAuction base_auction
         * @property {cosmos.base.v1beta1.ICoin|null} [corresponding_debt] CollateralAuction corresponding_debt
         * @property {cosmos.base.v1beta1.ICoin|null} [max_bid] CollateralAuction max_bid
         * @property {Array.<ununifi.auction.IWeightedAddress>|null} [lot_returns] CollateralAuction lot_returns
         */

        /**
         * Constructs a new CollateralAuction.
         * @memberof ununifi.auction
         * @classdesc Represents a CollateralAuction.
         * @implements ICollateralAuction
         * @constructor
         * @param {ununifi.auction.ICollateralAuction=} [properties] Properties to set
         */
        function CollateralAuction(properties) {
          this.lot_returns = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * CollateralAuction base_auction.
         * @member {ununifi.auction.IBaseAuction|null|undefined} base_auction
         * @memberof ununifi.auction.CollateralAuction
         * @instance
         */
        CollateralAuction.prototype.base_auction = null;

        /**
         * CollateralAuction corresponding_debt.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} corresponding_debt
         * @memberof ununifi.auction.CollateralAuction
         * @instance
         */
        CollateralAuction.prototype.corresponding_debt = null;

        /**
         * CollateralAuction max_bid.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} max_bid
         * @memberof ununifi.auction.CollateralAuction
         * @instance
         */
        CollateralAuction.prototype.max_bid = null;

        /**
         * CollateralAuction lot_returns.
         * @member {Array.<ununifi.auction.IWeightedAddress>} lot_returns
         * @memberof ununifi.auction.CollateralAuction
         * @instance
         */
        CollateralAuction.prototype.lot_returns = $util.emptyArray;

        /**
         * Encodes the specified CollateralAuction message. Does not implicitly {@link ununifi.auction.CollateralAuction.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.CollateralAuction
         * @static
         * @param {ununifi.auction.ICollateralAuction} message CollateralAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CollateralAuction.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.base_auction != null && Object.hasOwnProperty.call(message, 'base_auction'))
            $root.ununifi.auction.BaseAuction.encode(message.base_auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.corresponding_debt != null && Object.hasOwnProperty.call(message, 'corresponding_debt'))
            $root.cosmos.base.v1beta1.Coin.encode(message.corresponding_debt, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.max_bid != null && Object.hasOwnProperty.call(message, 'max_bid'))
            $root.cosmos.base.v1beta1.Coin.encode(message.max_bid, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.lot_returns != null && message.lot_returns.length)
            for (var i = 0; i < message.lot_returns.length; ++i)
              $root.ununifi.auction.WeightedAddress.encode(
                message.lot_returns[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified CollateralAuction message, length delimited. Does not implicitly {@link ununifi.auction.CollateralAuction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.CollateralAuction
         * @static
         * @param {ununifi.auction.ICollateralAuction} message CollateralAuction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CollateralAuction.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CollateralAuction message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.CollateralAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.CollateralAuction} CollateralAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CollateralAuction.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.CollateralAuction();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.base_auction = $root.ununifi.auction.BaseAuction.decode(reader, reader.uint32());
                break;
              case 2:
                message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 3:
                message.max_bid = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.lot_returns && message.lot_returns.length)) message.lot_returns = [];
                message.lot_returns.push($root.ununifi.auction.WeightedAddress.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a CollateralAuction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.CollateralAuction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.CollateralAuction} CollateralAuction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CollateralAuction.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CollateralAuction message.
         * @function verify
         * @memberof ununifi.auction.CollateralAuction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CollateralAuction.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.base_auction != null && message.hasOwnProperty('base_auction')) {
            var error = $root.ununifi.auction.BaseAuction.verify(message.base_auction);
            if (error) return 'base_auction.' + error;
          }
          if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.corresponding_debt);
            if (error) return 'corresponding_debt.' + error;
          }
          if (message.max_bid != null && message.hasOwnProperty('max_bid')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.max_bid);
            if (error) return 'max_bid.' + error;
          }
          if (message.lot_returns != null && message.hasOwnProperty('lot_returns')) {
            if (!Array.isArray(message.lot_returns)) return 'lot_returns: array expected';
            for (var i = 0; i < message.lot_returns.length; ++i) {
              var error = $root.ununifi.auction.WeightedAddress.verify(message.lot_returns[i]);
              if (error) return 'lot_returns.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a CollateralAuction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.CollateralAuction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.CollateralAuction} CollateralAuction
         */
        CollateralAuction.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.CollateralAuction) return object;
          var message = new $root.ununifi.auction.CollateralAuction();
          if (object.base_auction != null) {
            if (typeof object.base_auction !== 'object')
              throw TypeError('.ununifi.auction.CollateralAuction.base_auction: object expected');
            message.base_auction = $root.ununifi.auction.BaseAuction.fromObject(object.base_auction);
          }
          if (object.corresponding_debt != null) {
            if (typeof object.corresponding_debt !== 'object')
              throw TypeError('.ununifi.auction.CollateralAuction.corresponding_debt: object expected');
            message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.fromObject(object.corresponding_debt);
          }
          if (object.max_bid != null) {
            if (typeof object.max_bid !== 'object') throw TypeError('.ununifi.auction.CollateralAuction.max_bid: object expected');
            message.max_bid = $root.cosmos.base.v1beta1.Coin.fromObject(object.max_bid);
          }
          if (object.lot_returns) {
            if (!Array.isArray(object.lot_returns)) throw TypeError('.ununifi.auction.CollateralAuction.lot_returns: array expected');
            message.lot_returns = [];
            for (var i = 0; i < object.lot_returns.length; ++i) {
              if (typeof object.lot_returns[i] !== 'object')
                throw TypeError('.ununifi.auction.CollateralAuction.lot_returns: object expected');
              message.lot_returns[i] = $root.ununifi.auction.WeightedAddress.fromObject(object.lot_returns[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a CollateralAuction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.CollateralAuction
         * @static
         * @param {ununifi.auction.CollateralAuction} message CollateralAuction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CollateralAuction.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.lot_returns = [];
          if (options.defaults) {
            object.base_auction = null;
            object.corresponding_debt = null;
            object.max_bid = null;
          }
          if (message.base_auction != null && message.hasOwnProperty('base_auction'))
            object.base_auction = $root.ununifi.auction.BaseAuction.toObject(message.base_auction, options);
          if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt'))
            object.corresponding_debt = $root.cosmos.base.v1beta1.Coin.toObject(message.corresponding_debt, options);
          if (message.max_bid != null && message.hasOwnProperty('max_bid'))
            object.max_bid = $root.cosmos.base.v1beta1.Coin.toObject(message.max_bid, options);
          if (message.lot_returns && message.lot_returns.length) {
            object.lot_returns = [];
            for (var j = 0; j < message.lot_returns.length; ++j)
              object.lot_returns[j] = $root.ununifi.auction.WeightedAddress.toObject(message.lot_returns[j], options);
          }
          return object;
        };

        /**
         * Converts this CollateralAuction to JSON.
         * @function toJSON
         * @memberof ununifi.auction.CollateralAuction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CollateralAuction.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CollateralAuction;
      })();

      auction.WeightedAddress = (function () {
        /**
         * Properties of a WeightedAddress.
         * @memberof ununifi.auction
         * @interface IWeightedAddress
         * @property {string|null} [address] WeightedAddress address
         * @property {string|null} [weight] WeightedAddress weight
         */

        /**
         * Constructs a new WeightedAddress.
         * @memberof ununifi.auction
         * @classdesc Represents a WeightedAddress.
         * @implements IWeightedAddress
         * @constructor
         * @param {ununifi.auction.IWeightedAddress=} [properties] Properties to set
         */
        function WeightedAddress(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * WeightedAddress address.
         * @member {string} address
         * @memberof ununifi.auction.WeightedAddress
         * @instance
         */
        WeightedAddress.prototype.address = '';

        /**
         * WeightedAddress weight.
         * @member {string} weight
         * @memberof ununifi.auction.WeightedAddress
         * @instance
         */
        WeightedAddress.prototype.weight = '';

        /**
         * Encodes the specified WeightedAddress message. Does not implicitly {@link ununifi.auction.WeightedAddress.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.WeightedAddress
         * @static
         * @param {ununifi.auction.IWeightedAddress} message WeightedAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeightedAddress.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
          if (message.weight != null && Object.hasOwnProperty.call(message, 'weight'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.weight);
          return writer;
        };

        /**
         * Encodes the specified WeightedAddress message, length delimited. Does not implicitly {@link ununifi.auction.WeightedAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.WeightedAddress
         * @static
         * @param {ununifi.auction.IWeightedAddress} message WeightedAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeightedAddress.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WeightedAddress message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.WeightedAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.WeightedAddress} WeightedAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeightedAddress.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.WeightedAddress();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.address = reader.string();
                break;
              case 2:
                message.weight = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a WeightedAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.WeightedAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.WeightedAddress} WeightedAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeightedAddress.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WeightedAddress message.
         * @function verify
         * @memberof ununifi.auction.WeightedAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WeightedAddress.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.address != null && message.hasOwnProperty('address'))
            if (!$util.isString(message.address)) return 'address: string expected';
          if (message.weight != null && message.hasOwnProperty('weight'))
            if (!$util.isString(message.weight)) return 'weight: string expected';
          return null;
        };

        /**
         * Creates a WeightedAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.WeightedAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.WeightedAddress} WeightedAddress
         */
        WeightedAddress.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.WeightedAddress) return object;
          var message = new $root.ununifi.auction.WeightedAddress();
          if (object.address != null) message.address = String(object.address);
          if (object.weight != null) message.weight = String(object.weight);
          return message;
        };

        /**
         * Creates a plain object from a WeightedAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.WeightedAddress
         * @static
         * @param {ununifi.auction.WeightedAddress} message WeightedAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WeightedAddress.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.address = '';
            object.weight = '';
          }
          if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
          if (message.weight != null && message.hasOwnProperty('weight')) object.weight = message.weight;
          return object;
        };

        /**
         * Converts this WeightedAddress to JSON.
         * @function toJSON
         * @memberof ununifi.auction.WeightedAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WeightedAddress.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WeightedAddress;
      })();

      auction.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.auction
         * @interface IParams
         * @property {google.protobuf.IDuration|null} [max_auction_duration] Params max_auction_duration
         * @property {google.protobuf.IDuration|null} [bid_duration] Params bid_duration
         * @property {string|null} [increment_surplus] Params increment_surplus
         * @property {string|null} [increment_debt] Params increment_debt
         * @property {string|null} [increment_collateral] Params increment_collateral
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.auction
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.auction.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params max_auction_duration.
         * @member {google.protobuf.IDuration|null|undefined} max_auction_duration
         * @memberof ununifi.auction.Params
         * @instance
         */
        Params.prototype.max_auction_duration = null;

        /**
         * Params bid_duration.
         * @member {google.protobuf.IDuration|null|undefined} bid_duration
         * @memberof ununifi.auction.Params
         * @instance
         */
        Params.prototype.bid_duration = null;

        /**
         * Params increment_surplus.
         * @member {string} increment_surplus
         * @memberof ununifi.auction.Params
         * @instance
         */
        Params.prototype.increment_surplus = '';

        /**
         * Params increment_debt.
         * @member {string} increment_debt
         * @memberof ununifi.auction.Params
         * @instance
         */
        Params.prototype.increment_debt = '';

        /**
         * Params increment_collateral.
         * @member {string} increment_collateral
         * @memberof ununifi.auction.Params
         * @instance
         */
        Params.prototype.increment_collateral = '';

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.auction.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.Params
         * @static
         * @param {ununifi.auction.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.max_auction_duration != null && Object.hasOwnProperty.call(message, 'max_auction_duration'))
            $root.google.protobuf.Duration.encode(message.max_auction_duration, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.bid_duration != null && Object.hasOwnProperty.call(message, 'bid_duration'))
            $root.google.protobuf.Duration.encode(message.bid_duration, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.increment_surplus != null && Object.hasOwnProperty.call(message, 'increment_surplus'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.increment_surplus);
          if (message.increment_debt != null && Object.hasOwnProperty.call(message, 'increment_debt'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.increment_debt);
          if (message.increment_collateral != null && Object.hasOwnProperty.call(message, 'increment_collateral'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.increment_collateral);
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.auction.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.Params
         * @static
         * @param {ununifi.auction.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.max_auction_duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                break;
              case 2:
                message.bid_duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                break;
              case 3:
                message.increment_surplus = reader.string();
                break;
              case 4:
                message.increment_debt = reader.string();
                break;
              case 5:
                message.increment_collateral = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.auction.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.max_auction_duration != null && message.hasOwnProperty('max_auction_duration')) {
            var error = $root.google.protobuf.Duration.verify(message.max_auction_duration);
            if (error) return 'max_auction_duration.' + error;
          }
          if (message.bid_duration != null && message.hasOwnProperty('bid_duration')) {
            var error = $root.google.protobuf.Duration.verify(message.bid_duration);
            if (error) return 'bid_duration.' + error;
          }
          if (message.increment_surplus != null && message.hasOwnProperty('increment_surplus'))
            if (!$util.isString(message.increment_surplus)) return 'increment_surplus: string expected';
          if (message.increment_debt != null && message.hasOwnProperty('increment_debt'))
            if (!$util.isString(message.increment_debt)) return 'increment_debt: string expected';
          if (message.increment_collateral != null && message.hasOwnProperty('increment_collateral'))
            if (!$util.isString(message.increment_collateral)) return 'increment_collateral: string expected';
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.Params) return object;
          var message = new $root.ununifi.auction.Params();
          if (object.max_auction_duration != null) {
            if (typeof object.max_auction_duration !== 'object')
              throw TypeError('.ununifi.auction.Params.max_auction_duration: object expected');
            message.max_auction_duration = $root.google.protobuf.Duration.fromObject(object.max_auction_duration);
          }
          if (object.bid_duration != null) {
            if (typeof object.bid_duration !== 'object') throw TypeError('.ununifi.auction.Params.bid_duration: object expected');
            message.bid_duration = $root.google.protobuf.Duration.fromObject(object.bid_duration);
          }
          if (object.increment_surplus != null) message.increment_surplus = String(object.increment_surplus);
          if (object.increment_debt != null) message.increment_debt = String(object.increment_debt);
          if (object.increment_collateral != null) message.increment_collateral = String(object.increment_collateral);
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.Params
         * @static
         * @param {ununifi.auction.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.max_auction_duration = null;
            object.bid_duration = null;
            object.increment_surplus = '';
            object.increment_debt = '';
            object.increment_collateral = '';
          }
          if (message.max_auction_duration != null && message.hasOwnProperty('max_auction_duration'))
            object.max_auction_duration = $root.google.protobuf.Duration.toObject(message.max_auction_duration, options);
          if (message.bid_duration != null && message.hasOwnProperty('bid_duration'))
            object.bid_duration = $root.google.protobuf.Duration.toObject(message.bid_duration, options);
          if (message.increment_surplus != null && message.hasOwnProperty('increment_surplus'))
            object.increment_surplus = message.increment_surplus;
          if (message.increment_debt != null && message.hasOwnProperty('increment_debt')) object.increment_debt = message.increment_debt;
          if (message.increment_collateral != null && message.hasOwnProperty('increment_collateral'))
            object.increment_collateral = message.increment_collateral;
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.auction.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      auction.Msg = (function () {
        /**
         * Constructs a new Msg service.
         * @memberof ununifi.auction
         * @classdesc Represents a Msg
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Msg(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

        /**
         * Callback as used by {@link ununifi.auction.Msg#placeBid}.
         * @memberof ununifi.auction.Msg
         * @typedef PlaceBidCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.auction.MsgPlaceBidResponse} [response] MsgPlaceBidResponse
         */

        /**
         * Calls PlaceBid.
         * @function placeBid
         * @memberof ununifi.auction.Msg
         * @instance
         * @param {ununifi.auction.IMsgPlaceBid} request MsgPlaceBid message or plain object
         * @param {ununifi.auction.Msg.PlaceBidCallback} callback Node-style callback called with the error, if any, and MsgPlaceBidResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.placeBid = function placeBid(request, callback) {
            return this.rpcCall(placeBid, $root.ununifi.auction.MsgPlaceBid, $root.ununifi.auction.MsgPlaceBidResponse, request, callback);
          }),
          'name',
          { value: 'PlaceBid' },
        );

        /**
         * Calls PlaceBid.
         * @function placeBid
         * @memberof ununifi.auction.Msg
         * @instance
         * @param {ununifi.auction.IMsgPlaceBid} request MsgPlaceBid message or plain object
         * @returns {Promise<ununifi.auction.MsgPlaceBidResponse>} Promise
         * @variation 2
         */

        return Msg;
      })();

      auction.MsgPlaceBid = (function () {
        /**
         * Properties of a MsgPlaceBid.
         * @memberof ununifi.auction
         * @interface IMsgPlaceBid
         * @property {Long|null} [auction_id] MsgPlaceBid auction_id
         * @property {string|null} [bidder] MsgPlaceBid bidder
         * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgPlaceBid amount
         */

        /**
         * Constructs a new MsgPlaceBid.
         * @memberof ununifi.auction
         * @classdesc Represents a MsgPlaceBid.
         * @implements IMsgPlaceBid
         * @constructor
         * @param {ununifi.auction.IMsgPlaceBid=} [properties] Properties to set
         */
        function MsgPlaceBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgPlaceBid auction_id.
         * @member {Long} auction_id
         * @memberof ununifi.auction.MsgPlaceBid
         * @instance
         */
        MsgPlaceBid.prototype.auction_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * MsgPlaceBid bidder.
         * @member {string} bidder
         * @memberof ununifi.auction.MsgPlaceBid
         * @instance
         */
        MsgPlaceBid.prototype.bidder = '';

        /**
         * MsgPlaceBid amount.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
         * @memberof ununifi.auction.MsgPlaceBid
         * @instance
         */
        MsgPlaceBid.prototype.amount = null;

        /**
         * Encodes the specified MsgPlaceBid message. Does not implicitly {@link ununifi.auction.MsgPlaceBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.MsgPlaceBid
         * @static
         * @param {ununifi.auction.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.auction_id != null && Object.hasOwnProperty.call(message, 'auction_id'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.auction_id);
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bidder);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgPlaceBid message, length delimited. Does not implicitly {@link ununifi.auction.MsgPlaceBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.MsgPlaceBid
         * @static
         * @param {ununifi.auction.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPlaceBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.MsgPlaceBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.MsgPlaceBid} MsgPlaceBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.MsgPlaceBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.auction_id = reader.uint64();
                break;
              case 2:
                message.bidder = reader.string();
                break;
              case 3:
                message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPlaceBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.MsgPlaceBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.MsgPlaceBid} MsgPlaceBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPlaceBid message.
         * @function verify
         * @memberof ununifi.auction.MsgPlaceBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPlaceBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.auction_id != null && message.hasOwnProperty('auction_id'))
            if (
              !$util.isInteger(message.auction_id) &&
              !(message.auction_id && $util.isInteger(message.auction_id.low) && $util.isInteger(message.auction_id.high))
            )
              return 'auction_id: integer|Long expected';
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          if (message.amount != null && message.hasOwnProperty('amount')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
            if (error) return 'amount.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgPlaceBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.MsgPlaceBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.MsgPlaceBid} MsgPlaceBid
         */
        MsgPlaceBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.MsgPlaceBid) return object;
          var message = new $root.ununifi.auction.MsgPlaceBid();
          if (object.auction_id != null)
            if ($util.Long) (message.auction_id = $util.Long.fromValue(object.auction_id)).unsigned = true;
            else if (typeof object.auction_id === 'string') message.auction_id = parseInt(object.auction_id, 10);
            else if (typeof object.auction_id === 'number') message.auction_id = object.auction_id;
            else if (typeof object.auction_id === 'object')
              message.auction_id = new $util.LongBits(object.auction_id.low >>> 0, object.auction_id.high >>> 0).toNumber(true);
          if (object.bidder != null) message.bidder = String(object.bidder);
          if (object.amount != null) {
            if (typeof object.amount !== 'object') throw TypeError('.ununifi.auction.MsgPlaceBid.amount: object expected');
            message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgPlaceBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.MsgPlaceBid
         * @static
         * @param {ununifi.auction.MsgPlaceBid} message MsgPlaceBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPlaceBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.auction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.auction_id = options.longs === String ? '0' : 0;
            object.bidder = '';
            object.amount = null;
          }
          if (message.auction_id != null && message.hasOwnProperty('auction_id'))
            if (typeof message.auction_id === 'number')
              object.auction_id = options.longs === String ? String(message.auction_id) : message.auction_id;
            else
              object.auction_id =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.auction_id)
                  : options.longs === Number
                  ? new $util.LongBits(message.auction_id.low >>> 0, message.auction_id.high >>> 0).toNumber(true)
                  : message.auction_id;
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          if (message.amount != null && message.hasOwnProperty('amount'))
            object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
          return object;
        };

        /**
         * Converts this MsgPlaceBid to JSON.
         * @function toJSON
         * @memberof ununifi.auction.MsgPlaceBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPlaceBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPlaceBid;
      })();

      auction.MsgPlaceBidResponse = (function () {
        /**
         * Properties of a MsgPlaceBidResponse.
         * @memberof ununifi.auction
         * @interface IMsgPlaceBidResponse
         */

        /**
         * Constructs a new MsgPlaceBidResponse.
         * @memberof ununifi.auction
         * @classdesc Represents a MsgPlaceBidResponse.
         * @implements IMsgPlaceBidResponse
         * @constructor
         * @param {ununifi.auction.IMsgPlaceBidResponse=} [properties] Properties to set
         */
        function MsgPlaceBidResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgPlaceBidResponse message. Does not implicitly {@link ununifi.auction.MsgPlaceBidResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @static
         * @param {ununifi.auction.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBidResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgPlaceBidResponse message, length delimited. Does not implicitly {@link ununifi.auction.MsgPlaceBidResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @static
         * @param {ununifi.auction.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPlaceBidResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.MsgPlaceBidResponse} MsgPlaceBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBidResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.MsgPlaceBidResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPlaceBidResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.MsgPlaceBidResponse} MsgPlaceBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBidResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPlaceBidResponse message.
         * @function verify
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPlaceBidResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgPlaceBidResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.MsgPlaceBidResponse} MsgPlaceBidResponse
         */
        MsgPlaceBidResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.MsgPlaceBidResponse) return object;
          return new $root.ununifi.auction.MsgPlaceBidResponse();
        };

        /**
         * Creates a plain object from a MsgPlaceBidResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @static
         * @param {ununifi.auction.MsgPlaceBidResponse} message MsgPlaceBidResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPlaceBidResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgPlaceBidResponse to JSON.
         * @function toJSON
         * @memberof ununifi.auction.MsgPlaceBidResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPlaceBidResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPlaceBidResponse;
      })();

      auction.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.auction
         * @interface IGenesisState
         * @property {Long|null} [next_auction_id] GenesisState next_auction_id
         * @property {ununifi.auction.IParams|null} [params] GenesisState params
         * @property {Array.<google.protobuf.IAny>|null} [auctions] GenesisState auctions
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.auction
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.auction.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          this.auctions = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState next_auction_id.
         * @member {Long} next_auction_id
         * @memberof ununifi.auction.GenesisState
         * @instance
         */
        GenesisState.prototype.next_auction_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * GenesisState params.
         * @member {ununifi.auction.IParams|null|undefined} params
         * @memberof ununifi.auction.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * GenesisState auctions.
         * @member {Array.<google.protobuf.IAny>} auctions
         * @memberof ununifi.auction.GenesisState
         * @instance
         */
        GenesisState.prototype.auctions = $util.emptyArray;

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.auction.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.auction.GenesisState
         * @static
         * @param {ununifi.auction.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.next_auction_id != null && Object.hasOwnProperty.call(message, 'next_auction_id'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.next_auction_id);
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.auction.Params.encode(message.params, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.auctions != null && message.auctions.length)
            for (var i = 0; i < message.auctions.length; ++i)
              $root.google.protobuf.Any.encode(message.auctions[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.auction.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.auction.GenesisState
         * @static
         * @param {ununifi.auction.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.auction.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.auction.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.auction.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.next_auction_id = reader.uint64();
                break;
              case 2:
                message.params = $root.ununifi.auction.Params.decode(reader, reader.uint32());
                break;
              case 3:
                if (!(message.auctions && message.auctions.length)) message.auctions = [];
                message.auctions.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.auction.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.auction.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.auction.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.next_auction_id != null && message.hasOwnProperty('next_auction_id'))
            if (
              !$util.isInteger(message.next_auction_id) &&
              !(message.next_auction_id && $util.isInteger(message.next_auction_id.low) && $util.isInteger(message.next_auction_id.high))
            )
              return 'next_auction_id: integer|Long expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.auction.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          if (message.auctions != null && message.hasOwnProperty('auctions')) {
            if (!Array.isArray(message.auctions)) return 'auctions: array expected';
            for (var i = 0; i < message.auctions.length; ++i) {
              var error = $root.google.protobuf.Any.verify(message.auctions[i]);
              if (error) return 'auctions.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.auction.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.auction.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.auction.GenesisState) return object;
          var message = new $root.ununifi.auction.GenesisState();
          if (object.next_auction_id != null)
            if ($util.Long) (message.next_auction_id = $util.Long.fromValue(object.next_auction_id)).unsigned = true;
            else if (typeof object.next_auction_id === 'string') message.next_auction_id = parseInt(object.next_auction_id, 10);
            else if (typeof object.next_auction_id === 'number') message.next_auction_id = object.next_auction_id;
            else if (typeof object.next_auction_id === 'object')
              message.next_auction_id = new $util.LongBits(object.next_auction_id.low >>> 0, object.next_auction_id.high >>> 0).toNumber(
                true,
              );
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.auction.GenesisState.params: object expected');
            message.params = $root.ununifi.auction.Params.fromObject(object.params);
          }
          if (object.auctions) {
            if (!Array.isArray(object.auctions)) throw TypeError('.ununifi.auction.GenesisState.auctions: array expected');
            message.auctions = [];
            for (var i = 0; i < object.auctions.length; ++i) {
              if (typeof object.auctions[i] !== 'object') throw TypeError('.ununifi.auction.GenesisState.auctions: object expected');
              message.auctions[i] = $root.google.protobuf.Any.fromObject(object.auctions[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.auction.GenesisState
         * @static
         * @param {ununifi.auction.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.auctions = [];
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.next_auction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.next_auction_id = options.longs === String ? '0' : 0;
            object.params = null;
          }
          if (message.next_auction_id != null && message.hasOwnProperty('next_auction_id'))
            if (typeof message.next_auction_id === 'number')
              object.next_auction_id = options.longs === String ? String(message.next_auction_id) : message.next_auction_id;
            else
              object.next_auction_id =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.next_auction_id)
                  : options.longs === Number
                  ? new $util.LongBits(message.next_auction_id.low >>> 0, message.next_auction_id.high >>> 0).toNumber(true)
                  : message.next_auction_id;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.auction.Params.toObject(message.params, options);
          if (message.auctions && message.auctions.length) {
            object.auctions = [];
            for (var j = 0; j < message.auctions.length; ++j)
              object.auctions[j] = $root.google.protobuf.Any.toObject(message.auctions[j], options);
          }
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.auction.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      return auction;
    })();

    ununifi.cdp = (function () {
      /**
       * Namespace cdp.
       * @memberof ununifi
       * @namespace
       */
      var cdp = {};

      cdp.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.cdp
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.cdp.Query#params}.
         * @memberof ununifi.cdp.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.cdp.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(params, $root.ununifi.cdp.QueryParamsRequest, $root.ununifi.cdp.QueryParamsResponse, request, callback);
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.cdp.QueryParamsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Query#cdp}.
         * @memberof ununifi.cdp.Query
         * @typedef CdpCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.QueryGetCdpResponse} [response] QueryGetCdpResponse
         */

        /**
         * Calls Cdp.
         * @function cdp
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryGetCdpRequest} request QueryGetCdpRequest message or plain object
         * @param {ununifi.cdp.Query.CdpCallback} callback Node-style callback called with the error, if any, and QueryGetCdpResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.cdp = function cdp(request, callback) {
            return this.rpcCall(cdp, $root.ununifi.cdp.QueryGetCdpRequest, $root.ununifi.cdp.QueryGetCdpResponse, request, callback);
          }),
          'name',
          { value: 'Cdp' },
        );

        /**
         * Calls Cdp.
         * @function cdp
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryGetCdpRequest} request QueryGetCdpRequest message or plain object
         * @returns {Promise<ununifi.cdp.QueryGetCdpResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Query#cdpAll}.
         * @memberof ununifi.cdp.Query
         * @typedef CdpAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.QueryAllCdpResponse} [response] QueryAllCdpResponse
         */

        /**
         * Calls CdpAll.
         * @function cdpAll
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryAllCdpRequest} request QueryAllCdpRequest message or plain object
         * @param {ununifi.cdp.Query.CdpAllCallback} callback Node-style callback called with the error, if any, and QueryAllCdpResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.cdpAll = function cdpAll(request, callback) {
            return this.rpcCall(cdpAll, $root.ununifi.cdp.QueryAllCdpRequest, $root.ununifi.cdp.QueryAllCdpResponse, request, callback);
          }),
          'name',
          { value: 'CdpAll' },
        );

        /**
         * Calls CdpAll.
         * @function cdpAll
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryAllCdpRequest} request QueryAllCdpRequest message or plain object
         * @returns {Promise<ununifi.cdp.QueryAllCdpResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Query#accountAll}.
         * @memberof ununifi.cdp.Query
         * @typedef AccountAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.QueryAllAccountResponse} [response] QueryAllAccountResponse
         */

        /**
         * Calls AccountAll.
         * @function accountAll
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryAllAccountRequest} request QueryAllAccountRequest message or plain object
         * @param {ununifi.cdp.Query.AccountAllCallback} callback Node-style callback called with the error, if any, and QueryAllAccountResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.accountAll = function accountAll(request, callback) {
            return this.rpcCall(
              accountAll,
              $root.ununifi.cdp.QueryAllAccountRequest,
              $root.ununifi.cdp.QueryAllAccountResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'AccountAll' },
        );

        /**
         * Calls AccountAll.
         * @function accountAll
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryAllAccountRequest} request QueryAllAccountRequest message or plain object
         * @returns {Promise<ununifi.cdp.QueryAllAccountResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Query#depositAll}.
         * @memberof ununifi.cdp.Query
         * @typedef DepositAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.QueryAllDepositResponse} [response] QueryAllDepositResponse
         */

        /**
         * Calls DepositAll.
         * @function depositAll
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryAllDepositRequest} request QueryAllDepositRequest message or plain object
         * @param {ununifi.cdp.Query.DepositAllCallback} callback Node-style callback called with the error, if any, and QueryAllDepositResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.depositAll = function depositAll(request, callback) {
            return this.rpcCall(
              depositAll,
              $root.ununifi.cdp.QueryAllDepositRequest,
              $root.ununifi.cdp.QueryAllDepositResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'DepositAll' },
        );

        /**
         * Calls DepositAll.
         * @function depositAll
         * @memberof ununifi.cdp.Query
         * @instance
         * @param {ununifi.cdp.IQueryAllDepositRequest} request QueryAllDepositRequest message or plain object
         * @returns {Promise<ununifi.cdp.QueryAllDepositResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      cdp.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.cdp
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.cdp.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.cdp.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryParamsRequest
         * @static
         * @param {ununifi.cdp.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryParamsRequest
         * @static
         * @param {ununifi.cdp.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.cdp.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryParamsRequest) return object;
          return new $root.ununifi.cdp.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryParamsRequest
         * @static
         * @param {ununifi.cdp.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      cdp.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.cdp
         * @interface IQueryParamsResponse
         * @property {ununifi.cdp.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.cdp.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.cdp.IParams|null|undefined} params
         * @memberof ununifi.cdp.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.cdp.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryParamsResponse
         * @static
         * @param {ununifi.cdp.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.cdp.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryParamsResponse
         * @static
         * @param {ununifi.cdp.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.cdp.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.cdp.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.cdp.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryParamsResponse) return object;
          var message = new $root.ununifi.cdp.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.cdp.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.cdp.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryParamsResponse
         * @static
         * @param {ununifi.cdp.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.cdp.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      cdp.QueryGetCdpRequest = (function () {
        /**
         * Properties of a QueryGetCdpRequest.
         * @memberof ununifi.cdp
         * @interface IQueryGetCdpRequest
         * @property {string|null} [owner] QueryGetCdpRequest owner
         * @property {string|null} [collateral_type] QueryGetCdpRequest collateral_type
         */

        /**
         * Constructs a new QueryGetCdpRequest.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryGetCdpRequest.
         * @implements IQueryGetCdpRequest
         * @constructor
         * @param {ununifi.cdp.IQueryGetCdpRequest=} [properties] Properties to set
         */
        function QueryGetCdpRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGetCdpRequest owner.
         * @member {string} owner
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @instance
         */
        QueryGetCdpRequest.prototype.owner = '';

        /**
         * QueryGetCdpRequest collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @instance
         */
        QueryGetCdpRequest.prototype.collateral_type = '';

        /**
         * Encodes the specified QueryGetCdpRequest message. Does not implicitly {@link ununifi.cdp.QueryGetCdpRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @static
         * @param {ununifi.cdp.IQueryGetCdpRequest} message QueryGetCdpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetCdpRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
          return writer;
        };

        /**
         * Encodes the specified QueryGetCdpRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryGetCdpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @static
         * @param {ununifi.cdp.IQueryGetCdpRequest} message QueryGetCdpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetCdpRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetCdpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryGetCdpRequest} QueryGetCdpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetCdpRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryGetCdpRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.collateral_type = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetCdpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryGetCdpRequest} QueryGetCdpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetCdpRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetCdpRequest message.
         * @function verify
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetCdpRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          return null;
        };

        /**
         * Creates a QueryGetCdpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryGetCdpRequest} QueryGetCdpRequest
         */
        QueryGetCdpRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryGetCdpRequest) return object;
          var message = new $root.ununifi.cdp.QueryGetCdpRequest();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          return message;
        };

        /**
         * Creates a plain object from a QueryGetCdpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @static
         * @param {ununifi.cdp.QueryGetCdpRequest} message QueryGetCdpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetCdpRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.collateral_type = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          return object;
        };

        /**
         * Converts this QueryGetCdpRequest to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryGetCdpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetCdpRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetCdpRequest;
      })();

      cdp.QueryGetCdpResponse = (function () {
        /**
         * Properties of a QueryGetCdpResponse.
         * @memberof ununifi.cdp
         * @interface IQueryGetCdpResponse
         * @property {ununifi.cdp.IAugmentedCdp|null} [cdp] QueryGetCdpResponse cdp
         */

        /**
         * Constructs a new QueryGetCdpResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryGetCdpResponse.
         * @implements IQueryGetCdpResponse
         * @constructor
         * @param {ununifi.cdp.IQueryGetCdpResponse=} [properties] Properties to set
         */
        function QueryGetCdpResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGetCdpResponse cdp.
         * @member {ununifi.cdp.IAugmentedCdp|null|undefined} cdp
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @instance
         */
        QueryGetCdpResponse.prototype.cdp = null;

        /**
         * Encodes the specified QueryGetCdpResponse message. Does not implicitly {@link ununifi.cdp.QueryGetCdpResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @static
         * @param {ununifi.cdp.IQueryGetCdpResponse} message QueryGetCdpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetCdpResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.cdp != null && Object.hasOwnProperty.call(message, 'cdp'))
            $root.ununifi.cdp.AugmentedCdp.encode(message.cdp, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryGetCdpResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryGetCdpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @static
         * @param {ununifi.cdp.IQueryGetCdpResponse} message QueryGetCdpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetCdpResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetCdpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryGetCdpResponse} QueryGetCdpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetCdpResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryGetCdpResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.cdp = $root.ununifi.cdp.AugmentedCdp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetCdpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryGetCdpResponse} QueryGetCdpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetCdpResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetCdpResponse message.
         * @function verify
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetCdpResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.cdp != null && message.hasOwnProperty('cdp')) {
            var error = $root.ununifi.cdp.AugmentedCdp.verify(message.cdp);
            if (error) return 'cdp.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryGetCdpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryGetCdpResponse} QueryGetCdpResponse
         */
        QueryGetCdpResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryGetCdpResponse) return object;
          var message = new $root.ununifi.cdp.QueryGetCdpResponse();
          if (object.cdp != null) {
            if (typeof object.cdp !== 'object') throw TypeError('.ununifi.cdp.QueryGetCdpResponse.cdp: object expected');
            message.cdp = $root.ununifi.cdp.AugmentedCdp.fromObject(object.cdp);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryGetCdpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @static
         * @param {ununifi.cdp.QueryGetCdpResponse} message QueryGetCdpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetCdpResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.cdp = null;
          if (message.cdp != null && message.hasOwnProperty('cdp'))
            object.cdp = $root.ununifi.cdp.AugmentedCdp.toObject(message.cdp, options);
          return object;
        };

        /**
         * Converts this QueryGetCdpResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryGetCdpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetCdpResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetCdpResponse;
      })();

      cdp.QueryAllCdpRequest = (function () {
        /**
         * Properties of a QueryAllCdpRequest.
         * @memberof ununifi.cdp
         * @interface IQueryAllCdpRequest
         * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllCdpRequest pagination
         */

        /**
         * Constructs a new QueryAllCdpRequest.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryAllCdpRequest.
         * @implements IQueryAllCdpRequest
         * @constructor
         * @param {ununifi.cdp.IQueryAllCdpRequest=} [properties] Properties to set
         */
        function QueryAllCdpRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllCdpRequest pagination.
         * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @instance
         */
        QueryAllCdpRequest.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllCdpRequest message. Does not implicitly {@link ununifi.cdp.QueryAllCdpRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @static
         * @param {ununifi.cdp.IQueryAllCdpRequest} message QueryAllCdpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllCdpRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageRequest.encode(
              message.pagination,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllCdpRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllCdpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @static
         * @param {ununifi.cdp.IQueryAllCdpRequest} message QueryAllCdpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllCdpRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllCdpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryAllCdpRequest} QueryAllCdpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllCdpRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryAllCdpRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllCdpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryAllCdpRequest} QueryAllCdpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllCdpRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllCdpRequest message.
         * @function verify
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllCdpRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllCdpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryAllCdpRequest} QueryAllCdpRequest
         */
        QueryAllCdpRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryAllCdpRequest) return object;
          var message = new $root.ununifi.cdp.QueryAllCdpRequest();
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object') throw TypeError('.ununifi.cdp.QueryAllCdpRequest.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllCdpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @static
         * @param {ununifi.cdp.QueryAllCdpRequest} message QueryAllCdpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllCdpRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.pagination = null;
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllCdpRequest to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryAllCdpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllCdpRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllCdpRequest;
      })();

      cdp.QueryAllCdpResponse = (function () {
        /**
         * Properties of a QueryAllCdpResponse.
         * @memberof ununifi.cdp
         * @interface IQueryAllCdpResponse
         * @property {Array.<ununifi.cdp.IAugmentedCdp>|null} [cdp] QueryAllCdpResponse cdp
         * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllCdpResponse pagination
         */

        /**
         * Constructs a new QueryAllCdpResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryAllCdpResponse.
         * @implements IQueryAllCdpResponse
         * @constructor
         * @param {ununifi.cdp.IQueryAllCdpResponse=} [properties] Properties to set
         */
        function QueryAllCdpResponse(properties) {
          this.cdp = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllCdpResponse cdp.
         * @member {Array.<ununifi.cdp.IAugmentedCdp>} cdp
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @instance
         */
        QueryAllCdpResponse.prototype.cdp = $util.emptyArray;

        /**
         * QueryAllCdpResponse pagination.
         * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @instance
         */
        QueryAllCdpResponse.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllCdpResponse message. Does not implicitly {@link ununifi.cdp.QueryAllCdpResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @static
         * @param {ununifi.cdp.IQueryAllCdpResponse} message QueryAllCdpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllCdpResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.cdp != null && message.cdp.length)
            for (var i = 0; i < message.cdp.length; ++i)
              $root.ununifi.cdp.AugmentedCdp.encode(message.cdp[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageResponse.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllCdpResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllCdpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @static
         * @param {ununifi.cdp.IQueryAllCdpResponse} message QueryAllCdpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllCdpResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllCdpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryAllCdpResponse} QueryAllCdpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllCdpResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryAllCdpResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.cdp && message.cdp.length)) message.cdp = [];
                message.cdp.push($root.ununifi.cdp.AugmentedCdp.decode(reader, reader.uint32()));
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllCdpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryAllCdpResponse} QueryAllCdpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllCdpResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllCdpResponse message.
         * @function verify
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllCdpResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.cdp != null && message.hasOwnProperty('cdp')) {
            if (!Array.isArray(message.cdp)) return 'cdp: array expected';
            for (var i = 0; i < message.cdp.length; ++i) {
              var error = $root.ununifi.cdp.AugmentedCdp.verify(message.cdp[i]);
              if (error) return 'cdp.' + error;
            }
          }
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllCdpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryAllCdpResponse} QueryAllCdpResponse
         */
        QueryAllCdpResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryAllCdpResponse) return object;
          var message = new $root.ununifi.cdp.QueryAllCdpResponse();
          if (object.cdp) {
            if (!Array.isArray(object.cdp)) throw TypeError('.ununifi.cdp.QueryAllCdpResponse.cdp: array expected');
            message.cdp = [];
            for (var i = 0; i < object.cdp.length; ++i) {
              if (typeof object.cdp[i] !== 'object') throw TypeError('.ununifi.cdp.QueryAllCdpResponse.cdp: object expected');
              message.cdp[i] = $root.ununifi.cdp.AugmentedCdp.fromObject(object.cdp[i]);
            }
          }
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object') throw TypeError('.ununifi.cdp.QueryAllCdpResponse.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllCdpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @static
         * @param {ununifi.cdp.QueryAllCdpResponse} message QueryAllCdpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllCdpResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.cdp = [];
          if (options.defaults) object.pagination = null;
          if (message.cdp && message.cdp.length) {
            object.cdp = [];
            for (var j = 0; j < message.cdp.length; ++j) object.cdp[j] = $root.ununifi.cdp.AugmentedCdp.toObject(message.cdp[j], options);
          }
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllCdpResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryAllCdpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllCdpResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllCdpResponse;
      })();

      cdp.QueryAllAccountRequest = (function () {
        /**
         * Properties of a QueryAllAccountRequest.
         * @memberof ununifi.cdp
         * @interface IQueryAllAccountRequest
         */

        /**
         * Constructs a new QueryAllAccountRequest.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryAllAccountRequest.
         * @implements IQueryAllAccountRequest
         * @constructor
         * @param {ununifi.cdp.IQueryAllAccountRequest=} [properties] Properties to set
         */
        function QueryAllAccountRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryAllAccountRequest message. Does not implicitly {@link ununifi.cdp.QueryAllAccountRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @static
         * @param {ununifi.cdp.IQueryAllAccountRequest} message QueryAllAccountRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAccountRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryAllAccountRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllAccountRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @static
         * @param {ununifi.cdp.IQueryAllAccountRequest} message QueryAllAccountRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllAccountRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryAllAccountRequest} QueryAllAccountRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAccountRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryAllAccountRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllAccountRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryAllAccountRequest} QueryAllAccountRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAccountRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllAccountRequest message.
         * @function verify
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllAccountRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryAllAccountRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryAllAccountRequest} QueryAllAccountRequest
         */
        QueryAllAccountRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryAllAccountRequest) return object;
          return new $root.ununifi.cdp.QueryAllAccountRequest();
        };

        /**
         * Creates a plain object from a QueryAllAccountRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @static
         * @param {ununifi.cdp.QueryAllAccountRequest} message QueryAllAccountRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllAccountRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryAllAccountRequest to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryAllAccountRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllAccountRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllAccountRequest;
      })();

      cdp.QueryAllAccountResponse = (function () {
        /**
         * Properties of a QueryAllAccountResponse.
         * @memberof ununifi.cdp
         * @interface IQueryAllAccountResponse
         * @property {Array.<google.protobuf.IAny>|null} [accounts] QueryAllAccountResponse accounts
         */

        /**
         * Constructs a new QueryAllAccountResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryAllAccountResponse.
         * @implements IQueryAllAccountResponse
         * @constructor
         * @param {ununifi.cdp.IQueryAllAccountResponse=} [properties] Properties to set
         */
        function QueryAllAccountResponse(properties) {
          this.accounts = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllAccountResponse accounts.
         * @member {Array.<google.protobuf.IAny>} accounts
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @instance
         */
        QueryAllAccountResponse.prototype.accounts = $util.emptyArray;

        /**
         * Encodes the specified QueryAllAccountResponse message. Does not implicitly {@link ununifi.cdp.QueryAllAccountResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @static
         * @param {ununifi.cdp.IQueryAllAccountResponse} message QueryAllAccountResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAccountResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.accounts != null && message.accounts.length)
            for (var i = 0; i < message.accounts.length; ++i)
              $root.google.protobuf.Any.encode(message.accounts[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllAccountResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllAccountResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @static
         * @param {ununifi.cdp.IQueryAllAccountResponse} message QueryAllAccountResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllAccountResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryAllAccountResponse} QueryAllAccountResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAccountResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryAllAccountResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.accounts && message.accounts.length)) message.accounts = [];
                message.accounts.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllAccountResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryAllAccountResponse} QueryAllAccountResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllAccountResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllAccountResponse message.
         * @function verify
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllAccountResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.accounts != null && message.hasOwnProperty('accounts')) {
            if (!Array.isArray(message.accounts)) return 'accounts: array expected';
            for (var i = 0; i < message.accounts.length; ++i) {
              var error = $root.google.protobuf.Any.verify(message.accounts[i]);
              if (error) return 'accounts.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryAllAccountResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryAllAccountResponse} QueryAllAccountResponse
         */
        QueryAllAccountResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryAllAccountResponse) return object;
          var message = new $root.ununifi.cdp.QueryAllAccountResponse();
          if (object.accounts) {
            if (!Array.isArray(object.accounts)) throw TypeError('.ununifi.cdp.QueryAllAccountResponse.accounts: array expected');
            message.accounts = [];
            for (var i = 0; i < object.accounts.length; ++i) {
              if (typeof object.accounts[i] !== 'object') throw TypeError('.ununifi.cdp.QueryAllAccountResponse.accounts: object expected');
              message.accounts[i] = $root.google.protobuf.Any.fromObject(object.accounts[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllAccountResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @static
         * @param {ununifi.cdp.QueryAllAccountResponse} message QueryAllAccountResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllAccountResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.accounts = [];
          if (message.accounts && message.accounts.length) {
            object.accounts = [];
            for (var j = 0; j < message.accounts.length; ++j)
              object.accounts[j] = $root.google.protobuf.Any.toObject(message.accounts[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryAllAccountResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryAllAccountResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllAccountResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllAccountResponse;
      })();

      cdp.QueryAllDepositRequest = (function () {
        /**
         * Properties of a QueryAllDepositRequest.
         * @memberof ununifi.cdp
         * @interface IQueryAllDepositRequest
         * @property {string|null} [owner] QueryAllDepositRequest owner
         * @property {string|null} [collateral_type] QueryAllDepositRequest collateral_type
         */

        /**
         * Constructs a new QueryAllDepositRequest.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryAllDepositRequest.
         * @implements IQueryAllDepositRequest
         * @constructor
         * @param {ununifi.cdp.IQueryAllDepositRequest=} [properties] Properties to set
         */
        function QueryAllDepositRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllDepositRequest owner.
         * @member {string} owner
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @instance
         */
        QueryAllDepositRequest.prototype.owner = '';

        /**
         * QueryAllDepositRequest collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @instance
         */
        QueryAllDepositRequest.prototype.collateral_type = '';

        /**
         * Encodes the specified QueryAllDepositRequest message. Does not implicitly {@link ununifi.cdp.QueryAllDepositRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @static
         * @param {ununifi.cdp.IQueryAllDepositRequest} message QueryAllDepositRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllDepositRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
          return writer;
        };

        /**
         * Encodes the specified QueryAllDepositRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllDepositRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @static
         * @param {ununifi.cdp.IQueryAllDepositRequest} message QueryAllDepositRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllDepositRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllDepositRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryAllDepositRequest} QueryAllDepositRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllDepositRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryAllDepositRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.collateral_type = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllDepositRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryAllDepositRequest} QueryAllDepositRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllDepositRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllDepositRequest message.
         * @function verify
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllDepositRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          return null;
        };

        /**
         * Creates a QueryAllDepositRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryAllDepositRequest} QueryAllDepositRequest
         */
        QueryAllDepositRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryAllDepositRequest) return object;
          var message = new $root.ununifi.cdp.QueryAllDepositRequest();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          return message;
        };

        /**
         * Creates a plain object from a QueryAllDepositRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @static
         * @param {ununifi.cdp.QueryAllDepositRequest} message QueryAllDepositRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllDepositRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.collateral_type = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          return object;
        };

        /**
         * Converts this QueryAllDepositRequest to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryAllDepositRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllDepositRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllDepositRequest;
      })();

      cdp.QueryAllDepositResponse = (function () {
        /**
         * Properties of a QueryAllDepositResponse.
         * @memberof ununifi.cdp
         * @interface IQueryAllDepositResponse
         * @property {Array.<ununifi.cdp.IDeposit>|null} [deposits] QueryAllDepositResponse deposits
         */

        /**
         * Constructs a new QueryAllDepositResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a QueryAllDepositResponse.
         * @implements IQueryAllDepositResponse
         * @constructor
         * @param {ununifi.cdp.IQueryAllDepositResponse=} [properties] Properties to set
         */
        function QueryAllDepositResponse(properties) {
          this.deposits = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllDepositResponse deposits.
         * @member {Array.<ununifi.cdp.IDeposit>} deposits
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @instance
         */
        QueryAllDepositResponse.prototype.deposits = $util.emptyArray;

        /**
         * Encodes the specified QueryAllDepositResponse message. Does not implicitly {@link ununifi.cdp.QueryAllDepositResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @static
         * @param {ununifi.cdp.IQueryAllDepositResponse} message QueryAllDepositResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllDepositResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.deposits != null && message.deposits.length)
            for (var i = 0; i < message.deposits.length; ++i)
              $root.ununifi.cdp.Deposit.encode(message.deposits[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllDepositResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllDepositResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @static
         * @param {ununifi.cdp.IQueryAllDepositResponse} message QueryAllDepositResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllDepositResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllDepositResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.QueryAllDepositResponse} QueryAllDepositResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllDepositResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.QueryAllDepositResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.deposits && message.deposits.length)) message.deposits = [];
                message.deposits.push($root.ununifi.cdp.Deposit.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllDepositResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.QueryAllDepositResponse} QueryAllDepositResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllDepositResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllDepositResponse message.
         * @function verify
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllDepositResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.deposits != null && message.hasOwnProperty('deposits')) {
            if (!Array.isArray(message.deposits)) return 'deposits: array expected';
            for (var i = 0; i < message.deposits.length; ++i) {
              var error = $root.ununifi.cdp.Deposit.verify(message.deposits[i]);
              if (error) return 'deposits.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryAllDepositResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.QueryAllDepositResponse} QueryAllDepositResponse
         */
        QueryAllDepositResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.QueryAllDepositResponse) return object;
          var message = new $root.ununifi.cdp.QueryAllDepositResponse();
          if (object.deposits) {
            if (!Array.isArray(object.deposits)) throw TypeError('.ununifi.cdp.QueryAllDepositResponse.deposits: array expected');
            message.deposits = [];
            for (var i = 0; i < object.deposits.length; ++i) {
              if (typeof object.deposits[i] !== 'object') throw TypeError('.ununifi.cdp.QueryAllDepositResponse.deposits: object expected');
              message.deposits[i] = $root.ununifi.cdp.Deposit.fromObject(object.deposits[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllDepositResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @static
         * @param {ununifi.cdp.QueryAllDepositResponse} message QueryAllDepositResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllDepositResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.deposits = [];
          if (message.deposits && message.deposits.length) {
            object.deposits = [];
            for (var j = 0; j < message.deposits.length; ++j)
              object.deposits[j] = $root.ununifi.cdp.Deposit.toObject(message.deposits[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryAllDepositResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.QueryAllDepositResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllDepositResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllDepositResponse;
      })();

      cdp.Cdp = (function () {
        /**
         * Properties of a Cdp.
         * @memberof ununifi.cdp
         * @interface ICdp
         * @property {Long|null} [id] Cdp id
         * @property {string|null} [owner] Cdp owner
         * @property {string|null} [type] Cdp type
         * @property {cosmos.base.v1beta1.ICoin|null} [collateral] Cdp collateral
         * @property {cosmos.base.v1beta1.ICoin|null} [principal] Cdp principal
         * @property {cosmos.base.v1beta1.ICoin|null} [accumulated_fees] Cdp accumulated_fees
         * @property {google.protobuf.ITimestamp|null} [fees_updated] Cdp fees_updated
         * @property {string|null} [interest_factor] Cdp interest_factor
         */

        /**
         * Constructs a new Cdp.
         * @memberof ununifi.cdp
         * @classdesc Represents a Cdp.
         * @implements ICdp
         * @constructor
         * @param {ununifi.cdp.ICdp=} [properties] Properties to set
         */
        function Cdp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Cdp id.
         * @member {Long} id
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Cdp owner.
         * @member {string} owner
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.owner = '';

        /**
         * Cdp type.
         * @member {string} type
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.type = '';

        /**
         * Cdp collateral.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.collateral = null;

        /**
         * Cdp principal.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} principal
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.principal = null;

        /**
         * Cdp accumulated_fees.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} accumulated_fees
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.accumulated_fees = null;

        /**
         * Cdp fees_updated.
         * @member {google.protobuf.ITimestamp|null|undefined} fees_updated
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.fees_updated = null;

        /**
         * Cdp interest_factor.
         * @member {string} interest_factor
         * @memberof ununifi.cdp.Cdp
         * @instance
         */
        Cdp.prototype.interest_factor = '';

        /**
         * Encodes the specified Cdp message. Does not implicitly {@link ununifi.cdp.Cdp.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.Cdp
         * @static
         * @param {ununifi.cdp.ICdp} message Cdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cdp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
          if (message.type != null && Object.hasOwnProperty.call(message, 'type'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.type);
          if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
            $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          if (message.principal != null && Object.hasOwnProperty.call(message, 'principal'))
            $root.cosmos.base.v1beta1.Coin.encode(message.principal, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
          if (message.accumulated_fees != null && Object.hasOwnProperty.call(message, 'accumulated_fees'))
            $root.cosmos.base.v1beta1.Coin.encode(message.accumulated_fees, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
          if (message.fees_updated != null && Object.hasOwnProperty.call(message, 'fees_updated'))
            $root.google.protobuf.Timestamp.encode(message.fees_updated, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
          if (message.interest_factor != null && Object.hasOwnProperty.call(message, 'interest_factor'))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.interest_factor);
          return writer;
        };

        /**
         * Encodes the specified Cdp message, length delimited. Does not implicitly {@link ununifi.cdp.Cdp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.Cdp
         * @static
         * @param {ununifi.cdp.ICdp} message Cdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cdp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Cdp message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.Cdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.Cdp} Cdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cdp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.Cdp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.id = reader.uint64();
                break;
              case 2:
                message.owner = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 4:
                message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 5:
                message.principal = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 6:
                message.accumulated_fees = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 7:
                message.fees_updated = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 8:
                message.interest_factor = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Cdp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.Cdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.Cdp} Cdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cdp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Cdp message.
         * @function verify
         * @memberof ununifi.cdp.Cdp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Cdp.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.id != null && message.hasOwnProperty('id'))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
              return 'id: integer|Long expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.type != null && message.hasOwnProperty('type')) if (!$util.isString(message.type)) return 'type: string expected';
          if (message.collateral != null && message.hasOwnProperty('collateral')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
            if (error) return 'collateral.' + error;
          }
          if (message.principal != null && message.hasOwnProperty('principal')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.principal);
            if (error) return 'principal.' + error;
          }
          if (message.accumulated_fees != null && message.hasOwnProperty('accumulated_fees')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.accumulated_fees);
            if (error) return 'accumulated_fees.' + error;
          }
          if (message.fees_updated != null && message.hasOwnProperty('fees_updated')) {
            var error = $root.google.protobuf.Timestamp.verify(message.fees_updated);
            if (error) return 'fees_updated.' + error;
          }
          if (message.interest_factor != null && message.hasOwnProperty('interest_factor'))
            if (!$util.isString(message.interest_factor)) return 'interest_factor: string expected';
          return null;
        };

        /**
         * Creates a Cdp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.Cdp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.Cdp} Cdp
         */
        Cdp.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.Cdp) return object;
          var message = new $root.ununifi.cdp.Cdp();
          if (object.id != null)
            if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
            else if (typeof object.id === 'number') message.id = object.id;
            else if (typeof object.id === 'object')
              message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
          if (object.owner != null) message.owner = String(object.owner);
          if (object.type != null) message.type = String(object.type);
          if (object.collateral != null) {
            if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.Cdp.collateral: object expected');
            message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
          }
          if (object.principal != null) {
            if (typeof object.principal !== 'object') throw TypeError('.ununifi.cdp.Cdp.principal: object expected');
            message.principal = $root.cosmos.base.v1beta1.Coin.fromObject(object.principal);
          }
          if (object.accumulated_fees != null) {
            if (typeof object.accumulated_fees !== 'object') throw TypeError('.ununifi.cdp.Cdp.accumulated_fees: object expected');
            message.accumulated_fees = $root.cosmos.base.v1beta1.Coin.fromObject(object.accumulated_fees);
          }
          if (object.fees_updated != null) {
            if (typeof object.fees_updated !== 'object') throw TypeError('.ununifi.cdp.Cdp.fees_updated: object expected');
            message.fees_updated = $root.google.protobuf.Timestamp.fromObject(object.fees_updated);
          }
          if (object.interest_factor != null) message.interest_factor = String(object.interest_factor);
          return message;
        };

        /**
         * Creates a plain object from a Cdp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.Cdp
         * @static
         * @param {ununifi.cdp.Cdp} message Cdp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Cdp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.id = options.longs === String ? '0' : 0;
            object.owner = '';
            object.type = '';
            object.collateral = null;
            object.principal = null;
            object.accumulated_fees = null;
            object.fees_updated = null;
            object.interest_factor = '';
          }
          if (message.id != null && message.hasOwnProperty('id'))
            if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
            else
              object.id =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.id)
                  : options.longs === Number
                  ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                  : message.id;
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.type != null && message.hasOwnProperty('type')) object.type = message.type;
          if (message.collateral != null && message.hasOwnProperty('collateral'))
            object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
          if (message.principal != null && message.hasOwnProperty('principal'))
            object.principal = $root.cosmos.base.v1beta1.Coin.toObject(message.principal, options);
          if (message.accumulated_fees != null && message.hasOwnProperty('accumulated_fees'))
            object.accumulated_fees = $root.cosmos.base.v1beta1.Coin.toObject(message.accumulated_fees, options);
          if (message.fees_updated != null && message.hasOwnProperty('fees_updated'))
            object.fees_updated = $root.google.protobuf.Timestamp.toObject(message.fees_updated, options);
          if (message.interest_factor != null && message.hasOwnProperty('interest_factor'))
            object.interest_factor = message.interest_factor;
          return object;
        };

        /**
         * Converts this Cdp to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.Cdp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Cdp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Cdp;
      })();

      cdp.Deposit = (function () {
        /**
         * Properties of a Deposit.
         * @memberof ununifi.cdp
         * @interface IDeposit
         * @property {Long|null} [cdp_id] Deposit cdp_id
         * @property {string|null} [depositor] Deposit depositor
         * @property {cosmos.base.v1beta1.ICoin|null} [amount] Deposit amount
         */

        /**
         * Constructs a new Deposit.
         * @memberof ununifi.cdp
         * @classdesc Represents a Deposit.
         * @implements IDeposit
         * @constructor
         * @param {ununifi.cdp.IDeposit=} [properties] Properties to set
         */
        function Deposit(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Deposit cdp_id.
         * @member {Long} cdp_id
         * @memberof ununifi.cdp.Deposit
         * @instance
         */
        Deposit.prototype.cdp_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Deposit depositor.
         * @member {string} depositor
         * @memberof ununifi.cdp.Deposit
         * @instance
         */
        Deposit.prototype.depositor = '';

        /**
         * Deposit amount.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
         * @memberof ununifi.cdp.Deposit
         * @instance
         */
        Deposit.prototype.amount = null;

        /**
         * Encodes the specified Deposit message. Does not implicitly {@link ununifi.cdp.Deposit.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.Deposit
         * @static
         * @param {ununifi.cdp.IDeposit} message Deposit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Deposit.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.cdp_id != null && Object.hasOwnProperty.call(message, 'cdp_id'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.cdp_id);
          if (message.depositor != null && Object.hasOwnProperty.call(message, 'depositor'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.depositor);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Deposit message, length delimited. Does not implicitly {@link ununifi.cdp.Deposit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.Deposit
         * @static
         * @param {ununifi.cdp.IDeposit} message Deposit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Deposit.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Deposit message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.Deposit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.Deposit} Deposit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Deposit.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.Deposit();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.cdp_id = reader.uint64();
                break;
              case 2:
                message.depositor = reader.string();
                break;
              case 3:
                message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Deposit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.Deposit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.Deposit} Deposit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Deposit.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Deposit message.
         * @function verify
         * @memberof ununifi.cdp.Deposit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Deposit.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.cdp_id != null && message.hasOwnProperty('cdp_id'))
            if (
              !$util.isInteger(message.cdp_id) &&
              !(message.cdp_id && $util.isInteger(message.cdp_id.low) && $util.isInteger(message.cdp_id.high))
            )
              return 'cdp_id: integer|Long expected';
          if (message.depositor != null && message.hasOwnProperty('depositor'))
            if (!$util.isString(message.depositor)) return 'depositor: string expected';
          if (message.amount != null && message.hasOwnProperty('amount')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
            if (error) return 'amount.' + error;
          }
          return null;
        };

        /**
         * Creates a Deposit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.Deposit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.Deposit} Deposit
         */
        Deposit.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.Deposit) return object;
          var message = new $root.ununifi.cdp.Deposit();
          if (object.cdp_id != null)
            if ($util.Long) (message.cdp_id = $util.Long.fromValue(object.cdp_id)).unsigned = true;
            else if (typeof object.cdp_id === 'string') message.cdp_id = parseInt(object.cdp_id, 10);
            else if (typeof object.cdp_id === 'number') message.cdp_id = object.cdp_id;
            else if (typeof object.cdp_id === 'object')
              message.cdp_id = new $util.LongBits(object.cdp_id.low >>> 0, object.cdp_id.high >>> 0).toNumber(true);
          if (object.depositor != null) message.depositor = String(object.depositor);
          if (object.amount != null) {
            if (typeof object.amount !== 'object') throw TypeError('.ununifi.cdp.Deposit.amount: object expected');
            message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
          }
          return message;
        };

        /**
         * Creates a plain object from a Deposit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.Deposit
         * @static
         * @param {ununifi.cdp.Deposit} message Deposit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Deposit.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.cdp_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.cdp_id = options.longs === String ? '0' : 0;
            object.depositor = '';
            object.amount = null;
          }
          if (message.cdp_id != null && message.hasOwnProperty('cdp_id'))
            if (typeof message.cdp_id === 'number') object.cdp_id = options.longs === String ? String(message.cdp_id) : message.cdp_id;
            else
              object.cdp_id =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.cdp_id)
                  : options.longs === Number
                  ? new $util.LongBits(message.cdp_id.low >>> 0, message.cdp_id.high >>> 0).toNumber(true)
                  : message.cdp_id;
          if (message.depositor != null && message.hasOwnProperty('depositor')) object.depositor = message.depositor;
          if (message.amount != null && message.hasOwnProperty('amount'))
            object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
          return object;
        };

        /**
         * Converts this Deposit to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.Deposit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Deposit.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Deposit;
      })();

      cdp.AugmentedCdp = (function () {
        /**
         * Properties of an AugmentedCdp.
         * @memberof ununifi.cdp
         * @interface IAugmentedCdp
         * @property {ununifi.cdp.ICdp|null} [cdp] AugmentedCdp cdp
         * @property {cosmos.base.v1beta1.ICoin|null} [collateral_value] AugmentedCdp collateral_value
         * @property {string|null} [collateralization_ratio] AugmentedCdp collateralization_ratio
         */

        /**
         * Constructs a new AugmentedCdp.
         * @memberof ununifi.cdp
         * @classdesc Represents an AugmentedCdp.
         * @implements IAugmentedCdp
         * @constructor
         * @param {ununifi.cdp.IAugmentedCdp=} [properties] Properties to set
         */
        function AugmentedCdp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * AugmentedCdp cdp.
         * @member {ununifi.cdp.ICdp|null|undefined} cdp
         * @memberof ununifi.cdp.AugmentedCdp
         * @instance
         */
        AugmentedCdp.prototype.cdp = null;

        /**
         * AugmentedCdp collateral_value.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral_value
         * @memberof ununifi.cdp.AugmentedCdp
         * @instance
         */
        AugmentedCdp.prototype.collateral_value = null;

        /**
         * AugmentedCdp collateralization_ratio.
         * @member {string} collateralization_ratio
         * @memberof ununifi.cdp.AugmentedCdp
         * @instance
         */
        AugmentedCdp.prototype.collateralization_ratio = '';

        /**
         * Encodes the specified AugmentedCdp message. Does not implicitly {@link ununifi.cdp.AugmentedCdp.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.AugmentedCdp
         * @static
         * @param {ununifi.cdp.IAugmentedCdp} message AugmentedCdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AugmentedCdp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.cdp != null && Object.hasOwnProperty.call(message, 'cdp'))
            $root.ununifi.cdp.Cdp.encode(message.cdp, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.collateral_value != null && Object.hasOwnProperty.call(message, 'collateral_value'))
            $root.cosmos.base.v1beta1.Coin.encode(message.collateral_value, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.collateralization_ratio != null && Object.hasOwnProperty.call(message, 'collateralization_ratio'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.collateralization_ratio);
          return writer;
        };

        /**
         * Encodes the specified AugmentedCdp message, length delimited. Does not implicitly {@link ununifi.cdp.AugmentedCdp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.AugmentedCdp
         * @static
         * @param {ununifi.cdp.IAugmentedCdp} message AugmentedCdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AugmentedCdp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AugmentedCdp message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.AugmentedCdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.AugmentedCdp} AugmentedCdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AugmentedCdp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.AugmentedCdp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.cdp = $root.ununifi.cdp.Cdp.decode(reader, reader.uint32());
                break;
              case 2:
                message.collateral_value = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 3:
                message.collateralization_ratio = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an AugmentedCdp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.AugmentedCdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.AugmentedCdp} AugmentedCdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AugmentedCdp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AugmentedCdp message.
         * @function verify
         * @memberof ununifi.cdp.AugmentedCdp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AugmentedCdp.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.cdp != null && message.hasOwnProperty('cdp')) {
            var error = $root.ununifi.cdp.Cdp.verify(message.cdp);
            if (error) return 'cdp.' + error;
          }
          if (message.collateral_value != null && message.hasOwnProperty('collateral_value')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral_value);
            if (error) return 'collateral_value.' + error;
          }
          if (message.collateralization_ratio != null && message.hasOwnProperty('collateralization_ratio'))
            if (!$util.isString(message.collateralization_ratio)) return 'collateralization_ratio: string expected';
          return null;
        };

        /**
         * Creates an AugmentedCdp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.AugmentedCdp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.AugmentedCdp} AugmentedCdp
         */
        AugmentedCdp.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.AugmentedCdp) return object;
          var message = new $root.ununifi.cdp.AugmentedCdp();
          if (object.cdp != null) {
            if (typeof object.cdp !== 'object') throw TypeError('.ununifi.cdp.AugmentedCdp.cdp: object expected');
            message.cdp = $root.ununifi.cdp.Cdp.fromObject(object.cdp);
          }
          if (object.collateral_value != null) {
            if (typeof object.collateral_value !== 'object') throw TypeError('.ununifi.cdp.AugmentedCdp.collateral_value: object expected');
            message.collateral_value = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral_value);
          }
          if (object.collateralization_ratio != null) message.collateralization_ratio = String(object.collateralization_ratio);
          return message;
        };

        /**
         * Creates a plain object from an AugmentedCdp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.AugmentedCdp
         * @static
         * @param {ununifi.cdp.AugmentedCdp} message AugmentedCdp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AugmentedCdp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.cdp = null;
            object.collateral_value = null;
            object.collateralization_ratio = '';
          }
          if (message.cdp != null && message.hasOwnProperty('cdp')) object.cdp = $root.ununifi.cdp.Cdp.toObject(message.cdp, options);
          if (message.collateral_value != null && message.hasOwnProperty('collateral_value'))
            object.collateral_value = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral_value, options);
          if (message.collateralization_ratio != null && message.hasOwnProperty('collateralization_ratio'))
            object.collateralization_ratio = message.collateralization_ratio;
          return object;
        };

        /**
         * Converts this AugmentedCdp to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.AugmentedCdp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AugmentedCdp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AugmentedCdp;
      })();

      cdp.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.cdp
         * @interface IParams
         * @property {Array.<ununifi.cdp.ICollateralParam>|null} [collateral_params] Params collateral_params
         * @property {Array.<ununifi.cdp.IDebtParam>|null} [debt_params] Params debt_params
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.cdp
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.cdp.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          this.collateral_params = [];
          this.debt_params = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params collateral_params.
         * @member {Array.<ununifi.cdp.ICollateralParam>} collateral_params
         * @memberof ununifi.cdp.Params
         * @instance
         */
        Params.prototype.collateral_params = $util.emptyArray;

        /**
         * Params debt_params.
         * @member {Array.<ununifi.cdp.IDebtParam>} debt_params
         * @memberof ununifi.cdp.Params
         * @instance
         */
        Params.prototype.debt_params = $util.emptyArray;

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.cdp.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.Params
         * @static
         * @param {ununifi.cdp.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.collateral_params != null && message.collateral_params.length)
            for (var i = 0; i < message.collateral_params.length; ++i)
              $root.ununifi.cdp.CollateralParam.encode(
                message.collateral_params[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          if (message.debt_params != null && message.debt_params.length)
            for (var i = 0; i < message.debt_params.length; ++i)
              $root.ununifi.cdp.DebtParam.encode(message.debt_params[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.cdp.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.Params
         * @static
         * @param {ununifi.cdp.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.collateral_params && message.collateral_params.length)) message.collateral_params = [];
                message.collateral_params.push($root.ununifi.cdp.CollateralParam.decode(reader, reader.uint32()));
                break;
              case 2:
                if (!(message.debt_params && message.debt_params.length)) message.debt_params = [];
                message.debt_params.push($root.ununifi.cdp.DebtParam.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.cdp.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.collateral_params != null && message.hasOwnProperty('collateral_params')) {
            if (!Array.isArray(message.collateral_params)) return 'collateral_params: array expected';
            for (var i = 0; i < message.collateral_params.length; ++i) {
              var error = $root.ununifi.cdp.CollateralParam.verify(message.collateral_params[i]);
              if (error) return 'collateral_params.' + error;
            }
          }
          if (message.debt_params != null && message.hasOwnProperty('debt_params')) {
            if (!Array.isArray(message.debt_params)) return 'debt_params: array expected';
            for (var i = 0; i < message.debt_params.length; ++i) {
              var error = $root.ununifi.cdp.DebtParam.verify(message.debt_params[i]);
              if (error) return 'debt_params.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.Params) return object;
          var message = new $root.ununifi.cdp.Params();
          if (object.collateral_params) {
            if (!Array.isArray(object.collateral_params)) throw TypeError('.ununifi.cdp.Params.collateral_params: array expected');
            message.collateral_params = [];
            for (var i = 0; i < object.collateral_params.length; ++i) {
              if (typeof object.collateral_params[i] !== 'object')
                throw TypeError('.ununifi.cdp.Params.collateral_params: object expected');
              message.collateral_params[i] = $root.ununifi.cdp.CollateralParam.fromObject(object.collateral_params[i]);
            }
          }
          if (object.debt_params) {
            if (!Array.isArray(object.debt_params)) throw TypeError('.ununifi.cdp.Params.debt_params: array expected');
            message.debt_params = [];
            for (var i = 0; i < object.debt_params.length; ++i) {
              if (typeof object.debt_params[i] !== 'object') throw TypeError('.ununifi.cdp.Params.debt_params: object expected');
              message.debt_params[i] = $root.ununifi.cdp.DebtParam.fromObject(object.debt_params[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.Params
         * @static
         * @param {ununifi.cdp.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.collateral_params = [];
            object.debt_params = [];
          }
          if (message.collateral_params && message.collateral_params.length) {
            object.collateral_params = [];
            for (var j = 0; j < message.collateral_params.length; ++j)
              object.collateral_params[j] = $root.ununifi.cdp.CollateralParam.toObject(message.collateral_params[j], options);
          }
          if (message.debt_params && message.debt_params.length) {
            object.debt_params = [];
            for (var j = 0; j < message.debt_params.length; ++j)
              object.debt_params[j] = $root.ununifi.cdp.DebtParam.toObject(message.debt_params[j], options);
          }
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      cdp.CollateralParam = (function () {
        /**
         * Properties of a CollateralParam.
         * @memberof ununifi.cdp
         * @interface ICollateralParam
         * @property {string|null} [denom] CollateralParam denom
         * @property {string|null} [type] CollateralParam type
         * @property {string|null} [liquidation_ratio] CollateralParam liquidation_ratio
         * @property {cosmos.base.v1beta1.ICoin|null} [debt_limit] CollateralParam debt_limit
         * @property {string|null} [stability_fee] CollateralParam stability_fee
         * @property {string|null} [auction_size] CollateralParam auction_size
         * @property {string|null} [liquidation_penalty] CollateralParam liquidation_penalty
         * @property {number|null} [prefix] CollateralParam prefix
         * @property {string|null} [spot_market_id] CollateralParam spot_market_id
         * @property {string|null} [liquidation_market_id] CollateralParam liquidation_market_id
         * @property {string|null} [keeper_reward_percentage] CollateralParam keeper_reward_percentage
         * @property {string|null} [check_collateralization_index_count] CollateralParam check_collateralization_index_count
         * @property {string|null} [conversion_factor] CollateralParam conversion_factor
         */

        /**
         * Constructs a new CollateralParam.
         * @memberof ununifi.cdp
         * @classdesc Represents a CollateralParam.
         * @implements ICollateralParam
         * @constructor
         * @param {ununifi.cdp.ICollateralParam=} [properties] Properties to set
         */
        function CollateralParam(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * CollateralParam denom.
         * @member {string} denom
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.denom = '';

        /**
         * CollateralParam type.
         * @member {string} type
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.type = '';

        /**
         * CollateralParam liquidation_ratio.
         * @member {string} liquidation_ratio
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.liquidation_ratio = '';

        /**
         * CollateralParam debt_limit.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} debt_limit
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.debt_limit = null;

        /**
         * CollateralParam stability_fee.
         * @member {string} stability_fee
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.stability_fee = '';

        /**
         * CollateralParam auction_size.
         * @member {string} auction_size
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.auction_size = '';

        /**
         * CollateralParam liquidation_penalty.
         * @member {string} liquidation_penalty
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.liquidation_penalty = '';

        /**
         * CollateralParam prefix.
         * @member {number} prefix
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.prefix = 0;

        /**
         * CollateralParam spot_market_id.
         * @member {string} spot_market_id
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.spot_market_id = '';

        /**
         * CollateralParam liquidation_market_id.
         * @member {string} liquidation_market_id
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.liquidation_market_id = '';

        /**
         * CollateralParam keeper_reward_percentage.
         * @member {string} keeper_reward_percentage
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.keeper_reward_percentage = '';

        /**
         * CollateralParam check_collateralization_index_count.
         * @member {string} check_collateralization_index_count
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.check_collateralization_index_count = '';

        /**
         * CollateralParam conversion_factor.
         * @member {string} conversion_factor
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         */
        CollateralParam.prototype.conversion_factor = '';

        /**
         * Encodes the specified CollateralParam message. Does not implicitly {@link ununifi.cdp.CollateralParam.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.CollateralParam
         * @static
         * @param {ununifi.cdp.ICollateralParam} message CollateralParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CollateralParam.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
          if (message.type != null && Object.hasOwnProperty.call(message, 'type'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.type);
          if (message.liquidation_ratio != null && Object.hasOwnProperty.call(message, 'liquidation_ratio'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.liquidation_ratio);
          if (message.debt_limit != null && Object.hasOwnProperty.call(message, 'debt_limit'))
            $root.cosmos.base.v1beta1.Coin.encode(message.debt_limit, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          if (message.stability_fee != null && Object.hasOwnProperty.call(message, 'stability_fee'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.stability_fee);
          if (message.auction_size != null && Object.hasOwnProperty.call(message, 'auction_size'))
            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.auction_size);
          if (message.liquidation_penalty != null && Object.hasOwnProperty.call(message, 'liquidation_penalty'))
            writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.liquidation_penalty);
          if (message.prefix != null && Object.hasOwnProperty.call(message, 'prefix'))
            writer.uint32(/* id 8, wireType 0 =*/ 64).uint32(message.prefix);
          if (message.spot_market_id != null && Object.hasOwnProperty.call(message, 'spot_market_id'))
            writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.spot_market_id);
          if (message.liquidation_market_id != null && Object.hasOwnProperty.call(message, 'liquidation_market_id'))
            writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.liquidation_market_id);
          if (message.keeper_reward_percentage != null && Object.hasOwnProperty.call(message, 'keeper_reward_percentage'))
            writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.keeper_reward_percentage);
          if (
            message.check_collateralization_index_count != null &&
            Object.hasOwnProperty.call(message, 'check_collateralization_index_count')
          )
            writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.check_collateralization_index_count);
          if (message.conversion_factor != null && Object.hasOwnProperty.call(message, 'conversion_factor'))
            writer.uint32(/* id 13, wireType 2 =*/ 106).string(message.conversion_factor);
          return writer;
        };

        /**
         * Encodes the specified CollateralParam message, length delimited. Does not implicitly {@link ununifi.cdp.CollateralParam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.CollateralParam
         * @static
         * @param {ununifi.cdp.ICollateralParam} message CollateralParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CollateralParam.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CollateralParam message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.CollateralParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.CollateralParam} CollateralParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CollateralParam.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.CollateralParam();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.type = reader.string();
                break;
              case 3:
                message.liquidation_ratio = reader.string();
                break;
              case 4:
                message.debt_limit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 5:
                message.stability_fee = reader.string();
                break;
              case 6:
                message.auction_size = reader.string();
                break;
              case 7:
                message.liquidation_penalty = reader.string();
                break;
              case 8:
                message.prefix = reader.uint32();
                break;
              case 9:
                message.spot_market_id = reader.string();
                break;
              case 10:
                message.liquidation_market_id = reader.string();
                break;
              case 11:
                message.keeper_reward_percentage = reader.string();
                break;
              case 12:
                message.check_collateralization_index_count = reader.string();
                break;
              case 13:
                message.conversion_factor = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a CollateralParam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.CollateralParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.CollateralParam} CollateralParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CollateralParam.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CollateralParam message.
         * @function verify
         * @memberof ununifi.cdp.CollateralParam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CollateralParam.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          if (message.type != null && message.hasOwnProperty('type')) if (!$util.isString(message.type)) return 'type: string expected';
          if (message.liquidation_ratio != null && message.hasOwnProperty('liquidation_ratio'))
            if (!$util.isString(message.liquidation_ratio)) return 'liquidation_ratio: string expected';
          if (message.debt_limit != null && message.hasOwnProperty('debt_limit')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.debt_limit);
            if (error) return 'debt_limit.' + error;
          }
          if (message.stability_fee != null && message.hasOwnProperty('stability_fee'))
            if (!$util.isString(message.stability_fee)) return 'stability_fee: string expected';
          if (message.auction_size != null && message.hasOwnProperty('auction_size'))
            if (!$util.isString(message.auction_size)) return 'auction_size: string expected';
          if (message.liquidation_penalty != null && message.hasOwnProperty('liquidation_penalty'))
            if (!$util.isString(message.liquidation_penalty)) return 'liquidation_penalty: string expected';
          if (message.prefix != null && message.hasOwnProperty('prefix'))
            if (!$util.isInteger(message.prefix)) return 'prefix: integer expected';
          if (message.spot_market_id != null && message.hasOwnProperty('spot_market_id'))
            if (!$util.isString(message.spot_market_id)) return 'spot_market_id: string expected';
          if (message.liquidation_market_id != null && message.hasOwnProperty('liquidation_market_id'))
            if (!$util.isString(message.liquidation_market_id)) return 'liquidation_market_id: string expected';
          if (message.keeper_reward_percentage != null && message.hasOwnProperty('keeper_reward_percentage'))
            if (!$util.isString(message.keeper_reward_percentage)) return 'keeper_reward_percentage: string expected';
          if (message.check_collateralization_index_count != null && message.hasOwnProperty('check_collateralization_index_count'))
            if (!$util.isString(message.check_collateralization_index_count)) return 'check_collateralization_index_count: string expected';
          if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
            if (!$util.isString(message.conversion_factor)) return 'conversion_factor: string expected';
          return null;
        };

        /**
         * Creates a CollateralParam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.CollateralParam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.CollateralParam} CollateralParam
         */
        CollateralParam.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.CollateralParam) return object;
          var message = new $root.ununifi.cdp.CollateralParam();
          if (object.denom != null) message.denom = String(object.denom);
          if (object.type != null) message.type = String(object.type);
          if (object.liquidation_ratio != null) message.liquidation_ratio = String(object.liquidation_ratio);
          if (object.debt_limit != null) {
            if (typeof object.debt_limit !== 'object') throw TypeError('.ununifi.cdp.CollateralParam.debt_limit: object expected');
            message.debt_limit = $root.cosmos.base.v1beta1.Coin.fromObject(object.debt_limit);
          }
          if (object.stability_fee != null) message.stability_fee = String(object.stability_fee);
          if (object.auction_size != null) message.auction_size = String(object.auction_size);
          if (object.liquidation_penalty != null) message.liquidation_penalty = String(object.liquidation_penalty);
          if (object.prefix != null) message.prefix = object.prefix >>> 0;
          if (object.spot_market_id != null) message.spot_market_id = String(object.spot_market_id);
          if (object.liquidation_market_id != null) message.liquidation_market_id = String(object.liquidation_market_id);
          if (object.keeper_reward_percentage != null) message.keeper_reward_percentage = String(object.keeper_reward_percentage);
          if (object.check_collateralization_index_count != null)
            message.check_collateralization_index_count = String(object.check_collateralization_index_count);
          if (object.conversion_factor != null) message.conversion_factor = String(object.conversion_factor);
          return message;
        };

        /**
         * Creates a plain object from a CollateralParam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.CollateralParam
         * @static
         * @param {ununifi.cdp.CollateralParam} message CollateralParam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CollateralParam.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.denom = '';
            object.type = '';
            object.liquidation_ratio = '';
            object.debt_limit = null;
            object.stability_fee = '';
            object.auction_size = '';
            object.liquidation_penalty = '';
            object.prefix = 0;
            object.spot_market_id = '';
            object.liquidation_market_id = '';
            object.keeper_reward_percentage = '';
            object.check_collateralization_index_count = '';
            object.conversion_factor = '';
          }
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          if (message.type != null && message.hasOwnProperty('type')) object.type = message.type;
          if (message.liquidation_ratio != null && message.hasOwnProperty('liquidation_ratio'))
            object.liquidation_ratio = message.liquidation_ratio;
          if (message.debt_limit != null && message.hasOwnProperty('debt_limit'))
            object.debt_limit = $root.cosmos.base.v1beta1.Coin.toObject(message.debt_limit, options);
          if (message.stability_fee != null && message.hasOwnProperty('stability_fee')) object.stability_fee = message.stability_fee;
          if (message.auction_size != null && message.hasOwnProperty('auction_size')) object.auction_size = message.auction_size;
          if (message.liquidation_penalty != null && message.hasOwnProperty('liquidation_penalty'))
            object.liquidation_penalty = message.liquidation_penalty;
          if (message.prefix != null && message.hasOwnProperty('prefix')) object.prefix = message.prefix;
          if (message.spot_market_id != null && message.hasOwnProperty('spot_market_id')) object.spot_market_id = message.spot_market_id;
          if (message.liquidation_market_id != null && message.hasOwnProperty('liquidation_market_id'))
            object.liquidation_market_id = message.liquidation_market_id;
          if (message.keeper_reward_percentage != null && message.hasOwnProperty('keeper_reward_percentage'))
            object.keeper_reward_percentage = message.keeper_reward_percentage;
          if (message.check_collateralization_index_count != null && message.hasOwnProperty('check_collateralization_index_count'))
            object.check_collateralization_index_count = message.check_collateralization_index_count;
          if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
            object.conversion_factor = message.conversion_factor;
          return object;
        };

        /**
         * Converts this CollateralParam to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.CollateralParam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CollateralParam.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CollateralParam;
      })();

      cdp.DebtParam = (function () {
        /**
         * Properties of a DebtParam.
         * @memberof ununifi.cdp
         * @interface IDebtParam
         * @property {string|null} [denom] DebtParam denom
         * @property {string|null} [reference_asset] DebtParam reference_asset
         * @property {string|null} [conversion_factor] DebtParam conversion_factor
         * @property {string|null} [debt_floor] DebtParam debt_floor
         * @property {cosmos.base.v1beta1.ICoin|null} [global_debt_limit] DebtParam global_debt_limit
         * @property {string|null} [debt_denom] DebtParam debt_denom
         * @property {string|null} [surplus_auction_threshold] DebtParam surplus_auction_threshold
         * @property {string|null} [surplus_auction_lot] DebtParam surplus_auction_lot
         * @property {string|null} [debt_auction_threshold] DebtParam debt_auction_threshold
         * @property {string|null} [debt_auction_lot] DebtParam debt_auction_lot
         * @property {boolean|null} [circuit_breaker] DebtParam circuit_breaker
         */

        /**
         * Constructs a new DebtParam.
         * @memberof ununifi.cdp
         * @classdesc Represents a DebtParam.
         * @implements IDebtParam
         * @constructor
         * @param {ununifi.cdp.IDebtParam=} [properties] Properties to set
         */
        function DebtParam(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebtParam denom.
         * @member {string} denom
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.denom = '';

        /**
         * DebtParam reference_asset.
         * @member {string} reference_asset
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.reference_asset = '';

        /**
         * DebtParam conversion_factor.
         * @member {string} conversion_factor
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.conversion_factor = '';

        /**
         * DebtParam debt_floor.
         * @member {string} debt_floor
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.debt_floor = '';

        /**
         * DebtParam global_debt_limit.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} global_debt_limit
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.global_debt_limit = null;

        /**
         * DebtParam debt_denom.
         * @member {string} debt_denom
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.debt_denom = '';

        /**
         * DebtParam surplus_auction_threshold.
         * @member {string} surplus_auction_threshold
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.surplus_auction_threshold = '';

        /**
         * DebtParam surplus_auction_lot.
         * @member {string} surplus_auction_lot
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.surplus_auction_lot = '';

        /**
         * DebtParam debt_auction_threshold.
         * @member {string} debt_auction_threshold
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.debt_auction_threshold = '';

        /**
         * DebtParam debt_auction_lot.
         * @member {string} debt_auction_lot
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.debt_auction_lot = '';

        /**
         * DebtParam circuit_breaker.
         * @member {boolean} circuit_breaker
         * @memberof ununifi.cdp.DebtParam
         * @instance
         */
        DebtParam.prototype.circuit_breaker = false;

        /**
         * Encodes the specified DebtParam message. Does not implicitly {@link ununifi.cdp.DebtParam.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.DebtParam
         * @static
         * @param {ununifi.cdp.IDebtParam} message DebtParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebtParam.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
          if (message.reference_asset != null && Object.hasOwnProperty.call(message, 'reference_asset'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reference_asset);
          if (message.conversion_factor != null && Object.hasOwnProperty.call(message, 'conversion_factor'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.conversion_factor);
          if (message.debt_floor != null && Object.hasOwnProperty.call(message, 'debt_floor'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.debt_floor);
          if (message.global_debt_limit != null && Object.hasOwnProperty.call(message, 'global_debt_limit'))
            $root.cosmos.base.v1beta1.Coin.encode(message.global_debt_limit, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
          if (message.debt_denom != null && Object.hasOwnProperty.call(message, 'debt_denom'))
            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.debt_denom);
          if (message.surplus_auction_threshold != null && Object.hasOwnProperty.call(message, 'surplus_auction_threshold'))
            writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.surplus_auction_threshold);
          if (message.surplus_auction_lot != null && Object.hasOwnProperty.call(message, 'surplus_auction_lot'))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.surplus_auction_lot);
          if (message.debt_auction_threshold != null && Object.hasOwnProperty.call(message, 'debt_auction_threshold'))
            writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.debt_auction_threshold);
          if (message.debt_auction_lot != null && Object.hasOwnProperty.call(message, 'debt_auction_lot'))
            writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.debt_auction_lot);
          if (message.circuit_breaker != null && Object.hasOwnProperty.call(message, 'circuit_breaker'))
            writer.uint32(/* id 11, wireType 0 =*/ 88).bool(message.circuit_breaker);
          return writer;
        };

        /**
         * Encodes the specified DebtParam message, length delimited. Does not implicitly {@link ununifi.cdp.DebtParam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.DebtParam
         * @static
         * @param {ununifi.cdp.IDebtParam} message DebtParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebtParam.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebtParam message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.DebtParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.DebtParam} DebtParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebtParam.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.DebtParam();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.reference_asset = reader.string();
                break;
              case 3:
                message.conversion_factor = reader.string();
                break;
              case 4:
                message.debt_floor = reader.string();
                break;
              case 5:
                message.global_debt_limit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 6:
                message.debt_denom = reader.string();
                break;
              case 7:
                message.surplus_auction_threshold = reader.string();
                break;
              case 8:
                message.surplus_auction_lot = reader.string();
                break;
              case 9:
                message.debt_auction_threshold = reader.string();
                break;
              case 10:
                message.debt_auction_lot = reader.string();
                break;
              case 11:
                message.circuit_breaker = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DebtParam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.DebtParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.DebtParam} DebtParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebtParam.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebtParam message.
         * @function verify
         * @memberof ununifi.cdp.DebtParam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebtParam.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          if (message.reference_asset != null && message.hasOwnProperty('reference_asset'))
            if (!$util.isString(message.reference_asset)) return 'reference_asset: string expected';
          if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
            if (!$util.isString(message.conversion_factor)) return 'conversion_factor: string expected';
          if (message.debt_floor != null && message.hasOwnProperty('debt_floor'))
            if (!$util.isString(message.debt_floor)) return 'debt_floor: string expected';
          if (message.global_debt_limit != null && message.hasOwnProperty('global_debt_limit')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.global_debt_limit);
            if (error) return 'global_debt_limit.' + error;
          }
          if (message.debt_denom != null && message.hasOwnProperty('debt_denom'))
            if (!$util.isString(message.debt_denom)) return 'debt_denom: string expected';
          if (message.surplus_auction_threshold != null && message.hasOwnProperty('surplus_auction_threshold'))
            if (!$util.isString(message.surplus_auction_threshold)) return 'surplus_auction_threshold: string expected';
          if (message.surplus_auction_lot != null && message.hasOwnProperty('surplus_auction_lot'))
            if (!$util.isString(message.surplus_auction_lot)) return 'surplus_auction_lot: string expected';
          if (message.debt_auction_threshold != null && message.hasOwnProperty('debt_auction_threshold'))
            if (!$util.isString(message.debt_auction_threshold)) return 'debt_auction_threshold: string expected';
          if (message.debt_auction_lot != null && message.hasOwnProperty('debt_auction_lot'))
            if (!$util.isString(message.debt_auction_lot)) return 'debt_auction_lot: string expected';
          if (message.circuit_breaker != null && message.hasOwnProperty('circuit_breaker'))
            if (typeof message.circuit_breaker !== 'boolean') return 'circuit_breaker: boolean expected';
          return null;
        };

        /**
         * Creates a DebtParam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.DebtParam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.DebtParam} DebtParam
         */
        DebtParam.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.DebtParam) return object;
          var message = new $root.ununifi.cdp.DebtParam();
          if (object.denom != null) message.denom = String(object.denom);
          if (object.reference_asset != null) message.reference_asset = String(object.reference_asset);
          if (object.conversion_factor != null) message.conversion_factor = String(object.conversion_factor);
          if (object.debt_floor != null) message.debt_floor = String(object.debt_floor);
          if (object.global_debt_limit != null) {
            if (typeof object.global_debt_limit !== 'object') throw TypeError('.ununifi.cdp.DebtParam.global_debt_limit: object expected');
            message.global_debt_limit = $root.cosmos.base.v1beta1.Coin.fromObject(object.global_debt_limit);
          }
          if (object.debt_denom != null) message.debt_denom = String(object.debt_denom);
          if (object.surplus_auction_threshold != null) message.surplus_auction_threshold = String(object.surplus_auction_threshold);
          if (object.surplus_auction_lot != null) message.surplus_auction_lot = String(object.surplus_auction_lot);
          if (object.debt_auction_threshold != null) message.debt_auction_threshold = String(object.debt_auction_threshold);
          if (object.debt_auction_lot != null) message.debt_auction_lot = String(object.debt_auction_lot);
          if (object.circuit_breaker != null) message.circuit_breaker = Boolean(object.circuit_breaker);
          return message;
        };

        /**
         * Creates a plain object from a DebtParam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.DebtParam
         * @static
         * @param {ununifi.cdp.DebtParam} message DebtParam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebtParam.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.denom = '';
            object.reference_asset = '';
            object.conversion_factor = '';
            object.debt_floor = '';
            object.global_debt_limit = null;
            object.debt_denom = '';
            object.surplus_auction_threshold = '';
            object.surplus_auction_lot = '';
            object.debt_auction_threshold = '';
            object.debt_auction_lot = '';
            object.circuit_breaker = false;
          }
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          if (message.reference_asset != null && message.hasOwnProperty('reference_asset'))
            object.reference_asset = message.reference_asset;
          if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
            object.conversion_factor = message.conversion_factor;
          if (message.debt_floor != null && message.hasOwnProperty('debt_floor')) object.debt_floor = message.debt_floor;
          if (message.global_debt_limit != null && message.hasOwnProperty('global_debt_limit'))
            object.global_debt_limit = $root.cosmos.base.v1beta1.Coin.toObject(message.global_debt_limit, options);
          if (message.debt_denom != null && message.hasOwnProperty('debt_denom')) object.debt_denom = message.debt_denom;
          if (message.surplus_auction_threshold != null && message.hasOwnProperty('surplus_auction_threshold'))
            object.surplus_auction_threshold = message.surplus_auction_threshold;
          if (message.surplus_auction_lot != null && message.hasOwnProperty('surplus_auction_lot'))
            object.surplus_auction_lot = message.surplus_auction_lot;
          if (message.debt_auction_threshold != null && message.hasOwnProperty('debt_auction_threshold'))
            object.debt_auction_threshold = message.debt_auction_threshold;
          if (message.debt_auction_lot != null && message.hasOwnProperty('debt_auction_lot'))
            object.debt_auction_lot = message.debt_auction_lot;
          if (message.circuit_breaker != null && message.hasOwnProperty('circuit_breaker'))
            object.circuit_breaker = message.circuit_breaker;
          return object;
        };

        /**
         * Converts this DebtParam to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.DebtParam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebtParam.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebtParam;
      })();

      cdp.Msg = (function () {
        /**
         * Constructs a new Msg service.
         * @memberof ununifi.cdp
         * @classdesc Represents a Msg
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Msg(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

        /**
         * Callback as used by {@link ununifi.cdp.Msg#createCdp}.
         * @memberof ununifi.cdp.Msg
         * @typedef CreateCdpCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.MsgCreateCdpResponse} [response] MsgCreateCdpResponse
         */

        /**
         * Calls CreateCdp.
         * @function createCdp
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgCreateCdp} request MsgCreateCdp message or plain object
         * @param {ununifi.cdp.Msg.CreateCdpCallback} callback Node-style callback called with the error, if any, and MsgCreateCdpResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.createCdp = function createCdp(request, callback) {
            return this.rpcCall(createCdp, $root.ununifi.cdp.MsgCreateCdp, $root.ununifi.cdp.MsgCreateCdpResponse, request, callback);
          }),
          'name',
          { value: 'CreateCdp' },
        );

        /**
         * Calls CreateCdp.
         * @function createCdp
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgCreateCdp} request MsgCreateCdp message or plain object
         * @returns {Promise<ununifi.cdp.MsgCreateCdpResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Msg#deposit}.
         * @memberof ununifi.cdp.Msg
         * @typedef DepositCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.MsgDepositResponse} [response] MsgDepositResponse
         */

        /**
         * Calls Deposit.
         * @function deposit
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgDeposit} request MsgDeposit message or plain object
         * @param {ununifi.cdp.Msg.DepositCallback} callback Node-style callback called with the error, if any, and MsgDepositResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.deposit = function deposit(request, callback) {
            return this.rpcCall(deposit, $root.ununifi.cdp.MsgDeposit, $root.ununifi.cdp.MsgDepositResponse, request, callback);
          }),
          'name',
          { value: 'Deposit' },
        );

        /**
         * Calls Deposit.
         * @function deposit
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgDeposit} request MsgDeposit message or plain object
         * @returns {Promise<ununifi.cdp.MsgDepositResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Msg#withdraw}.
         * @memberof ununifi.cdp.Msg
         * @typedef WithdrawCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.MsgWithdrawResponse} [response] MsgWithdrawResponse
         */

        /**
         * Calls Withdraw.
         * @function withdraw
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgWithdraw} request MsgWithdraw message or plain object
         * @param {ununifi.cdp.Msg.WithdrawCallback} callback Node-style callback called with the error, if any, and MsgWithdrawResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.withdraw = function withdraw(request, callback) {
            return this.rpcCall(withdraw, $root.ununifi.cdp.MsgWithdraw, $root.ununifi.cdp.MsgWithdrawResponse, request, callback);
          }),
          'name',
          { value: 'Withdraw' },
        );

        /**
         * Calls Withdraw.
         * @function withdraw
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgWithdraw} request MsgWithdraw message or plain object
         * @returns {Promise<ununifi.cdp.MsgWithdrawResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Msg#drawDebt}.
         * @memberof ununifi.cdp.Msg
         * @typedef DrawDebtCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.MsgDrawDebtResponse} [response] MsgDrawDebtResponse
         */

        /**
         * Calls DrawDebt.
         * @function drawDebt
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgDrawDebt} request MsgDrawDebt message or plain object
         * @param {ununifi.cdp.Msg.DrawDebtCallback} callback Node-style callback called with the error, if any, and MsgDrawDebtResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.drawDebt = function drawDebt(request, callback) {
            return this.rpcCall(drawDebt, $root.ununifi.cdp.MsgDrawDebt, $root.ununifi.cdp.MsgDrawDebtResponse, request, callback);
          }),
          'name',
          { value: 'DrawDebt' },
        );

        /**
         * Calls DrawDebt.
         * @function drawDebt
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgDrawDebt} request MsgDrawDebt message or plain object
         * @returns {Promise<ununifi.cdp.MsgDrawDebtResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Msg#repayDebt}.
         * @memberof ununifi.cdp.Msg
         * @typedef RepayDebtCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.MsgRepayDebtResponse} [response] MsgRepayDebtResponse
         */

        /**
         * Calls RepayDebt.
         * @function repayDebt
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgRepayDebt} request MsgRepayDebt message or plain object
         * @param {ununifi.cdp.Msg.RepayDebtCallback} callback Node-style callback called with the error, if any, and MsgRepayDebtResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.repayDebt = function repayDebt(request, callback) {
            return this.rpcCall(repayDebt, $root.ununifi.cdp.MsgRepayDebt, $root.ununifi.cdp.MsgRepayDebtResponse, request, callback);
          }),
          'name',
          { value: 'RepayDebt' },
        );

        /**
         * Calls RepayDebt.
         * @function repayDebt
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgRepayDebt} request MsgRepayDebt message or plain object
         * @returns {Promise<ununifi.cdp.MsgRepayDebtResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.cdp.Msg#liquidate}.
         * @memberof ununifi.cdp.Msg
         * @typedef LiquidateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.cdp.MsgLiquidateResponse} [response] MsgLiquidateResponse
         */

        /**
         * Calls Liquidate.
         * @function liquidate
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgLiquidate} request MsgLiquidate message or plain object
         * @param {ununifi.cdp.Msg.LiquidateCallback} callback Node-style callback called with the error, if any, and MsgLiquidateResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.liquidate = function liquidate(request, callback) {
            return this.rpcCall(liquidate, $root.ununifi.cdp.MsgLiquidate, $root.ununifi.cdp.MsgLiquidateResponse, request, callback);
          }),
          'name',
          { value: 'Liquidate' },
        );

        /**
         * Calls Liquidate.
         * @function liquidate
         * @memberof ununifi.cdp.Msg
         * @instance
         * @param {ununifi.cdp.IMsgLiquidate} request MsgLiquidate message or plain object
         * @returns {Promise<ununifi.cdp.MsgLiquidateResponse>} Promise
         * @variation 2
         */

        return Msg;
      })();

      cdp.MsgCreateCdp = (function () {
        /**
         * Properties of a MsgCreateCdp.
         * @memberof ununifi.cdp
         * @interface IMsgCreateCdp
         * @property {string|null} [sender] MsgCreateCdp sender
         * @property {cosmos.base.v1beta1.ICoin|null} [collateral] MsgCreateCdp collateral
         * @property {cosmos.base.v1beta1.ICoin|null} [principal] MsgCreateCdp principal
         * @property {string|null} [collateral_type] MsgCreateCdp collateral_type
         */

        /**
         * Constructs a new MsgCreateCdp.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgCreateCdp.
         * @implements IMsgCreateCdp
         * @constructor
         * @param {ununifi.cdp.IMsgCreateCdp=} [properties] Properties to set
         */
        function MsgCreateCdp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgCreateCdp sender.
         * @member {string} sender
         * @memberof ununifi.cdp.MsgCreateCdp
         * @instance
         */
        MsgCreateCdp.prototype.sender = '';

        /**
         * MsgCreateCdp collateral.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
         * @memberof ununifi.cdp.MsgCreateCdp
         * @instance
         */
        MsgCreateCdp.prototype.collateral = null;

        /**
         * MsgCreateCdp principal.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} principal
         * @memberof ununifi.cdp.MsgCreateCdp
         * @instance
         */
        MsgCreateCdp.prototype.principal = null;

        /**
         * MsgCreateCdp collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.MsgCreateCdp
         * @instance
         */
        MsgCreateCdp.prototype.collateral_type = '';

        /**
         * Encodes the specified MsgCreateCdp message. Does not implicitly {@link ununifi.cdp.MsgCreateCdp.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgCreateCdp
         * @static
         * @param {ununifi.cdp.IMsgCreateCdp} message MsgCreateCdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateCdp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
            $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.principal != null && Object.hasOwnProperty.call(message, 'principal'))
            $root.cosmos.base.v1beta1.Coin.encode(message.principal, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.collateral_type);
          return writer;
        };

        /**
         * Encodes the specified MsgCreateCdp message, length delimited. Does not implicitly {@link ununifi.cdp.MsgCreateCdp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgCreateCdp
         * @static
         * @param {ununifi.cdp.IMsgCreateCdp} message MsgCreateCdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateCdp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCreateCdp message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgCreateCdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgCreateCdp} MsgCreateCdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateCdp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgCreateCdp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 3:
                message.principal = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                message.collateral_type = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCreateCdp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgCreateCdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgCreateCdp} MsgCreateCdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateCdp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCreateCdp message.
         * @function verify
         * @memberof ununifi.cdp.MsgCreateCdp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCreateCdp.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.collateral != null && message.hasOwnProperty('collateral')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
            if (error) return 'collateral.' + error;
          }
          if (message.principal != null && message.hasOwnProperty('principal')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.principal);
            if (error) return 'principal.' + error;
          }
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          return null;
        };

        /**
         * Creates a MsgCreateCdp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgCreateCdp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgCreateCdp} MsgCreateCdp
         */
        MsgCreateCdp.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgCreateCdp) return object;
          var message = new $root.ununifi.cdp.MsgCreateCdp();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.collateral != null) {
            if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.MsgCreateCdp.collateral: object expected');
            message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
          }
          if (object.principal != null) {
            if (typeof object.principal !== 'object') throw TypeError('.ununifi.cdp.MsgCreateCdp.principal: object expected');
            message.principal = $root.cosmos.base.v1beta1.Coin.fromObject(object.principal);
          }
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          return message;
        };

        /**
         * Creates a plain object from a MsgCreateCdp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgCreateCdp
         * @static
         * @param {ununifi.cdp.MsgCreateCdp} message MsgCreateCdp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCreateCdp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.collateral = null;
            object.principal = null;
            object.collateral_type = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.collateral != null && message.hasOwnProperty('collateral'))
            object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
          if (message.principal != null && message.hasOwnProperty('principal'))
            object.principal = $root.cosmos.base.v1beta1.Coin.toObject(message.principal, options);
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          return object;
        };

        /**
         * Converts this MsgCreateCdp to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgCreateCdp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCreateCdp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCreateCdp;
      })();

      cdp.MsgCreateCdpResponse = (function () {
        /**
         * Properties of a MsgCreateCdpResponse.
         * @memberof ununifi.cdp
         * @interface IMsgCreateCdpResponse
         */

        /**
         * Constructs a new MsgCreateCdpResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgCreateCdpResponse.
         * @implements IMsgCreateCdpResponse
         * @constructor
         * @param {ununifi.cdp.IMsgCreateCdpResponse=} [properties] Properties to set
         */
        function MsgCreateCdpResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgCreateCdpResponse message. Does not implicitly {@link ununifi.cdp.MsgCreateCdpResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @static
         * @param {ununifi.cdp.IMsgCreateCdpResponse} message MsgCreateCdpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateCdpResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgCreateCdpResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgCreateCdpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @static
         * @param {ununifi.cdp.IMsgCreateCdpResponse} message MsgCreateCdpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateCdpResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCreateCdpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgCreateCdpResponse} MsgCreateCdpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateCdpResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgCreateCdpResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCreateCdpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgCreateCdpResponse} MsgCreateCdpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateCdpResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCreateCdpResponse message.
         * @function verify
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCreateCdpResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgCreateCdpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgCreateCdpResponse} MsgCreateCdpResponse
         */
        MsgCreateCdpResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgCreateCdpResponse) return object;
          return new $root.ununifi.cdp.MsgCreateCdpResponse();
        };

        /**
         * Creates a plain object from a MsgCreateCdpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @static
         * @param {ununifi.cdp.MsgCreateCdpResponse} message MsgCreateCdpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCreateCdpResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgCreateCdpResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgCreateCdpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCreateCdpResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCreateCdpResponse;
      })();

      cdp.MsgDeposit = (function () {
        /**
         * Properties of a MsgDeposit.
         * @memberof ununifi.cdp
         * @interface IMsgDeposit
         * @property {string|null} [depositor] MsgDeposit depositor
         * @property {string|null} [owner] MsgDeposit owner
         * @property {cosmos.base.v1beta1.ICoin|null} [collateral] MsgDeposit collateral
         * @property {string|null} [collateral_type] MsgDeposit collateral_type
         */

        /**
         * Constructs a new MsgDeposit.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgDeposit.
         * @implements IMsgDeposit
         * @constructor
         * @param {ununifi.cdp.IMsgDeposit=} [properties] Properties to set
         */
        function MsgDeposit(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgDeposit depositor.
         * @member {string} depositor
         * @memberof ununifi.cdp.MsgDeposit
         * @instance
         */
        MsgDeposit.prototype.depositor = '';

        /**
         * MsgDeposit owner.
         * @member {string} owner
         * @memberof ununifi.cdp.MsgDeposit
         * @instance
         */
        MsgDeposit.prototype.owner = '';

        /**
         * MsgDeposit collateral.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
         * @memberof ununifi.cdp.MsgDeposit
         * @instance
         */
        MsgDeposit.prototype.collateral = null;

        /**
         * MsgDeposit collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.MsgDeposit
         * @instance
         */
        MsgDeposit.prototype.collateral_type = '';

        /**
         * Encodes the specified MsgDeposit message. Does not implicitly {@link ununifi.cdp.MsgDeposit.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgDeposit
         * @static
         * @param {ununifi.cdp.IMsgDeposit} message MsgDeposit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDeposit.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.depositor != null && Object.hasOwnProperty.call(message, 'depositor'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.depositor);
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
          if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
            $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.collateral_type);
          return writer;
        };

        /**
         * Encodes the specified MsgDeposit message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDeposit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgDeposit
         * @static
         * @param {ununifi.cdp.IMsgDeposit} message MsgDeposit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDeposit.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgDeposit message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgDeposit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgDeposit} MsgDeposit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDeposit.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgDeposit();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.depositor = reader.string();
                break;
              case 2:
                message.owner = reader.string();
                break;
              case 3:
                message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                message.collateral_type = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgDeposit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgDeposit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgDeposit} MsgDeposit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDeposit.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgDeposit message.
         * @function verify
         * @memberof ununifi.cdp.MsgDeposit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgDeposit.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.depositor != null && message.hasOwnProperty('depositor'))
            if (!$util.isString(message.depositor)) return 'depositor: string expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.collateral != null && message.hasOwnProperty('collateral')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
            if (error) return 'collateral.' + error;
          }
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          return null;
        };

        /**
         * Creates a MsgDeposit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgDeposit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgDeposit} MsgDeposit
         */
        MsgDeposit.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgDeposit) return object;
          var message = new $root.ununifi.cdp.MsgDeposit();
          if (object.depositor != null) message.depositor = String(object.depositor);
          if (object.owner != null) message.owner = String(object.owner);
          if (object.collateral != null) {
            if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.MsgDeposit.collateral: object expected');
            message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
          }
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          return message;
        };

        /**
         * Creates a plain object from a MsgDeposit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgDeposit
         * @static
         * @param {ununifi.cdp.MsgDeposit} message MsgDeposit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgDeposit.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.depositor = '';
            object.owner = '';
            object.collateral = null;
            object.collateral_type = '';
          }
          if (message.depositor != null && message.hasOwnProperty('depositor')) object.depositor = message.depositor;
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.collateral != null && message.hasOwnProperty('collateral'))
            object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          return object;
        };

        /**
         * Converts this MsgDeposit to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgDeposit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgDeposit.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgDeposit;
      })();

      cdp.MsgDepositResponse = (function () {
        /**
         * Properties of a MsgDepositResponse.
         * @memberof ununifi.cdp
         * @interface IMsgDepositResponse
         */

        /**
         * Constructs a new MsgDepositResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgDepositResponse.
         * @implements IMsgDepositResponse
         * @constructor
         * @param {ununifi.cdp.IMsgDepositResponse=} [properties] Properties to set
         */
        function MsgDepositResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgDepositResponse message. Does not implicitly {@link ununifi.cdp.MsgDepositResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgDepositResponse
         * @static
         * @param {ununifi.cdp.IMsgDepositResponse} message MsgDepositResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDepositResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgDepositResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDepositResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgDepositResponse
         * @static
         * @param {ununifi.cdp.IMsgDepositResponse} message MsgDepositResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDepositResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgDepositResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgDepositResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgDepositResponse} MsgDepositResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDepositResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgDepositResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgDepositResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgDepositResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgDepositResponse} MsgDepositResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDepositResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgDepositResponse message.
         * @function verify
         * @memberof ununifi.cdp.MsgDepositResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgDepositResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgDepositResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgDepositResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgDepositResponse} MsgDepositResponse
         */
        MsgDepositResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgDepositResponse) return object;
          return new $root.ununifi.cdp.MsgDepositResponse();
        };

        /**
         * Creates a plain object from a MsgDepositResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgDepositResponse
         * @static
         * @param {ununifi.cdp.MsgDepositResponse} message MsgDepositResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgDepositResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgDepositResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgDepositResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgDepositResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgDepositResponse;
      })();

      cdp.MsgWithdraw = (function () {
        /**
         * Properties of a MsgWithdraw.
         * @memberof ununifi.cdp
         * @interface IMsgWithdraw
         * @property {string|null} [depositor] MsgWithdraw depositor
         * @property {string|null} [owner] MsgWithdraw owner
         * @property {cosmos.base.v1beta1.ICoin|null} [collateral] MsgWithdraw collateral
         * @property {string|null} [collateral_type] MsgWithdraw collateral_type
         */

        /**
         * Constructs a new MsgWithdraw.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgWithdraw.
         * @implements IMsgWithdraw
         * @constructor
         * @param {ununifi.cdp.IMsgWithdraw=} [properties] Properties to set
         */
        function MsgWithdraw(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgWithdraw depositor.
         * @member {string} depositor
         * @memberof ununifi.cdp.MsgWithdraw
         * @instance
         */
        MsgWithdraw.prototype.depositor = '';

        /**
         * MsgWithdraw owner.
         * @member {string} owner
         * @memberof ununifi.cdp.MsgWithdraw
         * @instance
         */
        MsgWithdraw.prototype.owner = '';

        /**
         * MsgWithdraw collateral.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
         * @memberof ununifi.cdp.MsgWithdraw
         * @instance
         */
        MsgWithdraw.prototype.collateral = null;

        /**
         * MsgWithdraw collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.MsgWithdraw
         * @instance
         */
        MsgWithdraw.prototype.collateral_type = '';

        /**
         * Encodes the specified MsgWithdraw message. Does not implicitly {@link ununifi.cdp.MsgWithdraw.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgWithdraw
         * @static
         * @param {ununifi.cdp.IMsgWithdraw} message MsgWithdraw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdraw.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.depositor != null && Object.hasOwnProperty.call(message, 'depositor'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.depositor);
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
          if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
            $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.collateral_type);
          return writer;
        };

        /**
         * Encodes the specified MsgWithdraw message, length delimited. Does not implicitly {@link ununifi.cdp.MsgWithdraw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgWithdraw
         * @static
         * @param {ununifi.cdp.IMsgWithdraw} message MsgWithdraw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdraw.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgWithdraw message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgWithdraw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgWithdraw} MsgWithdraw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdraw.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgWithdraw();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.depositor = reader.string();
                break;
              case 2:
                message.owner = reader.string();
                break;
              case 3:
                message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                message.collateral_type = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgWithdraw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgWithdraw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgWithdraw} MsgWithdraw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdraw.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgWithdraw message.
         * @function verify
         * @memberof ununifi.cdp.MsgWithdraw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgWithdraw.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.depositor != null && message.hasOwnProperty('depositor'))
            if (!$util.isString(message.depositor)) return 'depositor: string expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.collateral != null && message.hasOwnProperty('collateral')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
            if (error) return 'collateral.' + error;
          }
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          return null;
        };

        /**
         * Creates a MsgWithdraw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgWithdraw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgWithdraw} MsgWithdraw
         */
        MsgWithdraw.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgWithdraw) return object;
          var message = new $root.ununifi.cdp.MsgWithdraw();
          if (object.depositor != null) message.depositor = String(object.depositor);
          if (object.owner != null) message.owner = String(object.owner);
          if (object.collateral != null) {
            if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.MsgWithdraw.collateral: object expected');
            message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
          }
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          return message;
        };

        /**
         * Creates a plain object from a MsgWithdraw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgWithdraw
         * @static
         * @param {ununifi.cdp.MsgWithdraw} message MsgWithdraw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgWithdraw.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.depositor = '';
            object.owner = '';
            object.collateral = null;
            object.collateral_type = '';
          }
          if (message.depositor != null && message.hasOwnProperty('depositor')) object.depositor = message.depositor;
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.collateral != null && message.hasOwnProperty('collateral'))
            object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          return object;
        };

        /**
         * Converts this MsgWithdraw to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgWithdraw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgWithdraw.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgWithdraw;
      })();

      cdp.MsgWithdrawResponse = (function () {
        /**
         * Properties of a MsgWithdrawResponse.
         * @memberof ununifi.cdp
         * @interface IMsgWithdrawResponse
         */

        /**
         * Constructs a new MsgWithdrawResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgWithdrawResponse.
         * @implements IMsgWithdrawResponse
         * @constructor
         * @param {ununifi.cdp.IMsgWithdrawResponse=} [properties] Properties to set
         */
        function MsgWithdrawResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgWithdrawResponse message. Does not implicitly {@link ununifi.cdp.MsgWithdrawResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @static
         * @param {ununifi.cdp.IMsgWithdrawResponse} message MsgWithdrawResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgWithdrawResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgWithdrawResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @static
         * @param {ununifi.cdp.IMsgWithdrawResponse} message MsgWithdrawResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgWithdrawResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgWithdrawResponse} MsgWithdrawResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgWithdrawResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgWithdrawResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgWithdrawResponse} MsgWithdrawResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgWithdrawResponse message.
         * @function verify
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgWithdrawResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgWithdrawResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgWithdrawResponse} MsgWithdrawResponse
         */
        MsgWithdrawResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgWithdrawResponse) return object;
          return new $root.ununifi.cdp.MsgWithdrawResponse();
        };

        /**
         * Creates a plain object from a MsgWithdrawResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @static
         * @param {ununifi.cdp.MsgWithdrawResponse} message MsgWithdrawResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgWithdrawResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgWithdrawResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgWithdrawResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgWithdrawResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgWithdrawResponse;
      })();

      cdp.MsgDrawDebt = (function () {
        /**
         * Properties of a MsgDrawDebt.
         * @memberof ununifi.cdp
         * @interface IMsgDrawDebt
         * @property {string|null} [sender] MsgDrawDebt sender
         * @property {string|null} [collateral_type] MsgDrawDebt collateral_type
         * @property {cosmos.base.v1beta1.ICoin|null} [principal] MsgDrawDebt principal
         */

        /**
         * Constructs a new MsgDrawDebt.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgDrawDebt.
         * @implements IMsgDrawDebt
         * @constructor
         * @param {ununifi.cdp.IMsgDrawDebt=} [properties] Properties to set
         */
        function MsgDrawDebt(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgDrawDebt sender.
         * @member {string} sender
         * @memberof ununifi.cdp.MsgDrawDebt
         * @instance
         */
        MsgDrawDebt.prototype.sender = '';

        /**
         * MsgDrawDebt collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.MsgDrawDebt
         * @instance
         */
        MsgDrawDebt.prototype.collateral_type = '';

        /**
         * MsgDrawDebt principal.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} principal
         * @memberof ununifi.cdp.MsgDrawDebt
         * @instance
         */
        MsgDrawDebt.prototype.principal = null;

        /**
         * Encodes the specified MsgDrawDebt message. Does not implicitly {@link ununifi.cdp.MsgDrawDebt.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgDrawDebt
         * @static
         * @param {ununifi.cdp.IMsgDrawDebt} message MsgDrawDebt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDrawDebt.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
          if (message.principal != null && Object.hasOwnProperty.call(message, 'principal'))
            $root.cosmos.base.v1beta1.Coin.encode(message.principal, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgDrawDebt message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDrawDebt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgDrawDebt
         * @static
         * @param {ununifi.cdp.IMsgDrawDebt} message MsgDrawDebt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDrawDebt.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgDrawDebt message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgDrawDebt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgDrawDebt} MsgDrawDebt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDrawDebt.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgDrawDebt();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.collateral_type = reader.string();
                break;
              case 3:
                message.principal = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgDrawDebt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgDrawDebt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgDrawDebt} MsgDrawDebt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDrawDebt.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgDrawDebt message.
         * @function verify
         * @memberof ununifi.cdp.MsgDrawDebt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgDrawDebt.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          if (message.principal != null && message.hasOwnProperty('principal')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.principal);
            if (error) return 'principal.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgDrawDebt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgDrawDebt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgDrawDebt} MsgDrawDebt
         */
        MsgDrawDebt.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgDrawDebt) return object;
          var message = new $root.ununifi.cdp.MsgDrawDebt();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          if (object.principal != null) {
            if (typeof object.principal !== 'object') throw TypeError('.ununifi.cdp.MsgDrawDebt.principal: object expected');
            message.principal = $root.cosmos.base.v1beta1.Coin.fromObject(object.principal);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgDrawDebt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgDrawDebt
         * @static
         * @param {ununifi.cdp.MsgDrawDebt} message MsgDrawDebt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgDrawDebt.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.collateral_type = '';
            object.principal = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          if (message.principal != null && message.hasOwnProperty('principal'))
            object.principal = $root.cosmos.base.v1beta1.Coin.toObject(message.principal, options);
          return object;
        };

        /**
         * Converts this MsgDrawDebt to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgDrawDebt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgDrawDebt.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgDrawDebt;
      })();

      cdp.MsgDrawDebtResponse = (function () {
        /**
         * Properties of a MsgDrawDebtResponse.
         * @memberof ununifi.cdp
         * @interface IMsgDrawDebtResponse
         */

        /**
         * Constructs a new MsgDrawDebtResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgDrawDebtResponse.
         * @implements IMsgDrawDebtResponse
         * @constructor
         * @param {ununifi.cdp.IMsgDrawDebtResponse=} [properties] Properties to set
         */
        function MsgDrawDebtResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgDrawDebtResponse message. Does not implicitly {@link ununifi.cdp.MsgDrawDebtResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @static
         * @param {ununifi.cdp.IMsgDrawDebtResponse} message MsgDrawDebtResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDrawDebtResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgDrawDebtResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDrawDebtResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @static
         * @param {ununifi.cdp.IMsgDrawDebtResponse} message MsgDrawDebtResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgDrawDebtResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgDrawDebtResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgDrawDebtResponse} MsgDrawDebtResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDrawDebtResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgDrawDebtResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgDrawDebtResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgDrawDebtResponse} MsgDrawDebtResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgDrawDebtResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgDrawDebtResponse message.
         * @function verify
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgDrawDebtResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgDrawDebtResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgDrawDebtResponse} MsgDrawDebtResponse
         */
        MsgDrawDebtResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgDrawDebtResponse) return object;
          return new $root.ununifi.cdp.MsgDrawDebtResponse();
        };

        /**
         * Creates a plain object from a MsgDrawDebtResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @static
         * @param {ununifi.cdp.MsgDrawDebtResponse} message MsgDrawDebtResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgDrawDebtResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgDrawDebtResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgDrawDebtResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgDrawDebtResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgDrawDebtResponse;
      })();

      cdp.MsgRepayDebt = (function () {
        /**
         * Properties of a MsgRepayDebt.
         * @memberof ununifi.cdp
         * @interface IMsgRepayDebt
         * @property {string|null} [sender] MsgRepayDebt sender
         * @property {string|null} [collateral_type] MsgRepayDebt collateral_type
         * @property {cosmos.base.v1beta1.ICoin|null} [payment] MsgRepayDebt payment
         */

        /**
         * Constructs a new MsgRepayDebt.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgRepayDebt.
         * @implements IMsgRepayDebt
         * @constructor
         * @param {ununifi.cdp.IMsgRepayDebt=} [properties] Properties to set
         */
        function MsgRepayDebt(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgRepayDebt sender.
         * @member {string} sender
         * @memberof ununifi.cdp.MsgRepayDebt
         * @instance
         */
        MsgRepayDebt.prototype.sender = '';

        /**
         * MsgRepayDebt collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.MsgRepayDebt
         * @instance
         */
        MsgRepayDebt.prototype.collateral_type = '';

        /**
         * MsgRepayDebt payment.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} payment
         * @memberof ununifi.cdp.MsgRepayDebt
         * @instance
         */
        MsgRepayDebt.prototype.payment = null;

        /**
         * Encodes the specified MsgRepayDebt message. Does not implicitly {@link ununifi.cdp.MsgRepayDebt.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgRepayDebt
         * @static
         * @param {ununifi.cdp.IMsgRepayDebt} message MsgRepayDebt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepayDebt.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
          if (message.payment != null && Object.hasOwnProperty.call(message, 'payment'))
            $root.cosmos.base.v1beta1.Coin.encode(message.payment, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgRepayDebt message, length delimited. Does not implicitly {@link ununifi.cdp.MsgRepayDebt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgRepayDebt
         * @static
         * @param {ununifi.cdp.IMsgRepayDebt} message MsgRepayDebt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepayDebt.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgRepayDebt message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgRepayDebt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgRepayDebt} MsgRepayDebt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepayDebt.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgRepayDebt();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.collateral_type = reader.string();
                break;
              case 3:
                message.payment = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgRepayDebt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgRepayDebt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgRepayDebt} MsgRepayDebt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepayDebt.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgRepayDebt message.
         * @function verify
         * @memberof ununifi.cdp.MsgRepayDebt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgRepayDebt.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          if (message.payment != null && message.hasOwnProperty('payment')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.payment);
            if (error) return 'payment.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgRepayDebt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgRepayDebt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgRepayDebt} MsgRepayDebt
         */
        MsgRepayDebt.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgRepayDebt) return object;
          var message = new $root.ununifi.cdp.MsgRepayDebt();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          if (object.payment != null) {
            if (typeof object.payment !== 'object') throw TypeError('.ununifi.cdp.MsgRepayDebt.payment: object expected');
            message.payment = $root.cosmos.base.v1beta1.Coin.fromObject(object.payment);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgRepayDebt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgRepayDebt
         * @static
         * @param {ununifi.cdp.MsgRepayDebt} message MsgRepayDebt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgRepayDebt.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.collateral_type = '';
            object.payment = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          if (message.payment != null && message.hasOwnProperty('payment'))
            object.payment = $root.cosmos.base.v1beta1.Coin.toObject(message.payment, options);
          return object;
        };

        /**
         * Converts this MsgRepayDebt to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgRepayDebt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgRepayDebt.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgRepayDebt;
      })();

      cdp.MsgRepayDebtResponse = (function () {
        /**
         * Properties of a MsgRepayDebtResponse.
         * @memberof ununifi.cdp
         * @interface IMsgRepayDebtResponse
         */

        /**
         * Constructs a new MsgRepayDebtResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgRepayDebtResponse.
         * @implements IMsgRepayDebtResponse
         * @constructor
         * @param {ununifi.cdp.IMsgRepayDebtResponse=} [properties] Properties to set
         */
        function MsgRepayDebtResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgRepayDebtResponse message. Does not implicitly {@link ununifi.cdp.MsgRepayDebtResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @static
         * @param {ununifi.cdp.IMsgRepayDebtResponse} message MsgRepayDebtResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepayDebtResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgRepayDebtResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgRepayDebtResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @static
         * @param {ununifi.cdp.IMsgRepayDebtResponse} message MsgRepayDebtResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepayDebtResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgRepayDebtResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgRepayDebtResponse} MsgRepayDebtResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepayDebtResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgRepayDebtResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgRepayDebtResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgRepayDebtResponse} MsgRepayDebtResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepayDebtResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgRepayDebtResponse message.
         * @function verify
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgRepayDebtResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgRepayDebtResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgRepayDebtResponse} MsgRepayDebtResponse
         */
        MsgRepayDebtResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgRepayDebtResponse) return object;
          return new $root.ununifi.cdp.MsgRepayDebtResponse();
        };

        /**
         * Creates a plain object from a MsgRepayDebtResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @static
         * @param {ununifi.cdp.MsgRepayDebtResponse} message MsgRepayDebtResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgRepayDebtResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgRepayDebtResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgRepayDebtResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgRepayDebtResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgRepayDebtResponse;
      })();

      cdp.MsgLiquidate = (function () {
        /**
         * Properties of a MsgLiquidate.
         * @memberof ununifi.cdp
         * @interface IMsgLiquidate
         * @property {string|null} [keeper] MsgLiquidate keeper
         * @property {string|null} [borrower] MsgLiquidate borrower
         * @property {string|null} [collateral_type] MsgLiquidate collateral_type
         */

        /**
         * Constructs a new MsgLiquidate.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgLiquidate.
         * @implements IMsgLiquidate
         * @constructor
         * @param {ununifi.cdp.IMsgLiquidate=} [properties] Properties to set
         */
        function MsgLiquidate(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgLiquidate keeper.
         * @member {string} keeper
         * @memberof ununifi.cdp.MsgLiquidate
         * @instance
         */
        MsgLiquidate.prototype.keeper = '';

        /**
         * MsgLiquidate borrower.
         * @member {string} borrower
         * @memberof ununifi.cdp.MsgLiquidate
         * @instance
         */
        MsgLiquidate.prototype.borrower = '';

        /**
         * MsgLiquidate collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.MsgLiquidate
         * @instance
         */
        MsgLiquidate.prototype.collateral_type = '';

        /**
         * Encodes the specified MsgLiquidate message. Does not implicitly {@link ununifi.cdp.MsgLiquidate.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgLiquidate
         * @static
         * @param {ununifi.cdp.IMsgLiquidate} message MsgLiquidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidate.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.keeper != null && Object.hasOwnProperty.call(message, 'keeper'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.keeper);
          if (message.borrower != null && Object.hasOwnProperty.call(message, 'borrower'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.borrower);
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.collateral_type);
          return writer;
        };

        /**
         * Encodes the specified MsgLiquidate message, length delimited. Does not implicitly {@link ununifi.cdp.MsgLiquidate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgLiquidate
         * @static
         * @param {ununifi.cdp.IMsgLiquidate} message MsgLiquidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgLiquidate message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgLiquidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgLiquidate} MsgLiquidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgLiquidate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.keeper = reader.string();
                break;
              case 2:
                message.borrower = reader.string();
                break;
              case 3:
                message.collateral_type = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgLiquidate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgLiquidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgLiquidate} MsgLiquidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgLiquidate message.
         * @function verify
         * @memberof ununifi.cdp.MsgLiquidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgLiquidate.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.keeper != null && message.hasOwnProperty('keeper'))
            if (!$util.isString(message.keeper)) return 'keeper: string expected';
          if (message.borrower != null && message.hasOwnProperty('borrower'))
            if (!$util.isString(message.borrower)) return 'borrower: string expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          return null;
        };

        /**
         * Creates a MsgLiquidate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgLiquidate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgLiquidate} MsgLiquidate
         */
        MsgLiquidate.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgLiquidate) return object;
          var message = new $root.ununifi.cdp.MsgLiquidate();
          if (object.keeper != null) message.keeper = String(object.keeper);
          if (object.borrower != null) message.borrower = String(object.borrower);
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          return message;
        };

        /**
         * Creates a plain object from a MsgLiquidate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgLiquidate
         * @static
         * @param {ununifi.cdp.MsgLiquidate} message MsgLiquidate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgLiquidate.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.keeper = '';
            object.borrower = '';
            object.collateral_type = '';
          }
          if (message.keeper != null && message.hasOwnProperty('keeper')) object.keeper = message.keeper;
          if (message.borrower != null && message.hasOwnProperty('borrower')) object.borrower = message.borrower;
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          return object;
        };

        /**
         * Converts this MsgLiquidate to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgLiquidate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgLiquidate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgLiquidate;
      })();

      cdp.MsgLiquidateResponse = (function () {
        /**
         * Properties of a MsgLiquidateResponse.
         * @memberof ununifi.cdp
         * @interface IMsgLiquidateResponse
         */

        /**
         * Constructs a new MsgLiquidateResponse.
         * @memberof ununifi.cdp
         * @classdesc Represents a MsgLiquidateResponse.
         * @implements IMsgLiquidateResponse
         * @constructor
         * @param {ununifi.cdp.IMsgLiquidateResponse=} [properties] Properties to set
         */
        function MsgLiquidateResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgLiquidateResponse message. Does not implicitly {@link ununifi.cdp.MsgLiquidateResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @static
         * @param {ununifi.cdp.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidateResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgLiquidateResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgLiquidateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @static
         * @param {ununifi.cdp.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidateResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgLiquidateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.MsgLiquidateResponse} MsgLiquidateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidateResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.MsgLiquidateResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgLiquidateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.MsgLiquidateResponse} MsgLiquidateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidateResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgLiquidateResponse message.
         * @function verify
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgLiquidateResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgLiquidateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.MsgLiquidateResponse} MsgLiquidateResponse
         */
        MsgLiquidateResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.MsgLiquidateResponse) return object;
          return new $root.ununifi.cdp.MsgLiquidateResponse();
        };

        /**
         * Creates a plain object from a MsgLiquidateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @static
         * @param {ununifi.cdp.MsgLiquidateResponse} message MsgLiquidateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgLiquidateResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgLiquidateResponse to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.MsgLiquidateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgLiquidateResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgLiquidateResponse;
      })();

      cdp.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.cdp
         * @interface IGenesisState
         * @property {ununifi.cdp.IParams|null} [params] GenesisState params
         * @property {Array.<ununifi.cdp.ICdp>|null} [cdps] GenesisState cdps
         * @property {Array.<ununifi.cdp.IDeposit>|null} [deposits] GenesisState deposits
         * @property {Long|null} [starting_cdp_id] GenesisState starting_cdp_id
         * @property {string|null} [gov_denom] GenesisState gov_denom
         * @property {Array.<ununifi.cdp.IGenesisAccumulationTime>|null} [previous_accumulation_times] GenesisState previous_accumulation_times
         * @property {Array.<ununifi.cdp.IGenesisTotalPrincipal>|null} [total_principals] GenesisState total_principals
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.cdp
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.cdp.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          this.cdps = [];
          this.deposits = [];
          this.previous_accumulation_times = [];
          this.total_principals = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState params.
         * @member {ununifi.cdp.IParams|null|undefined} params
         * @memberof ununifi.cdp.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * GenesisState cdps.
         * @member {Array.<ununifi.cdp.ICdp>} cdps
         * @memberof ununifi.cdp.GenesisState
         * @instance
         */
        GenesisState.prototype.cdps = $util.emptyArray;

        /**
         * GenesisState deposits.
         * @member {Array.<ununifi.cdp.IDeposit>} deposits
         * @memberof ununifi.cdp.GenesisState
         * @instance
         */
        GenesisState.prototype.deposits = $util.emptyArray;

        /**
         * GenesisState starting_cdp_id.
         * @member {Long} starting_cdp_id
         * @memberof ununifi.cdp.GenesisState
         * @instance
         */
        GenesisState.prototype.starting_cdp_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * GenesisState gov_denom.
         * @member {string} gov_denom
         * @memberof ununifi.cdp.GenesisState
         * @instance
         */
        GenesisState.prototype.gov_denom = '';

        /**
         * GenesisState previous_accumulation_times.
         * @member {Array.<ununifi.cdp.IGenesisAccumulationTime>} previous_accumulation_times
         * @memberof ununifi.cdp.GenesisState
         * @instance
         */
        GenesisState.prototype.previous_accumulation_times = $util.emptyArray;

        /**
         * GenesisState total_principals.
         * @member {Array.<ununifi.cdp.IGenesisTotalPrincipal>} total_principals
         * @memberof ununifi.cdp.GenesisState
         * @instance
         */
        GenesisState.prototype.total_principals = $util.emptyArray;

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.cdp.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.GenesisState
         * @static
         * @param {ununifi.cdp.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.cdp.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.cdps != null && message.cdps.length)
            for (var i = 0; i < message.cdps.length; ++i)
              $root.ununifi.cdp.Cdp.encode(message.cdps[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.deposits != null && message.deposits.length)
            for (var i = 0; i < message.deposits.length; ++i)
              $root.ununifi.cdp.Deposit.encode(message.deposits[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.starting_cdp_id != null && Object.hasOwnProperty.call(message, 'starting_cdp_id'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.starting_cdp_id);
          if (message.gov_denom != null && Object.hasOwnProperty.call(message, 'gov_denom'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.gov_denom);
          if (message.previous_accumulation_times != null && message.previous_accumulation_times.length)
            for (var i = 0; i < message.previous_accumulation_times.length; ++i)
              $root.ununifi.cdp.GenesisAccumulationTime.encode(
                message.previous_accumulation_times[i],
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
          if (message.total_principals != null && message.total_principals.length)
            for (var i = 0; i < message.total_principals.length; ++i)
              $root.ununifi.cdp.GenesisTotalPrincipal.encode(
                message.total_principals[i],
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.cdp.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.GenesisState
         * @static
         * @param {ununifi.cdp.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.cdp.Params.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message.cdps && message.cdps.length)) message.cdps = [];
                message.cdps.push($root.ununifi.cdp.Cdp.decode(reader, reader.uint32()));
                break;
              case 3:
                if (!(message.deposits && message.deposits.length)) message.deposits = [];
                message.deposits.push($root.ununifi.cdp.Deposit.decode(reader, reader.uint32()));
                break;
              case 4:
                message.starting_cdp_id = reader.uint64();
                break;
              case 5:
                message.gov_denom = reader.string();
                break;
              case 6:
                if (!(message.previous_accumulation_times && message.previous_accumulation_times.length))
                  message.previous_accumulation_times = [];
                message.previous_accumulation_times.push($root.ununifi.cdp.GenesisAccumulationTime.decode(reader, reader.uint32()));
                break;
              case 7:
                if (!(message.total_principals && message.total_principals.length)) message.total_principals = [];
                message.total_principals.push($root.ununifi.cdp.GenesisTotalPrincipal.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.cdp.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.cdp.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          if (message.cdps != null && message.hasOwnProperty('cdps')) {
            if (!Array.isArray(message.cdps)) return 'cdps: array expected';
            for (var i = 0; i < message.cdps.length; ++i) {
              var error = $root.ununifi.cdp.Cdp.verify(message.cdps[i]);
              if (error) return 'cdps.' + error;
            }
          }
          if (message.deposits != null && message.hasOwnProperty('deposits')) {
            if (!Array.isArray(message.deposits)) return 'deposits: array expected';
            for (var i = 0; i < message.deposits.length; ++i) {
              var error = $root.ununifi.cdp.Deposit.verify(message.deposits[i]);
              if (error) return 'deposits.' + error;
            }
          }
          if (message.starting_cdp_id != null && message.hasOwnProperty('starting_cdp_id'))
            if (
              !$util.isInteger(message.starting_cdp_id) &&
              !(message.starting_cdp_id && $util.isInteger(message.starting_cdp_id.low) && $util.isInteger(message.starting_cdp_id.high))
            )
              return 'starting_cdp_id: integer|Long expected';
          if (message.gov_denom != null && message.hasOwnProperty('gov_denom'))
            if (!$util.isString(message.gov_denom)) return 'gov_denom: string expected';
          if (message.previous_accumulation_times != null && message.hasOwnProperty('previous_accumulation_times')) {
            if (!Array.isArray(message.previous_accumulation_times)) return 'previous_accumulation_times: array expected';
            for (var i = 0; i < message.previous_accumulation_times.length; ++i) {
              var error = $root.ununifi.cdp.GenesisAccumulationTime.verify(message.previous_accumulation_times[i]);
              if (error) return 'previous_accumulation_times.' + error;
            }
          }
          if (message.total_principals != null && message.hasOwnProperty('total_principals')) {
            if (!Array.isArray(message.total_principals)) return 'total_principals: array expected';
            for (var i = 0; i < message.total_principals.length; ++i) {
              var error = $root.ununifi.cdp.GenesisTotalPrincipal.verify(message.total_principals[i]);
              if (error) return 'total_principals.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.GenesisState) return object;
          var message = new $root.ununifi.cdp.GenesisState();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.cdp.GenesisState.params: object expected');
            message.params = $root.ununifi.cdp.Params.fromObject(object.params);
          }
          if (object.cdps) {
            if (!Array.isArray(object.cdps)) throw TypeError('.ununifi.cdp.GenesisState.cdps: array expected');
            message.cdps = [];
            for (var i = 0; i < object.cdps.length; ++i) {
              if (typeof object.cdps[i] !== 'object') throw TypeError('.ununifi.cdp.GenesisState.cdps: object expected');
              message.cdps[i] = $root.ununifi.cdp.Cdp.fromObject(object.cdps[i]);
            }
          }
          if (object.deposits) {
            if (!Array.isArray(object.deposits)) throw TypeError('.ununifi.cdp.GenesisState.deposits: array expected');
            message.deposits = [];
            for (var i = 0; i < object.deposits.length; ++i) {
              if (typeof object.deposits[i] !== 'object') throw TypeError('.ununifi.cdp.GenesisState.deposits: object expected');
              message.deposits[i] = $root.ununifi.cdp.Deposit.fromObject(object.deposits[i]);
            }
          }
          if (object.starting_cdp_id != null)
            if ($util.Long) (message.starting_cdp_id = $util.Long.fromValue(object.starting_cdp_id)).unsigned = true;
            else if (typeof object.starting_cdp_id === 'string') message.starting_cdp_id = parseInt(object.starting_cdp_id, 10);
            else if (typeof object.starting_cdp_id === 'number') message.starting_cdp_id = object.starting_cdp_id;
            else if (typeof object.starting_cdp_id === 'object')
              message.starting_cdp_id = new $util.LongBits(object.starting_cdp_id.low >>> 0, object.starting_cdp_id.high >>> 0).toNumber(
                true,
              );
          if (object.gov_denom != null) message.gov_denom = String(object.gov_denom);
          if (object.previous_accumulation_times) {
            if (!Array.isArray(object.previous_accumulation_times))
              throw TypeError('.ununifi.cdp.GenesisState.previous_accumulation_times: array expected');
            message.previous_accumulation_times = [];
            for (var i = 0; i < object.previous_accumulation_times.length; ++i) {
              if (typeof object.previous_accumulation_times[i] !== 'object')
                throw TypeError('.ununifi.cdp.GenesisState.previous_accumulation_times: object expected');
              message.previous_accumulation_times[i] = $root.ununifi.cdp.GenesisAccumulationTime.fromObject(
                object.previous_accumulation_times[i],
              );
            }
          }
          if (object.total_principals) {
            if (!Array.isArray(object.total_principals)) throw TypeError('.ununifi.cdp.GenesisState.total_principals: array expected');
            message.total_principals = [];
            for (var i = 0; i < object.total_principals.length; ++i) {
              if (typeof object.total_principals[i] !== 'object')
                throw TypeError('.ununifi.cdp.GenesisState.total_principals: object expected');
              message.total_principals[i] = $root.ununifi.cdp.GenesisTotalPrincipal.fromObject(object.total_principals[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.GenesisState
         * @static
         * @param {ununifi.cdp.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.cdps = [];
            object.deposits = [];
            object.previous_accumulation_times = [];
            object.total_principals = [];
          }
          if (options.defaults) {
            object.params = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.starting_cdp_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.starting_cdp_id = options.longs === String ? '0' : 0;
            object.gov_denom = '';
          }
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.cdp.Params.toObject(message.params, options);
          if (message.cdps && message.cdps.length) {
            object.cdps = [];
            for (var j = 0; j < message.cdps.length; ++j) object.cdps[j] = $root.ununifi.cdp.Cdp.toObject(message.cdps[j], options);
          }
          if (message.deposits && message.deposits.length) {
            object.deposits = [];
            for (var j = 0; j < message.deposits.length; ++j)
              object.deposits[j] = $root.ununifi.cdp.Deposit.toObject(message.deposits[j], options);
          }
          if (message.starting_cdp_id != null && message.hasOwnProperty('starting_cdp_id'))
            if (typeof message.starting_cdp_id === 'number')
              object.starting_cdp_id = options.longs === String ? String(message.starting_cdp_id) : message.starting_cdp_id;
            else
              object.starting_cdp_id =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.starting_cdp_id)
                  : options.longs === Number
                  ? new $util.LongBits(message.starting_cdp_id.low >>> 0, message.starting_cdp_id.high >>> 0).toNumber(true)
                  : message.starting_cdp_id;
          if (message.gov_denom != null && message.hasOwnProperty('gov_denom')) object.gov_denom = message.gov_denom;
          if (message.previous_accumulation_times && message.previous_accumulation_times.length) {
            object.previous_accumulation_times = [];
            for (var j = 0; j < message.previous_accumulation_times.length; ++j)
              object.previous_accumulation_times[j] = $root.ununifi.cdp.GenesisAccumulationTime.toObject(
                message.previous_accumulation_times[j],
                options,
              );
          }
          if (message.total_principals && message.total_principals.length) {
            object.total_principals = [];
            for (var j = 0; j < message.total_principals.length; ++j)
              object.total_principals[j] = $root.ununifi.cdp.GenesisTotalPrincipal.toObject(message.total_principals[j], options);
          }
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      cdp.GenesisAccumulationTime = (function () {
        /**
         * Properties of a GenesisAccumulationTime.
         * @memberof ununifi.cdp
         * @interface IGenesisAccumulationTime
         * @property {string|null} [collateral_type] GenesisAccumulationTime collateral_type
         * @property {google.protobuf.ITimestamp|null} [previous_accumulation_time] GenesisAccumulationTime previous_accumulation_time
         * @property {string|null} [interest_factor] GenesisAccumulationTime interest_factor
         */

        /**
         * Constructs a new GenesisAccumulationTime.
         * @memberof ununifi.cdp
         * @classdesc Represents a GenesisAccumulationTime.
         * @implements IGenesisAccumulationTime
         * @constructor
         * @param {ununifi.cdp.IGenesisAccumulationTime=} [properties] Properties to set
         */
        function GenesisAccumulationTime(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisAccumulationTime collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @instance
         */
        GenesisAccumulationTime.prototype.collateral_type = '';

        /**
         * GenesisAccumulationTime previous_accumulation_time.
         * @member {google.protobuf.ITimestamp|null|undefined} previous_accumulation_time
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @instance
         */
        GenesisAccumulationTime.prototype.previous_accumulation_time = null;

        /**
         * GenesisAccumulationTime interest_factor.
         * @member {string} interest_factor
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @instance
         */
        GenesisAccumulationTime.prototype.interest_factor = '';

        /**
         * Encodes the specified GenesisAccumulationTime message. Does not implicitly {@link ununifi.cdp.GenesisAccumulationTime.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @static
         * @param {ununifi.cdp.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisAccumulationTime.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
          if (message.previous_accumulation_time != null && Object.hasOwnProperty.call(message, 'previous_accumulation_time'))
            $root.google.protobuf.Timestamp.encode(
              message.previous_accumulation_time,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.interest_factor != null && Object.hasOwnProperty.call(message, 'interest_factor'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.interest_factor);
          return writer;
        };

        /**
         * Encodes the specified GenesisAccumulationTime message, length delimited. Does not implicitly {@link ununifi.cdp.GenesisAccumulationTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @static
         * @param {ununifi.cdp.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisAccumulationTime.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisAccumulationTime message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.GenesisAccumulationTime} GenesisAccumulationTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisAccumulationTime.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.GenesisAccumulationTime();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.collateral_type = reader.string();
                break;
              case 2:
                message.previous_accumulation_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 3:
                message.interest_factor = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisAccumulationTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.GenesisAccumulationTime} GenesisAccumulationTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisAccumulationTime.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisAccumulationTime message.
         * @function verify
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisAccumulationTime.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time')) {
            var error = $root.google.protobuf.Timestamp.verify(message.previous_accumulation_time);
            if (error) return 'previous_accumulation_time.' + error;
          }
          if (message.interest_factor != null && message.hasOwnProperty('interest_factor'))
            if (!$util.isString(message.interest_factor)) return 'interest_factor: string expected';
          return null;
        };

        /**
         * Creates a GenesisAccumulationTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.GenesisAccumulationTime} GenesisAccumulationTime
         */
        GenesisAccumulationTime.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.GenesisAccumulationTime) return object;
          var message = new $root.ununifi.cdp.GenesisAccumulationTime();
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          if (object.previous_accumulation_time != null) {
            if (typeof object.previous_accumulation_time !== 'object')
              throw TypeError('.ununifi.cdp.GenesisAccumulationTime.previous_accumulation_time: object expected');
            message.previous_accumulation_time = $root.google.protobuf.Timestamp.fromObject(object.previous_accumulation_time);
          }
          if (object.interest_factor != null) message.interest_factor = String(object.interest_factor);
          return message;
        };

        /**
         * Creates a plain object from a GenesisAccumulationTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @static
         * @param {ununifi.cdp.GenesisAccumulationTime} message GenesisAccumulationTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisAccumulationTime.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.collateral_type = '';
            object.previous_accumulation_time = null;
            object.interest_factor = '';
          }
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time'))
            object.previous_accumulation_time = $root.google.protobuf.Timestamp.toObject(message.previous_accumulation_time, options);
          if (message.interest_factor != null && message.hasOwnProperty('interest_factor'))
            object.interest_factor = message.interest_factor;
          return object;
        };

        /**
         * Converts this GenesisAccumulationTime to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.GenesisAccumulationTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisAccumulationTime.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisAccumulationTime;
      })();

      cdp.GenesisTotalPrincipal = (function () {
        /**
         * Properties of a GenesisTotalPrincipal.
         * @memberof ununifi.cdp
         * @interface IGenesisTotalPrincipal
         * @property {string|null} [collateral_type] GenesisTotalPrincipal collateral_type
         * @property {string|null} [total_principal] GenesisTotalPrincipal total_principal
         */

        /**
         * Constructs a new GenesisTotalPrincipal.
         * @memberof ununifi.cdp
         * @classdesc Represents a GenesisTotalPrincipal.
         * @implements IGenesisTotalPrincipal
         * @constructor
         * @param {ununifi.cdp.IGenesisTotalPrincipal=} [properties] Properties to set
         */
        function GenesisTotalPrincipal(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisTotalPrincipal collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @instance
         */
        GenesisTotalPrincipal.prototype.collateral_type = '';

        /**
         * GenesisTotalPrincipal total_principal.
         * @member {string} total_principal
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @instance
         */
        GenesisTotalPrincipal.prototype.total_principal = '';

        /**
         * Encodes the specified GenesisTotalPrincipal message. Does not implicitly {@link ununifi.cdp.GenesisTotalPrincipal.verify|verify} messages.
         * @function encode
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @static
         * @param {ununifi.cdp.IGenesisTotalPrincipal} message GenesisTotalPrincipal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisTotalPrincipal.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
          if (message.total_principal != null && Object.hasOwnProperty.call(message, 'total_principal'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.total_principal);
          return writer;
        };

        /**
         * Encodes the specified GenesisTotalPrincipal message, length delimited. Does not implicitly {@link ununifi.cdp.GenesisTotalPrincipal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @static
         * @param {ununifi.cdp.IGenesisTotalPrincipal} message GenesisTotalPrincipal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisTotalPrincipal.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisTotalPrincipal message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.cdp.GenesisTotalPrincipal} GenesisTotalPrincipal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisTotalPrincipal.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.cdp.GenesisTotalPrincipal();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.collateral_type = reader.string();
                break;
              case 2:
                message.total_principal = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisTotalPrincipal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.cdp.GenesisTotalPrincipal} GenesisTotalPrincipal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisTotalPrincipal.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisTotalPrincipal message.
         * @function verify
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisTotalPrincipal.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          if (message.total_principal != null && message.hasOwnProperty('total_principal'))
            if (!$util.isString(message.total_principal)) return 'total_principal: string expected';
          return null;
        };

        /**
         * Creates a GenesisTotalPrincipal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.cdp.GenesisTotalPrincipal} GenesisTotalPrincipal
         */
        GenesisTotalPrincipal.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.cdp.GenesisTotalPrincipal) return object;
          var message = new $root.ununifi.cdp.GenesisTotalPrincipal();
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          if (object.total_principal != null) message.total_principal = String(object.total_principal);
          return message;
        };

        /**
         * Creates a plain object from a GenesisTotalPrincipal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @static
         * @param {ununifi.cdp.GenesisTotalPrincipal} message GenesisTotalPrincipal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisTotalPrincipal.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.collateral_type = '';
            object.total_principal = '';
          }
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          if (message.total_principal != null && message.hasOwnProperty('total_principal'))
            object.total_principal = message.total_principal;
          return object;
        };

        /**
         * Converts this GenesisTotalPrincipal to JSON.
         * @function toJSON
         * @memberof ununifi.cdp.GenesisTotalPrincipal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisTotalPrincipal.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisTotalPrincipal;
      })();

      return cdp;
    })();

    ununifi.ecosystemincentive = (function () {
      /**
       * Namespace ecosystemincentive.
       * @memberof ununifi
       * @namespace
       */
      var ecosystemincentive = {};

      ecosystemincentive.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Query#params}.
         * @memberof ununifi.ecosystemincentive.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.ecosystemincentive.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(
              params,
              $root.ununifi.ecosystemincentive.QueryParamsRequest,
              $root.ununifi.ecosystemincentive.QueryParamsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.QueryParamsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Query#incentiveUnit}.
         * @memberof ununifi.ecosystemincentive.Query
         * @typedef IncentiveUnitCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} [response] QueryIncentiveUnitResponse
         */

        /**
         * Calls IncentiveUnit.
         * @function incentiveUnit
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} request QueryIncentiveUnitRequest message or plain object
         * @param {ununifi.ecosystemincentive.Query.IncentiveUnitCallback} callback Node-style callback called with the error, if any, and QueryIncentiveUnitResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.incentiveUnit = function incentiveUnit(request, callback) {
            return this.rpcCall(
              incentiveUnit,
              $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest,
              $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'IncentiveUnit' },
        );

        /**
         * Calls IncentiveUnit.
         * @function incentiveUnit
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} request QueryIncentiveUnitRequest message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.QueryIncentiveUnitResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Query#allRewards}.
         * @memberof ununifi.ecosystemincentive.Query
         * @typedef AllRewardsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.QueryAllRewardsResponse} [response] QueryAllRewardsResponse
         */

        /**
         * Calls AllRewards.
         * @function allRewards
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} request QueryAllRewardsRequest message or plain object
         * @param {ununifi.ecosystemincentive.Query.AllRewardsCallback} callback Node-style callback called with the error, if any, and QueryAllRewardsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.allRewards = function allRewards(request, callback) {
            return this.rpcCall(
              allRewards,
              $root.ununifi.ecosystemincentive.QueryAllRewardsRequest,
              $root.ununifi.ecosystemincentive.QueryAllRewardsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'AllRewards' },
        );

        /**
         * Calls AllRewards.
         * @function allRewards
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} request QueryAllRewardsRequest message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.QueryAllRewardsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Query#reward}.
         * @memberof ununifi.ecosystemincentive.Query
         * @typedef RewardCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.QueryRewardResponse} [response] QueryRewardResponse
         */

        /**
         * Calls Reward.
         * @function reward
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryRewardRequest} request QueryRewardRequest message or plain object
         * @param {ununifi.ecosystemincentive.Query.RewardCallback} callback Node-style callback called with the error, if any, and QueryRewardResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.reward = function reward(request, callback) {
            return this.rpcCall(
              reward,
              $root.ununifi.ecosystemincentive.QueryRewardRequest,
              $root.ununifi.ecosystemincentive.QueryRewardResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Reward' },
        );

        /**
         * Calls Reward.
         * @function reward
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryRewardRequest} request QueryRewardRequest message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.QueryRewardResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Query#recordedIncentiveUnitId}.
         * @memberof ununifi.ecosystemincentive.Query
         * @typedef RecordedIncentiveUnitIdCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} [response] QueryRecordedIncentiveUnitIdResponse
         */

        /**
         * Calls RecordedIncentiveUnitId.
         * @function recordedIncentiveUnitId
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} request QueryRecordedIncentiveUnitIdRequest message or plain object
         * @param {ununifi.ecosystemincentive.Query.RecordedIncentiveUnitIdCallback} callback Node-style callback called with the error, if any, and QueryRecordedIncentiveUnitIdResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.recordedIncentiveUnitId = function recordedIncentiveUnitId(request, callback) {
            return this.rpcCall(
              recordedIncentiveUnitId,
              $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest,
              $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'RecordedIncentiveUnitId' },
        );

        /**
         * Calls RecordedIncentiveUnitId.
         * @function recordedIncentiveUnitId
         * @memberof ununifi.ecosystemincentive.Query
         * @instance
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} request QueryRecordedIncentiveUnitIdRequest message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      ecosystemincentive.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsRequest) return object;
          return new $root.ununifi.ecosystemincentive.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @static
         * @param {ununifi.ecosystemincentive.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      ecosystemincentive.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryParamsResponse
         * @property {ununifi.ecosystemincentive.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsResponse) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @static
         * @param {ununifi.ecosystemincentive.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      ecosystemincentive.QueryIncentiveUnitRequest = (function () {
        /**
         * Properties of a QueryIncentiveUnitRequest.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryIncentiveUnitRequest
         * @property {string|null} [incentive_unit_id] QueryIncentiveUnitRequest incentive_unit_id
         */

        /**
         * Constructs a new QueryIncentiveUnitRequest.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryIncentiveUnitRequest.
         * @implements IQueryIncentiveUnitRequest
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest=} [properties] Properties to set
         */
        function QueryIncentiveUnitRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryIncentiveUnitRequest incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @instance
         */
        QueryIncentiveUnitRequest.prototype.incentive_unit_id = '';

        /**
         * Encodes the specified QueryIncentiveUnitRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} message QueryIncentiveUnitRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryIncentiveUnitRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
          return writer;
        };

        /**
         * Encodes the specified QueryIncentiveUnitRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} message QueryIncentiveUnitRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryIncentiveUnitRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryIncentiveUnitRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} QueryIncentiveUnitRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryIncentiveUnitRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryIncentiveUnitRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} QueryIncentiveUnitRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryIncentiveUnitRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryIncentiveUnitRequest message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryIncentiveUnitRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          return null;
        };

        /**
         * Creates a QueryIncentiveUnitRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} QueryIncentiveUnitRequest
         */
        QueryIncentiveUnitRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest();
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryIncentiveUnitRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @static
         * @param {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} message QueryIncentiveUnitRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryIncentiveUnitRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.incentive_unit_id = '';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          return object;
        };

        /**
         * Converts this QueryIncentiveUnitRequest to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryIncentiveUnitRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryIncentiveUnitRequest;
      })();

      ecosystemincentive.QueryIncentiveUnitResponse = (function () {
        /**
         * Properties of a QueryIncentiveUnitResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryIncentiveUnitResponse
         * @property {ununifi.ecosystemincentive.IIncentiveUnit|null} [incentive_unit] QueryIncentiveUnitResponse incentive_unit
         */

        /**
         * Constructs a new QueryIncentiveUnitResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryIncentiveUnitResponse.
         * @implements IQueryIncentiveUnitResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitResponse=} [properties] Properties to set
         */
        function QueryIncentiveUnitResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryIncentiveUnitResponse incentive_unit.
         * @member {ununifi.ecosystemincentive.IIncentiveUnit|null|undefined} incentive_unit
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @instance
         */
        QueryIncentiveUnitResponse.prototype.incentive_unit = null;

        /**
         * Encodes the specified QueryIncentiveUnitResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitResponse} message QueryIncentiveUnitResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryIncentiveUnitResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit != null && Object.hasOwnProperty.call(message, 'incentive_unit'))
            $root.ununifi.ecosystemincentive.IncentiveUnit.encode(
              message.incentive_unit,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryIncentiveUnitResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitResponse} message QueryIncentiveUnitResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryIncentiveUnitResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryIncentiveUnitResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} QueryIncentiveUnitResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryIncentiveUnitResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit = $root.ununifi.ecosystemincentive.IncentiveUnit.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryIncentiveUnitResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} QueryIncentiveUnitResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryIncentiveUnitResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryIncentiveUnitResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryIncentiveUnitResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit != null && message.hasOwnProperty('incentive_unit')) {
            var error = $root.ununifi.ecosystemincentive.IncentiveUnit.verify(message.incentive_unit);
            if (error) return 'incentive_unit.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryIncentiveUnitResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} QueryIncentiveUnitResponse
         */
        QueryIncentiveUnitResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse();
          if (object.incentive_unit != null) {
            if (typeof object.incentive_unit !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.QueryIncentiveUnitResponse.incentive_unit: object expected');
            message.incentive_unit = $root.ununifi.ecosystemincentive.IncentiveUnit.fromObject(object.incentive_unit);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryIncentiveUnitResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @static
         * @param {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} message QueryIncentiveUnitResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryIncentiveUnitResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.incentive_unit = null;
          if (message.incentive_unit != null && message.hasOwnProperty('incentive_unit'))
            object.incentive_unit = $root.ununifi.ecosystemincentive.IncentiveUnit.toObject(message.incentive_unit, options);
          return object;
        };

        /**
         * Converts this QueryIncentiveUnitResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryIncentiveUnitResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryIncentiveUnitResponse;
      })();

      ecosystemincentive.QueryAllRewardsRequest = (function () {
        /**
         * Properties of a QueryAllRewardsRequest.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryAllRewardsRequest
         * @property {string|null} [subject_addr] QueryAllRewardsRequest subject_addr
         */

        /**
         * Constructs a new QueryAllRewardsRequest.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryAllRewardsRequest.
         * @implements IQueryAllRewardsRequest
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest=} [properties] Properties to set
         */
        function QueryAllRewardsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllRewardsRequest subject_addr.
         * @member {string} subject_addr
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @instance
         */
        QueryAllRewardsRequest.prototype.subject_addr = '';

        /**
         * Encodes the specified QueryAllRewardsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} message QueryAllRewardsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRewardsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
          return writer;
        };

        /**
         * Encodes the specified QueryAllRewardsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} message QueryAllRewardsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllRewardsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRewardsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryAllRewardsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.subject_addr = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllRewardsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllRewardsRequest message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllRewardsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
            if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
          return null;
        };

        /**
         * Creates a QueryAllRewardsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
         */
        QueryAllRewardsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryAllRewardsRequest) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryAllRewardsRequest();
          if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
          return message;
        };

        /**
         * Creates a plain object from a QueryAllRewardsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @static
         * @param {ununifi.ecosystemincentive.QueryAllRewardsRequest} message QueryAllRewardsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllRewardsRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.subject_addr = '';
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
          return object;
        };

        /**
         * Converts this QueryAllRewardsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllRewardsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllRewardsRequest;
      })();

      ecosystemincentive.QueryAllRewardsResponse = (function () {
        /**
         * Properties of a QueryAllRewardsResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryAllRewardsResponse
         * @property {ununifi.ecosystemincentive.IRewardStore|null} [rewards] QueryAllRewardsResponse rewards
         */

        /**
         * Constructs a new QueryAllRewardsResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryAllRewardsResponse.
         * @implements IQueryAllRewardsResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse=} [properties] Properties to set
         */
        function QueryAllRewardsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllRewardsResponse rewards.
         * @member {ununifi.ecosystemincentive.IRewardStore|null|undefined} rewards
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @instance
         */
        QueryAllRewardsResponse.prototype.rewards = null;

        /**
         * Encodes the specified QueryAllRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse} message QueryAllRewardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRewardsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.rewards != null && Object.hasOwnProperty.call(message, 'rewards'))
            $root.ununifi.ecosystemincentive.RewardStore.encode(message.rewards, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse} message QueryAllRewardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllRewardsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRewardsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryAllRewardsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.rewards = $root.ununifi.ecosystemincentive.RewardStore.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllRewardsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllRewardsResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllRewardsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.rewards != null && message.hasOwnProperty('rewards')) {
            var error = $root.ununifi.ecosystemincentive.RewardStore.verify(message.rewards);
            if (error) return 'rewards.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllRewardsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
         */
        QueryAllRewardsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryAllRewardsResponse) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryAllRewardsResponse();
          if (object.rewards != null) {
            if (typeof object.rewards !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.QueryAllRewardsResponse.rewards: object expected');
            message.rewards = $root.ununifi.ecosystemincentive.RewardStore.fromObject(object.rewards);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllRewardsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @static
         * @param {ununifi.ecosystemincentive.QueryAllRewardsResponse} message QueryAllRewardsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllRewardsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.rewards = null;
          if (message.rewards != null && message.hasOwnProperty('rewards'))
            object.rewards = $root.ununifi.ecosystemincentive.RewardStore.toObject(message.rewards, options);
          return object;
        };

        /**
         * Converts this QueryAllRewardsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllRewardsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllRewardsResponse;
      })();

      ecosystemincentive.QueryRewardRequest = (function () {
        /**
         * Properties of a QueryRewardRequest.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryRewardRequest
         * @property {string|null} [subject_addr] QueryRewardRequest subject_addr
         * @property {string|null} [denom] QueryRewardRequest denom
         */

        /**
         * Constructs a new QueryRewardRequest.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryRewardRequest.
         * @implements IQueryRewardRequest
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryRewardRequest=} [properties] Properties to set
         */
        function QueryRewardRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRewardRequest subject_addr.
         * @member {string} subject_addr
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @instance
         */
        QueryRewardRequest.prototype.subject_addr = '';

        /**
         * QueryRewardRequest denom.
         * @member {string} denom
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @instance
         */
        QueryRewardRequest.prototype.denom = '';

        /**
         * Encodes the specified QueryRewardRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRewardRequest} message QueryRewardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
          return writer;
        };

        /**
         * Encodes the specified QueryRewardRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRewardRequest} message QueryRewardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRewardRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryRewardRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.subject_addr = reader.string();
                break;
              case 2:
                message.denom = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryRewardRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRewardRequest message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRewardRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
            if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          return null;
        };

        /**
         * Creates a QueryRewardRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
         */
        QueryRewardRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryRewardRequest) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryRewardRequest();
          if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
          if (object.denom != null) message.denom = String(object.denom);
          return message;
        };

        /**
         * Creates a plain object from a QueryRewardRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @static
         * @param {ununifi.ecosystemincentive.QueryRewardRequest} message QueryRewardRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRewardRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.subject_addr = '';
            object.denom = '';
          }
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          return object;
        };

        /**
         * Converts this QueryRewardRequest to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryRewardRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRewardRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRewardRequest;
      })();

      ecosystemincentive.QueryRewardResponse = (function () {
        /**
         * Properties of a QueryRewardResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryRewardResponse
         * @property {cosmos.base.v1beta1.ICoin|null} [reward] QueryRewardResponse reward
         */

        /**
         * Constructs a new QueryRewardResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryRewardResponse.
         * @implements IQueryRewardResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryRewardResponse=} [properties] Properties to set
         */
        function QueryRewardResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRewardResponse reward.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} reward
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @instance
         */
        QueryRewardResponse.prototype.reward = null;

        /**
         * Encodes the specified QueryRewardResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRewardResponse} message QueryRewardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.reward != null && Object.hasOwnProperty.call(message, 'reward'))
            $root.cosmos.base.v1beta1.Coin.encode(message.reward, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryRewardResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRewardResponse} message QueryRewardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRewardResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryRewardResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryRewardResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRewardResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRewardResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.reward != null && message.hasOwnProperty('reward')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.reward);
            if (error) return 'reward.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryRewardResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
         */
        QueryRewardResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryRewardResponse) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryRewardResponse();
          if (object.reward != null) {
            if (typeof object.reward !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.QueryRewardResponse.reward: object expected');
            message.reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.reward);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryRewardResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @static
         * @param {ununifi.ecosystemincentive.QueryRewardResponse} message QueryRewardResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRewardResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.reward = null;
          if (message.reward != null && message.hasOwnProperty('reward'))
            object.reward = $root.cosmos.base.v1beta1.Coin.toObject(message.reward, options);
          return object;
        };

        /**
         * Converts this QueryRewardResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryRewardResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRewardResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRewardResponse;
      })();

      ecosystemincentive.QueryRecordedIncentiveUnitIdRequest = (function () {
        /**
         * Properties of a QueryRecordedIncentiveUnitIdRequest.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryRecordedIncentiveUnitIdRequest
         * @property {string|null} [class_id] QueryRecordedIncentiveUnitIdRequest class_id
         * @property {string|null} [nft_id] QueryRecordedIncentiveUnitIdRequest nft_id
         */

        /**
         * Constructs a new QueryRecordedIncentiveUnitIdRequest.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryRecordedIncentiveUnitIdRequest.
         * @implements IQueryRecordedIncentiveUnitIdRequest
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest=} [properties] Properties to set
         */
        function QueryRecordedIncentiveUnitIdRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRecordedIncentiveUnitIdRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @instance
         */
        QueryRecordedIncentiveUnitIdRequest.prototype.class_id = '';

        /**
         * QueryRecordedIncentiveUnitIdRequest nft_id.
         * @member {string} nft_id
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @instance
         */
        QueryRecordedIncentiveUnitIdRequest.prototype.nft_id = '';

        /**
         * Encodes the specified QueryRecordedIncentiveUnitIdRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} message QueryRecordedIncentiveUnitIdRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRecordedIncentiveUnitIdRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified QueryRecordedIncentiveUnitIdRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} message QueryRecordedIncentiveUnitIdRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRecordedIncentiveUnitIdRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRecordedIncentiveUnitIdRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} QueryRecordedIncentiveUnitIdRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRecordedIncentiveUnitIdRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryRecordedIncentiveUnitIdRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} QueryRecordedIncentiveUnitIdRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRecordedIncentiveUnitIdRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRecordedIncentiveUnitIdRequest message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRecordedIncentiveUnitIdRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates a QueryRecordedIncentiveUnitIdRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} QueryRecordedIncentiveUnitIdRequest
         */
        QueryRecordedIncentiveUnitIdRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryRecordedIncentiveUnitIdRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @static
         * @param {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} message QueryRecordedIncentiveUnitIdRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRecordedIncentiveUnitIdRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this QueryRecordedIncentiveUnitIdRequest to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRecordedIncentiveUnitIdRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRecordedIncentiveUnitIdRequest;
      })();

      ecosystemincentive.QueryRecordedIncentiveUnitIdResponse = (function () {
        /**
         * Properties of a QueryRecordedIncentiveUnitIdResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IQueryRecordedIncentiveUnitIdResponse
         * @property {string|null} [incentive_unit_id] QueryRecordedIncentiveUnitIdResponse incentive_unit_id
         */

        /**
         * Constructs a new QueryRecordedIncentiveUnitIdResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a QueryRecordedIncentiveUnitIdResponse.
         * @implements IQueryRecordedIncentiveUnitIdResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdResponse=} [properties] Properties to set
         */
        function QueryRecordedIncentiveUnitIdResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRecordedIncentiveUnitIdResponse incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @instance
         */
        QueryRecordedIncentiveUnitIdResponse.prototype.incentive_unit_id = '';

        /**
         * Encodes the specified QueryRecordedIncentiveUnitIdResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdResponse} message QueryRecordedIncentiveUnitIdResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRecordedIncentiveUnitIdResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
          return writer;
        };

        /**
         * Encodes the specified QueryRecordedIncentiveUnitIdResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @static
         * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdResponse} message QueryRecordedIncentiveUnitIdResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRecordedIncentiveUnitIdResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRecordedIncentiveUnitIdResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} QueryRecordedIncentiveUnitIdResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRecordedIncentiveUnitIdResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryRecordedIncentiveUnitIdResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} QueryRecordedIncentiveUnitIdResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRecordedIncentiveUnitIdResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRecordedIncentiveUnitIdResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRecordedIncentiveUnitIdResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          return null;
        };

        /**
         * Creates a QueryRecordedIncentiveUnitIdResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} QueryRecordedIncentiveUnitIdResponse
         */
        QueryRecordedIncentiveUnitIdResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse) return object;
          var message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse();
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryRecordedIncentiveUnitIdResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @static
         * @param {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} message QueryRecordedIncentiveUnitIdResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRecordedIncentiveUnitIdResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.incentive_unit_id = '';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          return object;
        };

        /**
         * Converts this QueryRecordedIncentiveUnitIdResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRecordedIncentiveUnitIdResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRecordedIncentiveUnitIdResponse;
      })();

      ecosystemincentive.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.ecosystemincentive
         * @interface IParams
         * @property {Array.<ununifi.ecosystemincentive.IRewardParams>|null} [reward_params] Params reward_params
         * @property {Long|null} [max_incentive_unit_id_len] Params max_incentive_unit_id_len
         * @property {Long|null} [max_subject_info_num_in_unit] Params max_subject_info_num_in_unit
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.ecosystemincentive.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          this.reward_params = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params reward_params.
         * @member {Array.<ununifi.ecosystemincentive.IRewardParams>} reward_params
         * @memberof ununifi.ecosystemincentive.Params
         * @instance
         */
        Params.prototype.reward_params = $util.emptyArray;

        /**
         * Params max_incentive_unit_id_len.
         * @member {Long} max_incentive_unit_id_len
         * @memberof ununifi.ecosystemincentive.Params
         * @instance
         */
        Params.prototype.max_incentive_unit_id_len = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params max_subject_info_num_in_unit.
         * @member {Long} max_subject_info_num_in_unit
         * @memberof ununifi.ecosystemincentive.Params
         * @instance
         */
        Params.prototype.max_subject_info_num_in_unit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.Params
         * @static
         * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.reward_params != null && message.reward_params.length)
            for (var i = 0; i < message.reward_params.length; ++i)
              $root.ununifi.ecosystemincentive.RewardParams.encode(
                message.reward_params[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          if (message.max_incentive_unit_id_len != null && Object.hasOwnProperty.call(message, 'max_incentive_unit_id_len'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.max_incentive_unit_id_len);
          if (message.max_subject_info_num_in_unit != null && Object.hasOwnProperty.call(message, 'max_subject_info_num_in_unit'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.max_subject_info_num_in_unit);
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.Params
         * @static
         * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.reward_params && message.reward_params.length)) message.reward_params = [];
                message.reward_params.push($root.ununifi.ecosystemincentive.RewardParams.decode(reader, reader.uint32()));
                break;
              case 2:
                message.max_incentive_unit_id_len = reader.uint64();
                break;
              case 3:
                message.max_subject_info_num_in_unit = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.reward_params != null && message.hasOwnProperty('reward_params')) {
            if (!Array.isArray(message.reward_params)) return 'reward_params: array expected';
            for (var i = 0; i < message.reward_params.length; ++i) {
              var error = $root.ununifi.ecosystemincentive.RewardParams.verify(message.reward_params[i]);
              if (error) return 'reward_params.' + error;
            }
          }
          if (message.max_incentive_unit_id_len != null && message.hasOwnProperty('max_incentive_unit_id_len'))
            if (
              !$util.isInteger(message.max_incentive_unit_id_len) &&
              !(
                message.max_incentive_unit_id_len &&
                $util.isInteger(message.max_incentive_unit_id_len.low) &&
                $util.isInteger(message.max_incentive_unit_id_len.high)
              )
            )
              return 'max_incentive_unit_id_len: integer|Long expected';
          if (message.max_subject_info_num_in_unit != null && message.hasOwnProperty('max_subject_info_num_in_unit'))
            if (
              !$util.isInteger(message.max_subject_info_num_in_unit) &&
              !(
                message.max_subject_info_num_in_unit &&
                $util.isInteger(message.max_subject_info_num_in_unit.low) &&
                $util.isInteger(message.max_subject_info_num_in_unit.high)
              )
            )
              return 'max_subject_info_num_in_unit: integer|Long expected';
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.Params) return object;
          var message = new $root.ununifi.ecosystemincentive.Params();
          if (object.reward_params) {
            if (!Array.isArray(object.reward_params)) throw TypeError('.ununifi.ecosystemincentive.Params.reward_params: array expected');
            message.reward_params = [];
            for (var i = 0; i < object.reward_params.length; ++i) {
              if (typeof object.reward_params[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.Params.reward_params: object expected');
              message.reward_params[i] = $root.ununifi.ecosystemincentive.RewardParams.fromObject(object.reward_params[i]);
            }
          }
          if (object.max_incentive_unit_id_len != null)
            if ($util.Long) (message.max_incentive_unit_id_len = $util.Long.fromValue(object.max_incentive_unit_id_len)).unsigned = true;
            else if (typeof object.max_incentive_unit_id_len === 'string')
              message.max_incentive_unit_id_len = parseInt(object.max_incentive_unit_id_len, 10);
            else if (typeof object.max_incentive_unit_id_len === 'number')
              message.max_incentive_unit_id_len = object.max_incentive_unit_id_len;
            else if (typeof object.max_incentive_unit_id_len === 'object')
              message.max_incentive_unit_id_len = new $util.LongBits(
                object.max_incentive_unit_id_len.low >>> 0,
                object.max_incentive_unit_id_len.high >>> 0,
              ).toNumber(true);
          if (object.max_subject_info_num_in_unit != null)
            if ($util.Long)
              (message.max_subject_info_num_in_unit = $util.Long.fromValue(object.max_subject_info_num_in_unit)).unsigned = true;
            else if (typeof object.max_subject_info_num_in_unit === 'string')
              message.max_subject_info_num_in_unit = parseInt(object.max_subject_info_num_in_unit, 10);
            else if (typeof object.max_subject_info_num_in_unit === 'number')
              message.max_subject_info_num_in_unit = object.max_subject_info_num_in_unit;
            else if (typeof object.max_subject_info_num_in_unit === 'object')
              message.max_subject_info_num_in_unit = new $util.LongBits(
                object.max_subject_info_num_in_unit.low >>> 0,
                object.max_subject_info_num_in_unit.high >>> 0,
              ).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.Params
         * @static
         * @param {ununifi.ecosystemincentive.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.reward_params = [];
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.max_incentive_unit_id_len =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.max_incentive_unit_id_len = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.max_subject_info_num_in_unit =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.max_subject_info_num_in_unit = options.longs === String ? '0' : 0;
          }
          if (message.reward_params && message.reward_params.length) {
            object.reward_params = [];
            for (var j = 0; j < message.reward_params.length; ++j)
              object.reward_params[j] = $root.ununifi.ecosystemincentive.RewardParams.toObject(message.reward_params[j], options);
          }
          if (message.max_incentive_unit_id_len != null && message.hasOwnProperty('max_incentive_unit_id_len'))
            if (typeof message.max_incentive_unit_id_len === 'number')
              object.max_incentive_unit_id_len =
                options.longs === String ? String(message.max_incentive_unit_id_len) : message.max_incentive_unit_id_len;
            else
              object.max_incentive_unit_id_len =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.max_incentive_unit_id_len)
                  : options.longs === Number
                  ? new $util.LongBits(message.max_incentive_unit_id_len.low >>> 0, message.max_incentive_unit_id_len.high >>> 0).toNumber(
                      true,
                    )
                  : message.max_incentive_unit_id_len;
          if (message.max_subject_info_num_in_unit != null && message.hasOwnProperty('max_subject_info_num_in_unit'))
            if (typeof message.max_subject_info_num_in_unit === 'number')
              object.max_subject_info_num_in_unit =
                options.longs === String ? String(message.max_subject_info_num_in_unit) : message.max_subject_info_num_in_unit;
            else
              object.max_subject_info_num_in_unit =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.max_subject_info_num_in_unit)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.max_subject_info_num_in_unit.low >>> 0,
                      message.max_subject_info_num_in_unit.high >>> 0,
                    ).toNumber(true)
                  : message.max_subject_info_num_in_unit;
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      ecosystemincentive.RewardParams = (function () {
        /**
         * Properties of a RewardParams.
         * @memberof ununifi.ecosystemincentive
         * @interface IRewardParams
         * @property {string|null} [module_name] RewardParams module_name
         * @property {Array.<ununifi.ecosystemincentive.IRewardRate>|null} [reward_rate] RewardParams reward_rate
         */

        /**
         * Constructs a new RewardParams.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a RewardParams.
         * @implements IRewardParams
         * @constructor
         * @param {ununifi.ecosystemincentive.IRewardParams=} [properties] Properties to set
         */
        function RewardParams(properties) {
          this.reward_rate = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RewardParams module_name.
         * @member {string} module_name
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @instance
         */
        RewardParams.prototype.module_name = '';

        /**
         * RewardParams reward_rate.
         * @member {Array.<ununifi.ecosystemincentive.IRewardRate>} reward_rate
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @instance
         */
        RewardParams.prototype.reward_rate = $util.emptyArray;

        /**
         * Encodes the specified RewardParams message. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @static
         * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.module_name != null && Object.hasOwnProperty.call(message, 'module_name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.module_name);
          if (message.reward_rate != null && message.reward_rate.length)
            for (var i = 0; i < message.reward_rate.length; ++i)
              $root.ununifi.ecosystemincentive.RewardRate.encode(
                message.reward_rate[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified RewardParams message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @static
         * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RewardParams message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.RewardParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.module_name = reader.string();
                break;
              case 2:
                if (!(message.reward_rate && message.reward_rate.length)) message.reward_rate = [];
                message.reward_rate.push($root.ununifi.ecosystemincentive.RewardRate.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RewardParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RewardParams message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RewardParams.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.module_name != null && message.hasOwnProperty('module_name'))
            if (!$util.isString(message.module_name)) return 'module_name: string expected';
          if (message.reward_rate != null && message.hasOwnProperty('reward_rate')) {
            if (!Array.isArray(message.reward_rate)) return 'reward_rate: array expected';
            for (var i = 0; i < message.reward_rate.length; ++i) {
              var error = $root.ununifi.ecosystemincentive.RewardRate.verify(message.reward_rate[i]);
              if (error) return 'reward_rate.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a RewardParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
         */
        RewardParams.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.RewardParams) return object;
          var message = new $root.ununifi.ecosystemincentive.RewardParams();
          if (object.module_name != null) message.module_name = String(object.module_name);
          if (object.reward_rate) {
            if (!Array.isArray(object.reward_rate)) throw TypeError('.ununifi.ecosystemincentive.RewardParams.reward_rate: array expected');
            message.reward_rate = [];
            for (var i = 0; i < object.reward_rate.length; ++i) {
              if (typeof object.reward_rate[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.RewardParams.reward_rate: object expected');
              message.reward_rate[i] = $root.ununifi.ecosystemincentive.RewardRate.fromObject(object.reward_rate[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a RewardParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @static
         * @param {ununifi.ecosystemincentive.RewardParams} message RewardParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RewardParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.reward_rate = [];
          if (options.defaults) object.module_name = '';
          if (message.module_name != null && message.hasOwnProperty('module_name')) object.module_name = message.module_name;
          if (message.reward_rate && message.reward_rate.length) {
            object.reward_rate = [];
            for (var j = 0; j < message.reward_rate.length; ++j)
              object.reward_rate[j] = $root.ununifi.ecosystemincentive.RewardRate.toObject(message.reward_rate[j], options);
          }
          return object;
        };

        /**
         * Converts this RewardParams to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.RewardParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RewardParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RewardParams;
      })();

      ecosystemincentive.RewardRate = (function () {
        /**
         * Properties of a RewardRate.
         * @memberof ununifi.ecosystemincentive
         * @interface IRewardRate
         * @property {ununifi.ecosystemincentive.RewardType|null} [reward_type] RewardRate reward_type
         * @property {string|null} [rate] RewardRate rate
         */

        /**
         * Constructs a new RewardRate.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a RewardRate.
         * @implements IRewardRate
         * @constructor
         * @param {ununifi.ecosystemincentive.IRewardRate=} [properties] Properties to set
         */
        function RewardRate(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RewardRate reward_type.
         * @member {ununifi.ecosystemincentive.RewardType} reward_type
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @instance
         */
        RewardRate.prototype.reward_type = 0;

        /**
         * RewardRate rate.
         * @member {string} rate
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @instance
         */
        RewardRate.prototype.rate = '';

        /**
         * Encodes the specified RewardRate message. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @static
         * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardRate.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.reward_type != null && Object.hasOwnProperty.call(message, 'reward_type'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.reward_type);
          if (message.rate != null && Object.hasOwnProperty.call(message, 'rate'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.rate);
          return writer;
        };

        /**
         * Encodes the specified RewardRate message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @static
         * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardRate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RewardRate message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardRate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.RewardRate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.reward_type = reader.int32();
                break;
              case 2:
                message.rate = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RewardRate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardRate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RewardRate message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RewardRate.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.reward_type != null && message.hasOwnProperty('reward_type'))
            switch (message.reward_type) {
              default:
                return 'reward_type: enum value expected';
              case 0:
                break;
            }
          if (message.rate != null && message.hasOwnProperty('rate')) if (!$util.isString(message.rate)) return 'rate: string expected';
          return null;
        };

        /**
         * Creates a RewardRate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
         */
        RewardRate.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.RewardRate) return object;
          var message = new $root.ununifi.ecosystemincentive.RewardRate();
          switch (object.reward_type) {
            case 'NFTMARKET_FRONTEND':
            case 0:
              message.reward_type = 0;
              break;
          }
          if (object.rate != null) message.rate = String(object.rate);
          return message;
        };

        /**
         * Creates a plain object from a RewardRate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @static
         * @param {ununifi.ecosystemincentive.RewardRate} message RewardRate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RewardRate.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.reward_type = options.enums === String ? 'NFTMARKET_FRONTEND' : 0;
            object.rate = '';
          }
          if (message.reward_type != null && message.hasOwnProperty('reward_type'))
            object.reward_type =
              options.enums === String ? $root.ununifi.ecosystemincentive.RewardType[message.reward_type] : message.reward_type;
          if (message.rate != null && message.hasOwnProperty('rate')) object.rate = message.rate;
          return object;
        };

        /**
         * Converts this RewardRate to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.RewardRate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RewardRate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RewardRate;
      })();

      /**
       * RewardType enum.
       * @name ununifi.ecosystemincentive.RewardType
       * @enum {number}
       * @property {number} NFTMARKET_FRONTEND=0 NFTMARKET_FRONTEND value
       */
      ecosystemincentive.RewardType = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'NFTMARKET_FRONTEND')] = 0;
        return values;
      })();

      ecosystemincentive.IncentiveUnit = (function () {
        /**
         * Properties of an IncentiveUnit.
         * @memberof ununifi.ecosystemincentive
         * @interface IIncentiveUnit
         * @property {string|null} [id] IncentiveUnit id
         * @property {Array.<ununifi.ecosystemincentive.ISubjectInfo>|null} [subject_info_lists] IncentiveUnit subject_info_lists
         */

        /**
         * Constructs a new IncentiveUnit.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an IncentiveUnit.
         * @implements IIncentiveUnit
         * @constructor
         * @param {ununifi.ecosystemincentive.IIncentiveUnit=} [properties] Properties to set
         */
        function IncentiveUnit(properties) {
          this.subject_info_lists = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncentiveUnit id.
         * @member {string} id
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @instance
         */
        IncentiveUnit.prototype.id = '';

        /**
         * IncentiveUnit subject_info_lists.
         * @member {Array.<ununifi.ecosystemincentive.ISubjectInfo>} subject_info_lists
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @instance
         */
        IncentiveUnit.prototype.subject_info_lists = $util.emptyArray;

        /**
         * Encodes the specified IncentiveUnit message. Does not implicitly {@link ununifi.ecosystemincentive.IncentiveUnit.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @static
         * @param {ununifi.ecosystemincentive.IIncentiveUnit} message IncentiveUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncentiveUnit.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
          if (message.subject_info_lists != null && message.subject_info_lists.length)
            for (var i = 0; i < message.subject_info_lists.length; ++i)
              $root.ununifi.ecosystemincentive.SubjectInfo.encode(
                message.subject_info_lists[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified IncentiveUnit message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.IncentiveUnit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @static
         * @param {ununifi.ecosystemincentive.IIncentiveUnit} message IncentiveUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncentiveUnit.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IncentiveUnit message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.IncentiveUnit} IncentiveUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncentiveUnit.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.IncentiveUnit();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.id = reader.string();
                break;
              case 2:
                if (!(message.subject_info_lists && message.subject_info_lists.length)) message.subject_info_lists = [];
                message.subject_info_lists.push($root.ununifi.ecosystemincentive.SubjectInfo.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an IncentiveUnit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.IncentiveUnit} IncentiveUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncentiveUnit.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IncentiveUnit message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IncentiveUnit.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
          if (message.subject_info_lists != null && message.hasOwnProperty('subject_info_lists')) {
            if (!Array.isArray(message.subject_info_lists)) return 'subject_info_lists: array expected';
            for (var i = 0; i < message.subject_info_lists.length; ++i) {
              var error = $root.ununifi.ecosystemincentive.SubjectInfo.verify(message.subject_info_lists[i]);
              if (error) return 'subject_info_lists.' + error;
            }
          }
          return null;
        };

        /**
         * Creates an IncentiveUnit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.IncentiveUnit} IncentiveUnit
         */
        IncentiveUnit.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.IncentiveUnit) return object;
          var message = new $root.ununifi.ecosystemincentive.IncentiveUnit();
          if (object.id != null) message.id = String(object.id);
          if (object.subject_info_lists) {
            if (!Array.isArray(object.subject_info_lists))
              throw TypeError('.ununifi.ecosystemincentive.IncentiveUnit.subject_info_lists: array expected');
            message.subject_info_lists = [];
            for (var i = 0; i < object.subject_info_lists.length; ++i) {
              if (typeof object.subject_info_lists[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.IncentiveUnit.subject_info_lists: object expected');
              message.subject_info_lists[i] = $root.ununifi.ecosystemincentive.SubjectInfo.fromObject(object.subject_info_lists[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an IncentiveUnit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @static
         * @param {ununifi.ecosystemincentive.IncentiveUnit} message IncentiveUnit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IncentiveUnit.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.subject_info_lists = [];
          if (options.defaults) object.id = '';
          if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
          if (message.subject_info_lists && message.subject_info_lists.length) {
            object.subject_info_lists = [];
            for (var j = 0; j < message.subject_info_lists.length; ++j)
              object.subject_info_lists[j] = $root.ununifi.ecosystemincentive.SubjectInfo.toObject(message.subject_info_lists[j], options);
          }
          return object;
        };

        /**
         * Converts this IncentiveUnit to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.IncentiveUnit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IncentiveUnit.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IncentiveUnit;
      })();

      ecosystemincentive.SubjectInfo = (function () {
        /**
         * Properties of a SubjectInfo.
         * @memberof ununifi.ecosystemincentive
         * @interface ISubjectInfo
         * @property {string|null} [subject_addr] SubjectInfo subject_addr
         * @property {string|null} [weight] SubjectInfo weight
         */

        /**
         * Constructs a new SubjectInfo.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a SubjectInfo.
         * @implements ISubjectInfo
         * @constructor
         * @param {ununifi.ecosystemincentive.ISubjectInfo=} [properties] Properties to set
         */
        function SubjectInfo(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubjectInfo subject_addr.
         * @member {string} subject_addr
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @instance
         */
        SubjectInfo.prototype.subject_addr = '';

        /**
         * SubjectInfo weight.
         * @member {string} weight
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @instance
         */
        SubjectInfo.prototype.weight = '';

        /**
         * Encodes the specified SubjectInfo message. Does not implicitly {@link ununifi.ecosystemincentive.SubjectInfo.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @static
         * @param {ununifi.ecosystemincentive.ISubjectInfo} message SubjectInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubjectInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
          if (message.weight != null && Object.hasOwnProperty.call(message, 'weight'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.weight);
          return writer;
        };

        /**
         * Encodes the specified SubjectInfo message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.SubjectInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @static
         * @param {ununifi.ecosystemincentive.ISubjectInfo} message SubjectInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubjectInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubjectInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.SubjectInfo} SubjectInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubjectInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.SubjectInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.subject_addr = reader.string();
                break;
              case 2:
                message.weight = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SubjectInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.SubjectInfo} SubjectInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubjectInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubjectInfo message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubjectInfo.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
            if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
          if (message.weight != null && message.hasOwnProperty('weight'))
            if (!$util.isString(message.weight)) return 'weight: string expected';
          return null;
        };

        /**
         * Creates a SubjectInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.SubjectInfo} SubjectInfo
         */
        SubjectInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.SubjectInfo) return object;
          var message = new $root.ununifi.ecosystemincentive.SubjectInfo();
          if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
          if (object.weight != null) message.weight = String(object.weight);
          return message;
        };

        /**
         * Creates a plain object from a SubjectInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @static
         * @param {ununifi.ecosystemincentive.SubjectInfo} message SubjectInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubjectInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.subject_addr = '';
            object.weight = '';
          }
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
          if (message.weight != null && message.hasOwnProperty('weight')) object.weight = message.weight;
          return object;
        };

        /**
         * Converts this SubjectInfo to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.SubjectInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubjectInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SubjectInfo;
      })();

      ecosystemincentive.RewardStore = (function () {
        /**
         * Properties of a RewardStore.
         * @memberof ununifi.ecosystemincentive
         * @interface IRewardStore
         * @property {string|null} [subject_addr] RewardStore subject_addr
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] RewardStore rewards
         */

        /**
         * Constructs a new RewardStore.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a RewardStore.
         * @implements IRewardStore
         * @constructor
         * @param {ununifi.ecosystemincentive.IRewardStore=} [properties] Properties to set
         */
        function RewardStore(properties) {
          this.rewards = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RewardStore subject_addr.
         * @member {string} subject_addr
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @instance
         */
        RewardStore.prototype.subject_addr = '';

        /**
         * RewardStore rewards.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @instance
         */
        RewardStore.prototype.rewards = $util.emptyArray;

        /**
         * Encodes the specified RewardStore message. Does not implicitly {@link ununifi.ecosystemincentive.RewardStore.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @static
         * @param {ununifi.ecosystemincentive.IRewardStore} message RewardStore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardStore.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
          if (message.rewards != null && message.rewards.length)
            for (var i = 0; i < message.rewards.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified RewardStore message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardStore.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @static
         * @param {ununifi.ecosystemincentive.IRewardStore} message RewardStore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardStore.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RewardStore message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.RewardStore} RewardStore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardStore.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.RewardStore();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.subject_addr = reader.string();
                break;
              case 2:
                if (!(message.rewards && message.rewards.length)) message.rewards = [];
                message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RewardStore message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.RewardStore} RewardStore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardStore.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RewardStore message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RewardStore.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
            if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
          if (message.rewards != null && message.hasOwnProperty('rewards')) {
            if (!Array.isArray(message.rewards)) return 'rewards: array expected';
            for (var i = 0; i < message.rewards.length; ++i) {
              var error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
              if (error) return 'rewards.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a RewardStore message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.RewardStore} RewardStore
         */
        RewardStore.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.RewardStore) return object;
          var message = new $root.ununifi.ecosystemincentive.RewardStore();
          if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
          if (object.rewards) {
            if (!Array.isArray(object.rewards)) throw TypeError('.ununifi.ecosystemincentive.RewardStore.rewards: array expected');
            message.rewards = [];
            for (var i = 0; i < object.rewards.length; ++i) {
              if (typeof object.rewards[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.RewardStore.rewards: object expected');
              message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a RewardStore message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @static
         * @param {ununifi.ecosystemincentive.RewardStore} message RewardStore
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RewardStore.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.rewards = [];
          if (options.defaults) object.subject_addr = '';
          if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
          if (message.rewards && message.rewards.length) {
            object.rewards = [];
            for (var j = 0; j < message.rewards.length; ++j)
              object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
          }
          return object;
        };

        /**
         * Converts this RewardStore to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.RewardStore
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RewardStore.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RewardStore;
      })();

      ecosystemincentive.MemoInputs = (function () {
        /**
         * Properties of a MemoInputs.
         * @memberof ununifi.ecosystemincentive
         * @interface IMemoInputs
         * @property {string|null} [version] MemoInputs version
         * @property {string|null} [incentive_unit_id] MemoInputs incentive_unit_id
         */

        /**
         * Constructs a new MemoInputs.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a MemoInputs.
         * @implements IMemoInputs
         * @constructor
         * @param {ununifi.ecosystemincentive.IMemoInputs=} [properties] Properties to set
         */
        function MemoInputs(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemoInputs version.
         * @member {string} version
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @instance
         */
        MemoInputs.prototype.version = '';

        /**
         * MemoInputs incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @instance
         */
        MemoInputs.prototype.incentive_unit_id = '';

        /**
         * Encodes the specified MemoInputs message. Does not implicitly {@link ununifi.ecosystemincentive.MemoInputs.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @static
         * @param {ununifi.ecosystemincentive.IMemoInputs} message MemoInputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemoInputs.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.version != null && Object.hasOwnProperty.call(message, 'version'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.version);
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.incentive_unit_id);
          return writer;
        };

        /**
         * Encodes the specified MemoInputs message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MemoInputs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @static
         * @param {ununifi.ecosystemincentive.IMemoInputs} message MemoInputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemoInputs.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemoInputs message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.MemoInputs} MemoInputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemoInputs.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.MemoInputs();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.version = reader.string();
                break;
              case 2:
                message.incentive_unit_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MemoInputs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.MemoInputs} MemoInputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemoInputs.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MemoInputs message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MemoInputs.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.version != null && message.hasOwnProperty('version'))
            if (!$util.isString(message.version)) return 'version: string expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          return null;
        };

        /**
         * Creates a MemoInputs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.MemoInputs} MemoInputs
         */
        MemoInputs.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.MemoInputs) return object;
          var message = new $root.ununifi.ecosystemincentive.MemoInputs();
          if (object.version != null) message.version = String(object.version);
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          return message;
        };

        /**
         * Creates a plain object from a MemoInputs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @static
         * @param {ununifi.ecosystemincentive.MemoInputs} message MemoInputs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemoInputs.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.version = '';
            object.incentive_unit_id = '';
          }
          if (message.version != null && message.hasOwnProperty('version')) object.version = message.version;
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          return object;
        };

        /**
         * Converts this MemoInputs to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.MemoInputs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemoInputs.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MemoInputs;
      })();

      ecosystemincentive.Msg = (function () {
        /**
         * Constructs a new Msg service.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a Msg
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Msg(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Msg#register}.
         * @memberof ununifi.ecosystemincentive.Msg
         * @typedef RegisterCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.MsgRegisterResponse} [response] MsgRegisterResponse
         */

        /**
         * Calls Register.
         * @function register
         * @memberof ununifi.ecosystemincentive.Msg
         * @instance
         * @param {ununifi.ecosystemincentive.IMsgRegister} request MsgRegister message or plain object
         * @param {ununifi.ecosystemincentive.Msg.RegisterCallback} callback Node-style callback called with the error, if any, and MsgRegisterResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.register = function register(request, callback) {
            return this.rpcCall(
              register,
              $root.ununifi.ecosystemincentive.MsgRegister,
              $root.ununifi.ecosystemincentive.MsgRegisterResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Register' },
        );

        /**
         * Calls Register.
         * @function register
         * @memberof ununifi.ecosystemincentive.Msg
         * @instance
         * @param {ununifi.ecosystemincentive.IMsgRegister} request MsgRegister message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.MsgRegisterResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawAllRewards}.
         * @memberof ununifi.ecosystemincentive.Msg
         * @typedef WithdrawAllRewardsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} [response] MsgWithdrawAllRewardsResponse
         */

        /**
         * Calls WithdrawAllRewards.
         * @function withdrawAllRewards
         * @memberof ununifi.ecosystemincentive.Msg
         * @instance
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
         * @param {ununifi.ecosystemincentive.Msg.WithdrawAllRewardsCallback} callback Node-style callback called with the error, if any, and MsgWithdrawAllRewardsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.withdrawAllRewards = function withdrawAllRewards(request, callback) {
            return this.rpcCall(
              withdrawAllRewards,
              $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards,
              $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'WithdrawAllRewards' },
        );

        /**
         * Calls WithdrawAllRewards.
         * @function withdrawAllRewards
         * @memberof ununifi.ecosystemincentive.Msg
         * @instance
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawReward}.
         * @memberof ununifi.ecosystemincentive.Msg
         * @typedef WithdrawRewardCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} [response] MsgWithdrawRewardResponse
         */

        /**
         * Calls WithdrawReward.
         * @function withdrawReward
         * @memberof ununifi.ecosystemincentive.Msg
         * @instance
         * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
         * @param {ununifi.ecosystemincentive.Msg.WithdrawRewardCallback} callback Node-style callback called with the error, if any, and MsgWithdrawRewardResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.withdrawReward = function withdrawReward(request, callback) {
            return this.rpcCall(
              withdrawReward,
              $root.ununifi.ecosystemincentive.MsgWithdrawReward,
              $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'WithdrawReward' },
        );

        /**
         * Calls WithdrawReward.
         * @function withdrawReward
         * @memberof ununifi.ecosystemincentive.Msg
         * @instance
         * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
         * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawRewardResponse>} Promise
         * @variation 2
         */

        return Msg;
      })();

      ecosystemincentive.MsgRegister = (function () {
        /**
         * Properties of a MsgRegister.
         * @memberof ununifi.ecosystemincentive
         * @interface IMsgRegister
         * @property {string|null} [sender] MsgRegister sender
         * @property {string|null} [incentive_unit_id] MsgRegister incentive_unit_id
         * @property {Array.<string>|null} [subject_addrs] MsgRegister subject_addrs
         * @property {Array.<string>|null} [weights] MsgRegister weights
         */

        /**
         * Constructs a new MsgRegister.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a MsgRegister.
         * @implements IMsgRegister
         * @constructor
         * @param {ununifi.ecosystemincentive.IMsgRegister=} [properties] Properties to set
         */
        function MsgRegister(properties) {
          this.subject_addrs = [];
          this.weights = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgRegister sender.
         * @member {string} sender
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @instance
         */
        MsgRegister.prototype.sender = '';

        /**
         * MsgRegister incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @instance
         */
        MsgRegister.prototype.incentive_unit_id = '';

        /**
         * MsgRegister subject_addrs.
         * @member {Array.<string>} subject_addrs
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @instance
         */
        MsgRegister.prototype.subject_addrs = $util.emptyArray;

        /**
         * MsgRegister weights.
         * @member {Array.<string>} weights
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @instance
         */
        MsgRegister.prototype.weights = $util.emptyArray;

        /**
         * Encodes the specified MsgRegister message. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegister.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @static
         * @param {ununifi.ecosystemincentive.IMsgRegister} message MsgRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRegister.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.incentive_unit_id);
          if (message.subject_addrs != null && message.subject_addrs.length)
            for (var i = 0; i < message.subject_addrs.length; ++i)
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.subject_addrs[i]);
          if (message.weights != null && message.weights.length)
            for (var i = 0; i < message.weights.length; ++i) writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.weights[i]);
          return writer;
        };

        /**
         * Encodes the specified MsgRegister message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegister.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @static
         * @param {ununifi.ecosystemincentive.IMsgRegister} message MsgRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRegister.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgRegister message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.MsgRegister} MsgRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRegister.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.MsgRegister();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.incentive_unit_id = reader.string();
                break;
              case 3:
                if (!(message.subject_addrs && message.subject_addrs.length)) message.subject_addrs = [];
                message.subject_addrs.push(reader.string());
                break;
              case 4:
                if (!(message.weights && message.weights.length)) message.weights = [];
                message.weights.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgRegister message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.MsgRegister} MsgRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRegister.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgRegister message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgRegister.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          if (message.subject_addrs != null && message.hasOwnProperty('subject_addrs')) {
            if (!Array.isArray(message.subject_addrs)) return 'subject_addrs: array expected';
            for (var i = 0; i < message.subject_addrs.length; ++i)
              if (!$util.isString(message.subject_addrs[i])) return 'subject_addrs: string[] expected';
          }
          if (message.weights != null && message.hasOwnProperty('weights')) {
            if (!Array.isArray(message.weights)) return 'weights: array expected';
            for (var i = 0; i < message.weights.length; ++i) if (!$util.isString(message.weights[i])) return 'weights: string[] expected';
          }
          return null;
        };

        /**
         * Creates a MsgRegister message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.MsgRegister} MsgRegister
         */
        MsgRegister.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.MsgRegister) return object;
          var message = new $root.ununifi.ecosystemincentive.MsgRegister();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          if (object.subject_addrs) {
            if (!Array.isArray(object.subject_addrs))
              throw TypeError('.ununifi.ecosystemincentive.MsgRegister.subject_addrs: array expected');
            message.subject_addrs = [];
            for (var i = 0; i < object.subject_addrs.length; ++i) message.subject_addrs[i] = String(object.subject_addrs[i]);
          }
          if (object.weights) {
            if (!Array.isArray(object.weights)) throw TypeError('.ununifi.ecosystemincentive.MsgRegister.weights: array expected');
            message.weights = [];
            for (var i = 0; i < object.weights.length; ++i) message.weights[i] = String(object.weights[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgRegister message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @static
         * @param {ununifi.ecosystemincentive.MsgRegister} message MsgRegister
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgRegister.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.subject_addrs = [];
            object.weights = [];
          }
          if (options.defaults) {
            object.sender = '';
            object.incentive_unit_id = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          if (message.subject_addrs && message.subject_addrs.length) {
            object.subject_addrs = [];
            for (var j = 0; j < message.subject_addrs.length; ++j) object.subject_addrs[j] = message.subject_addrs[j];
          }
          if (message.weights && message.weights.length) {
            object.weights = [];
            for (var j = 0; j < message.weights.length; ++j) object.weights[j] = message.weights[j];
          }
          return object;
        };

        /**
         * Converts this MsgRegister to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.MsgRegister
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgRegister.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgRegister;
      })();

      ecosystemincentive.MsgRegisterResponse = (function () {
        /**
         * Properties of a MsgRegisterResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IMsgRegisterResponse
         */

        /**
         * Constructs a new MsgRegisterResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a MsgRegisterResponse.
         * @implements IMsgRegisterResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IMsgRegisterResponse=} [properties] Properties to set
         */
        function MsgRegisterResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgRegisterResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegisterResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @static
         * @param {ununifi.ecosystemincentive.IMsgRegisterResponse} message MsgRegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRegisterResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgRegisterResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegisterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @static
         * @param {ununifi.ecosystemincentive.IMsgRegisterResponse} message MsgRegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgRegisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.MsgRegisterResponse} MsgRegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRegisterResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.MsgRegisterResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgRegisterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.MsgRegisterResponse} MsgRegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRegisterResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgRegisterResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgRegisterResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgRegisterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.MsgRegisterResponse} MsgRegisterResponse
         */
        MsgRegisterResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.MsgRegisterResponse) return object;
          return new $root.ununifi.ecosystemincentive.MsgRegisterResponse();
        };

        /**
         * Creates a plain object from a MsgRegisterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @static
         * @param {ununifi.ecosystemincentive.MsgRegisterResponse} message MsgRegisterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgRegisterResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgRegisterResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgRegisterResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgRegisterResponse;
      })();

      ecosystemincentive.MsgWithdrawAllRewards = (function () {
        /**
         * Properties of a MsgWithdrawAllRewards.
         * @memberof ununifi.ecosystemincentive
         * @interface IMsgWithdrawAllRewards
         * @property {string|null} [sender] MsgWithdrawAllRewards sender
         */

        /**
         * Constructs a new MsgWithdrawAllRewards.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a MsgWithdrawAllRewards.
         * @implements IMsgWithdrawAllRewards
         * @constructor
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards=} [properties] Properties to set
         */
        function MsgWithdrawAllRewards(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgWithdrawAllRewards sender.
         * @member {string} sender
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @instance
         */
        MsgWithdrawAllRewards.prototype.sender = '';

        /**
         * Encodes the specified MsgWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawAllRewards.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          return writer;
        };

        /**
         * Encodes the specified MsgWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawAllRewards.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgWithdrawAllRewards message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgWithdrawAllRewards.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          return null;
        };

        /**
         * Creates a MsgWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
         */
        MsgWithdrawAllRewards.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards) return object;
          var message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
          if (object.sender != null) message.sender = String(object.sender);
          return message;
        };

        /**
         * Creates a plain object from a MsgWithdrawAllRewards message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @static
         * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewards} message MsgWithdrawAllRewards
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgWithdrawAllRewards.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.sender = '';
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          return object;
        };

        /**
         * Converts this MsgWithdrawAllRewards to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgWithdrawAllRewards.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgWithdrawAllRewards;
      })();

      ecosystemincentive.MsgWithdrawAllRewardsResponse = (function () {
        /**
         * Properties of a MsgWithdrawAllRewardsResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IMsgWithdrawAllRewardsResponse
         */

        /**
         * Constructs a new MsgWithdrawAllRewardsResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a MsgWithdrawAllRewardsResponse.
         * @implements IMsgWithdrawAllRewardsResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse=} [properties] Properties to set
         */
        function MsgWithdrawAllRewardsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgWithdrawAllRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawAllRewardsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgWithdrawAllRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawAllRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawAllRewardsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawAllRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgWithdrawAllRewardsResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgWithdrawAllRewardsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgWithdrawAllRewardsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
         */
        MsgWithdrawAllRewardsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse) return object;
          return new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
        };

        /**
         * Creates a plain object from a MsgWithdrawAllRewardsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @static
         * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgWithdrawAllRewardsResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgWithdrawAllRewardsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgWithdrawAllRewardsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgWithdrawAllRewardsResponse;
      })();

      ecosystemincentive.MsgWithdrawReward = (function () {
        /**
         * Properties of a MsgWithdrawReward.
         * @memberof ununifi.ecosystemincentive
         * @interface IMsgWithdrawReward
         * @property {string|null} [sender] MsgWithdrawReward sender
         * @property {string|null} [denom] MsgWithdrawReward denom
         */

        /**
         * Constructs a new MsgWithdrawReward.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a MsgWithdrawReward.
         * @implements IMsgWithdrawReward
         * @constructor
         * @param {ununifi.ecosystemincentive.IMsgWithdrawReward=} [properties] Properties to set
         */
        function MsgWithdrawReward(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgWithdrawReward sender.
         * @member {string} sender
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @instance
         */
        MsgWithdrawReward.prototype.sender = '';

        /**
         * MsgWithdrawReward denom.
         * @member {string} denom
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @instance
         */
        MsgWithdrawReward.prototype.denom = '';

        /**
         * Encodes the specified MsgWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawReward.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
          return writer;
        };

        /**
         * Encodes the specified MsgWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgWithdrawReward message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawReward.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.denom = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgWithdrawReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgWithdrawReward message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgWithdrawReward.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          return null;
        };

        /**
         * Creates a MsgWithdrawReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
         */
        MsgWithdrawReward.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawReward) return object;
          var message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.denom != null) message.denom = String(object.denom);
          return message;
        };

        /**
         * Creates a plain object from a MsgWithdrawReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @static
         * @param {ununifi.ecosystemincentive.MsgWithdrawReward} message MsgWithdrawReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgWithdrawReward.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.denom = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          return object;
        };

        /**
         * Converts this MsgWithdrawReward to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgWithdrawReward.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgWithdrawReward;
      })();

      ecosystemincentive.MsgWithdrawRewardResponse = (function () {
        /**
         * Properties of a MsgWithdrawRewardResponse.
         * @memberof ununifi.ecosystemincentive
         * @interface IMsgWithdrawRewardResponse
         */

        /**
         * Constructs a new MsgWithdrawRewardResponse.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a MsgWithdrawRewardResponse.
         * @implements IMsgWithdrawRewardResponse
         * @constructor
         * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse=} [properties] Properties to set
         */
        function MsgWithdrawRewardResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgWithdrawRewardResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawRewardResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgWithdrawRewardResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @static
         * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgWithdrawRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawRewardResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgWithdrawRewardResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgWithdrawRewardResponse message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgWithdrawRewardResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgWithdrawRewardResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
         */
        MsgWithdrawRewardResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse) return object;
          return new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
        };

        /**
         * Creates a plain object from a MsgWithdrawRewardResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @static
         * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} message MsgWithdrawRewardResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgWithdrawRewardResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgWithdrawRewardResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgWithdrawRewardResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgWithdrawRewardResponse;
      })();

      ecosystemincentive.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.ecosystemincentive
         * @interface IGenesisState
         * @property {ununifi.ecosystemincentive.IParams|null} [params] GenesisState params
         * @property {Array.<ununifi.ecosystemincentive.IIncentiveUnit>|null} [incentive_units] GenesisState incentive_units
         * @property {Array.<ununifi.ecosystemincentive.IRewardStore>|null} [reward_stores] GenesisState reward_stores
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.ecosystemincentive.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          this.incentive_units = [];
          this.reward_stores = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState params.
         * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * GenesisState incentive_units.
         * @member {Array.<ununifi.ecosystemincentive.IIncentiveUnit>} incentive_units
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @instance
         */
        GenesisState.prototype.incentive_units = $util.emptyArray;

        /**
         * GenesisState reward_stores.
         * @member {Array.<ununifi.ecosystemincentive.IRewardStore>} reward_stores
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @instance
         */
        GenesisState.prototype.reward_stores = $util.emptyArray;

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @static
         * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.incentive_units != null && message.incentive_units.length)
            for (var i = 0; i < message.incentive_units.length; ++i)
              $root.ununifi.ecosystemincentive.IncentiveUnit.encode(
                message.incentive_units[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.reward_stores != null && message.reward_stores.length)
            for (var i = 0; i < message.reward_stores.length; ++i)
              $root.ununifi.ecosystemincentive.RewardStore.encode(
                message.reward_stores[i],
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @static
         * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message.incentive_units && message.incentive_units.length)) message.incentive_units = [];
                message.incentive_units.push($root.ununifi.ecosystemincentive.IncentiveUnit.decode(reader, reader.uint32()));
                break;
              case 3:
                if (!(message.reward_stores && message.reward_stores.length)) message.reward_stores = [];
                message.reward_stores.push($root.ununifi.ecosystemincentive.RewardStore.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          if (message.incentive_units != null && message.hasOwnProperty('incentive_units')) {
            if (!Array.isArray(message.incentive_units)) return 'incentive_units: array expected';
            for (var i = 0; i < message.incentive_units.length; ++i) {
              var error = $root.ununifi.ecosystemincentive.IncentiveUnit.verify(message.incentive_units[i]);
              if (error) return 'incentive_units.' + error;
            }
          }
          if (message.reward_stores != null && message.hasOwnProperty('reward_stores')) {
            if (!Array.isArray(message.reward_stores)) return 'reward_stores: array expected';
            for (var i = 0; i < message.reward_stores.length; ++i) {
              var error = $root.ununifi.ecosystemincentive.RewardStore.verify(message.reward_stores[i]);
              if (error) return 'reward_stores.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.GenesisState) return object;
          var message = new $root.ununifi.ecosystemincentive.GenesisState();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.ecosystemincentive.GenesisState.params: object expected');
            message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
          }
          if (object.incentive_units) {
            if (!Array.isArray(object.incentive_units))
              throw TypeError('.ununifi.ecosystemincentive.GenesisState.incentive_units: array expected');
            message.incentive_units = [];
            for (var i = 0; i < object.incentive_units.length; ++i) {
              if (typeof object.incentive_units[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.GenesisState.incentive_units: object expected');
              message.incentive_units[i] = $root.ununifi.ecosystemincentive.IncentiveUnit.fromObject(object.incentive_units[i]);
            }
          }
          if (object.reward_stores) {
            if (!Array.isArray(object.reward_stores))
              throw TypeError('.ununifi.ecosystemincentive.GenesisState.reward_stores: array expected');
            message.reward_stores = [];
            for (var i = 0; i < object.reward_stores.length; ++i) {
              if (typeof object.reward_stores[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.GenesisState.reward_stores: object expected');
              message.reward_stores[i] = $root.ununifi.ecosystemincentive.RewardStore.fromObject(object.reward_stores[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @static
         * @param {ununifi.ecosystemincentive.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.incentive_units = [];
            object.reward_stores = [];
          }
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
          if (message.incentive_units && message.incentive_units.length) {
            object.incentive_units = [];
            for (var j = 0; j < message.incentive_units.length; ++j)
              object.incentive_units[j] = $root.ununifi.ecosystemincentive.IncentiveUnit.toObject(message.incentive_units[j], options);
          }
          if (message.reward_stores && message.reward_stores.length) {
            object.reward_stores = [];
            for (var j = 0; j < message.reward_stores.length; ++j)
              object.reward_stores[j] = $root.ununifi.ecosystemincentive.RewardStore.toObject(message.reward_stores[j], options);
          }
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      ecosystemincentive.EventRegister = (function () {
        /**
         * Properties of an EventRegister.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventRegister
         * @property {string|null} [incentive_unit_id] EventRegister incentive_unit_id
         * @property {Array.<ununifi.ecosystemincentive.ISubjectInfo>|null} [subject_info_lists] EventRegister subject_info_lists
         */

        /**
         * Constructs a new EventRegister.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventRegister.
         * @implements IEventRegister
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventRegister=} [properties] Properties to set
         */
        function EventRegister(properties) {
          this.subject_info_lists = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventRegister incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @instance
         */
        EventRegister.prototype.incentive_unit_id = '';

        /**
         * EventRegister subject_info_lists.
         * @member {Array.<ununifi.ecosystemincentive.ISubjectInfo>} subject_info_lists
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @instance
         */
        EventRegister.prototype.subject_info_lists = $util.emptyArray;

        /**
         * Encodes the specified EventRegister message. Does not implicitly {@link ununifi.ecosystemincentive.EventRegister.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @static
         * @param {ununifi.ecosystemincentive.IEventRegister} message EventRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRegister.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
          if (message.subject_info_lists != null && message.subject_info_lists.length)
            for (var i = 0; i < message.subject_info_lists.length; ++i)
              $root.ununifi.ecosystemincentive.SubjectInfo.encode(
                message.subject_info_lists[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EventRegister message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventRegister.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @static
         * @param {ununifi.ecosystemincentive.IEventRegister} message EventRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRegister.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventRegister message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventRegister} EventRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRegister.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventRegister();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit_id = reader.string();
                break;
              case 2:
                if (!(message.subject_info_lists && message.subject_info_lists.length)) message.subject_info_lists = [];
                message.subject_info_lists.push($root.ununifi.ecosystemincentive.SubjectInfo.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventRegister message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventRegister} EventRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRegister.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventRegister message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventRegister.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          if (message.subject_info_lists != null && message.hasOwnProperty('subject_info_lists')) {
            if (!Array.isArray(message.subject_info_lists)) return 'subject_info_lists: array expected';
            for (var i = 0; i < message.subject_info_lists.length; ++i) {
              var error = $root.ununifi.ecosystemincentive.SubjectInfo.verify(message.subject_info_lists[i]);
              if (error) return 'subject_info_lists.' + error;
            }
          }
          return null;
        };

        /**
         * Creates an EventRegister message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventRegister} EventRegister
         */
        EventRegister.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventRegister) return object;
          var message = new $root.ununifi.ecosystemincentive.EventRegister();
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          if (object.subject_info_lists) {
            if (!Array.isArray(object.subject_info_lists))
              throw TypeError('.ununifi.ecosystemincentive.EventRegister.subject_info_lists: array expected');
            message.subject_info_lists = [];
            for (var i = 0; i < object.subject_info_lists.length; ++i) {
              if (typeof object.subject_info_lists[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.EventRegister.subject_info_lists: object expected');
              message.subject_info_lists[i] = $root.ununifi.ecosystemincentive.SubjectInfo.fromObject(object.subject_info_lists[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an EventRegister message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @static
         * @param {ununifi.ecosystemincentive.EventRegister} message EventRegister
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventRegister.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.subject_info_lists = [];
          if (options.defaults) object.incentive_unit_id = '';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          if (message.subject_info_lists && message.subject_info_lists.length) {
            object.subject_info_lists = [];
            for (var j = 0; j < message.subject_info_lists.length; ++j)
              object.subject_info_lists[j] = $root.ununifi.ecosystemincentive.SubjectInfo.toObject(message.subject_info_lists[j], options);
          }
          return object;
        };

        /**
         * Converts this EventRegister to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventRegister
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventRegister.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventRegister;
      })();

      ecosystemincentive.EventWithdrawAllRewards = (function () {
        /**
         * Properties of an EventWithdrawAllRewards.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventWithdrawAllRewards
         * @property {string|null} [sender] EventWithdrawAllRewards sender
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [all_withdrawn_rewards] EventWithdrawAllRewards all_withdrawn_rewards
         */

        /**
         * Constructs a new EventWithdrawAllRewards.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventWithdrawAllRewards.
         * @implements IEventWithdrawAllRewards
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards=} [properties] Properties to set
         */
        function EventWithdrawAllRewards(properties) {
          this.all_withdrawn_rewards = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventWithdrawAllRewards sender.
         * @member {string} sender
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @instance
         */
        EventWithdrawAllRewards.prototype.sender = '';

        /**
         * EventWithdrawAllRewards all_withdrawn_rewards.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} all_withdrawn_rewards
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @instance
         */
        EventWithdrawAllRewards.prototype.all_withdrawn_rewards = $util.emptyArray;

        /**
         * Encodes the specified EventWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @static
         * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventWithdrawAllRewards.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.all_withdrawn_rewards != null && message.all_withdrawn_rewards.length)
            for (var i = 0; i < message.all_withdrawn_rewards.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(
                message.all_withdrawn_rewards[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EventWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @static
         * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventWithdrawAllRewards message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventWithdrawAllRewards.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                if (!(message.all_withdrawn_rewards && message.all_withdrawn_rewards.length)) message.all_withdrawn_rewards = [];
                message.all_withdrawn_rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventWithdrawAllRewards message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventWithdrawAllRewards message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventWithdrawAllRewards.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.all_withdrawn_rewards != null && message.hasOwnProperty('all_withdrawn_rewards')) {
            if (!Array.isArray(message.all_withdrawn_rewards)) return 'all_withdrawn_rewards: array expected';
            for (var i = 0; i < message.all_withdrawn_rewards.length; ++i) {
              var error = $root.cosmos.base.v1beta1.Coin.verify(message.all_withdrawn_rewards[i]);
              if (error) return 'all_withdrawn_rewards.' + error;
            }
          }
          return null;
        };

        /**
         * Creates an EventWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
         */
        EventWithdrawAllRewards.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawAllRewards) return object;
          var message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.all_withdrawn_rewards) {
            if (!Array.isArray(object.all_withdrawn_rewards))
              throw TypeError('.ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: array expected');
            message.all_withdrawn_rewards = [];
            for (var i = 0; i < object.all_withdrawn_rewards.length; ++i) {
              if (typeof object.all_withdrawn_rewards[i] !== 'object')
                throw TypeError('.ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: object expected');
              message.all_withdrawn_rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.all_withdrawn_rewards[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an EventWithdrawAllRewards message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @static
         * @param {ununifi.ecosystemincentive.EventWithdrawAllRewards} message EventWithdrawAllRewards
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventWithdrawAllRewards.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.all_withdrawn_rewards = [];
          if (options.defaults) object.sender = '';
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.all_withdrawn_rewards && message.all_withdrawn_rewards.length) {
            object.all_withdrawn_rewards = [];
            for (var j = 0; j < message.all_withdrawn_rewards.length; ++j)
              object.all_withdrawn_rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.all_withdrawn_rewards[j], options);
          }
          return object;
        };

        /**
         * Converts this EventWithdrawAllRewards to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventWithdrawAllRewards.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventWithdrawAllRewards;
      })();

      ecosystemincentive.EventWithdrawReward = (function () {
        /**
         * Properties of an EventWithdrawReward.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventWithdrawReward
         * @property {string|null} [sender] EventWithdrawReward sender
         * @property {cosmos.base.v1beta1.ICoin|null} [withdrawn_reward] EventWithdrawReward withdrawn_reward
         */

        /**
         * Constructs a new EventWithdrawReward.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventWithdrawReward.
         * @implements IEventWithdrawReward
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventWithdrawReward=} [properties] Properties to set
         */
        function EventWithdrawReward(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventWithdrawReward sender.
         * @member {string} sender
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @instance
         */
        EventWithdrawReward.prototype.sender = '';

        /**
         * EventWithdrawReward withdrawn_reward.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} withdrawn_reward
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @instance
         */
        EventWithdrawReward.prototype.withdrawn_reward = null;

        /**
         * Encodes the specified EventWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @static
         * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventWithdrawReward.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.withdrawn_reward != null && Object.hasOwnProperty.call(message, 'withdrawn_reward'))
            $root.cosmos.base.v1beta1.Coin.encode(message.withdrawn_reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EventWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @static
         * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventWithdrawReward message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventWithdrawReward.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventWithdrawReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventWithdrawReward message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventWithdrawReward.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.withdrawn_reward != null && message.hasOwnProperty('withdrawn_reward')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.withdrawn_reward);
            if (error) return 'withdrawn_reward.' + error;
          }
          return null;
        };

        /**
         * Creates an EventWithdrawReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
         */
        EventWithdrawReward.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawReward) return object;
          var message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.withdrawn_reward != null) {
            if (typeof object.withdrawn_reward !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.EventWithdrawReward.withdrawn_reward: object expected');
            message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.withdrawn_reward);
          }
          return message;
        };

        /**
         * Creates a plain object from an EventWithdrawReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @static
         * @param {ununifi.ecosystemincentive.EventWithdrawReward} message EventWithdrawReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventWithdrawReward.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.withdrawn_reward = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.withdrawn_reward != null && message.hasOwnProperty('withdrawn_reward'))
            object.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.withdrawn_reward, options);
          return object;
        };

        /**
         * Converts this EventWithdrawReward to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventWithdrawReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventWithdrawReward.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventWithdrawReward;
      })();

      ecosystemincentive.EventFailedParsingMemoInputs = (function () {
        /**
         * Properties of an EventFailedParsingMemoInputs.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventFailedParsingMemoInputs
         * @property {string|null} [class_id] EventFailedParsingMemoInputs class_id
         * @property {string|null} [nft_id] EventFailedParsingMemoInputs nft_id
         * @property {string|null} [memo] EventFailedParsingMemoInputs memo
         */

        /**
         * Constructs a new EventFailedParsingMemoInputs.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventFailedParsingMemoInputs.
         * @implements IEventFailedParsingMemoInputs
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventFailedParsingMemoInputs=} [properties] Properties to set
         */
        function EventFailedParsingMemoInputs(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventFailedParsingMemoInputs class_id.
         * @member {string} class_id
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @instance
         */
        EventFailedParsingMemoInputs.prototype.class_id = '';

        /**
         * EventFailedParsingMemoInputs nft_id.
         * @member {string} nft_id
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @instance
         */
        EventFailedParsingMemoInputs.prototype.nft_id = '';

        /**
         * EventFailedParsingMemoInputs memo.
         * @member {string} memo
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @instance
         */
        EventFailedParsingMemoInputs.prototype.memo = '';

        /**
         * Encodes the specified EventFailedParsingMemoInputs message. Does not implicitly {@link ununifi.ecosystemincentive.EventFailedParsingMemoInputs.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @static
         * @param {ununifi.ecosystemincentive.IEventFailedParsingMemoInputs} message EventFailedParsingMemoInputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventFailedParsingMemoInputs.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          if (message.memo != null && Object.hasOwnProperty.call(message, 'memo'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.memo);
          return writer;
        };

        /**
         * Encodes the specified EventFailedParsingMemoInputs message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventFailedParsingMemoInputs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @static
         * @param {ununifi.ecosystemincentive.IEventFailedParsingMemoInputs} message EventFailedParsingMemoInputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventFailedParsingMemoInputs.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventFailedParsingMemoInputs message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} EventFailedParsingMemoInputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventFailedParsingMemoInputs.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventFailedParsingMemoInputs();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              case 3:
                message.memo = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventFailedParsingMemoInputs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} EventFailedParsingMemoInputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventFailedParsingMemoInputs.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventFailedParsingMemoInputs message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventFailedParsingMemoInputs.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          if (message.memo != null && message.hasOwnProperty('memo')) if (!$util.isString(message.memo)) return 'memo: string expected';
          return null;
        };

        /**
         * Creates an EventFailedParsingMemoInputs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} EventFailedParsingMemoInputs
         */
        EventFailedParsingMemoInputs.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventFailedParsingMemoInputs) return object;
          var message = new $root.ununifi.ecosystemincentive.EventFailedParsingMemoInputs();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          if (object.memo != null) message.memo = String(object.memo);
          return message;
        };

        /**
         * Creates a plain object from an EventFailedParsingMemoInputs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @static
         * @param {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} message EventFailedParsingMemoInputs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventFailedParsingMemoInputs.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
            object.memo = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          if (message.memo != null && message.hasOwnProperty('memo')) object.memo = message.memo;
          return object;
        };

        /**
         * Converts this EventFailedParsingMemoInputs to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventFailedParsingMemoInputs.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventFailedParsingMemoInputs;
      })();

      ecosystemincentive.EventRecordedIncentiveUnitId = (function () {
        /**
         * Properties of an EventRecordedIncentiveUnitId.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventRecordedIncentiveUnitId
         * @property {string|null} [incentive_unit_id] EventRecordedIncentiveUnitId incentive_unit_id
         * @property {string|null} [class_id] EventRecordedIncentiveUnitId class_id
         * @property {string|null} [nft_id] EventRecordedIncentiveUnitId nft_id
         */

        /**
         * Constructs a new EventRecordedIncentiveUnitId.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventRecordedIncentiveUnitId.
         * @implements IEventRecordedIncentiveUnitId
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventRecordedIncentiveUnitId=} [properties] Properties to set
         */
        function EventRecordedIncentiveUnitId(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventRecordedIncentiveUnitId incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @instance
         */
        EventRecordedIncentiveUnitId.prototype.incentive_unit_id = '';

        /**
         * EventRecordedIncentiveUnitId class_id.
         * @member {string} class_id
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @instance
         */
        EventRecordedIncentiveUnitId.prototype.class_id = '';

        /**
         * EventRecordedIncentiveUnitId nft_id.
         * @member {string} nft_id
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @instance
         */
        EventRecordedIncentiveUnitId.prototype.nft_id = '';

        /**
         * Encodes the specified EventRecordedIncentiveUnitId message. Does not implicitly {@link ununifi.ecosystemincentive.EventRecordedIncentiveUnitId.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @static
         * @param {ununifi.ecosystemincentive.IEventRecordedIncentiveUnitId} message EventRecordedIncentiveUnitId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRecordedIncentiveUnitId.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventRecordedIncentiveUnitId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventRecordedIncentiveUnitId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @static
         * @param {ununifi.ecosystemincentive.IEventRecordedIncentiveUnitId} message EventRecordedIncentiveUnitId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRecordedIncentiveUnitId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventRecordedIncentiveUnitId message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} EventRecordedIncentiveUnitId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRecordedIncentiveUnitId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventRecordedIncentiveUnitId();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit_id = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventRecordedIncentiveUnitId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} EventRecordedIncentiveUnitId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRecordedIncentiveUnitId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventRecordedIncentiveUnitId message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventRecordedIncentiveUnitId.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventRecordedIncentiveUnitId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} EventRecordedIncentiveUnitId
         */
        EventRecordedIncentiveUnitId.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventRecordedIncentiveUnitId) return object;
          var message = new $root.ununifi.ecosystemincentive.EventRecordedIncentiveUnitId();
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventRecordedIncentiveUnitId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @static
         * @param {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} message EventRecordedIncentiveUnitId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventRecordedIncentiveUnitId.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.incentive_unit_id = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventRecordedIncentiveUnitId to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventRecordedIncentiveUnitId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventRecordedIncentiveUnitId;
      })();

      ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward = (function () {
        /**
         * Properties of an EventDeletedNftIdRecordedForFrontendReward.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventDeletedNftIdRecordedForFrontendReward
         * @property {string|null} [incentive_unit_id] EventDeletedNftIdRecordedForFrontendReward incentive_unit_id
         * @property {string|null} [class_id] EventDeletedNftIdRecordedForFrontendReward class_id
         * @property {string|null} [nft_id] EventDeletedNftIdRecordedForFrontendReward nft_id
         */

        /**
         * Constructs a new EventDeletedNftIdRecordedForFrontendReward.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventDeletedNftIdRecordedForFrontendReward.
         * @implements IEventDeletedNftIdRecordedForFrontendReward
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward=} [properties] Properties to set
         */
        function EventDeletedNftIdRecordedForFrontendReward(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventDeletedNftIdRecordedForFrontendReward incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @instance
         */
        EventDeletedNftIdRecordedForFrontendReward.prototype.incentive_unit_id = '';

        /**
         * EventDeletedNftIdRecordedForFrontendReward class_id.
         * @member {string} class_id
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @instance
         */
        EventDeletedNftIdRecordedForFrontendReward.prototype.class_id = '';

        /**
         * EventDeletedNftIdRecordedForFrontendReward nft_id.
         * @member {string} nft_id
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @instance
         */
        EventDeletedNftIdRecordedForFrontendReward.prototype.nft_id = '';

        /**
         * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @static
         * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventDeletedNftIdRecordedForFrontendReward.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @static
         * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventDeletedNftIdRecordedForFrontendReward.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventDeletedNftIdRecordedForFrontendReward.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit_id = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventDeletedNftIdRecordedForFrontendReward.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventDeletedNftIdRecordedForFrontendReward message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventDeletedNftIdRecordedForFrontendReward.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventDeletedNftIdRecordedForFrontendReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
         */
        EventDeletedNftIdRecordedForFrontendReward.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward) return object;
          var message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventDeletedNftIdRecordedForFrontendReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @static
         * @param {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventDeletedNftIdRecordedForFrontendReward.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.incentive_unit_id = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventDeletedNftIdRecordedForFrontendReward to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventDeletedNftIdRecordedForFrontendReward.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventDeletedNftIdRecordedForFrontendReward;
      })();

      ecosystemincentive.EventNotRegisteredIncentiveUnitId = (function () {
        /**
         * Properties of an EventNotRegisteredIncentiveUnitId.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventNotRegisteredIncentiveUnitId
         * @property {string|null} [incentive_unit_id] EventNotRegisteredIncentiveUnitId incentive_unit_id
         * @property {string|null} [class_id] EventNotRegisteredIncentiveUnitId class_id
         * @property {string|null} [nft_id] EventNotRegisteredIncentiveUnitId nft_id
         */

        /**
         * Constructs a new EventNotRegisteredIncentiveUnitId.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventNotRegisteredIncentiveUnitId.
         * @implements IEventNotRegisteredIncentiveUnitId
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventNotRegisteredIncentiveUnitId=} [properties] Properties to set
         */
        function EventNotRegisteredIncentiveUnitId(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventNotRegisteredIncentiveUnitId incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @instance
         */
        EventNotRegisteredIncentiveUnitId.prototype.incentive_unit_id = '';

        /**
         * EventNotRegisteredIncentiveUnitId class_id.
         * @member {string} class_id
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @instance
         */
        EventNotRegisteredIncentiveUnitId.prototype.class_id = '';

        /**
         * EventNotRegisteredIncentiveUnitId nft_id.
         * @member {string} nft_id
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @instance
         */
        EventNotRegisteredIncentiveUnitId.prototype.nft_id = '';

        /**
         * Encodes the specified EventNotRegisteredIncentiveUnitId message. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @static
         * @param {ununifi.ecosystemincentive.IEventNotRegisteredIncentiveUnitId} message EventNotRegisteredIncentiveUnitId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventNotRegisteredIncentiveUnitId.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventNotRegisteredIncentiveUnitId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @static
         * @param {ununifi.ecosystemincentive.IEventNotRegisteredIncentiveUnitId} message EventNotRegisteredIncentiveUnitId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventNotRegisteredIncentiveUnitId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventNotRegisteredIncentiveUnitId message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} EventNotRegisteredIncentiveUnitId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventNotRegisteredIncentiveUnitId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit_id = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventNotRegisteredIncentiveUnitId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} EventNotRegisteredIncentiveUnitId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventNotRegisteredIncentiveUnitId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventNotRegisteredIncentiveUnitId message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventNotRegisteredIncentiveUnitId.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventNotRegisteredIncentiveUnitId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} EventNotRegisteredIncentiveUnitId
         */
        EventNotRegisteredIncentiveUnitId.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId) return object;
          var message = new $root.ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId();
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventNotRegisteredIncentiveUnitId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @static
         * @param {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} message EventNotRegisteredIncentiveUnitId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventNotRegisteredIncentiveUnitId.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.incentive_unit_id = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventNotRegisteredIncentiveUnitId to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventNotRegisteredIncentiveUnitId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventNotRegisteredIncentiveUnitId;
      })();

      ecosystemincentive.EventNotRecordedNftId = (function () {
        /**
         * Properties of an EventNotRecordedNftId.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventNotRecordedNftId
         * @property {string|null} [class_id] EventNotRecordedNftId class_id
         * @property {string|null} [nft_id] EventNotRecordedNftId nft_id
         */

        /**
         * Constructs a new EventNotRecordedNftId.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventNotRecordedNftId.
         * @implements IEventNotRecordedNftId
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId=} [properties] Properties to set
         */
        function EventNotRecordedNftId(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventNotRecordedNftId class_id.
         * @member {string} class_id
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @instance
         */
        EventNotRecordedNftId.prototype.class_id = '';

        /**
         * EventNotRecordedNftId nft_id.
         * @member {string} nft_id
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @instance
         */
        EventNotRecordedNftId.prototype.nft_id = '';

        /**
         * Encodes the specified EventNotRecordedNftId message. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @static
         * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventNotRecordedNftId.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventNotRecordedNftId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @static
         * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventNotRecordedNftId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventNotRecordedNftId message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventNotRecordedNftId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventNotRecordedNftId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventNotRecordedNftId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventNotRecordedNftId message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventNotRecordedNftId.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventNotRecordedNftId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
         */
        EventNotRecordedNftId.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventNotRecordedNftId) return object;
          var message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventNotRecordedNftId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @static
         * @param {ununifi.ecosystemincentive.EventNotRecordedNftId} message EventNotRecordedNftId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventNotRecordedNftId.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventNotRecordedNftId to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventNotRecordedNftId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventNotRecordedNftId;
      })();

      ecosystemincentive.EventUpdatedReward = (function () {
        /**
         * Properties of an EventUpdatedReward.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventUpdatedReward
         * @property {string|null} [incentive_unit_id] EventUpdatedReward incentive_unit_id
         * @property {cosmos.base.v1beta1.ICoin|null} [earned_reward] EventUpdatedReward earned_reward
         */

        /**
         * Constructs a new EventUpdatedReward.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventUpdatedReward.
         * @implements IEventUpdatedReward
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventUpdatedReward=} [properties] Properties to set
         */
        function EventUpdatedReward(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventUpdatedReward incentive_unit_id.
         * @member {string} incentive_unit_id
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @instance
         */
        EventUpdatedReward.prototype.incentive_unit_id = '';

        /**
         * EventUpdatedReward earned_reward.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} earned_reward
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @instance
         */
        EventUpdatedReward.prototype.earned_reward = null;

        /**
         * Encodes the specified EventUpdatedReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @static
         * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventUpdatedReward.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
          if (message.earned_reward != null && Object.hasOwnProperty.call(message, 'earned_reward'))
            $root.cosmos.base.v1beta1.Coin.encode(message.earned_reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EventUpdatedReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @static
         * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventUpdatedReward.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventUpdatedReward message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventUpdatedReward.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.incentive_unit_id = reader.string();
                break;
              case 2:
                message.earned_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventUpdatedReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventUpdatedReward.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventUpdatedReward message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventUpdatedReward.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
          if (message.earned_reward != null && message.hasOwnProperty('earned_reward')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.earned_reward);
            if (error) return 'earned_reward.' + error;
          }
          return null;
        };

        /**
         * Creates an EventUpdatedReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
         */
        EventUpdatedReward.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventUpdatedReward) return object;
          var message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
          if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
          if (object.earned_reward != null) {
            if (typeof object.earned_reward !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.EventUpdatedReward.earned_reward: object expected');
            message.earned_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.earned_reward);
          }
          return message;
        };

        /**
         * Creates a plain object from an EventUpdatedReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @static
         * @param {ununifi.ecosystemincentive.EventUpdatedReward} message EventUpdatedReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventUpdatedReward.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.incentive_unit_id = '';
            object.earned_reward = null;
          }
          if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
            object.incentive_unit_id = message.incentive_unit_id;
          if (message.earned_reward != null && message.hasOwnProperty('earned_reward'))
            object.earned_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.earned_reward, options);
          return object;
        };

        /**
         * Converts this EventUpdatedReward to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventUpdatedReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventUpdatedReward.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventUpdatedReward;
      })();

      ecosystemincentive.EventVersionUnmatched = (function () {
        /**
         * Properties of an EventVersionUnmatched.
         * @memberof ununifi.ecosystemincentive
         * @interface IEventVersionUnmatched
         * @property {string|null} [unmatched_version] EventVersionUnmatched unmatched_version
         * @property {string|null} [class_id] EventVersionUnmatched class_id
         * @property {string|null} [nft_id] EventVersionUnmatched nft_id
         */

        /**
         * Constructs a new EventVersionUnmatched.
         * @memberof ununifi.ecosystemincentive
         * @classdesc Represents an EventVersionUnmatched.
         * @implements IEventVersionUnmatched
         * @constructor
         * @param {ununifi.ecosystemincentive.IEventVersionUnmatched=} [properties] Properties to set
         */
        function EventVersionUnmatched(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventVersionUnmatched unmatched_version.
         * @member {string} unmatched_version
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @instance
         */
        EventVersionUnmatched.prototype.unmatched_version = '';

        /**
         * EventVersionUnmatched class_id.
         * @member {string} class_id
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @instance
         */
        EventVersionUnmatched.prototype.class_id = '';

        /**
         * EventVersionUnmatched nft_id.
         * @member {string} nft_id
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @instance
         */
        EventVersionUnmatched.prototype.nft_id = '';

        /**
         * Encodes the specified EventVersionUnmatched message. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @static
         * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventVersionUnmatched.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.unmatched_version != null && Object.hasOwnProperty.call(message, 'unmatched_version'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.unmatched_version);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventVersionUnmatched message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @static
         * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventVersionUnmatched.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventVersionUnmatched message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventVersionUnmatched.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.unmatched_version = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventVersionUnmatched message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventVersionUnmatched.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventVersionUnmatched message.
         * @function verify
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventVersionUnmatched.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.unmatched_version != null && message.hasOwnProperty('unmatched_version'))
            if (!$util.isString(message.unmatched_version)) return 'unmatched_version: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventVersionUnmatched message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
         */
        EventVersionUnmatched.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ecosystemincentive.EventVersionUnmatched) return object;
          var message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
          if (object.unmatched_version != null) message.unmatched_version = String(object.unmatched_version);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventVersionUnmatched message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @static
         * @param {ununifi.ecosystemincentive.EventVersionUnmatched} message EventVersionUnmatched
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventVersionUnmatched.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.unmatched_version = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.unmatched_version != null && message.hasOwnProperty('unmatched_version'))
            object.unmatched_version = message.unmatched_version;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventVersionUnmatched to JSON.
         * @function toJSON
         * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventVersionUnmatched.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventVersionUnmatched;
      })();

      return ecosystemincentive;
    })();

    ununifi.ethereum = (function () {
      /**
       * Namespace ethereum.
       * @memberof ununifi
       * @namespace
       */
      var ethereum = {};

      ethereum.SignDocForMetamask = (function () {
        /**
         * Properties of a SignDocForMetamask.
         * @memberof ununifi.ethereum
         * @interface ISignDocForMetamask
         * @property {cosmos.tx.v1beta1.ITxBody|null} [body] SignDocForMetamask body
         * @property {cosmos.tx.v1beta1.IAuthInfo|null} [auth_info] SignDocForMetamask auth_info
         * @property {string|null} [chain_id] SignDocForMetamask chain_id
         * @property {Long|null} [account_number] SignDocForMetamask account_number
         */

        /**
         * Constructs a new SignDocForMetamask.
         * @memberof ununifi.ethereum
         * @classdesc Represents a SignDocForMetamask.
         * @implements ISignDocForMetamask
         * @constructor
         * @param {ununifi.ethereum.ISignDocForMetamask=} [properties] Properties to set
         */
        function SignDocForMetamask(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignDocForMetamask body.
         * @member {cosmos.tx.v1beta1.ITxBody|null|undefined} body
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @instance
         */
        SignDocForMetamask.prototype.body = null;

        /**
         * SignDocForMetamask auth_info.
         * @member {cosmos.tx.v1beta1.IAuthInfo|null|undefined} auth_info
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @instance
         */
        SignDocForMetamask.prototype.auth_info = null;

        /**
         * SignDocForMetamask chain_id.
         * @member {string} chain_id
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @instance
         */
        SignDocForMetamask.prototype.chain_id = '';

        /**
         * SignDocForMetamask account_number.
         * @member {Long} account_number
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @instance
         */
        SignDocForMetamask.prototype.account_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified SignDocForMetamask message. Does not implicitly {@link ununifi.ethereum.SignDocForMetamask.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @static
         * @param {ununifi.ethereum.ISignDocForMetamask} message SignDocForMetamask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignDocForMetamask.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.body != null && Object.hasOwnProperty.call(message, 'body'))
            $root.cosmos.tx.v1beta1.TxBody.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.auth_info != null && Object.hasOwnProperty.call(message, 'auth_info'))
            $root.cosmos.tx.v1beta1.AuthInfo.encode(message.auth_info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.chain_id);
          if (message.account_number != null && Object.hasOwnProperty.call(message, 'account_number'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.account_number);
          return writer;
        };

        /**
         * Encodes the specified SignDocForMetamask message, length delimited. Does not implicitly {@link ununifi.ethereum.SignDocForMetamask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @static
         * @param {ununifi.ethereum.ISignDocForMetamask} message SignDocForMetamask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignDocForMetamask.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignDocForMetamask message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ethereum.SignDocForMetamask} SignDocForMetamask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignDocForMetamask.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ethereum.SignDocForMetamask();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.body = $root.cosmos.tx.v1beta1.TxBody.decode(reader, reader.uint32());
                break;
              case 2:
                message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.decode(reader, reader.uint32());
                break;
              case 3:
                message.chain_id = reader.string();
                break;
              case 4:
                message.account_number = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SignDocForMetamask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ethereum.SignDocForMetamask} SignDocForMetamask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignDocForMetamask.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignDocForMetamask message.
         * @function verify
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignDocForMetamask.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.body != null && message.hasOwnProperty('body')) {
            var error = $root.cosmos.tx.v1beta1.TxBody.verify(message.body);
            if (error) return 'body.' + error;
          }
          if (message.auth_info != null && message.hasOwnProperty('auth_info')) {
            var error = $root.cosmos.tx.v1beta1.AuthInfo.verify(message.auth_info);
            if (error) return 'auth_info.' + error;
          }
          if (message.chain_id != null && message.hasOwnProperty('chain_id'))
            if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
          if (message.account_number != null && message.hasOwnProperty('account_number'))
            if (
              !$util.isInteger(message.account_number) &&
              !(message.account_number && $util.isInteger(message.account_number.low) && $util.isInteger(message.account_number.high))
            )
              return 'account_number: integer|Long expected';
          return null;
        };

        /**
         * Creates a SignDocForMetamask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ethereum.SignDocForMetamask} SignDocForMetamask
         */
        SignDocForMetamask.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ethereum.SignDocForMetamask) return object;
          var message = new $root.ununifi.ethereum.SignDocForMetamask();
          if (object.body != null) {
            if (typeof object.body !== 'object') throw TypeError('.ununifi.ethereum.SignDocForMetamask.body: object expected');
            message.body = $root.cosmos.tx.v1beta1.TxBody.fromObject(object.body);
          }
          if (object.auth_info != null) {
            if (typeof object.auth_info !== 'object') throw TypeError('.ununifi.ethereum.SignDocForMetamask.auth_info: object expected');
            message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.fromObject(object.auth_info);
          }
          if (object.chain_id != null) message.chain_id = String(object.chain_id);
          if (object.account_number != null)
            if ($util.Long) (message.account_number = $util.Long.fromValue(object.account_number)).unsigned = true;
            else if (typeof object.account_number === 'string') message.account_number = parseInt(object.account_number, 10);
            else if (typeof object.account_number === 'number') message.account_number = object.account_number;
            else if (typeof object.account_number === 'object')
              message.account_number = new $util.LongBits(object.account_number.low >>> 0, object.account_number.high >>> 0).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a SignDocForMetamask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @static
         * @param {ununifi.ethereum.SignDocForMetamask} message SignDocForMetamask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignDocForMetamask.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.body = null;
            object.auth_info = null;
            object.chain_id = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.account_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.account_number = options.longs === String ? '0' : 0;
          }
          if (message.body != null && message.hasOwnProperty('body'))
            object.body = $root.cosmos.tx.v1beta1.TxBody.toObject(message.body, options);
          if (message.auth_info != null && message.hasOwnProperty('auth_info'))
            object.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.toObject(message.auth_info, options);
          if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
          if (message.account_number != null && message.hasOwnProperty('account_number'))
            if (typeof message.account_number === 'number')
              object.account_number = options.longs === String ? String(message.account_number) : message.account_number;
            else
              object.account_number =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.account_number)
                  : options.longs === Number
                  ? new $util.LongBits(message.account_number.low >>> 0, message.account_number.high >>> 0).toNumber(true)
                  : message.account_number;
          return object;
        };

        /**
         * Converts this SignDocForMetamask to JSON.
         * @function toJSON
         * @memberof ununifi.ethereum.SignDocForMetamask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignDocForMetamask.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignDocForMetamask;
      })();

      return ethereum;
    })();

    ununifi.incentive = (function () {
      /**
       * Namespace incentive.
       * @memberof ununifi
       * @namespace
       */
      var incentive = {};

      incentive.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.incentive
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.incentive.Query#params}.
         * @memberof ununifi.incentive.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.incentive.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.incentive.Query
         * @instance
         * @param {ununifi.incentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.incentive.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(
              params,
              $root.ununifi.incentive.QueryParamsRequest,
              $root.ununifi.incentive.QueryParamsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.incentive.Query
         * @instance
         * @param {ununifi.incentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.incentive.QueryParamsResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      incentive.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.incentive
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.incentive
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.incentive.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.incentive.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.QueryParamsRequest
         * @static
         * @param {ununifi.incentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.incentive.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.QueryParamsRequest
         * @static
         * @param {ununifi.incentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.incentive.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.QueryParamsRequest) return object;
          return new $root.ununifi.incentive.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.QueryParamsRequest
         * @static
         * @param {ununifi.incentive.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      incentive.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.incentive
         * @interface IQueryParamsResponse
         * @property {ununifi.incentive.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.incentive
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.incentive.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.incentive.IParams|null|undefined} params
         * @memberof ununifi.incentive.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.incentive.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.QueryParamsResponse
         * @static
         * @param {ununifi.incentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.incentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.incentive.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.QueryParamsResponse
         * @static
         * @param {ununifi.incentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.incentive.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.incentive.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.incentive.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.QueryParamsResponse) return object;
          var message = new $root.ununifi.incentive.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.incentive.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.incentive.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.QueryParamsResponse
         * @static
         * @param {ununifi.incentive.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.incentive.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      incentive.BaseClaim = (function () {
        /**
         * Properties of a BaseClaim.
         * @memberof ununifi.incentive
         * @interface IBaseClaim
         * @property {string|null} [owner] BaseClaim owner
         * @property {cosmos.base.v1beta1.ICoin|null} [reward] BaseClaim reward
         */

        /**
         * Constructs a new BaseClaim.
         * @memberof ununifi.incentive
         * @classdesc Represents a BaseClaim.
         * @implements IBaseClaim
         * @constructor
         * @param {ununifi.incentive.IBaseClaim=} [properties] Properties to set
         */
        function BaseClaim(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseClaim owner.
         * @member {string} owner
         * @memberof ununifi.incentive.BaseClaim
         * @instance
         */
        BaseClaim.prototype.owner = '';

        /**
         * BaseClaim reward.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} reward
         * @memberof ununifi.incentive.BaseClaim
         * @instance
         */
        BaseClaim.prototype.reward = null;

        /**
         * Encodes the specified BaseClaim message. Does not implicitly {@link ununifi.incentive.BaseClaim.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.BaseClaim
         * @static
         * @param {ununifi.incentive.IBaseClaim} message BaseClaim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseClaim.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.reward != null && Object.hasOwnProperty.call(message, 'reward'))
            $root.cosmos.base.v1beta1.Coin.encode(message.reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified BaseClaim message, length delimited. Does not implicitly {@link ununifi.incentive.BaseClaim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.BaseClaim
         * @static
         * @param {ununifi.incentive.IBaseClaim} message BaseClaim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseClaim.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaseClaim message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.BaseClaim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.BaseClaim} BaseClaim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseClaim.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.BaseClaim();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a BaseClaim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.BaseClaim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.BaseClaim} BaseClaim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseClaim.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaseClaim message.
         * @function verify
         * @memberof ununifi.incentive.BaseClaim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaseClaim.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.reward != null && message.hasOwnProperty('reward')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.reward);
            if (error) return 'reward.' + error;
          }
          return null;
        };

        /**
         * Creates a BaseClaim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.BaseClaim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.BaseClaim} BaseClaim
         */
        BaseClaim.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.BaseClaim) return object;
          var message = new $root.ununifi.incentive.BaseClaim();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.reward != null) {
            if (typeof object.reward !== 'object') throw TypeError('.ununifi.incentive.BaseClaim.reward: object expected');
            message.reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.reward);
          }
          return message;
        };

        /**
         * Creates a plain object from a BaseClaim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.BaseClaim
         * @static
         * @param {ununifi.incentive.BaseClaim} message BaseClaim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaseClaim.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.reward = null;
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.reward != null && message.hasOwnProperty('reward'))
            object.reward = $root.cosmos.base.v1beta1.Coin.toObject(message.reward, options);
          return object;
        };

        /**
         * Converts this BaseClaim to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.BaseClaim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaseClaim.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BaseClaim;
      })();

      incentive.BaseMultiClaim = (function () {
        /**
         * Properties of a BaseMultiClaim.
         * @memberof ununifi.incentive
         * @interface IBaseMultiClaim
         * @property {string|null} [owner] BaseMultiClaim owner
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [reward] BaseMultiClaim reward
         */

        /**
         * Constructs a new BaseMultiClaim.
         * @memberof ununifi.incentive
         * @classdesc Represents a BaseMultiClaim.
         * @implements IBaseMultiClaim
         * @constructor
         * @param {ununifi.incentive.IBaseMultiClaim=} [properties] Properties to set
         */
        function BaseMultiClaim(properties) {
          this.reward = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseMultiClaim owner.
         * @member {string} owner
         * @memberof ununifi.incentive.BaseMultiClaim
         * @instance
         */
        BaseMultiClaim.prototype.owner = '';

        /**
         * BaseMultiClaim reward.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} reward
         * @memberof ununifi.incentive.BaseMultiClaim
         * @instance
         */
        BaseMultiClaim.prototype.reward = $util.emptyArray;

        /**
         * Encodes the specified BaseMultiClaim message. Does not implicitly {@link ununifi.incentive.BaseMultiClaim.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.BaseMultiClaim
         * @static
         * @param {ununifi.incentive.IBaseMultiClaim} message BaseMultiClaim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseMultiClaim.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.reward != null && message.reward.length)
            for (var i = 0; i < message.reward.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.reward[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified BaseMultiClaim message, length delimited. Does not implicitly {@link ununifi.incentive.BaseMultiClaim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.BaseMultiClaim
         * @static
         * @param {ununifi.incentive.IBaseMultiClaim} message BaseMultiClaim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseMultiClaim.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaseMultiClaim message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.BaseMultiClaim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.BaseMultiClaim} BaseMultiClaim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseMultiClaim.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.BaseMultiClaim();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                if (!(message.reward && message.reward.length)) message.reward = [];
                message.reward.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a BaseMultiClaim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.BaseMultiClaim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.BaseMultiClaim} BaseMultiClaim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseMultiClaim.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaseMultiClaim message.
         * @function verify
         * @memberof ununifi.incentive.BaseMultiClaim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaseMultiClaim.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.reward != null && message.hasOwnProperty('reward')) {
            if (!Array.isArray(message.reward)) return 'reward: array expected';
            for (var i = 0; i < message.reward.length; ++i) {
              var error = $root.cosmos.base.v1beta1.Coin.verify(message.reward[i]);
              if (error) return 'reward.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a BaseMultiClaim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.BaseMultiClaim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.BaseMultiClaim} BaseMultiClaim
         */
        BaseMultiClaim.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.BaseMultiClaim) return object;
          var message = new $root.ununifi.incentive.BaseMultiClaim();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.reward) {
            if (!Array.isArray(object.reward)) throw TypeError('.ununifi.incentive.BaseMultiClaim.reward: array expected');
            message.reward = [];
            for (var i = 0; i < object.reward.length; ++i) {
              if (typeof object.reward[i] !== 'object') throw TypeError('.ununifi.incentive.BaseMultiClaim.reward: object expected');
              message.reward[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.reward[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a BaseMultiClaim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.BaseMultiClaim
         * @static
         * @param {ununifi.incentive.BaseMultiClaim} message BaseMultiClaim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaseMultiClaim.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.reward = [];
          if (options.defaults) object.owner = '';
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.reward && message.reward.length) {
            object.reward = [];
            for (var j = 0; j < message.reward.length; ++j)
              object.reward[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.reward[j], options);
          }
          return object;
        };

        /**
         * Converts this BaseMultiClaim to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.BaseMultiClaim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaseMultiClaim.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BaseMultiClaim;
      })();

      incentive.CdpMintingClaim = (function () {
        /**
         * Properties of a CdpMintingClaim.
         * @memberof ununifi.incentive
         * @interface ICdpMintingClaim
         * @property {ununifi.incentive.IBaseClaim|null} [base_claim] CdpMintingClaim base_claim
         * @property {Array.<ununifi.incentive.IRewardIndex>|null} [reward_indexes] CdpMintingClaim reward_indexes
         */

        /**
         * Constructs a new CdpMintingClaim.
         * @memberof ununifi.incentive
         * @classdesc Represents a CdpMintingClaim.
         * @implements ICdpMintingClaim
         * @constructor
         * @param {ununifi.incentive.ICdpMintingClaim=} [properties] Properties to set
         */
        function CdpMintingClaim(properties) {
          this.reward_indexes = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * CdpMintingClaim base_claim.
         * @member {ununifi.incentive.IBaseClaim|null|undefined} base_claim
         * @memberof ununifi.incentive.CdpMintingClaim
         * @instance
         */
        CdpMintingClaim.prototype.base_claim = null;

        /**
         * CdpMintingClaim reward_indexes.
         * @member {Array.<ununifi.incentive.IRewardIndex>} reward_indexes
         * @memberof ununifi.incentive.CdpMintingClaim
         * @instance
         */
        CdpMintingClaim.prototype.reward_indexes = $util.emptyArray;

        /**
         * Encodes the specified CdpMintingClaim message. Does not implicitly {@link ununifi.incentive.CdpMintingClaim.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.CdpMintingClaim
         * @static
         * @param {ununifi.incentive.ICdpMintingClaim} message CdpMintingClaim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CdpMintingClaim.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.base_claim != null && Object.hasOwnProperty.call(message, 'base_claim'))
            $root.ununifi.incentive.BaseClaim.encode(message.base_claim, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.reward_indexes != null && message.reward_indexes.length)
            for (var i = 0; i < message.reward_indexes.length; ++i)
              $root.ununifi.incentive.RewardIndex.encode(
                message.reward_indexes[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified CdpMintingClaim message, length delimited. Does not implicitly {@link ununifi.incentive.CdpMintingClaim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.CdpMintingClaim
         * @static
         * @param {ununifi.incentive.ICdpMintingClaim} message CdpMintingClaim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CdpMintingClaim.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CdpMintingClaim message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.CdpMintingClaim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.CdpMintingClaim} CdpMintingClaim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CdpMintingClaim.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.CdpMintingClaim();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.base_claim = $root.ununifi.incentive.BaseClaim.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message.reward_indexes && message.reward_indexes.length)) message.reward_indexes = [];
                message.reward_indexes.push($root.ununifi.incentive.RewardIndex.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a CdpMintingClaim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.CdpMintingClaim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.CdpMintingClaim} CdpMintingClaim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CdpMintingClaim.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CdpMintingClaim message.
         * @function verify
         * @memberof ununifi.incentive.CdpMintingClaim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CdpMintingClaim.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.base_claim != null && message.hasOwnProperty('base_claim')) {
            var error = $root.ununifi.incentive.BaseClaim.verify(message.base_claim);
            if (error) return 'base_claim.' + error;
          }
          if (message.reward_indexes != null && message.hasOwnProperty('reward_indexes')) {
            if (!Array.isArray(message.reward_indexes)) return 'reward_indexes: array expected';
            for (var i = 0; i < message.reward_indexes.length; ++i) {
              var error = $root.ununifi.incentive.RewardIndex.verify(message.reward_indexes[i]);
              if (error) return 'reward_indexes.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a CdpMintingClaim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.CdpMintingClaim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.CdpMintingClaim} CdpMintingClaim
         */
        CdpMintingClaim.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.CdpMintingClaim) return object;
          var message = new $root.ununifi.incentive.CdpMintingClaim();
          if (object.base_claim != null) {
            if (typeof object.base_claim !== 'object') throw TypeError('.ununifi.incentive.CdpMintingClaim.base_claim: object expected');
            message.base_claim = $root.ununifi.incentive.BaseClaim.fromObject(object.base_claim);
          }
          if (object.reward_indexes) {
            if (!Array.isArray(object.reward_indexes)) throw TypeError('.ununifi.incentive.CdpMintingClaim.reward_indexes: array expected');
            message.reward_indexes = [];
            for (var i = 0; i < object.reward_indexes.length; ++i) {
              if (typeof object.reward_indexes[i] !== 'object')
                throw TypeError('.ununifi.incentive.CdpMintingClaim.reward_indexes: object expected');
              message.reward_indexes[i] = $root.ununifi.incentive.RewardIndex.fromObject(object.reward_indexes[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a CdpMintingClaim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.CdpMintingClaim
         * @static
         * @param {ununifi.incentive.CdpMintingClaim} message CdpMintingClaim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CdpMintingClaim.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.reward_indexes = [];
          if (options.defaults) object.base_claim = null;
          if (message.base_claim != null && message.hasOwnProperty('base_claim'))
            object.base_claim = $root.ununifi.incentive.BaseClaim.toObject(message.base_claim, options);
          if (message.reward_indexes && message.reward_indexes.length) {
            object.reward_indexes = [];
            for (var j = 0; j < message.reward_indexes.length; ++j)
              object.reward_indexes[j] = $root.ununifi.incentive.RewardIndex.toObject(message.reward_indexes[j], options);
          }
          return object;
        };

        /**
         * Converts this CdpMintingClaim to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.CdpMintingClaim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CdpMintingClaim.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CdpMintingClaim;
      })();

      incentive.RewardIndex = (function () {
        /**
         * Properties of a RewardIndex.
         * @memberof ununifi.incentive
         * @interface IRewardIndex
         * @property {string|null} [collateral_type] RewardIndex collateral_type
         * @property {string|null} [reward_factor] RewardIndex reward_factor
         */

        /**
         * Constructs a new RewardIndex.
         * @memberof ununifi.incentive
         * @classdesc Represents a RewardIndex.
         * @implements IRewardIndex
         * @constructor
         * @param {ununifi.incentive.IRewardIndex=} [properties] Properties to set
         */
        function RewardIndex(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RewardIndex collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.incentive.RewardIndex
         * @instance
         */
        RewardIndex.prototype.collateral_type = '';

        /**
         * RewardIndex reward_factor.
         * @member {string} reward_factor
         * @memberof ununifi.incentive.RewardIndex
         * @instance
         */
        RewardIndex.prototype.reward_factor = '';

        /**
         * Encodes the specified RewardIndex message. Does not implicitly {@link ununifi.incentive.RewardIndex.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.RewardIndex
         * @static
         * @param {ununifi.incentive.IRewardIndex} message RewardIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardIndex.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
          if (message.reward_factor != null && Object.hasOwnProperty.call(message, 'reward_factor'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reward_factor);
          return writer;
        };

        /**
         * Encodes the specified RewardIndex message, length delimited. Does not implicitly {@link ununifi.incentive.RewardIndex.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.RewardIndex
         * @static
         * @param {ununifi.incentive.IRewardIndex} message RewardIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardIndex.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RewardIndex message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.RewardIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.RewardIndex} RewardIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardIndex.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.RewardIndex();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.collateral_type = reader.string();
                break;
              case 2:
                message.reward_factor = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RewardIndex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.RewardIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.RewardIndex} RewardIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardIndex.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RewardIndex message.
         * @function verify
         * @memberof ununifi.incentive.RewardIndex
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RewardIndex.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          if (message.reward_factor != null && message.hasOwnProperty('reward_factor'))
            if (!$util.isString(message.reward_factor)) return 'reward_factor: string expected';
          return null;
        };

        /**
         * Creates a RewardIndex message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.RewardIndex
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.RewardIndex} RewardIndex
         */
        RewardIndex.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.RewardIndex) return object;
          var message = new $root.ununifi.incentive.RewardIndex();
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          if (object.reward_factor != null) message.reward_factor = String(object.reward_factor);
          return message;
        };

        /**
         * Creates a plain object from a RewardIndex message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.RewardIndex
         * @static
         * @param {ununifi.incentive.RewardIndex} message RewardIndex
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RewardIndex.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.collateral_type = '';
            object.reward_factor = '';
          }
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          if (message.reward_factor != null && message.hasOwnProperty('reward_factor')) object.reward_factor = message.reward_factor;
          return object;
        };

        /**
         * Converts this RewardIndex to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.RewardIndex
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RewardIndex.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RewardIndex;
      })();

      incentive.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.incentive
         * @interface IParams
         * @property {Array.<ununifi.incentive.IRewardPeriod>|null} [cdp_minting_reward_periods] Params cdp_minting_reward_periods
         * @property {Array.<ununifi.incentive.IMultiplier>|null} [claim_multipliers] Params claim_multipliers
         * @property {google.protobuf.ITimestamp|null} [claim_end] Params claim_end
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.incentive
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.incentive.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          this.cdp_minting_reward_periods = [];
          this.claim_multipliers = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params cdp_minting_reward_periods.
         * @member {Array.<ununifi.incentive.IRewardPeriod>} cdp_minting_reward_periods
         * @memberof ununifi.incentive.Params
         * @instance
         */
        Params.prototype.cdp_minting_reward_periods = $util.emptyArray;

        /**
         * Params claim_multipliers.
         * @member {Array.<ununifi.incentive.IMultiplier>} claim_multipliers
         * @memberof ununifi.incentive.Params
         * @instance
         */
        Params.prototype.claim_multipliers = $util.emptyArray;

        /**
         * Params claim_end.
         * @member {google.protobuf.ITimestamp|null|undefined} claim_end
         * @memberof ununifi.incentive.Params
         * @instance
         */
        Params.prototype.claim_end = null;

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.incentive.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.Params
         * @static
         * @param {ununifi.incentive.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.cdp_minting_reward_periods != null && message.cdp_minting_reward_periods.length)
            for (var i = 0; i < message.cdp_minting_reward_periods.length; ++i)
              $root.ununifi.incentive.RewardPeriod.encode(
                message.cdp_minting_reward_periods[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          if (message.claim_multipliers != null && message.claim_multipliers.length)
            for (var i = 0; i < message.claim_multipliers.length; ++i)
              $root.ununifi.incentive.Multiplier.encode(
                message.claim_multipliers[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.claim_end != null && Object.hasOwnProperty.call(message, 'claim_end'))
            $root.google.protobuf.Timestamp.encode(message.claim_end, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.incentive.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.Params
         * @static
         * @param {ununifi.incentive.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.cdp_minting_reward_periods && message.cdp_minting_reward_periods.length))
                  message.cdp_minting_reward_periods = [];
                message.cdp_minting_reward_periods.push($root.ununifi.incentive.RewardPeriod.decode(reader, reader.uint32()));
                break;
              case 2:
                if (!(message.claim_multipliers && message.claim_multipliers.length)) message.claim_multipliers = [];
                message.claim_multipliers.push($root.ununifi.incentive.Multiplier.decode(reader, reader.uint32()));
                break;
              case 3:
                message.claim_end = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.incentive.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.cdp_minting_reward_periods != null && message.hasOwnProperty('cdp_minting_reward_periods')) {
            if (!Array.isArray(message.cdp_minting_reward_periods)) return 'cdp_minting_reward_periods: array expected';
            for (var i = 0; i < message.cdp_minting_reward_periods.length; ++i) {
              var error = $root.ununifi.incentive.RewardPeriod.verify(message.cdp_minting_reward_periods[i]);
              if (error) return 'cdp_minting_reward_periods.' + error;
            }
          }
          if (message.claim_multipliers != null && message.hasOwnProperty('claim_multipliers')) {
            if (!Array.isArray(message.claim_multipliers)) return 'claim_multipliers: array expected';
            for (var i = 0; i < message.claim_multipliers.length; ++i) {
              var error = $root.ununifi.incentive.Multiplier.verify(message.claim_multipliers[i]);
              if (error) return 'claim_multipliers.' + error;
            }
          }
          if (message.claim_end != null && message.hasOwnProperty('claim_end')) {
            var error = $root.google.protobuf.Timestamp.verify(message.claim_end);
            if (error) return 'claim_end.' + error;
          }
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.Params) return object;
          var message = new $root.ununifi.incentive.Params();
          if (object.cdp_minting_reward_periods) {
            if (!Array.isArray(object.cdp_minting_reward_periods))
              throw TypeError('.ununifi.incentive.Params.cdp_minting_reward_periods: array expected');
            message.cdp_minting_reward_periods = [];
            for (var i = 0; i < object.cdp_minting_reward_periods.length; ++i) {
              if (typeof object.cdp_minting_reward_periods[i] !== 'object')
                throw TypeError('.ununifi.incentive.Params.cdp_minting_reward_periods: object expected');
              message.cdp_minting_reward_periods[i] = $root.ununifi.incentive.RewardPeriod.fromObject(object.cdp_minting_reward_periods[i]);
            }
          }
          if (object.claim_multipliers) {
            if (!Array.isArray(object.claim_multipliers)) throw TypeError('.ununifi.incentive.Params.claim_multipliers: array expected');
            message.claim_multipliers = [];
            for (var i = 0; i < object.claim_multipliers.length; ++i) {
              if (typeof object.claim_multipliers[i] !== 'object')
                throw TypeError('.ununifi.incentive.Params.claim_multipliers: object expected');
              message.claim_multipliers[i] = $root.ununifi.incentive.Multiplier.fromObject(object.claim_multipliers[i]);
            }
          }
          if (object.claim_end != null) {
            if (typeof object.claim_end !== 'object') throw TypeError('.ununifi.incentive.Params.claim_end: object expected');
            message.claim_end = $root.google.protobuf.Timestamp.fromObject(object.claim_end);
          }
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.Params
         * @static
         * @param {ununifi.incentive.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.cdp_minting_reward_periods = [];
            object.claim_multipliers = [];
          }
          if (options.defaults) object.claim_end = null;
          if (message.cdp_minting_reward_periods && message.cdp_minting_reward_periods.length) {
            object.cdp_minting_reward_periods = [];
            for (var j = 0; j < message.cdp_minting_reward_periods.length; ++j)
              object.cdp_minting_reward_periods[j] = $root.ununifi.incentive.RewardPeriod.toObject(
                message.cdp_minting_reward_periods[j],
                options,
              );
          }
          if (message.claim_multipliers && message.claim_multipliers.length) {
            object.claim_multipliers = [];
            for (var j = 0; j < message.claim_multipliers.length; ++j)
              object.claim_multipliers[j] = $root.ununifi.incentive.Multiplier.toObject(message.claim_multipliers[j], options);
          }
          if (message.claim_end != null && message.hasOwnProperty('claim_end'))
            object.claim_end = $root.google.protobuf.Timestamp.toObject(message.claim_end, options);
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      incentive.RewardPeriod = (function () {
        /**
         * Properties of a RewardPeriod.
         * @memberof ununifi.incentive
         * @interface IRewardPeriod
         * @property {boolean|null} [active] RewardPeriod active
         * @property {string|null} [collateral_type] RewardPeriod collateral_type
         * @property {google.protobuf.ITimestamp|null} [start] RewardPeriod start
         * @property {google.protobuf.ITimestamp|null} [end] RewardPeriod end
         * @property {cosmos.base.v1beta1.ICoin|null} [rewards_per_second] RewardPeriod rewards_per_second
         */

        /**
         * Constructs a new RewardPeriod.
         * @memberof ununifi.incentive
         * @classdesc Represents a RewardPeriod.
         * @implements IRewardPeriod
         * @constructor
         * @param {ununifi.incentive.IRewardPeriod=} [properties] Properties to set
         */
        function RewardPeriod(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RewardPeriod active.
         * @member {boolean} active
         * @memberof ununifi.incentive.RewardPeriod
         * @instance
         */
        RewardPeriod.prototype.active = false;

        /**
         * RewardPeriod collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.incentive.RewardPeriod
         * @instance
         */
        RewardPeriod.prototype.collateral_type = '';

        /**
         * RewardPeriod start.
         * @member {google.protobuf.ITimestamp|null|undefined} start
         * @memberof ununifi.incentive.RewardPeriod
         * @instance
         */
        RewardPeriod.prototype.start = null;

        /**
         * RewardPeriod end.
         * @member {google.protobuf.ITimestamp|null|undefined} end
         * @memberof ununifi.incentive.RewardPeriod
         * @instance
         */
        RewardPeriod.prototype.end = null;

        /**
         * RewardPeriod rewards_per_second.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} rewards_per_second
         * @memberof ununifi.incentive.RewardPeriod
         * @instance
         */
        RewardPeriod.prototype.rewards_per_second = null;

        /**
         * Encodes the specified RewardPeriod message. Does not implicitly {@link ununifi.incentive.RewardPeriod.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.RewardPeriod
         * @static
         * @param {ununifi.incentive.IRewardPeriod} message RewardPeriod message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardPeriod.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.active != null && Object.hasOwnProperty.call(message, 'active'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.active);
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
          if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
            $root.google.protobuf.Timestamp.encode(message.start, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            $root.google.protobuf.Timestamp.encode(message.end, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          if (message.rewards_per_second != null && Object.hasOwnProperty.call(message, 'rewards_per_second'))
            $root.cosmos.base.v1beta1.Coin.encode(message.rewards_per_second, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified RewardPeriod message, length delimited. Does not implicitly {@link ununifi.incentive.RewardPeriod.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.RewardPeriod
         * @static
         * @param {ununifi.incentive.IRewardPeriod} message RewardPeriod message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RewardPeriod.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RewardPeriod message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.RewardPeriod
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.RewardPeriod} RewardPeriod
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardPeriod.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.RewardPeriod();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.active = reader.bool();
                break;
              case 2:
                message.collateral_type = reader.string();
                break;
              case 3:
                message.start = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 4:
                message.end = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 5:
                message.rewards_per_second = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RewardPeriod message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.RewardPeriod
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.RewardPeriod} RewardPeriod
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RewardPeriod.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RewardPeriod message.
         * @function verify
         * @memberof ununifi.incentive.RewardPeriod
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RewardPeriod.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.active != null && message.hasOwnProperty('active'))
            if (typeof message.active !== 'boolean') return 'active: boolean expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          if (message.start != null && message.hasOwnProperty('start')) {
            var error = $root.google.protobuf.Timestamp.verify(message.start);
            if (error) return 'start.' + error;
          }
          if (message.end != null && message.hasOwnProperty('end')) {
            var error = $root.google.protobuf.Timestamp.verify(message.end);
            if (error) return 'end.' + error;
          }
          if (message.rewards_per_second != null && message.hasOwnProperty('rewards_per_second')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards_per_second);
            if (error) return 'rewards_per_second.' + error;
          }
          return null;
        };

        /**
         * Creates a RewardPeriod message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.RewardPeriod
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.RewardPeriod} RewardPeriod
         */
        RewardPeriod.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.RewardPeriod) return object;
          var message = new $root.ununifi.incentive.RewardPeriod();
          if (object.active != null) message.active = Boolean(object.active);
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          if (object.start != null) {
            if (typeof object.start !== 'object') throw TypeError('.ununifi.incentive.RewardPeriod.start: object expected');
            message.start = $root.google.protobuf.Timestamp.fromObject(object.start);
          }
          if (object.end != null) {
            if (typeof object.end !== 'object') throw TypeError('.ununifi.incentive.RewardPeriod.end: object expected');
            message.end = $root.google.protobuf.Timestamp.fromObject(object.end);
          }
          if (object.rewards_per_second != null) {
            if (typeof object.rewards_per_second !== 'object')
              throw TypeError('.ununifi.incentive.RewardPeriod.rewards_per_second: object expected');
            message.rewards_per_second = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards_per_second);
          }
          return message;
        };

        /**
         * Creates a plain object from a RewardPeriod message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.RewardPeriod
         * @static
         * @param {ununifi.incentive.RewardPeriod} message RewardPeriod
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RewardPeriod.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.active = false;
            object.collateral_type = '';
            object.start = null;
            object.end = null;
            object.rewards_per_second = null;
          }
          if (message.active != null && message.hasOwnProperty('active')) object.active = message.active;
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          if (message.start != null && message.hasOwnProperty('start'))
            object.start = $root.google.protobuf.Timestamp.toObject(message.start, options);
          if (message.end != null && message.hasOwnProperty('end'))
            object.end = $root.google.protobuf.Timestamp.toObject(message.end, options);
          if (message.rewards_per_second != null && message.hasOwnProperty('rewards_per_second'))
            object.rewards_per_second = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards_per_second, options);
          return object;
        };

        /**
         * Converts this RewardPeriod to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.RewardPeriod
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RewardPeriod.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RewardPeriod;
      })();

      incentive.Multiplier = (function () {
        /**
         * Properties of a Multiplier.
         * @memberof ununifi.incentive
         * @interface IMultiplier
         * @property {string|null} [name] Multiplier name
         * @property {Long|null} [months_lockup] Multiplier months_lockup
         * @property {string|null} [factor] Multiplier factor
         */

        /**
         * Constructs a new Multiplier.
         * @memberof ununifi.incentive
         * @classdesc Represents a Multiplier.
         * @implements IMultiplier
         * @constructor
         * @param {ununifi.incentive.IMultiplier=} [properties] Properties to set
         */
        function Multiplier(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Multiplier name.
         * @member {string} name
         * @memberof ununifi.incentive.Multiplier
         * @instance
         */
        Multiplier.prototype.name = '';

        /**
         * Multiplier months_lockup.
         * @member {Long} months_lockup
         * @memberof ununifi.incentive.Multiplier
         * @instance
         */
        Multiplier.prototype.months_lockup = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Multiplier factor.
         * @member {string} factor
         * @memberof ununifi.incentive.Multiplier
         * @instance
         */
        Multiplier.prototype.factor = '';

        /**
         * Encodes the specified Multiplier message. Does not implicitly {@link ununifi.incentive.Multiplier.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.Multiplier
         * @static
         * @param {ununifi.incentive.IMultiplier} message Multiplier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Multiplier.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.months_lockup != null && Object.hasOwnProperty.call(message, 'months_lockup'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.months_lockup);
          if (message.factor != null && Object.hasOwnProperty.call(message, 'factor'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.factor);
          return writer;
        };

        /**
         * Encodes the specified Multiplier message, length delimited. Does not implicitly {@link ununifi.incentive.Multiplier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.Multiplier
         * @static
         * @param {ununifi.incentive.IMultiplier} message Multiplier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Multiplier.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Multiplier message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.Multiplier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.Multiplier} Multiplier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Multiplier.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.Multiplier();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message.months_lockup = reader.int64();
                break;
              case 3:
                message.factor = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Multiplier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.Multiplier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.Multiplier} Multiplier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Multiplier.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Multiplier message.
         * @function verify
         * @memberof ununifi.incentive.Multiplier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Multiplier.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.months_lockup != null && message.hasOwnProperty('months_lockup'))
            if (
              !$util.isInteger(message.months_lockup) &&
              !(message.months_lockup && $util.isInteger(message.months_lockup.low) && $util.isInteger(message.months_lockup.high))
            )
              return 'months_lockup: integer|Long expected';
          if (message.factor != null && message.hasOwnProperty('factor'))
            if (!$util.isString(message.factor)) return 'factor: string expected';
          return null;
        };

        /**
         * Creates a Multiplier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.Multiplier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.Multiplier} Multiplier
         */
        Multiplier.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.Multiplier) return object;
          var message = new $root.ununifi.incentive.Multiplier();
          if (object.name != null) message.name = String(object.name);
          if (object.months_lockup != null)
            if ($util.Long) (message.months_lockup = $util.Long.fromValue(object.months_lockup)).unsigned = false;
            else if (typeof object.months_lockup === 'string') message.months_lockup = parseInt(object.months_lockup, 10);
            else if (typeof object.months_lockup === 'number') message.months_lockup = object.months_lockup;
            else if (typeof object.months_lockup === 'object')
              message.months_lockup = new $util.LongBits(object.months_lockup.low >>> 0, object.months_lockup.high >>> 0).toNumber();
          if (object.factor != null) message.factor = String(object.factor);
          return message;
        };

        /**
         * Creates a plain object from a Multiplier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.Multiplier
         * @static
         * @param {ununifi.incentive.Multiplier} message Multiplier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Multiplier.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.months_lockup = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.months_lockup = options.longs === String ? '0' : 0;
            object.factor = '';
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.months_lockup != null && message.hasOwnProperty('months_lockup'))
            if (typeof message.months_lockup === 'number')
              object.months_lockup = options.longs === String ? String(message.months_lockup) : message.months_lockup;
            else
              object.months_lockup =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.months_lockup)
                  : options.longs === Number
                  ? new $util.LongBits(message.months_lockup.low >>> 0, message.months_lockup.high >>> 0).toNumber()
                  : message.months_lockup;
          if (message.factor != null && message.hasOwnProperty('factor')) object.factor = message.factor;
          return object;
        };

        /**
         * Converts this Multiplier to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.Multiplier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Multiplier.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Multiplier;
      })();

      incentive.Msg = (function () {
        /**
         * Constructs a new Msg service.
         * @memberof ununifi.incentive
         * @classdesc Represents a Msg
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Msg(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

        /**
         * Callback as used by {@link ununifi.incentive.Msg#claimCdpMintingReward}.
         * @memberof ununifi.incentive.Msg
         * @typedef ClaimCdpMintingRewardCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.incentive.MsgClaimCdpMintingRewardResponse} [response] MsgClaimCdpMintingRewardResponse
         */

        /**
         * Calls ClaimCdpMintingReward.
         * @function claimCdpMintingReward
         * @memberof ununifi.incentive.Msg
         * @instance
         * @param {ununifi.incentive.IMsgClaimCdpMintingReward} request MsgClaimCdpMintingReward message or plain object
         * @param {ununifi.incentive.Msg.ClaimCdpMintingRewardCallback} callback Node-style callback called with the error, if any, and MsgClaimCdpMintingRewardResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.claimCdpMintingReward = function claimCdpMintingReward(request, callback) {
            return this.rpcCall(
              claimCdpMintingReward,
              $root.ununifi.incentive.MsgClaimCdpMintingReward,
              $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ClaimCdpMintingReward' },
        );

        /**
         * Calls ClaimCdpMintingReward.
         * @function claimCdpMintingReward
         * @memberof ununifi.incentive.Msg
         * @instance
         * @param {ununifi.incentive.IMsgClaimCdpMintingReward} request MsgClaimCdpMintingReward message or plain object
         * @returns {Promise<ununifi.incentive.MsgClaimCdpMintingRewardResponse>} Promise
         * @variation 2
         */

        return Msg;
      })();

      incentive.MsgClaimCdpMintingReward = (function () {
        /**
         * Properties of a MsgClaimCdpMintingReward.
         * @memberof ununifi.incentive
         * @interface IMsgClaimCdpMintingReward
         * @property {string|null} [sender] MsgClaimCdpMintingReward sender
         * @property {string|null} [multiplier_name] MsgClaimCdpMintingReward multiplier_name
         */

        /**
         * Constructs a new MsgClaimCdpMintingReward.
         * @memberof ununifi.incentive
         * @classdesc Represents a MsgClaimCdpMintingReward.
         * @implements IMsgClaimCdpMintingReward
         * @constructor
         * @param {ununifi.incentive.IMsgClaimCdpMintingReward=} [properties] Properties to set
         */
        function MsgClaimCdpMintingReward(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgClaimCdpMintingReward sender.
         * @member {string} sender
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @instance
         */
        MsgClaimCdpMintingReward.prototype.sender = '';

        /**
         * MsgClaimCdpMintingReward multiplier_name.
         * @member {string} multiplier_name
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @instance
         */
        MsgClaimCdpMintingReward.prototype.multiplier_name = '';

        /**
         * Encodes the specified MsgClaimCdpMintingReward message. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingReward.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @static
         * @param {ununifi.incentive.IMsgClaimCdpMintingReward} message MsgClaimCdpMintingReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgClaimCdpMintingReward.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.multiplier_name != null && Object.hasOwnProperty.call(message, 'multiplier_name'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.multiplier_name);
          return writer;
        };

        /**
         * Encodes the specified MsgClaimCdpMintingReward message, length delimited. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @static
         * @param {ununifi.incentive.IMsgClaimCdpMintingReward} message MsgClaimCdpMintingReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgClaimCdpMintingReward.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgClaimCdpMintingReward message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.MsgClaimCdpMintingReward} MsgClaimCdpMintingReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgClaimCdpMintingReward.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.MsgClaimCdpMintingReward();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.multiplier_name = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgClaimCdpMintingReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.MsgClaimCdpMintingReward} MsgClaimCdpMintingReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgClaimCdpMintingReward.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgClaimCdpMintingReward message.
         * @function verify
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgClaimCdpMintingReward.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.multiplier_name != null && message.hasOwnProperty('multiplier_name'))
            if (!$util.isString(message.multiplier_name)) return 'multiplier_name: string expected';
          return null;
        };

        /**
         * Creates a MsgClaimCdpMintingReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.MsgClaimCdpMintingReward} MsgClaimCdpMintingReward
         */
        MsgClaimCdpMintingReward.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.MsgClaimCdpMintingReward) return object;
          var message = new $root.ununifi.incentive.MsgClaimCdpMintingReward();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.multiplier_name != null) message.multiplier_name = String(object.multiplier_name);
          return message;
        };

        /**
         * Creates a plain object from a MsgClaimCdpMintingReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @static
         * @param {ununifi.incentive.MsgClaimCdpMintingReward} message MsgClaimCdpMintingReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgClaimCdpMintingReward.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.multiplier_name = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.multiplier_name != null && message.hasOwnProperty('multiplier_name'))
            object.multiplier_name = message.multiplier_name;
          return object;
        };

        /**
         * Converts this MsgClaimCdpMintingReward to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.MsgClaimCdpMintingReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgClaimCdpMintingReward.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgClaimCdpMintingReward;
      })();

      incentive.MsgClaimCdpMintingRewardResponse = (function () {
        /**
         * Properties of a MsgClaimCdpMintingRewardResponse.
         * @memberof ununifi.incentive
         * @interface IMsgClaimCdpMintingRewardResponse
         */

        /**
         * Constructs a new MsgClaimCdpMintingRewardResponse.
         * @memberof ununifi.incentive
         * @classdesc Represents a MsgClaimCdpMintingRewardResponse.
         * @implements IMsgClaimCdpMintingRewardResponse
         * @constructor
         * @param {ununifi.incentive.IMsgClaimCdpMintingRewardResponse=} [properties] Properties to set
         */
        function MsgClaimCdpMintingRewardResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgClaimCdpMintingRewardResponse message. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingRewardResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @static
         * @param {ununifi.incentive.IMsgClaimCdpMintingRewardResponse} message MsgClaimCdpMintingRewardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgClaimCdpMintingRewardResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgClaimCdpMintingRewardResponse message, length delimited. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingRewardResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @static
         * @param {ununifi.incentive.IMsgClaimCdpMintingRewardResponse} message MsgClaimCdpMintingRewardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgClaimCdpMintingRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgClaimCdpMintingRewardResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.MsgClaimCdpMintingRewardResponse} MsgClaimCdpMintingRewardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgClaimCdpMintingRewardResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgClaimCdpMintingRewardResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.MsgClaimCdpMintingRewardResponse} MsgClaimCdpMintingRewardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgClaimCdpMintingRewardResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgClaimCdpMintingRewardResponse message.
         * @function verify
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgClaimCdpMintingRewardResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgClaimCdpMintingRewardResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.MsgClaimCdpMintingRewardResponse} MsgClaimCdpMintingRewardResponse
         */
        MsgClaimCdpMintingRewardResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse) return object;
          return new $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse();
        };

        /**
         * Creates a plain object from a MsgClaimCdpMintingRewardResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @static
         * @param {ununifi.incentive.MsgClaimCdpMintingRewardResponse} message MsgClaimCdpMintingRewardResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgClaimCdpMintingRewardResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgClaimCdpMintingRewardResponse to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgClaimCdpMintingRewardResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgClaimCdpMintingRewardResponse;
      })();

      incentive.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.incentive
         * @interface IGenesisState
         * @property {ununifi.incentive.IParams|null} [params] GenesisState params
         * @property {Array.<ununifi.incentive.IGenesisAccumulationTime>|null} [cdp_accumulation_times] GenesisState cdp_accumulation_times
         * @property {Array.<ununifi.incentive.ICdpMintingClaim>|null} [cdp_minting_claims] GenesisState cdp_minting_claims
         * @property {ununifi.incentive.IGenesisDenoms|null} [denoms] GenesisState denoms
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.incentive
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.incentive.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          this.cdp_accumulation_times = [];
          this.cdp_minting_claims = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState params.
         * @member {ununifi.incentive.IParams|null|undefined} params
         * @memberof ununifi.incentive.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * GenesisState cdp_accumulation_times.
         * @member {Array.<ununifi.incentive.IGenesisAccumulationTime>} cdp_accumulation_times
         * @memberof ununifi.incentive.GenesisState
         * @instance
         */
        GenesisState.prototype.cdp_accumulation_times = $util.emptyArray;

        /**
         * GenesisState cdp_minting_claims.
         * @member {Array.<ununifi.incentive.ICdpMintingClaim>} cdp_minting_claims
         * @memberof ununifi.incentive.GenesisState
         * @instance
         */
        GenesisState.prototype.cdp_minting_claims = $util.emptyArray;

        /**
         * GenesisState denoms.
         * @member {ununifi.incentive.IGenesisDenoms|null|undefined} denoms
         * @memberof ununifi.incentive.GenesisState
         * @instance
         */
        GenesisState.prototype.denoms = null;

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.incentive.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.GenesisState
         * @static
         * @param {ununifi.incentive.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.incentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.cdp_accumulation_times != null && message.cdp_accumulation_times.length)
            for (var i = 0; i < message.cdp_accumulation_times.length; ++i)
              $root.ununifi.incentive.GenesisAccumulationTime.encode(
                message.cdp_accumulation_times[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.cdp_minting_claims != null && message.cdp_minting_claims.length)
            for (var i = 0; i < message.cdp_minting_claims.length; ++i)
              $root.ununifi.incentive.CdpMintingClaim.encode(
                message.cdp_minting_claims[i],
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
          if (message.denoms != null && Object.hasOwnProperty.call(message, 'denoms'))
            $root.ununifi.incentive.GenesisDenoms.encode(message.denoms, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.incentive.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.GenesisState
         * @static
         * @param {ununifi.incentive.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.incentive.Params.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message.cdp_accumulation_times && message.cdp_accumulation_times.length)) message.cdp_accumulation_times = [];
                message.cdp_accumulation_times.push($root.ununifi.incentive.GenesisAccumulationTime.decode(reader, reader.uint32()));
                break;
              case 3:
                if (!(message.cdp_minting_claims && message.cdp_minting_claims.length)) message.cdp_minting_claims = [];
                message.cdp_minting_claims.push($root.ununifi.incentive.CdpMintingClaim.decode(reader, reader.uint32()));
                break;
              case 4:
                message.denoms = $root.ununifi.incentive.GenesisDenoms.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.incentive.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.incentive.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          if (message.cdp_accumulation_times != null && message.hasOwnProperty('cdp_accumulation_times')) {
            if (!Array.isArray(message.cdp_accumulation_times)) return 'cdp_accumulation_times: array expected';
            for (var i = 0; i < message.cdp_accumulation_times.length; ++i) {
              var error = $root.ununifi.incentive.GenesisAccumulationTime.verify(message.cdp_accumulation_times[i]);
              if (error) return 'cdp_accumulation_times.' + error;
            }
          }
          if (message.cdp_minting_claims != null && message.hasOwnProperty('cdp_minting_claims')) {
            if (!Array.isArray(message.cdp_minting_claims)) return 'cdp_minting_claims: array expected';
            for (var i = 0; i < message.cdp_minting_claims.length; ++i) {
              var error = $root.ununifi.incentive.CdpMintingClaim.verify(message.cdp_minting_claims[i]);
              if (error) return 'cdp_minting_claims.' + error;
            }
          }
          if (message.denoms != null && message.hasOwnProperty('denoms')) {
            var error = $root.ununifi.incentive.GenesisDenoms.verify(message.denoms);
            if (error) return 'denoms.' + error;
          }
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.GenesisState) return object;
          var message = new $root.ununifi.incentive.GenesisState();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.incentive.GenesisState.params: object expected');
            message.params = $root.ununifi.incentive.Params.fromObject(object.params);
          }
          if (object.cdp_accumulation_times) {
            if (!Array.isArray(object.cdp_accumulation_times))
              throw TypeError('.ununifi.incentive.GenesisState.cdp_accumulation_times: array expected');
            message.cdp_accumulation_times = [];
            for (var i = 0; i < object.cdp_accumulation_times.length; ++i) {
              if (typeof object.cdp_accumulation_times[i] !== 'object')
                throw TypeError('.ununifi.incentive.GenesisState.cdp_accumulation_times: object expected');
              message.cdp_accumulation_times[i] = $root.ununifi.incentive.GenesisAccumulationTime.fromObject(
                object.cdp_accumulation_times[i],
              );
            }
          }
          if (object.cdp_minting_claims) {
            if (!Array.isArray(object.cdp_minting_claims))
              throw TypeError('.ununifi.incentive.GenesisState.cdp_minting_claims: array expected');
            message.cdp_minting_claims = [];
            for (var i = 0; i < object.cdp_minting_claims.length; ++i) {
              if (typeof object.cdp_minting_claims[i] !== 'object')
                throw TypeError('.ununifi.incentive.GenesisState.cdp_minting_claims: object expected');
              message.cdp_minting_claims[i] = $root.ununifi.incentive.CdpMintingClaim.fromObject(object.cdp_minting_claims[i]);
            }
          }
          if (object.denoms != null) {
            if (typeof object.denoms !== 'object') throw TypeError('.ununifi.incentive.GenesisState.denoms: object expected');
            message.denoms = $root.ununifi.incentive.GenesisDenoms.fromObject(object.denoms);
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.GenesisState
         * @static
         * @param {ununifi.incentive.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.cdp_accumulation_times = [];
            object.cdp_minting_claims = [];
          }
          if (options.defaults) {
            object.params = null;
            object.denoms = null;
          }
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.incentive.Params.toObject(message.params, options);
          if (message.cdp_accumulation_times && message.cdp_accumulation_times.length) {
            object.cdp_accumulation_times = [];
            for (var j = 0; j < message.cdp_accumulation_times.length; ++j)
              object.cdp_accumulation_times[j] = $root.ununifi.incentive.GenesisAccumulationTime.toObject(
                message.cdp_accumulation_times[j],
                options,
              );
          }
          if (message.cdp_minting_claims && message.cdp_minting_claims.length) {
            object.cdp_minting_claims = [];
            for (var j = 0; j < message.cdp_minting_claims.length; ++j)
              object.cdp_minting_claims[j] = $root.ununifi.incentive.CdpMintingClaim.toObject(message.cdp_minting_claims[j], options);
          }
          if (message.denoms != null && message.hasOwnProperty('denoms'))
            object.denoms = $root.ununifi.incentive.GenesisDenoms.toObject(message.denoms, options);
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      incentive.GenesisAccumulationTime = (function () {
        /**
         * Properties of a GenesisAccumulationTime.
         * @memberof ununifi.incentive
         * @interface IGenesisAccumulationTime
         * @property {string|null} [collateral_type] GenesisAccumulationTime collateral_type
         * @property {google.protobuf.ITimestamp|null} [previous_accumulation_time] GenesisAccumulationTime previous_accumulation_time
         */

        /**
         * Constructs a new GenesisAccumulationTime.
         * @memberof ununifi.incentive
         * @classdesc Represents a GenesisAccumulationTime.
         * @implements IGenesisAccumulationTime
         * @constructor
         * @param {ununifi.incentive.IGenesisAccumulationTime=} [properties] Properties to set
         */
        function GenesisAccumulationTime(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisAccumulationTime collateral_type.
         * @member {string} collateral_type
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @instance
         */
        GenesisAccumulationTime.prototype.collateral_type = '';

        /**
         * GenesisAccumulationTime previous_accumulation_time.
         * @member {google.protobuf.ITimestamp|null|undefined} previous_accumulation_time
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @instance
         */
        GenesisAccumulationTime.prototype.previous_accumulation_time = null;

        /**
         * Encodes the specified GenesisAccumulationTime message. Does not implicitly {@link ununifi.incentive.GenesisAccumulationTime.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @static
         * @param {ununifi.incentive.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisAccumulationTime.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
          if (message.previous_accumulation_time != null && Object.hasOwnProperty.call(message, 'previous_accumulation_time'))
            $root.google.protobuf.Timestamp.encode(
              message.previous_accumulation_time,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisAccumulationTime message, length delimited. Does not implicitly {@link ununifi.incentive.GenesisAccumulationTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @static
         * @param {ununifi.incentive.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisAccumulationTime.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisAccumulationTime message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.GenesisAccumulationTime} GenesisAccumulationTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisAccumulationTime.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.GenesisAccumulationTime();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.collateral_type = reader.string();
                break;
              case 2:
                message.previous_accumulation_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisAccumulationTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.GenesisAccumulationTime} GenesisAccumulationTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisAccumulationTime.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisAccumulationTime message.
         * @function verify
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisAccumulationTime.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
          if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time')) {
            var error = $root.google.protobuf.Timestamp.verify(message.previous_accumulation_time);
            if (error) return 'previous_accumulation_time.' + error;
          }
          return null;
        };

        /**
         * Creates a GenesisAccumulationTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.GenesisAccumulationTime} GenesisAccumulationTime
         */
        GenesisAccumulationTime.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.GenesisAccumulationTime) return object;
          var message = new $root.ununifi.incentive.GenesisAccumulationTime();
          if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
          if (object.previous_accumulation_time != null) {
            if (typeof object.previous_accumulation_time !== 'object')
              throw TypeError('.ununifi.incentive.GenesisAccumulationTime.previous_accumulation_time: object expected');
            message.previous_accumulation_time = $root.google.protobuf.Timestamp.fromObject(object.previous_accumulation_time);
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisAccumulationTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @static
         * @param {ununifi.incentive.GenesisAccumulationTime} message GenesisAccumulationTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisAccumulationTime.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.collateral_type = '';
            object.previous_accumulation_time = null;
          }
          if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
            object.collateral_type = message.collateral_type;
          if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time'))
            object.previous_accumulation_time = $root.google.protobuf.Timestamp.toObject(message.previous_accumulation_time, options);
          return object;
        };

        /**
         * Converts this GenesisAccumulationTime to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.GenesisAccumulationTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisAccumulationTime.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisAccumulationTime;
      })();

      incentive.GenesisDenoms = (function () {
        /**
         * Properties of a GenesisDenoms.
         * @memberof ununifi.incentive
         * @interface IGenesisDenoms
         * @property {string|null} [principal_denom] GenesisDenoms principal_denom
         * @property {string|null} [cdp_minting_reward_denom] GenesisDenoms cdp_minting_reward_denom
         */

        /**
         * Constructs a new GenesisDenoms.
         * @memberof ununifi.incentive
         * @classdesc Represents a GenesisDenoms.
         * @implements IGenesisDenoms
         * @constructor
         * @param {ununifi.incentive.IGenesisDenoms=} [properties] Properties to set
         */
        function GenesisDenoms(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisDenoms principal_denom.
         * @member {string} principal_denom
         * @memberof ununifi.incentive.GenesisDenoms
         * @instance
         */
        GenesisDenoms.prototype.principal_denom = '';

        /**
         * GenesisDenoms cdp_minting_reward_denom.
         * @member {string} cdp_minting_reward_denom
         * @memberof ununifi.incentive.GenesisDenoms
         * @instance
         */
        GenesisDenoms.prototype.cdp_minting_reward_denom = '';

        /**
         * Encodes the specified GenesisDenoms message. Does not implicitly {@link ununifi.incentive.GenesisDenoms.verify|verify} messages.
         * @function encode
         * @memberof ununifi.incentive.GenesisDenoms
         * @static
         * @param {ununifi.incentive.IGenesisDenoms} message GenesisDenoms message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisDenoms.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.principal_denom != null && Object.hasOwnProperty.call(message, 'principal_denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.principal_denom);
          if (message.cdp_minting_reward_denom != null && Object.hasOwnProperty.call(message, 'cdp_minting_reward_denom'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.cdp_minting_reward_denom);
          return writer;
        };

        /**
         * Encodes the specified GenesisDenoms message, length delimited. Does not implicitly {@link ununifi.incentive.GenesisDenoms.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.incentive.GenesisDenoms
         * @static
         * @param {ununifi.incentive.IGenesisDenoms} message GenesisDenoms message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisDenoms.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisDenoms message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.incentive.GenesisDenoms
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.incentive.GenesisDenoms} GenesisDenoms
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisDenoms.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.incentive.GenesisDenoms();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.principal_denom = reader.string();
                break;
              case 2:
                message.cdp_minting_reward_denom = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisDenoms message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.incentive.GenesisDenoms
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.incentive.GenesisDenoms} GenesisDenoms
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisDenoms.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisDenoms message.
         * @function verify
         * @memberof ununifi.incentive.GenesisDenoms
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisDenoms.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.principal_denom != null && message.hasOwnProperty('principal_denom'))
            if (!$util.isString(message.principal_denom)) return 'principal_denom: string expected';
          if (message.cdp_minting_reward_denom != null && message.hasOwnProperty('cdp_minting_reward_denom'))
            if (!$util.isString(message.cdp_minting_reward_denom)) return 'cdp_minting_reward_denom: string expected';
          return null;
        };

        /**
         * Creates a GenesisDenoms message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.incentive.GenesisDenoms
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.incentive.GenesisDenoms} GenesisDenoms
         */
        GenesisDenoms.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.incentive.GenesisDenoms) return object;
          var message = new $root.ununifi.incentive.GenesisDenoms();
          if (object.principal_denom != null) message.principal_denom = String(object.principal_denom);
          if (object.cdp_minting_reward_denom != null) message.cdp_minting_reward_denom = String(object.cdp_minting_reward_denom);
          return message;
        };

        /**
         * Creates a plain object from a GenesisDenoms message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.incentive.GenesisDenoms
         * @static
         * @param {ununifi.incentive.GenesisDenoms} message GenesisDenoms
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisDenoms.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.principal_denom = '';
            object.cdp_minting_reward_denom = '';
          }
          if (message.principal_denom != null && message.hasOwnProperty('principal_denom'))
            object.principal_denom = message.principal_denom;
          if (message.cdp_minting_reward_denom != null && message.hasOwnProperty('cdp_minting_reward_denom'))
            object.cdp_minting_reward_denom = message.cdp_minting_reward_denom;
          return object;
        };

        /**
         * Converts this GenesisDenoms to JSON.
         * @function toJSON
         * @memberof ununifi.incentive.GenesisDenoms
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisDenoms.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisDenoms;
      })();

      return incentive;
    })();

    ununifi.nftmarket = (function () {
      /**
       * Namespace nftmarket.
       * @memberof ununifi
       * @namespace
       */
      var nftmarket = {};

      nftmarket.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#params}.
         * @memberof ununifi.nftmarket.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.nftmarket.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(
              params,
              $root.ununifi.nftmarket.QueryParamsRequest,
              $root.ununifi.nftmarket.QueryParamsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryParamsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#nftListing}.
         * @memberof ununifi.nftmarket.Query
         * @typedef NftListingCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryNftListingResponse} [response] QueryNftListingResponse
         */

        /**
         * Calls NftListing.
         * @function nftListing
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryNftListingRequest} request QueryNftListingRequest message or plain object
         * @param {ununifi.nftmarket.Query.NftListingCallback} callback Node-style callback called with the error, if any, and QueryNftListingResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.nftListing = function nftListing(request, callback) {
            return this.rpcCall(
              nftListing,
              $root.ununifi.nftmarket.QueryNftListingRequest,
              $root.ununifi.nftmarket.QueryNftListingResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'NftListing' },
        );

        /**
         * Calls NftListing.
         * @function nftListing
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryNftListingRequest} request QueryNftListingRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryNftListingResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#listedNfts}.
         * @memberof ununifi.nftmarket.Query
         * @typedef ListedNftsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryListedNftsResponse} [response] QueryListedNftsResponse
         */

        /**
         * Calls ListedNfts.
         * @function listedNfts
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
         * @param {ununifi.nftmarket.Query.ListedNftsCallback} callback Node-style callback called with the error, if any, and QueryListedNftsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.listedNfts = function listedNfts(request, callback) {
            return this.rpcCall(
              listedNfts,
              $root.ununifi.nftmarket.QueryListedNftsRequest,
              $root.ununifi.nftmarket.QueryListedNftsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ListedNfts' },
        );

        /**
         * Calls ListedNfts.
         * @function listedNfts
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryListedNftsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#listedClasses}.
         * @memberof ununifi.nftmarket.Query
         * @typedef ListedClassesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryListedClassesResponse} [response] QueryListedClassesResponse
         */

        /**
         * Calls ListedClasses.
         * @function listedClasses
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
         * @param {ununifi.nftmarket.Query.ListedClassesCallback} callback Node-style callback called with the error, if any, and QueryListedClassesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.listedClasses = function listedClasses(request, callback) {
            return this.rpcCall(
              listedClasses,
              $root.ununifi.nftmarket.QueryListedClassesRequest,
              $root.ununifi.nftmarket.QueryListedClassesResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ListedClasses' },
        );

        /**
         * Calls ListedClasses.
         * @function listedClasses
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryListedClassesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#listedClass}.
         * @memberof ununifi.nftmarket.Query
         * @typedef ListedClassCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryListedClassResponse} [response] QueryListedClassResponse
         */

        /**
         * Calls ListedClass.
         * @function listedClass
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
         * @param {ununifi.nftmarket.Query.ListedClassCallback} callback Node-style callback called with the error, if any, and QueryListedClassResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.listedClass = function listedClass(request, callback) {
            return this.rpcCall(
              listedClass,
              $root.ununifi.nftmarket.QueryListedClassRequest,
              $root.ununifi.nftmarket.QueryListedClassResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ListedClass' },
        );

        /**
         * Calls ListedClass.
         * @function listedClass
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryListedClassResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#loans}.
         * @memberof ununifi.nftmarket.Query
         * @typedef LoansCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryLoansResponse} [response] QueryLoansResponse
         */

        /**
         * Calls Loans.
         * @function loans
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryLoansRequest} request QueryLoansRequest message or plain object
         * @param {ununifi.nftmarket.Query.LoansCallback} callback Node-style callback called with the error, if any, and QueryLoansResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.loans = function loans(request, callback) {
            return this.rpcCall(
              loans,
              $root.ununifi.nftmarket.QueryLoansRequest,
              $root.ununifi.nftmarket.QueryLoansResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Loans' },
        );

        /**
         * Calls Loans.
         * @function loans
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryLoansRequest} request QueryLoansRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryLoansResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#loan}.
         * @memberof ununifi.nftmarket.Query
         * @typedef LoanCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryLoanResponse} [response] QueryLoanResponse
         */

        /**
         * Calls Loan.
         * @function loan
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryLoanRequest} request QueryLoanRequest message or plain object
         * @param {ununifi.nftmarket.Query.LoanCallback} callback Node-style callback called with the error, if any, and QueryLoanResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.loan = function loan(request, callback) {
            return this.rpcCall(
              loan,
              $root.ununifi.nftmarket.QueryLoanRequest,
              $root.ununifi.nftmarket.QueryLoanResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Loan' },
        );

        /**
         * Calls Loan.
         * @function loan
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryLoanRequest} request QueryLoanRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryLoanResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#cDPsList}.
         * @memberof ununifi.nftmarket.Query
         * @typedef CDPsListCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryCDPsListResponse} [response] QueryCDPsListResponse
         */

        /**
         * Calls CDPsList.
         * @function cDPsList
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryCDPsListRequest} request QueryCDPsListRequest message or plain object
         * @param {ununifi.nftmarket.Query.CDPsListCallback} callback Node-style callback called with the error, if any, and QueryCDPsListResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.cDPsList = function cDPsList(request, callback) {
            return this.rpcCall(
              cDPsList,
              $root.ununifi.nftmarket.QueryCDPsListRequest,
              $root.ununifi.nftmarket.QueryCDPsListResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'CDPsList' },
        );

        /**
         * Calls CDPsList.
         * @function cDPsList
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryCDPsListRequest} request QueryCDPsListRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryCDPsListResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#nftBids}.
         * @memberof ununifi.nftmarket.Query
         * @typedef NftBidsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryNftBidsResponse} [response] QueryNftBidsResponse
         */

        /**
         * Calls NftBids.
         * @function nftBids
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
         * @param {ununifi.nftmarket.Query.NftBidsCallback} callback Node-style callback called with the error, if any, and QueryNftBidsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.nftBids = function nftBids(request, callback) {
            return this.rpcCall(
              nftBids,
              $root.ununifi.nftmarket.QueryNftBidsRequest,
              $root.ununifi.nftmarket.QueryNftBidsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'NftBids' },
        );

        /**
         * Calls NftBids.
         * @function nftBids
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryNftBidsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#bidderBids}.
         * @memberof ununifi.nftmarket.Query
         * @typedef BidderBidsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryBidderBidsResponse} [response] QueryBidderBidsResponse
         */

        /**
         * Calls BidderBids.
         * @function bidderBids
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
         * @param {ununifi.nftmarket.Query.BidderBidsCallback} callback Node-style callback called with the error, if any, and QueryBidderBidsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.bidderBids = function bidderBids(request, callback) {
            return this.rpcCall(
              bidderBids,
              $root.ununifi.nftmarket.QueryBidderBidsRequest,
              $root.ununifi.nftmarket.QueryBidderBidsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'BidderBids' },
        );

        /**
         * Calls BidderBids.
         * @function bidderBids
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryBidderBidsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#paymentStatus}.
         * @memberof ununifi.nftmarket.Query
         * @typedef PaymentStatusCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryPaymentStatusResponse} [response] QueryPaymentStatusResponse
         */

        /**
         * Calls PaymentStatus.
         * @function paymentStatus
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} request QueryPaymentStatusRequest message or plain object
         * @param {ununifi.nftmarket.Query.PaymentStatusCallback} callback Node-style callback called with the error, if any, and QueryPaymentStatusResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.paymentStatus = function paymentStatus(request, callback) {
            return this.rpcCall(
              paymentStatus,
              $root.ununifi.nftmarket.QueryPaymentStatusRequest,
              $root.ununifi.nftmarket.QueryPaymentStatusResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'PaymentStatus' },
        );

        /**
         * Calls PaymentStatus.
         * @function paymentStatus
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} request QueryPaymentStatusRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryPaymentStatusResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Query#rewards}.
         * @memberof ununifi.nftmarket.Query
         * @typedef RewardsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.QueryRewardsResponse} [response] QueryRewardsResponse
         */

        /**
         * Calls Rewards.
         * @function rewards
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
         * @param {ununifi.nftmarket.Query.RewardsCallback} callback Node-style callback called with the error, if any, and QueryRewardsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.rewards = function rewards(request, callback) {
            return this.rpcCall(
              rewards,
              $root.ununifi.nftmarket.QueryRewardsRequest,
              $root.ununifi.nftmarket.QueryRewardsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Rewards' },
        );

        /**
         * Calls Rewards.
         * @function rewards
         * @memberof ununifi.nftmarket.Query
         * @instance
         * @param {ununifi.nftmarket.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
         * @returns {Promise<ununifi.nftmarket.QueryRewardsResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      nftmarket.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryParamsRequest) return object;
          return new $root.ununifi.nftmarket.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @static
         * @param {ununifi.nftmarket.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      nftmarket.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryParamsResponse
         * @property {ununifi.nftmarket.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.nftmarket.IParams|null|undefined} params
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.nftmarket.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.nftmarket.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.nftmarket.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryParamsResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmarket.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.nftmarket.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @static
         * @param {ununifi.nftmarket.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.nftmarket.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      nftmarket.QueryNftListingRequest = (function () {
        /**
         * Properties of a QueryNftListingRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryNftListingRequest
         * @property {string|null} [class_id] QueryNftListingRequest class_id
         * @property {string|null} [nft_id] QueryNftListingRequest nft_id
         */

        /**
         * Constructs a new QueryNftListingRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryNftListingRequest.
         * @implements IQueryNftListingRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryNftListingRequest=} [properties] Properties to set
         */
        function QueryNftListingRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryNftListingRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @instance
         */
        QueryNftListingRequest.prototype.class_id = '';

        /**
         * QueryNftListingRequest nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @instance
         */
        QueryNftListingRequest.prototype.nft_id = '';

        /**
         * Encodes the specified QueryNftListingRequest message. Does not implicitly {@link ununifi.nftmarket.QueryNftListingRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @static
         * @param {ununifi.nftmarket.IQueryNftListingRequest} message QueryNftListingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftListingRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified QueryNftListingRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftListingRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @static
         * @param {ununifi.nftmarket.IQueryNftListingRequest} message QueryNftListingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftListingRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryNftListingRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryNftListingRequest} QueryNftListingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftListingRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryNftListingRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryNftListingRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryNftListingRequest} QueryNftListingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftListingRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryNftListingRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryNftListingRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates a QueryNftListingRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryNftListingRequest} QueryNftListingRequest
         */
        QueryNftListingRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryNftListingRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryNftListingRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryNftListingRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @static
         * @param {ununifi.nftmarket.QueryNftListingRequest} message QueryNftListingRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryNftListingRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this QueryNftListingRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryNftListingRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryNftListingRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryNftListingRequest;
      })();

      nftmarket.QueryNftListingResponse = (function () {
        /**
         * Properties of a QueryNftListingResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryNftListingResponse
         * @property {ununifi.nftmarket.INftListing|null} [listing] QueryNftListingResponse listing
         */

        /**
         * Constructs a new QueryNftListingResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryNftListingResponse.
         * @implements IQueryNftListingResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryNftListingResponse=} [properties] Properties to set
         */
        function QueryNftListingResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryNftListingResponse listing.
         * @member {ununifi.nftmarket.INftListing|null|undefined} listing
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @instance
         */
        QueryNftListingResponse.prototype.listing = null;

        /**
         * Encodes the specified QueryNftListingResponse message. Does not implicitly {@link ununifi.nftmarket.QueryNftListingResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @static
         * @param {ununifi.nftmarket.IQueryNftListingResponse} message QueryNftListingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftListingResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.listing != null && Object.hasOwnProperty.call(message, 'listing'))
            $root.ununifi.nftmarket.NftListing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftListingResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @static
         * @param {ununifi.nftmarket.IQueryNftListingResponse} message QueryNftListingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryNftListingResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryNftListingResponse} QueryNftListingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftListingResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryNftListingResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.listing = $root.ununifi.nftmarket.NftListing.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryNftListingResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryNftListingResponse} QueryNftListingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryNftListingResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryNftListingResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.listing != null && message.hasOwnProperty('listing')) {
            var error = $root.ununifi.nftmarket.NftListing.verify(message.listing);
            if (error) return 'listing.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryNftListingResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryNftListingResponse} QueryNftListingResponse
         */
        QueryNftListingResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryNftListingResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryNftListingResponse();
          if (object.listing != null) {
            if (typeof object.listing !== 'object') throw TypeError('.ununifi.nftmarket.QueryNftListingResponse.listing: object expected');
            message.listing = $root.ununifi.nftmarket.NftListing.fromObject(object.listing);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryNftListingResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @static
         * @param {ununifi.nftmarket.QueryNftListingResponse} message QueryNftListingResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryNftListingResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.listing = null;
          if (message.listing != null && message.hasOwnProperty('listing'))
            object.listing = $root.ununifi.nftmarket.NftListing.toObject(message.listing, options);
          return object;
        };

        /**
         * Converts this QueryNftListingResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryNftListingResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryNftListingResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryNftListingResponse;
      })();

      nftmarket.QueryListedNftsRequest = (function () {
        /**
         * Properties of a QueryListedNftsRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryListedNftsRequest
         * @property {string|null} [owner] QueryListedNftsRequest owner
         */

        /**
         * Constructs a new QueryListedNftsRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryListedNftsRequest.
         * @implements IQueryListedNftsRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryListedNftsRequest=} [properties] Properties to set
         */
        function QueryListedNftsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryListedNftsRequest owner.
         * @member {string} owner
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @instance
         */
        QueryListedNftsRequest.prototype.owner = '';

        /**
         * Encodes the specified QueryListedNftsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedNftsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          return writer;
        };

        /**
         * Encodes the specified QueryListedNftsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedNftsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryListedNftsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryListedNftsRequest} QueryListedNftsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedNftsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryListedNftsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryListedNftsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryListedNftsRequest} QueryListedNftsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedNftsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryListedNftsRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryListedNftsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          return null;
        };

        /**
         * Creates a QueryListedNftsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryListedNftsRequest} QueryListedNftsRequest
         */
        QueryListedNftsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryListedNftsRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryListedNftsRequest();
          if (object.owner != null) message.owner = String(object.owner);
          return message;
        };

        /**
         * Creates a plain object from a QueryListedNftsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @static
         * @param {ununifi.nftmarket.QueryListedNftsRequest} message QueryListedNftsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryListedNftsRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.owner = '';
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          return object;
        };

        /**
         * Converts this QueryListedNftsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryListedNftsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryListedNftsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryListedNftsRequest;
      })();

      nftmarket.QueryListedClassesRequest = (function () {
        /**
         * Properties of a QueryListedClassesRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryListedClassesRequest
         * @property {number|null} [nft_limit] QueryListedClassesRequest nft_limit
         */

        /**
         * Constructs a new QueryListedClassesRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryListedClassesRequest.
         * @implements IQueryListedClassesRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryListedClassesRequest=} [properties] Properties to set
         */
        function QueryListedClassesRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryListedClassesRequest nft_limit.
         * @member {number} nft_limit
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @instance
         */
        QueryListedClassesRequest.prototype.nft_limit = 0;

        /**
         * Encodes the specified QueryListedClassesRequest message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassesRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.nft_limit != null && Object.hasOwnProperty.call(message, 'nft_limit'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.nft_limit);
          return writer;
        };

        /**
         * Encodes the specified QueryListedClassesRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassesRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryListedClassesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryListedClassesRequest} QueryListedClassesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassesRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryListedClassesRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.nft_limit = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryListedClassesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryListedClassesRequest} QueryListedClassesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassesRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryListedClassesRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryListedClassesRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.nft_limit != null && message.hasOwnProperty('nft_limit'))
            if (!$util.isInteger(message.nft_limit)) return 'nft_limit: integer expected';
          return null;
        };

        /**
         * Creates a QueryListedClassesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryListedClassesRequest} QueryListedClassesRequest
         */
        QueryListedClassesRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryListedClassesRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryListedClassesRequest();
          if (object.nft_limit != null) message.nft_limit = object.nft_limit | 0;
          return message;
        };

        /**
         * Creates a plain object from a QueryListedClassesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @static
         * @param {ununifi.nftmarket.QueryListedClassesRequest} message QueryListedClassesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryListedClassesRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.nft_limit = 0;
          if (message.nft_limit != null && message.hasOwnProperty('nft_limit')) object.nft_limit = message.nft_limit;
          return object;
        };

        /**
         * Converts this QueryListedClassesRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryListedClassesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryListedClassesRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryListedClassesRequest;
      })();

      nftmarket.QueryListedClassRequest = (function () {
        /**
         * Properties of a QueryListedClassRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryListedClassRequest
         * @property {string|null} [class_id] QueryListedClassRequest class_id
         * @property {number|null} [nft_limit] QueryListedClassRequest nft_limit
         */

        /**
         * Constructs a new QueryListedClassRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryListedClassRequest.
         * @implements IQueryListedClassRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryListedClassRequest=} [properties] Properties to set
         */
        function QueryListedClassRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryListedClassRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @instance
         */
        QueryListedClassRequest.prototype.class_id = '';

        /**
         * QueryListedClassRequest nft_limit.
         * @member {number} nft_limit
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @instance
         */
        QueryListedClassRequest.prototype.nft_limit = 0;

        /**
         * Encodes the specified QueryListedClassRequest message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_limit != null && Object.hasOwnProperty.call(message, 'nft_limit'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nft_limit);
          return writer;
        };

        /**
         * Encodes the specified QueryListedClassRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryListedClassRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryListedClassRequest} QueryListedClassRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryListedClassRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_limit = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryListedClassRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryListedClassRequest} QueryListedClassRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryListedClassRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryListedClassRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_limit != null && message.hasOwnProperty('nft_limit'))
            if (!$util.isInteger(message.nft_limit)) return 'nft_limit: integer expected';
          return null;
        };

        /**
         * Creates a QueryListedClassRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryListedClassRequest} QueryListedClassRequest
         */
        QueryListedClassRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryListedClassRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryListedClassRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_limit != null) message.nft_limit = object.nft_limit | 0;
          return message;
        };

        /**
         * Creates a plain object from a QueryListedClassRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @static
         * @param {ununifi.nftmarket.QueryListedClassRequest} message QueryListedClassRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryListedClassRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_limit = 0;
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_limit != null && message.hasOwnProperty('nft_limit')) object.nft_limit = message.nft_limit;
          return object;
        };

        /**
         * Converts this QueryListedClassRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryListedClassRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryListedClassRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryListedClassRequest;
      })();

      nftmarket.QueryListedNftsResponse = (function () {
        /**
         * Properties of a QueryListedNftsResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryListedNftsResponse
         * @property {Array.<ununifi.nftmarket.INftListing>|null} [listings] QueryListedNftsResponse listings
         */

        /**
         * Constructs a new QueryListedNftsResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryListedNftsResponse.
         * @implements IQueryListedNftsResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryListedNftsResponse=} [properties] Properties to set
         */
        function QueryListedNftsResponse(properties) {
          this.listings = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryListedNftsResponse listings.
         * @member {Array.<ununifi.nftmarket.INftListing>} listings
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @instance
         */
        QueryListedNftsResponse.prototype.listings = $util.emptyArray;

        /**
         * Encodes the specified QueryListedNftsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedNftsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.listings != null && message.listings.length)
            for (var i = 0; i < message.listings.length; ++i)
              $root.ununifi.nftmarket.NftListing.encode(message.listings[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryListedNftsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedNftsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryListedNftsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryListedNftsResponse} QueryListedNftsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedNftsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryListedNftsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.listings && message.listings.length)) message.listings = [];
                message.listings.push($root.ununifi.nftmarket.NftListing.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryListedNftsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryListedNftsResponse} QueryListedNftsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedNftsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryListedNftsResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryListedNftsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.listings != null && message.hasOwnProperty('listings')) {
            if (!Array.isArray(message.listings)) return 'listings: array expected';
            for (var i = 0; i < message.listings.length; ++i) {
              var error = $root.ununifi.nftmarket.NftListing.verify(message.listings[i]);
              if (error) return 'listings.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryListedNftsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryListedNftsResponse} QueryListedNftsResponse
         */
        QueryListedNftsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryListedNftsResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryListedNftsResponse();
          if (object.listings) {
            if (!Array.isArray(object.listings)) throw TypeError('.ununifi.nftmarket.QueryListedNftsResponse.listings: array expected');
            message.listings = [];
            for (var i = 0; i < object.listings.length; ++i) {
              if (typeof object.listings[i] !== 'object')
                throw TypeError('.ununifi.nftmarket.QueryListedNftsResponse.listings: object expected');
              message.listings[i] = $root.ununifi.nftmarket.NftListing.fromObject(object.listings[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryListedNftsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @static
         * @param {ununifi.nftmarket.QueryListedNftsResponse} message QueryListedNftsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryListedNftsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.listings = [];
          if (message.listings && message.listings.length) {
            object.listings = [];
            for (var j = 0; j < message.listings.length; ++j)
              object.listings[j] = $root.ununifi.nftmarket.NftListing.toObject(message.listings[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryListedNftsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryListedNftsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryListedNftsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryListedNftsResponse;
      })();

      nftmarket.QueryListedClassesResponse = (function () {
        /**
         * Properties of a QueryListedClassesResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryListedClassesResponse
         * @property {Array.<ununifi.nftmarket.IQueryListedClassResponse>|null} [classes] QueryListedClassesResponse classes
         */

        /**
         * Constructs a new QueryListedClassesResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryListedClassesResponse.
         * @implements IQueryListedClassesResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryListedClassesResponse=} [properties] Properties to set
         */
        function QueryListedClassesResponse(properties) {
          this.classes = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryListedClassesResponse classes.
         * @member {Array.<ununifi.nftmarket.IQueryListedClassResponse>} classes
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @instance
         */
        QueryListedClassesResponse.prototype.classes = $util.emptyArray;

        /**
         * Encodes the specified QueryListedClassesResponse message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassesResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.classes != null && message.classes.length)
            for (var i = 0; i < message.classes.length; ++i)
              $root.ununifi.nftmarket.QueryListedClassResponse.encode(
                message.classes[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryListedClassesResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassesResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryListedClassesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryListedClassesResponse} QueryListedClassesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassesResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryListedClassesResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.classes && message.classes.length)) message.classes = [];
                message.classes.push($root.ununifi.nftmarket.QueryListedClassResponse.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryListedClassesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryListedClassesResponse} QueryListedClassesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassesResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryListedClassesResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryListedClassesResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.classes != null && message.hasOwnProperty('classes')) {
            if (!Array.isArray(message.classes)) return 'classes: array expected';
            for (var i = 0; i < message.classes.length; ++i) {
              var error = $root.ununifi.nftmarket.QueryListedClassResponse.verify(message.classes[i]);
              if (error) return 'classes.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryListedClassesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryListedClassesResponse} QueryListedClassesResponse
         */
        QueryListedClassesResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryListedClassesResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryListedClassesResponse();
          if (object.classes) {
            if (!Array.isArray(object.classes)) throw TypeError('.ununifi.nftmarket.QueryListedClassesResponse.classes: array expected');
            message.classes = [];
            for (var i = 0; i < object.classes.length; ++i) {
              if (typeof object.classes[i] !== 'object')
                throw TypeError('.ununifi.nftmarket.QueryListedClassesResponse.classes: object expected');
              message.classes[i] = $root.ununifi.nftmarket.QueryListedClassResponse.fromObject(object.classes[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryListedClassesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @static
         * @param {ununifi.nftmarket.QueryListedClassesResponse} message QueryListedClassesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryListedClassesResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.classes = [];
          if (message.classes && message.classes.length) {
            object.classes = [];
            for (var j = 0; j < message.classes.length; ++j)
              object.classes[j] = $root.ununifi.nftmarket.QueryListedClassResponse.toObject(message.classes[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryListedClassesResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryListedClassesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryListedClassesResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryListedClassesResponse;
      })();

      nftmarket.QueryListedClassResponse = (function () {
        /**
         * Properties of a QueryListedClassResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryListedClassResponse
         * @property {string|null} [class_id] QueryListedClassResponse class_id
         * @property {string|null} [name] QueryListedClassResponse name
         * @property {string|null} [description] QueryListedClassResponse description
         * @property {string|null} [symbol] QueryListedClassResponse symbol
         * @property {string|null} [uri] QueryListedClassResponse uri
         * @property {string|null} [urihash] QueryListedClassResponse urihash
         * @property {Array.<ununifi.nftmarket.IListedNft>|null} [nfts] QueryListedClassResponse nfts
         * @property {Long|null} [nft_count] QueryListedClassResponse nft_count
         */

        /**
         * Constructs a new QueryListedClassResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryListedClassResponse.
         * @implements IQueryListedClassResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryListedClassResponse=} [properties] Properties to set
         */
        function QueryListedClassResponse(properties) {
          this.nfts = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryListedClassResponse class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.class_id = '';

        /**
         * QueryListedClassResponse name.
         * @member {string} name
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.name = '';

        /**
         * QueryListedClassResponse description.
         * @member {string} description
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.description = '';

        /**
         * QueryListedClassResponse symbol.
         * @member {string} symbol
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.symbol = '';

        /**
         * QueryListedClassResponse uri.
         * @member {string} uri
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.uri = '';

        /**
         * QueryListedClassResponse urihash.
         * @member {string} urihash
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.urihash = '';

        /**
         * QueryListedClassResponse nfts.
         * @member {Array.<ununifi.nftmarket.IListedNft>} nfts
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.nfts = $util.emptyArray;

        /**
         * QueryListedClassResponse nft_count.
         * @member {Long} nft_count
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         */
        QueryListedClassResponse.prototype.nft_count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified QueryListedClassResponse message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
          if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.description);
          if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.symbol);
          if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.uri);
          if (message.urihash != null && Object.hasOwnProperty.call(message, 'urihash'))
            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.urihash);
          if (message.nfts != null && message.nfts.length)
            for (var i = 0; i < message.nfts.length; ++i)
              $root.ununifi.nftmarket.ListedNft.encode(message.nfts[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
          if (message.nft_count != null && Object.hasOwnProperty.call(message, 'nft_count'))
            writer.uint32(/* id 8, wireType 0 =*/ 64).uint64(message.nft_count);
          return writer;
        };

        /**
         * Encodes the specified QueryListedClassResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @static
         * @param {ununifi.nftmarket.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryListedClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryListedClassResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryListedClassResponse} QueryListedClassResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryListedClassResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.name = reader.string();
                break;
              case 3:
                message.description = reader.string();
                break;
              case 4:
                message.symbol = reader.string();
                break;
              case 5:
                message.uri = reader.string();
                break;
              case 6:
                message.urihash = reader.string();
                break;
              case 7:
                if (!(message.nfts && message.nfts.length)) message.nfts = [];
                message.nfts.push($root.ununifi.nftmarket.ListedNft.decode(reader, reader.uint32()));
                break;
              case 8:
                message.nft_count = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryListedClassResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryListedClassResponse} QueryListedClassResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryListedClassResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryListedClassResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryListedClassResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.description != null && message.hasOwnProperty('description'))
            if (!$util.isString(message.description)) return 'description: string expected';
          if (message.symbol != null && message.hasOwnProperty('symbol'))
            if (!$util.isString(message.symbol)) return 'symbol: string expected';
          if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
          if (message.urihash != null && message.hasOwnProperty('urihash'))
            if (!$util.isString(message.urihash)) return 'urihash: string expected';
          if (message.nfts != null && message.hasOwnProperty('nfts')) {
            if (!Array.isArray(message.nfts)) return 'nfts: array expected';
            for (var i = 0; i < message.nfts.length; ++i) {
              var error = $root.ununifi.nftmarket.ListedNft.verify(message.nfts[i]);
              if (error) return 'nfts.' + error;
            }
          }
          if (message.nft_count != null && message.hasOwnProperty('nft_count'))
            if (
              !$util.isInteger(message.nft_count) &&
              !(message.nft_count && $util.isInteger(message.nft_count.low) && $util.isInteger(message.nft_count.high))
            )
              return 'nft_count: integer|Long expected';
          return null;
        };

        /**
         * Creates a QueryListedClassResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryListedClassResponse} QueryListedClassResponse
         */
        QueryListedClassResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryListedClassResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryListedClassResponse();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.name != null) message.name = String(object.name);
          if (object.description != null) message.description = String(object.description);
          if (object.symbol != null) message.symbol = String(object.symbol);
          if (object.uri != null) message.uri = String(object.uri);
          if (object.urihash != null) message.urihash = String(object.urihash);
          if (object.nfts) {
            if (!Array.isArray(object.nfts)) throw TypeError('.ununifi.nftmarket.QueryListedClassResponse.nfts: array expected');
            message.nfts = [];
            for (var i = 0; i < object.nfts.length; ++i) {
              if (typeof object.nfts[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryListedClassResponse.nfts: object expected');
              message.nfts[i] = $root.ununifi.nftmarket.ListedNft.fromObject(object.nfts[i]);
            }
          }
          if (object.nft_count != null)
            if ($util.Long) (message.nft_count = $util.Long.fromValue(object.nft_count)).unsigned = true;
            else if (typeof object.nft_count === 'string') message.nft_count = parseInt(object.nft_count, 10);
            else if (typeof object.nft_count === 'number') message.nft_count = object.nft_count;
            else if (typeof object.nft_count === 'object')
              message.nft_count = new $util.LongBits(object.nft_count.low >>> 0, object.nft_count.high >>> 0).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a QueryListedClassResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @static
         * @param {ununifi.nftmarket.QueryListedClassResponse} message QueryListedClassResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryListedClassResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.nfts = [];
          if (options.defaults) {
            object.class_id = '';
            object.name = '';
            object.description = '';
            object.symbol = '';
            object.uri = '';
            object.urihash = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_count = options.longs === String ? '0' : 0;
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
          if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
          if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
          if (message.urihash != null && message.hasOwnProperty('urihash')) object.urihash = message.urihash;
          if (message.nfts && message.nfts.length) {
            object.nfts = [];
            for (var j = 0; j < message.nfts.length; ++j)
              object.nfts[j] = $root.ununifi.nftmarket.ListedNft.toObject(message.nfts[j], options);
          }
          if (message.nft_count != null && message.hasOwnProperty('nft_count'))
            if (typeof message.nft_count === 'number')
              object.nft_count = options.longs === String ? String(message.nft_count) : message.nft_count;
            else
              object.nft_count =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_count)
                  : options.longs === Number
                  ? new $util.LongBits(message.nft_count.low >>> 0, message.nft_count.high >>> 0).toNumber(true)
                  : message.nft_count;
          return object;
        };

        /**
         * Converts this QueryListedClassResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryListedClassResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryListedClassResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryListedClassResponse;
      })();

      nftmarket.QueryLoansRequest = (function () {
        /**
         * Properties of a QueryLoansRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryLoansRequest
         */

        /**
         * Constructs a new QueryLoansRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryLoansRequest.
         * @implements IQueryLoansRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryLoansRequest=} [properties] Properties to set
         */
        function QueryLoansRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryLoansRequest message. Does not implicitly {@link ununifi.nftmarket.QueryLoansRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @static
         * @param {ununifi.nftmarket.IQueryLoansRequest} message QueryLoansRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoansRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryLoansRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoansRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @static
         * @param {ununifi.nftmarket.IQueryLoansRequest} message QueryLoansRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoansRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryLoansRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryLoansRequest} QueryLoansRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoansRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryLoansRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryLoansRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryLoansRequest} QueryLoansRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoansRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryLoansRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryLoansRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryLoansRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryLoansRequest} QueryLoansRequest
         */
        QueryLoansRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryLoansRequest) return object;
          return new $root.ununifi.nftmarket.QueryLoansRequest();
        };

        /**
         * Creates a plain object from a QueryLoansRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @static
         * @param {ununifi.nftmarket.QueryLoansRequest} message QueryLoansRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryLoansRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryLoansRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryLoansRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryLoansRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryLoansRequest;
      })();

      nftmarket.QueryLoansResponse = (function () {
        /**
         * Properties of a QueryLoansResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryLoansResponse
         * @property {Array.<ununifi.nftmarket.ILoan>|null} [loans] QueryLoansResponse loans
         */

        /**
         * Constructs a new QueryLoansResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryLoansResponse.
         * @implements IQueryLoansResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryLoansResponse=} [properties] Properties to set
         */
        function QueryLoansResponse(properties) {
          this.loans = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryLoansResponse loans.
         * @member {Array.<ununifi.nftmarket.ILoan>} loans
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @instance
         */
        QueryLoansResponse.prototype.loans = $util.emptyArray;

        /**
         * Encodes the specified QueryLoansResponse message. Does not implicitly {@link ununifi.nftmarket.QueryLoansResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @static
         * @param {ununifi.nftmarket.IQueryLoansResponse} message QueryLoansResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoansResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.loans != null && message.loans.length)
            for (var i = 0; i < message.loans.length; ++i)
              $root.ununifi.nftmarket.Loan.encode(message.loans[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryLoansResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoansResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @static
         * @param {ununifi.nftmarket.IQueryLoansResponse} message QueryLoansResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoansResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryLoansResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryLoansResponse} QueryLoansResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoansResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryLoansResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.loans && message.loans.length)) message.loans = [];
                message.loans.push($root.ununifi.nftmarket.Loan.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryLoansResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryLoansResponse} QueryLoansResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoansResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryLoansResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryLoansResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.loans != null && message.hasOwnProperty('loans')) {
            if (!Array.isArray(message.loans)) return 'loans: array expected';
            for (var i = 0; i < message.loans.length; ++i) {
              var error = $root.ununifi.nftmarket.Loan.verify(message.loans[i]);
              if (error) return 'loans.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryLoansResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryLoansResponse} QueryLoansResponse
         */
        QueryLoansResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryLoansResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryLoansResponse();
          if (object.loans) {
            if (!Array.isArray(object.loans)) throw TypeError('.ununifi.nftmarket.QueryLoansResponse.loans: array expected');
            message.loans = [];
            for (var i = 0; i < object.loans.length; ++i) {
              if (typeof object.loans[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryLoansResponse.loans: object expected');
              message.loans[i] = $root.ununifi.nftmarket.Loan.fromObject(object.loans[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryLoansResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @static
         * @param {ununifi.nftmarket.QueryLoansResponse} message QueryLoansResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryLoansResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.loans = [];
          if (message.loans && message.loans.length) {
            object.loans = [];
            for (var j = 0; j < message.loans.length; ++j)
              object.loans[j] = $root.ununifi.nftmarket.Loan.toObject(message.loans[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryLoansResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryLoansResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryLoansResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryLoansResponse;
      })();

      nftmarket.QueryLoanRequest = (function () {
        /**
         * Properties of a QueryLoanRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryLoanRequest
         * @property {string|null} [class_id] QueryLoanRequest class_id
         * @property {string|null} [nft_id] QueryLoanRequest nft_id
         */

        /**
         * Constructs a new QueryLoanRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryLoanRequest.
         * @implements IQueryLoanRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryLoanRequest=} [properties] Properties to set
         */
        function QueryLoanRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryLoanRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @instance
         */
        QueryLoanRequest.prototype.class_id = '';

        /**
         * QueryLoanRequest nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @instance
         */
        QueryLoanRequest.prototype.nft_id = '';

        /**
         * Encodes the specified QueryLoanRequest message. Does not implicitly {@link ununifi.nftmarket.QueryLoanRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @static
         * @param {ununifi.nftmarket.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoanRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified QueryLoanRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoanRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @static
         * @param {ununifi.nftmarket.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoanRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryLoanRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryLoanRequest} QueryLoanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoanRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryLoanRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryLoanRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryLoanRequest} QueryLoanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoanRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryLoanRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryLoanRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates a QueryLoanRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryLoanRequest} QueryLoanRequest
         */
        QueryLoanRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryLoanRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryLoanRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryLoanRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @static
         * @param {ununifi.nftmarket.QueryLoanRequest} message QueryLoanRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryLoanRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this QueryLoanRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryLoanRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryLoanRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryLoanRequest;
      })();

      nftmarket.QueryLoanResponse = (function () {
        /**
         * Properties of a QueryLoanResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryLoanResponse
         * @property {ununifi.nftmarket.ILoan|null} [loan] QueryLoanResponse loan
         * @property {string|null} [borrowing_limit] QueryLoanResponse borrowing_limit
         */

        /**
         * Constructs a new QueryLoanResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryLoanResponse.
         * @implements IQueryLoanResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryLoanResponse=} [properties] Properties to set
         */
        function QueryLoanResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryLoanResponse loan.
         * @member {ununifi.nftmarket.ILoan|null|undefined} loan
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @instance
         */
        QueryLoanResponse.prototype.loan = null;

        /**
         * QueryLoanResponse borrowing_limit.
         * @member {string} borrowing_limit
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @instance
         */
        QueryLoanResponse.prototype.borrowing_limit = '';

        /**
         * Encodes the specified QueryLoanResponse message. Does not implicitly {@link ununifi.nftmarket.QueryLoanResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @static
         * @param {ununifi.nftmarket.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoanResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.loan != null && Object.hasOwnProperty.call(message, 'loan'))
            $root.ununifi.nftmarket.Loan.encode(message.loan, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.borrowing_limit != null && Object.hasOwnProperty.call(message, 'borrowing_limit'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.borrowing_limit);
          return writer;
        };

        /**
         * Encodes the specified QueryLoanResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoanResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @static
         * @param {ununifi.nftmarket.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryLoanResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryLoanResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryLoanResponse} QueryLoanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoanResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryLoanResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.loan = $root.ununifi.nftmarket.Loan.decode(reader, reader.uint32());
                break;
              case 2:
                message.borrowing_limit = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryLoanResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryLoanResponse} QueryLoanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryLoanResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryLoanResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryLoanResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.loan != null && message.hasOwnProperty('loan')) {
            var error = $root.ununifi.nftmarket.Loan.verify(message.loan);
            if (error) return 'loan.' + error;
          }
          if (message.borrowing_limit != null && message.hasOwnProperty('borrowing_limit'))
            if (!$util.isString(message.borrowing_limit)) return 'borrowing_limit: string expected';
          return null;
        };

        /**
         * Creates a QueryLoanResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryLoanResponse} QueryLoanResponse
         */
        QueryLoanResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryLoanResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryLoanResponse();
          if (object.loan != null) {
            if (typeof object.loan !== 'object') throw TypeError('.ununifi.nftmarket.QueryLoanResponse.loan: object expected');
            message.loan = $root.ununifi.nftmarket.Loan.fromObject(object.loan);
          }
          if (object.borrowing_limit != null) message.borrowing_limit = String(object.borrowing_limit);
          return message;
        };

        /**
         * Creates a plain object from a QueryLoanResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @static
         * @param {ununifi.nftmarket.QueryLoanResponse} message QueryLoanResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryLoanResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.loan = null;
            object.borrowing_limit = '';
          }
          if (message.loan != null && message.hasOwnProperty('loan'))
            object.loan = $root.ununifi.nftmarket.Loan.toObject(message.loan, options);
          if (message.borrowing_limit != null && message.hasOwnProperty('borrowing_limit'))
            object.borrowing_limit = message.borrowing_limit;
          return object;
        };

        /**
         * Converts this QueryLoanResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryLoanResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryLoanResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryLoanResponse;
      })();

      nftmarket.QueryCDPsListRequest = (function () {
        /**
         * Properties of a QueryCDPsListRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryCDPsListRequest
         */

        /**
         * Constructs a new QueryCDPsListRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryCDPsListRequest.
         * @implements IQueryCDPsListRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryCDPsListRequest=} [properties] Properties to set
         */
        function QueryCDPsListRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryCDPsListRequest message. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @static
         * @param {ununifi.nftmarket.IQueryCDPsListRequest} message QueryCDPsListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryCDPsListRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryCDPsListRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @static
         * @param {ununifi.nftmarket.IQueryCDPsListRequest} message QueryCDPsListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryCDPsListRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryCDPsListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryCDPsListRequest} QueryCDPsListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryCDPsListRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryCDPsListRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryCDPsListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryCDPsListRequest} QueryCDPsListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryCDPsListRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryCDPsListRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryCDPsListRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryCDPsListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryCDPsListRequest} QueryCDPsListRequest
         */
        QueryCDPsListRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryCDPsListRequest) return object;
          return new $root.ununifi.nftmarket.QueryCDPsListRequest();
        };

        /**
         * Creates a plain object from a QueryCDPsListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @static
         * @param {ununifi.nftmarket.QueryCDPsListRequest} message QueryCDPsListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryCDPsListRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryCDPsListRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryCDPsListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryCDPsListRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryCDPsListRequest;
      })();

      nftmarket.QueryCDPsListResponse = (function () {
        /**
         * Properties of a QueryCDPsListResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryCDPsListResponse
         */

        /**
         * Constructs a new QueryCDPsListResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryCDPsListResponse.
         * @implements IQueryCDPsListResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryCDPsListResponse=} [properties] Properties to set
         */
        function QueryCDPsListResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryCDPsListResponse message. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @static
         * @param {ununifi.nftmarket.IQueryCDPsListResponse} message QueryCDPsListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryCDPsListResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryCDPsListResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @static
         * @param {ununifi.nftmarket.IQueryCDPsListResponse} message QueryCDPsListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryCDPsListResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryCDPsListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryCDPsListResponse} QueryCDPsListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryCDPsListResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryCDPsListResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryCDPsListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryCDPsListResponse} QueryCDPsListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryCDPsListResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryCDPsListResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryCDPsListResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryCDPsListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryCDPsListResponse} QueryCDPsListResponse
         */
        QueryCDPsListResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryCDPsListResponse) return object;
          return new $root.ununifi.nftmarket.QueryCDPsListResponse();
        };

        /**
         * Creates a plain object from a QueryCDPsListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @static
         * @param {ununifi.nftmarket.QueryCDPsListResponse} message QueryCDPsListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryCDPsListResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryCDPsListResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryCDPsListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryCDPsListResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryCDPsListResponse;
      })();

      nftmarket.QueryNftBidsRequest = (function () {
        /**
         * Properties of a QueryNftBidsRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryNftBidsRequest
         * @property {string|null} [class_id] QueryNftBidsRequest class_id
         * @property {string|null} [nft_id] QueryNftBidsRequest nft_id
         */

        /**
         * Constructs a new QueryNftBidsRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryNftBidsRequest.
         * @implements IQueryNftBidsRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryNftBidsRequest=} [properties] Properties to set
         */
        function QueryNftBidsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryNftBidsRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @instance
         */
        QueryNftBidsRequest.prototype.class_id = '';

        /**
         * QueryNftBidsRequest nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @instance
         */
        QueryNftBidsRequest.prototype.nft_id = '';

        /**
         * Encodes the specified QueryNftBidsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftBidsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified QueryNftBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryNftBidsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryNftBidsRequest} QueryNftBidsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftBidsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryNftBidsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryNftBidsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryNftBidsRequest} QueryNftBidsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftBidsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryNftBidsRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryNftBidsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates a QueryNftBidsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryNftBidsRequest} QueryNftBidsRequest
         */
        QueryNftBidsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryNftBidsRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryNftBidsRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryNftBidsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @static
         * @param {ununifi.nftmarket.QueryNftBidsRequest} message QueryNftBidsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryNftBidsRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this QueryNftBidsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryNftBidsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryNftBidsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryNftBidsRequest;
      })();

      nftmarket.QueryNftBidsResponse = (function () {
        /**
         * Properties of a QueryNftBidsResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryNftBidsResponse
         * @property {Array.<ununifi.nftmarket.INftBid>|null} [bids] QueryNftBidsResponse bids
         */

        /**
         * Constructs a new QueryNftBidsResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryNftBidsResponse.
         * @implements IQueryNftBidsResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryNftBidsResponse=} [properties] Properties to set
         */
        function QueryNftBidsResponse(properties) {
          this.bids = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryNftBidsResponse bids.
         * @member {Array.<ununifi.nftmarket.INftBid>} bids
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @instance
         */
        QueryNftBidsResponse.prototype.bids = $util.emptyArray;

        /**
         * Encodes the specified QueryNftBidsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftBidsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.bids != null && message.bids.length)
            for (var i = 0; i < message.bids.length; ++i)
              $root.ununifi.nftmarket.NftBid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryNftBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNftBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryNftBidsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryNftBidsResponse} QueryNftBidsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftBidsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryNftBidsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.bids && message.bids.length)) message.bids = [];
                message.bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryNftBidsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryNftBidsResponse} QueryNftBidsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNftBidsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryNftBidsResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryNftBidsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.bids != null && message.hasOwnProperty('bids')) {
            if (!Array.isArray(message.bids)) return 'bids: array expected';
            for (var i = 0; i < message.bids.length; ++i) {
              var error = $root.ununifi.nftmarket.NftBid.verify(message.bids[i]);
              if (error) return 'bids.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryNftBidsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryNftBidsResponse} QueryNftBidsResponse
         */
        QueryNftBidsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryNftBidsResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryNftBidsResponse();
          if (object.bids) {
            if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftmarket.QueryNftBidsResponse.bids: array expected');
            message.bids = [];
            for (var i = 0; i < object.bids.length; ++i) {
              if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryNftBidsResponse.bids: object expected');
              message.bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.bids[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryNftBidsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @static
         * @param {ununifi.nftmarket.QueryNftBidsResponse} message QueryNftBidsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryNftBidsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.bids = [];
          if (message.bids && message.bids.length) {
            object.bids = [];
            for (var j = 0; j < message.bids.length; ++j)
              object.bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.bids[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryNftBidsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryNftBidsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryNftBidsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryNftBidsResponse;
      })();

      nftmarket.QueryPaymentStatusRequest = (function () {
        /**
         * Properties of a QueryPaymentStatusRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryPaymentStatusRequest
         * @property {string|null} [class_id] QueryPaymentStatusRequest class_id
         * @property {string|null} [nft_id] QueryPaymentStatusRequest nft_id
         * @property {string|null} [bidder] QueryPaymentStatusRequest bidder
         */

        /**
         * Constructs a new QueryPaymentStatusRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryPaymentStatusRequest.
         * @implements IQueryPaymentStatusRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryPaymentStatusRequest=} [properties] Properties to set
         */
        function QueryPaymentStatusRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryPaymentStatusRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @instance
         */
        QueryPaymentStatusRequest.prototype.class_id = '';

        /**
         * QueryPaymentStatusRequest nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @instance
         */
        QueryPaymentStatusRequest.prototype.nft_id = '';

        /**
         * QueryPaymentStatusRequest bidder.
         * @member {string} bidder
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @instance
         */
        QueryPaymentStatusRequest.prototype.bidder = '';

        /**
         * Encodes the specified QueryPaymentStatusRequest message. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @static
         * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} message QueryPaymentStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPaymentStatusRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.bidder);
          return writer;
        };

        /**
         * Encodes the specified QueryPaymentStatusRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @static
         * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} message QueryPaymentStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPaymentStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryPaymentStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryPaymentStatusRequest} QueryPaymentStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPaymentStatusRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryPaymentStatusRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              case 3:
                message.bidder = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryPaymentStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryPaymentStatusRequest} QueryPaymentStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPaymentStatusRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryPaymentStatusRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryPaymentStatusRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          return null;
        };

        /**
         * Creates a QueryPaymentStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryPaymentStatusRequest} QueryPaymentStatusRequest
         */
        QueryPaymentStatusRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryPaymentStatusRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryPaymentStatusRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          if (object.bidder != null) message.bidder = String(object.bidder);
          return message;
        };

        /**
         * Creates a plain object from a QueryPaymentStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @static
         * @param {ununifi.nftmarket.QueryPaymentStatusRequest} message QueryPaymentStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryPaymentStatusRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
            object.bidder = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          return object;
        };

        /**
         * Converts this QueryPaymentStatusRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryPaymentStatusRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryPaymentStatusRequest;
      })();

      nftmarket.QueryPaymentStatusResponse = (function () {
        /**
         * Properties of a QueryPaymentStatusResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryPaymentStatusResponse
         * @property {ununifi.nftmarket.IPaymentStatus|null} [paymentStatus] QueryPaymentStatusResponse paymentStatus
         */

        /**
         * Constructs a new QueryPaymentStatusResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryPaymentStatusResponse.
         * @implements IQueryPaymentStatusResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryPaymentStatusResponse=} [properties] Properties to set
         */
        function QueryPaymentStatusResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryPaymentStatusResponse paymentStatus.
         * @member {ununifi.nftmarket.IPaymentStatus|null|undefined} paymentStatus
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @instance
         */
        QueryPaymentStatusResponse.prototype.paymentStatus = null;

        /**
         * Encodes the specified QueryPaymentStatusResponse message. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @static
         * @param {ununifi.nftmarket.IQueryPaymentStatusResponse} message QueryPaymentStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPaymentStatusResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.paymentStatus != null && Object.hasOwnProperty.call(message, 'paymentStatus'))
            $root.ununifi.nftmarket.PaymentStatus.encode(message.paymentStatus, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryPaymentStatusResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @static
         * @param {ununifi.nftmarket.IQueryPaymentStatusResponse} message QueryPaymentStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryPaymentStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryPaymentStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryPaymentStatusResponse} QueryPaymentStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPaymentStatusResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryPaymentStatusResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.paymentStatus = $root.ununifi.nftmarket.PaymentStatus.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryPaymentStatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryPaymentStatusResponse} QueryPaymentStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryPaymentStatusResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryPaymentStatusResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryPaymentStatusResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.paymentStatus != null && message.hasOwnProperty('paymentStatus')) {
            var error = $root.ununifi.nftmarket.PaymentStatus.verify(message.paymentStatus);
            if (error) return 'paymentStatus.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryPaymentStatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryPaymentStatusResponse} QueryPaymentStatusResponse
         */
        QueryPaymentStatusResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryPaymentStatusResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryPaymentStatusResponse();
          if (object.paymentStatus != null) {
            if (typeof object.paymentStatus !== 'object')
              throw TypeError('.ununifi.nftmarket.QueryPaymentStatusResponse.paymentStatus: object expected');
            message.paymentStatus = $root.ununifi.nftmarket.PaymentStatus.fromObject(object.paymentStatus);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryPaymentStatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @static
         * @param {ununifi.nftmarket.QueryPaymentStatusResponse} message QueryPaymentStatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryPaymentStatusResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.paymentStatus = null;
          if (message.paymentStatus != null && message.hasOwnProperty('paymentStatus'))
            object.paymentStatus = $root.ununifi.nftmarket.PaymentStatus.toObject(message.paymentStatus, options);
          return object;
        };

        /**
         * Converts this QueryPaymentStatusResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryPaymentStatusResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryPaymentStatusResponse;
      })();

      nftmarket.QueryBidderBidsRequest = (function () {
        /**
         * Properties of a QueryBidderBidsRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryBidderBidsRequest
         * @property {string|null} [bidder] QueryBidderBidsRequest bidder
         */

        /**
         * Constructs a new QueryBidderBidsRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryBidderBidsRequest.
         * @implements IQueryBidderBidsRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryBidderBidsRequest=} [properties] Properties to set
         */
        function QueryBidderBidsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryBidderBidsRequest bidder.
         * @member {string} bidder
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @instance
         */
        QueryBidderBidsRequest.prototype.bidder = '';

        /**
         * Encodes the specified QueryBidderBidsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryBidderBidsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
          return writer;
        };

        /**
         * Encodes the specified QueryBidderBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryBidderBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryBidderBidsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryBidderBidsRequest} QueryBidderBidsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryBidderBidsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryBidderBidsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.bidder = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryBidderBidsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryBidderBidsRequest} QueryBidderBidsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryBidderBidsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryBidderBidsRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryBidderBidsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          return null;
        };

        /**
         * Creates a QueryBidderBidsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryBidderBidsRequest} QueryBidderBidsRequest
         */
        QueryBidderBidsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryBidderBidsRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryBidderBidsRequest();
          if (object.bidder != null) message.bidder = String(object.bidder);
          return message;
        };

        /**
         * Creates a plain object from a QueryBidderBidsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @static
         * @param {ununifi.nftmarket.QueryBidderBidsRequest} message QueryBidderBidsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryBidderBidsRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.bidder = '';
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          return object;
        };

        /**
         * Converts this QueryBidderBidsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryBidderBidsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryBidderBidsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryBidderBidsRequest;
      })();

      nftmarket.QueryBidderBidsResponse = (function () {
        /**
         * Properties of a QueryBidderBidsResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryBidderBidsResponse
         * @property {Array.<ununifi.nftmarket.INftBid>|null} [bids] QueryBidderBidsResponse bids
         */

        /**
         * Constructs a new QueryBidderBidsResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryBidderBidsResponse.
         * @implements IQueryBidderBidsResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryBidderBidsResponse=} [properties] Properties to set
         */
        function QueryBidderBidsResponse(properties) {
          this.bids = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryBidderBidsResponse bids.
         * @member {Array.<ununifi.nftmarket.INftBid>} bids
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @instance
         */
        QueryBidderBidsResponse.prototype.bids = $util.emptyArray;

        /**
         * Encodes the specified QueryBidderBidsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryBidderBidsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.bids != null && message.bids.length)
            for (var i = 0; i < message.bids.length; ++i)
              $root.ununifi.nftmarket.NftBid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryBidderBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryBidderBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryBidderBidsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryBidderBidsResponse} QueryBidderBidsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryBidderBidsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryBidderBidsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.bids && message.bids.length)) message.bids = [];
                message.bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryBidderBidsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryBidderBidsResponse} QueryBidderBidsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryBidderBidsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryBidderBidsResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryBidderBidsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.bids != null && message.hasOwnProperty('bids')) {
            if (!Array.isArray(message.bids)) return 'bids: array expected';
            for (var i = 0; i < message.bids.length; ++i) {
              var error = $root.ununifi.nftmarket.NftBid.verify(message.bids[i]);
              if (error) return 'bids.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryBidderBidsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryBidderBidsResponse} QueryBidderBidsResponse
         */
        QueryBidderBidsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryBidderBidsResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryBidderBidsResponse();
          if (object.bids) {
            if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftmarket.QueryBidderBidsResponse.bids: array expected');
            message.bids = [];
            for (var i = 0; i < object.bids.length; ++i) {
              if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryBidderBidsResponse.bids: object expected');
              message.bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.bids[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryBidderBidsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @static
         * @param {ununifi.nftmarket.QueryBidderBidsResponse} message QueryBidderBidsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryBidderBidsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.bids = [];
          if (message.bids && message.bids.length) {
            object.bids = [];
            for (var j = 0; j < message.bids.length; ++j)
              object.bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.bids[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryBidderBidsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryBidderBidsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryBidderBidsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryBidderBidsResponse;
      })();

      nftmarket.QueryRewardsRequest = (function () {
        /**
         * Properties of a QueryRewardsRequest.
         * @memberof ununifi.nftmarket
         * @interface IQueryRewardsRequest
         * @property {Long|null} [address] QueryRewardsRequest address
         */

        /**
         * Constructs a new QueryRewardsRequest.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryRewardsRequest.
         * @implements IQueryRewardsRequest
         * @constructor
         * @param {ununifi.nftmarket.IQueryRewardsRequest=} [properties] Properties to set
         */
        function QueryRewardsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRewardsRequest address.
         * @member {Long} address
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @instance
         */
        QueryRewardsRequest.prototype.address = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified QueryRewardsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryRewardsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.address);
          return writer;
        };

        /**
         * Encodes the specified QueryRewardsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryRewardsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @static
         * @param {ununifi.nftmarket.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRewardsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryRewardsRequest} QueryRewardsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryRewardsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.address = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryRewardsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryRewardsRequest} QueryRewardsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRewardsRequest message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRewardsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.address != null && message.hasOwnProperty('address'))
            if (
              !$util.isInteger(message.address) &&
              !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high))
            )
              return 'address: integer|Long expected';
          return null;
        };

        /**
         * Creates a QueryRewardsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryRewardsRequest} QueryRewardsRequest
         */
        QueryRewardsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryRewardsRequest) return object;
          var message = new $root.ununifi.nftmarket.QueryRewardsRequest();
          if (object.address != null)
            if ($util.Long) (message.address = $util.Long.fromValue(object.address)).unsigned = true;
            else if (typeof object.address === 'string') message.address = parseInt(object.address, 10);
            else if (typeof object.address === 'number') message.address = object.address;
            else if (typeof object.address === 'object')
              message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a QueryRewardsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @static
         * @param {ununifi.nftmarket.QueryRewardsRequest} message QueryRewardsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRewardsRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults)
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.address = options.longs === String ? '0' : 0;
          if (message.address != null && message.hasOwnProperty('address'))
            if (typeof message.address === 'number') object.address = options.longs === String ? String(message.address) : message.address;
            else
              object.address =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.address)
                  : options.longs === Number
                  ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true)
                  : message.address;
          return object;
        };

        /**
         * Converts this QueryRewardsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryRewardsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRewardsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRewardsRequest;
      })();

      nftmarket.QueryRewardsResponse = (function () {
        /**
         * Properties of a QueryRewardsResponse.
         * @memberof ununifi.nftmarket
         * @interface IQueryRewardsResponse
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] QueryRewardsResponse rewards
         */

        /**
         * Constructs a new QueryRewardsResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a QueryRewardsResponse.
         * @implements IQueryRewardsResponse
         * @constructor
         * @param {ununifi.nftmarket.IQueryRewardsResponse=} [properties] Properties to set
         */
        function QueryRewardsResponse(properties) {
          this.rewards = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRewardsResponse rewards.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @instance
         */
        QueryRewardsResponse.prototype.rewards = $util.emptyArray;

        /**
         * Encodes the specified QueryRewardsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryRewardsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.rewards != null && message.rewards.length)
            for (var i = 0; i < message.rewards.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryRewardsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryRewardsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @static
         * @param {ununifi.nftmarket.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRewardsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.QueryRewardsResponse} QueryRewardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.QueryRewardsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.rewards && message.rewards.length)) message.rewards = [];
                message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryRewardsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.QueryRewardsResponse} QueryRewardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRewardsResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRewardsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.rewards != null && message.hasOwnProperty('rewards')) {
            if (!Array.isArray(message.rewards)) return 'rewards: array expected';
            for (var i = 0; i < message.rewards.length; ++i) {
              var error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
              if (error) return 'rewards.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryRewardsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.QueryRewardsResponse} QueryRewardsResponse
         */
        QueryRewardsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.QueryRewardsResponse) return object;
          var message = new $root.ununifi.nftmarket.QueryRewardsResponse();
          if (object.rewards) {
            if (!Array.isArray(object.rewards)) throw TypeError('.ununifi.nftmarket.QueryRewardsResponse.rewards: array expected');
            message.rewards = [];
            for (var i = 0; i < object.rewards.length; ++i) {
              if (typeof object.rewards[i] !== 'object')
                throw TypeError('.ununifi.nftmarket.QueryRewardsResponse.rewards: object expected');
              message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryRewardsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @static
         * @param {ununifi.nftmarket.QueryRewardsResponse} message QueryRewardsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRewardsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.rewards = [];
          if (message.rewards && message.rewards.length) {
            object.rewards = [];
            for (var j = 0; j < message.rewards.length; ++j)
              object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryRewardsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.QueryRewardsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRewardsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRewardsResponse;
      })();

      /**
       * ListingType enum.
       * @name ununifi.nftmarket.ListingType
       * @enum {number}
       * @property {number} DIRECT_ASSET_BORROW=0 DIRECT_ASSET_BORROW value
       * @property {number} SYNTHETIC_ASSET_CREATION=1 SYNTHETIC_ASSET_CREATION value
       * @property {number} LATE_SHIPPING=2 LATE_SHIPPING value
       */
      nftmarket.ListingType = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'DIRECT_ASSET_BORROW')] = 0;
        values[(valuesById[1] = 'SYNTHETIC_ASSET_CREATION')] = 1;
        values[(valuesById[2] = 'LATE_SHIPPING')] = 2;
        return values;
      })();

      /**
       * ListingState enum.
       * @name ununifi.nftmarket.ListingState
       * @enum {number}
       * @property {number} LISTING=0 LISTING value
       * @property {number} BIDDING=1 BIDDING value
       * @property {number} SELLING_DECISION=2 SELLING_DECISION value
       * @property {number} LIQUIDATION=3 LIQUIDATION value
       * @property {number} END_LISTING=4 END_LISTING value
       * @property {number} SUCCESSFUL_BID=5 SUCCESSFUL_BID value
       */
      nftmarket.ListingState = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'LISTING')] = 0;
        values[(valuesById[1] = 'BIDDING')] = 1;
        values[(valuesById[2] = 'SELLING_DECISION')] = 2;
        values[(valuesById[3] = 'LIQUIDATION')] = 3;
        values[(valuesById[4] = 'END_LISTING')] = 4;
        values[(valuesById[5] = 'SUCCESSFUL_BID')] = 5;
        return values;
      })();

      nftmarket.NftIdentifier = (function () {
        /**
         * Properties of a NftIdentifier.
         * @memberof ununifi.nftmarket
         * @interface INftIdentifier
         * @property {string|null} [class_id] NftIdentifier class_id
         * @property {string|null} [nft_id] NftIdentifier nft_id
         */

        /**
         * Constructs a new NftIdentifier.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a NftIdentifier.
         * @implements INftIdentifier
         * @constructor
         * @param {ununifi.nftmarket.INftIdentifier=} [properties] Properties to set
         */
        function NftIdentifier(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * NftIdentifier class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.NftIdentifier
         * @instance
         */
        NftIdentifier.prototype.class_id = '';

        /**
         * NftIdentifier nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.NftIdentifier
         * @instance
         */
        NftIdentifier.prototype.nft_id = '';

        /**
         * Encodes the specified NftIdentifier message. Does not implicitly {@link ununifi.nftmarket.NftIdentifier.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.NftIdentifier
         * @static
         * @param {ununifi.nftmarket.INftIdentifier} message NftIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftIdentifier.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified NftIdentifier message, length delimited. Does not implicitly {@link ununifi.nftmarket.NftIdentifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.NftIdentifier
         * @static
         * @param {ununifi.nftmarket.INftIdentifier} message NftIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NftIdentifier message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.NftIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.NftIdentifier} NftIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftIdentifier.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.NftIdentifier();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a NftIdentifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.NftIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.NftIdentifier} NftIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftIdentifier.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NftIdentifier message.
         * @function verify
         * @memberof ununifi.nftmarket.NftIdentifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NftIdentifier.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates a NftIdentifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.NftIdentifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.NftIdentifier} NftIdentifier
         */
        NftIdentifier.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.NftIdentifier) return object;
          var message = new $root.ununifi.nftmarket.NftIdentifier();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from a NftIdentifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.NftIdentifier
         * @static
         * @param {ununifi.nftmarket.NftIdentifier} message NftIdentifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NftIdentifier.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this NftIdentifier to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.NftIdentifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NftIdentifier.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NftIdentifier;
      })();

      nftmarket.Loan = (function () {
        /**
         * Properties of a Loan.
         * @memberof ununifi.nftmarket
         * @interface ILoan
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] Loan nft_id
         * @property {cosmos.base.v1beta1.ICoin|null} [loan] Loan loan
         */

        /**
         * Constructs a new Loan.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a Loan.
         * @implements ILoan
         * @constructor
         * @param {ununifi.nftmarket.ILoan=} [properties] Properties to set
         */
        function Loan(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Loan nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.Loan
         * @instance
         */
        Loan.prototype.nft_id = null;

        /**
         * Loan loan.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} loan
         * @memberof ununifi.nftmarket.Loan
         * @instance
         */
        Loan.prototype.loan = null;

        /**
         * Encodes the specified Loan message. Does not implicitly {@link ununifi.nftmarket.Loan.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.Loan
         * @static
         * @param {ununifi.nftmarket.ILoan} message Loan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Loan.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.loan != null && Object.hasOwnProperty.call(message, 'loan'))
            $root.cosmos.base.v1beta1.Coin.encode(message.loan, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Loan message, length delimited. Does not implicitly {@link ununifi.nftmarket.Loan.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.Loan
         * @static
         * @param {ununifi.nftmarket.ILoan} message Loan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Loan.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Loan message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.Loan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.Loan} Loan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Loan.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.Loan();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 2:
                message.loan = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Loan message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.Loan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.Loan} Loan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Loan.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Loan message.
         * @function verify
         * @memberof ununifi.nftmarket.Loan
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Loan.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.loan != null && message.hasOwnProperty('loan')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.loan);
            if (error) return 'loan.' + error;
          }
          return null;
        };

        /**
         * Creates a Loan message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.Loan
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.Loan} Loan
         */
        Loan.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.Loan) return object;
          var message = new $root.ununifi.nftmarket.Loan();
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.Loan.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          if (object.loan != null) {
            if (typeof object.loan !== 'object') throw TypeError('.ununifi.nftmarket.Loan.loan: object expected');
            message.loan = $root.cosmos.base.v1beta1.Coin.fromObject(object.loan);
          }
          return message;
        };

        /**
         * Creates a plain object from a Loan message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.Loan
         * @static
         * @param {ununifi.nftmarket.Loan} message Loan
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Loan.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.nft_id = null;
            object.loan = null;
          }
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.loan != null && message.hasOwnProperty('loan'))
            object.loan = $root.cosmos.base.v1beta1.Coin.toObject(message.loan, options);
          return object;
        };

        /**
         * Converts this Loan to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.Loan
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Loan.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Loan;
      })();

      nftmarket.ListedClass = (function () {
        /**
         * Properties of a ListedClass.
         * @memberof ununifi.nftmarket
         * @interface IListedClass
         * @property {string|null} [class_id] ListedClass class_id
         * @property {Array.<string>|null} [nft_ids] ListedClass nft_ids
         */

        /**
         * Constructs a new ListedClass.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a ListedClass.
         * @implements IListedClass
         * @constructor
         * @param {ununifi.nftmarket.IListedClass=} [properties] Properties to set
         */
        function ListedClass(properties) {
          this.nft_ids = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListedClass class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.ListedClass
         * @instance
         */
        ListedClass.prototype.class_id = '';

        /**
         * ListedClass nft_ids.
         * @member {Array.<string>} nft_ids
         * @memberof ununifi.nftmarket.ListedClass
         * @instance
         */
        ListedClass.prototype.nft_ids = $util.emptyArray;

        /**
         * Encodes the specified ListedClass message. Does not implicitly {@link ununifi.nftmarket.ListedClass.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.ListedClass
         * @static
         * @param {ununifi.nftmarket.IListedClass} message ListedClass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListedClass.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_ids != null && message.nft_ids.length)
            for (var i = 0; i < message.nft_ids.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_ids[i]);
          return writer;
        };

        /**
         * Encodes the specified ListedClass message, length delimited. Does not implicitly {@link ununifi.nftmarket.ListedClass.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.ListedClass
         * @static
         * @param {ununifi.nftmarket.IListedClass} message ListedClass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListedClass.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListedClass message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.ListedClass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.ListedClass} ListedClass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListedClass.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.ListedClass();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                if (!(message.nft_ids && message.nft_ids.length)) message.nft_ids = [];
                message.nft_ids.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ListedClass message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.ListedClass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.ListedClass} ListedClass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListedClass.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListedClass message.
         * @function verify
         * @memberof ununifi.nftmarket.ListedClass
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListedClass.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_ids != null && message.hasOwnProperty('nft_ids')) {
            if (!Array.isArray(message.nft_ids)) return 'nft_ids: array expected';
            for (var i = 0; i < message.nft_ids.length; ++i) if (!$util.isString(message.nft_ids[i])) return 'nft_ids: string[] expected';
          }
          return null;
        };

        /**
         * Creates a ListedClass message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.ListedClass
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.ListedClass} ListedClass
         */
        ListedClass.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.ListedClass) return object;
          var message = new $root.ununifi.nftmarket.ListedClass();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_ids) {
            if (!Array.isArray(object.nft_ids)) throw TypeError('.ununifi.nftmarket.ListedClass.nft_ids: array expected');
            message.nft_ids = [];
            for (var i = 0; i < object.nft_ids.length; ++i) message.nft_ids[i] = String(object.nft_ids[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a ListedClass message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.ListedClass
         * @static
         * @param {ununifi.nftmarket.ListedClass} message ListedClass
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListedClass.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.nft_ids = [];
          if (options.defaults) object.class_id = '';
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_ids && message.nft_ids.length) {
            object.nft_ids = [];
            for (var j = 0; j < message.nft_ids.length; ++j) object.nft_ids[j] = message.nft_ids[j];
          }
          return object;
        };

        /**
         * Converts this ListedClass to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.ListedClass
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListedClass.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListedClass;
      })();

      nftmarket.ListedNft = (function () {
        /**
         * Properties of a ListedNft.
         * @memberof ununifi.nftmarket
         * @interface IListedNft
         * @property {string|null} [id] ListedNft id
         * @property {string|null} [uri] ListedNft uri
         * @property {string|null} [uri_hash] ListedNft uri_hash
         */

        /**
         * Constructs a new ListedNft.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a ListedNft.
         * @implements IListedNft
         * @constructor
         * @param {ununifi.nftmarket.IListedNft=} [properties] Properties to set
         */
        function ListedNft(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListedNft id.
         * @member {string} id
         * @memberof ununifi.nftmarket.ListedNft
         * @instance
         */
        ListedNft.prototype.id = '';

        /**
         * ListedNft uri.
         * @member {string} uri
         * @memberof ununifi.nftmarket.ListedNft
         * @instance
         */
        ListedNft.prototype.uri = '';

        /**
         * ListedNft uri_hash.
         * @member {string} uri_hash
         * @memberof ununifi.nftmarket.ListedNft
         * @instance
         */
        ListedNft.prototype.uri_hash = '';

        /**
         * Encodes the specified ListedNft message. Does not implicitly {@link ununifi.nftmarket.ListedNft.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.ListedNft
         * @static
         * @param {ununifi.nftmarket.IListedNft} message ListedNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListedNft.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
          if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.uri);
          if (message.uri_hash != null && Object.hasOwnProperty.call(message, 'uri_hash'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.uri_hash);
          return writer;
        };

        /**
         * Encodes the specified ListedNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.ListedNft.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.ListedNft
         * @static
         * @param {ununifi.nftmarket.IListedNft} message ListedNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListedNft.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListedNft message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.ListedNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.ListedNft} ListedNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListedNft.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.ListedNft();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.id = reader.string();
                break;
              case 2:
                message.uri = reader.string();
                break;
              case 3:
                message.uri_hash = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ListedNft message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.ListedNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.ListedNft} ListedNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListedNft.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListedNft message.
         * @function verify
         * @memberof ununifi.nftmarket.ListedNft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListedNft.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
          if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
          if (message.uri_hash != null && message.hasOwnProperty('uri_hash'))
            if (!$util.isString(message.uri_hash)) return 'uri_hash: string expected';
          return null;
        };

        /**
         * Creates a ListedNft message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.ListedNft
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.ListedNft} ListedNft
         */
        ListedNft.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.ListedNft) return object;
          var message = new $root.ununifi.nftmarket.ListedNft();
          if (object.id != null) message.id = String(object.id);
          if (object.uri != null) message.uri = String(object.uri);
          if (object.uri_hash != null) message.uri_hash = String(object.uri_hash);
          return message;
        };

        /**
         * Creates a plain object from a ListedNft message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.ListedNft
         * @static
         * @param {ununifi.nftmarket.ListedNft} message ListedNft
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListedNft.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.id = '';
            object.uri = '';
            object.uri_hash = '';
          }
          if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
          if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
          if (message.uri_hash != null && message.hasOwnProperty('uri_hash')) object.uri_hash = message.uri_hash;
          return object;
        };

        /**
         * Converts this ListedNft to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.ListedNft
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListedNft.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListedNft;
      })();

      nftmarket.NftListing = (function () {
        /**
         * Properties of a NftListing.
         * @memberof ununifi.nftmarket
         * @interface INftListing
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] NftListing nft_id
         * @property {string|null} [owner] NftListing owner
         * @property {ununifi.nftmarket.ListingType|null} [listing_type] NftListing listing_type
         * @property {ununifi.nftmarket.ListingState|null} [state] NftListing state
         * @property {string|null} [bid_token] NftListing bid_token
         * @property {string|null} [min_bid] NftListing min_bid
         * @property {Long|null} [bid_active_rank] NftListing bid_active_rank
         * @property {google.protobuf.ITimestamp|null} [started_at] NftListing started_at
         * @property {google.protobuf.ITimestamp|null} [end_at] NftListing end_at
         * @property {google.protobuf.ITimestamp|null} [full_payment_end_at] NftListing full_payment_end_at
         * @property {google.protobuf.ITimestamp|null} [successful_bid_end_at] NftListing successful_bid_end_at
         * @property {Long|null} [auto_relisted_count] NftListing auto_relisted_count
         */

        /**
         * Constructs a new NftListing.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a NftListing.
         * @implements INftListing
         * @constructor
         * @param {ununifi.nftmarket.INftListing=} [properties] Properties to set
         */
        function NftListing(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * NftListing nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.nft_id = null;

        /**
         * NftListing owner.
         * @member {string} owner
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.owner = '';

        /**
         * NftListing listing_type.
         * @member {ununifi.nftmarket.ListingType} listing_type
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.listing_type = 0;

        /**
         * NftListing state.
         * @member {ununifi.nftmarket.ListingState} state
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.state = 0;

        /**
         * NftListing bid_token.
         * @member {string} bid_token
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.bid_token = '';

        /**
         * NftListing min_bid.
         * @member {string} min_bid
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.min_bid = '';

        /**
         * NftListing bid_active_rank.
         * @member {Long} bid_active_rank
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.bid_active_rank = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * NftListing started_at.
         * @member {google.protobuf.ITimestamp|null|undefined} started_at
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.started_at = null;

        /**
         * NftListing end_at.
         * @member {google.protobuf.ITimestamp|null|undefined} end_at
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.end_at = null;

        /**
         * NftListing full_payment_end_at.
         * @member {google.protobuf.ITimestamp|null|undefined} full_payment_end_at
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.full_payment_end_at = null;

        /**
         * NftListing successful_bid_end_at.
         * @member {google.protobuf.ITimestamp|null|undefined} successful_bid_end_at
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.successful_bid_end_at = null;

        /**
         * NftListing auto_relisted_count.
         * @member {Long} auto_relisted_count
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         */
        NftListing.prototype.auto_relisted_count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified NftListing message. Does not implicitly {@link ununifi.nftmarket.NftListing.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.NftListing
         * @static
         * @param {ununifi.nftmarket.INftListing} message NftListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftListing.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
          if (message.listing_type != null && Object.hasOwnProperty.call(message, 'listing_type'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.listing_type);
          if (message.state != null && Object.hasOwnProperty.call(message, 'state'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.state);
          if (message.bid_token != null && Object.hasOwnProperty.call(message, 'bid_token'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.bid_token);
          if (message.min_bid != null && Object.hasOwnProperty.call(message, 'min_bid'))
            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.min_bid);
          if (message.bid_active_rank != null && Object.hasOwnProperty.call(message, 'bid_active_rank'))
            writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.bid_active_rank);
          if (message.started_at != null && Object.hasOwnProperty.call(message, 'started_at'))
            $root.google.protobuf.Timestamp.encode(message.started_at, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
          if (message.end_at != null && Object.hasOwnProperty.call(message, 'end_at'))
            $root.google.protobuf.Timestamp.encode(message.end_at, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
          if (message.full_payment_end_at != null && Object.hasOwnProperty.call(message, 'full_payment_end_at'))
            $root.google.protobuf.Timestamp.encode(message.full_payment_end_at, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
          if (message.successful_bid_end_at != null && Object.hasOwnProperty.call(message, 'successful_bid_end_at'))
            $root.google.protobuf.Timestamp.encode(
              message.successful_bid_end_at,
              writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
            ).ldelim();
          if (message.auto_relisted_count != null && Object.hasOwnProperty.call(message, 'auto_relisted_count'))
            writer.uint32(/* id 12, wireType 0 =*/ 96).uint64(message.auto_relisted_count);
          return writer;
        };

        /**
         * Encodes the specified NftListing message, length delimited. Does not implicitly {@link ununifi.nftmarket.NftListing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.NftListing
         * @static
         * @param {ununifi.nftmarket.INftListing} message NftListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftListing.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NftListing message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.NftListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.NftListing} NftListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftListing.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.NftListing();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 2:
                message.owner = reader.string();
                break;
              case 3:
                message.listing_type = reader.int32();
                break;
              case 4:
                message.state = reader.int32();
                break;
              case 5:
                message.bid_token = reader.string();
                break;
              case 6:
                message.min_bid = reader.string();
                break;
              case 7:
                message.bid_active_rank = reader.uint64();
                break;
              case 8:
                message.started_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 9:
                message.end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 10:
                message.full_payment_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 11:
                message.successful_bid_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 12:
                message.auto_relisted_count = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a NftListing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.NftListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.NftListing} NftListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftListing.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NftListing message.
         * @function verify
         * @memberof ununifi.nftmarket.NftListing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NftListing.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.listing_type != null && message.hasOwnProperty('listing_type'))
            switch (message.listing_type) {
              default:
                return 'listing_type: enum value expected';
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.state != null && message.hasOwnProperty('state'))
            switch (message.state) {
              default:
                return 'state: enum value expected';
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
            }
          if (message.bid_token != null && message.hasOwnProperty('bid_token'))
            if (!$util.isString(message.bid_token)) return 'bid_token: string expected';
          if (message.min_bid != null && message.hasOwnProperty('min_bid'))
            if (!$util.isString(message.min_bid)) return 'min_bid: string expected';
          if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
            if (
              !$util.isInteger(message.bid_active_rank) &&
              !(message.bid_active_rank && $util.isInteger(message.bid_active_rank.low) && $util.isInteger(message.bid_active_rank.high))
            )
              return 'bid_active_rank: integer|Long expected';
          if (message.started_at != null && message.hasOwnProperty('started_at')) {
            var error = $root.google.protobuf.Timestamp.verify(message.started_at);
            if (error) return 'started_at.' + error;
          }
          if (message.end_at != null && message.hasOwnProperty('end_at')) {
            var error = $root.google.protobuf.Timestamp.verify(message.end_at);
            if (error) return 'end_at.' + error;
          }
          if (message.full_payment_end_at != null && message.hasOwnProperty('full_payment_end_at')) {
            var error = $root.google.protobuf.Timestamp.verify(message.full_payment_end_at);
            if (error) return 'full_payment_end_at.' + error;
          }
          if (message.successful_bid_end_at != null && message.hasOwnProperty('successful_bid_end_at')) {
            var error = $root.google.protobuf.Timestamp.verify(message.successful_bid_end_at);
            if (error) return 'successful_bid_end_at.' + error;
          }
          if (message.auto_relisted_count != null && message.hasOwnProperty('auto_relisted_count'))
            if (
              !$util.isInteger(message.auto_relisted_count) &&
              !(
                message.auto_relisted_count &&
                $util.isInteger(message.auto_relisted_count.low) &&
                $util.isInteger(message.auto_relisted_count.high)
              )
            )
              return 'auto_relisted_count: integer|Long expected';
          return null;
        };

        /**
         * Creates a NftListing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.NftListing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.NftListing} NftListing
         */
        NftListing.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.NftListing) return object;
          var message = new $root.ununifi.nftmarket.NftListing();
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.NftListing.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          if (object.owner != null) message.owner = String(object.owner);
          switch (object.listing_type) {
            case 'DIRECT_ASSET_BORROW':
            case 0:
              message.listing_type = 0;
              break;
            case 'SYNTHETIC_ASSET_CREATION':
            case 1:
              message.listing_type = 1;
              break;
            case 'LATE_SHIPPING':
            case 2:
              message.listing_type = 2;
              break;
          }
          switch (object.state) {
            case 'LISTING':
            case 0:
              message.state = 0;
              break;
            case 'BIDDING':
            case 1:
              message.state = 1;
              break;
            case 'SELLING_DECISION':
            case 2:
              message.state = 2;
              break;
            case 'LIQUIDATION':
            case 3:
              message.state = 3;
              break;
            case 'END_LISTING':
            case 4:
              message.state = 4;
              break;
            case 'SUCCESSFUL_BID':
            case 5:
              message.state = 5;
              break;
          }
          if (object.bid_token != null) message.bid_token = String(object.bid_token);
          if (object.min_bid != null) message.min_bid = String(object.min_bid);
          if (object.bid_active_rank != null)
            if ($util.Long) (message.bid_active_rank = $util.Long.fromValue(object.bid_active_rank)).unsigned = true;
            else if (typeof object.bid_active_rank === 'string') message.bid_active_rank = parseInt(object.bid_active_rank, 10);
            else if (typeof object.bid_active_rank === 'number') message.bid_active_rank = object.bid_active_rank;
            else if (typeof object.bid_active_rank === 'object')
              message.bid_active_rank = new $util.LongBits(object.bid_active_rank.low >>> 0, object.bid_active_rank.high >>> 0).toNumber(
                true,
              );
          if (object.started_at != null) {
            if (typeof object.started_at !== 'object') throw TypeError('.ununifi.nftmarket.NftListing.started_at: object expected');
            message.started_at = $root.google.protobuf.Timestamp.fromObject(object.started_at);
          }
          if (object.end_at != null) {
            if (typeof object.end_at !== 'object') throw TypeError('.ununifi.nftmarket.NftListing.end_at: object expected');
            message.end_at = $root.google.protobuf.Timestamp.fromObject(object.end_at);
          }
          if (object.full_payment_end_at != null) {
            if (typeof object.full_payment_end_at !== 'object')
              throw TypeError('.ununifi.nftmarket.NftListing.full_payment_end_at: object expected');
            message.full_payment_end_at = $root.google.protobuf.Timestamp.fromObject(object.full_payment_end_at);
          }
          if (object.successful_bid_end_at != null) {
            if (typeof object.successful_bid_end_at !== 'object')
              throw TypeError('.ununifi.nftmarket.NftListing.successful_bid_end_at: object expected');
            message.successful_bid_end_at = $root.google.protobuf.Timestamp.fromObject(object.successful_bid_end_at);
          }
          if (object.auto_relisted_count != null)
            if ($util.Long) (message.auto_relisted_count = $util.Long.fromValue(object.auto_relisted_count)).unsigned = true;
            else if (typeof object.auto_relisted_count === 'string') message.auto_relisted_count = parseInt(object.auto_relisted_count, 10);
            else if (typeof object.auto_relisted_count === 'number') message.auto_relisted_count = object.auto_relisted_count;
            else if (typeof object.auto_relisted_count === 'object')
              message.auto_relisted_count = new $util.LongBits(
                object.auto_relisted_count.low >>> 0,
                object.auto_relisted_count.high >>> 0,
              ).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a NftListing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.NftListing
         * @static
         * @param {ununifi.nftmarket.NftListing} message NftListing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NftListing.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.nft_id = null;
            object.owner = '';
            object.listing_type = options.enums === String ? 'DIRECT_ASSET_BORROW' : 0;
            object.state = options.enums === String ? 'LISTING' : 0;
            object.bid_token = '';
            object.min_bid = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.bid_active_rank = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.bid_active_rank = options.longs === String ? '0' : 0;
            object.started_at = null;
            object.end_at = null;
            object.full_payment_end_at = null;
            object.successful_bid_end_at = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.auto_relisted_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.auto_relisted_count = options.longs === String ? '0' : 0;
          }
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.listing_type != null && message.hasOwnProperty('listing_type'))
            object.listing_type =
              options.enums === String ? $root.ununifi.nftmarket.ListingType[message.listing_type] : message.listing_type;
          if (message.state != null && message.hasOwnProperty('state'))
            object.state = options.enums === String ? $root.ununifi.nftmarket.ListingState[message.state] : message.state;
          if (message.bid_token != null && message.hasOwnProperty('bid_token')) object.bid_token = message.bid_token;
          if (message.min_bid != null && message.hasOwnProperty('min_bid')) object.min_bid = message.min_bid;
          if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
            if (typeof message.bid_active_rank === 'number')
              object.bid_active_rank = options.longs === String ? String(message.bid_active_rank) : message.bid_active_rank;
            else
              object.bid_active_rank =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.bid_active_rank)
                  : options.longs === Number
                  ? new $util.LongBits(message.bid_active_rank.low >>> 0, message.bid_active_rank.high >>> 0).toNumber(true)
                  : message.bid_active_rank;
          if (message.started_at != null && message.hasOwnProperty('started_at'))
            object.started_at = $root.google.protobuf.Timestamp.toObject(message.started_at, options);
          if (message.end_at != null && message.hasOwnProperty('end_at'))
            object.end_at = $root.google.protobuf.Timestamp.toObject(message.end_at, options);
          if (message.full_payment_end_at != null && message.hasOwnProperty('full_payment_end_at'))
            object.full_payment_end_at = $root.google.protobuf.Timestamp.toObject(message.full_payment_end_at, options);
          if (message.successful_bid_end_at != null && message.hasOwnProperty('successful_bid_end_at'))
            object.successful_bid_end_at = $root.google.protobuf.Timestamp.toObject(message.successful_bid_end_at, options);
          if (message.auto_relisted_count != null && message.hasOwnProperty('auto_relisted_count'))
            if (typeof message.auto_relisted_count === 'number')
              object.auto_relisted_count = options.longs === String ? String(message.auto_relisted_count) : message.auto_relisted_count;
            else
              object.auto_relisted_count =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.auto_relisted_count)
                  : options.longs === Number
                  ? new $util.LongBits(message.auto_relisted_count.low >>> 0, message.auto_relisted_count.high >>> 0).toNumber(true)
                  : message.auto_relisted_count;
          return object;
        };

        /**
         * Converts this NftListing to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.NftListing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NftListing.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NftListing;
      })();

      nftmarket.NftBid = (function () {
        /**
         * Properties of a NftBid.
         * @memberof ununifi.nftmarket
         * @interface INftBid
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] NftBid nft_id
         * @property {string|null} [bidder] NftBid bidder
         * @property {cosmos.base.v1beta1.ICoin|null} [amount] NftBid amount
         * @property {boolean|null} [automatic_payment] NftBid automatic_payment
         * @property {string|null} [paid_amount] NftBid paid_amount
         * @property {google.protobuf.ITimestamp|null} [bid_time] NftBid bid_time
         */

        /**
         * Constructs a new NftBid.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a NftBid.
         * @implements INftBid
         * @constructor
         * @param {ununifi.nftmarket.INftBid=} [properties] Properties to set
         */
        function NftBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * NftBid nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.NftBid
         * @instance
         */
        NftBid.prototype.nft_id = null;

        /**
         * NftBid bidder.
         * @member {string} bidder
         * @memberof ununifi.nftmarket.NftBid
         * @instance
         */
        NftBid.prototype.bidder = '';

        /**
         * NftBid amount.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
         * @memberof ununifi.nftmarket.NftBid
         * @instance
         */
        NftBid.prototype.amount = null;

        /**
         * NftBid automatic_payment.
         * @member {boolean} automatic_payment
         * @memberof ununifi.nftmarket.NftBid
         * @instance
         */
        NftBid.prototype.automatic_payment = false;

        /**
         * NftBid paid_amount.
         * @member {string} paid_amount
         * @memberof ununifi.nftmarket.NftBid
         * @instance
         */
        NftBid.prototype.paid_amount = '';

        /**
         * NftBid bid_time.
         * @member {google.protobuf.ITimestamp|null|undefined} bid_time
         * @memberof ununifi.nftmarket.NftBid
         * @instance
         */
        NftBid.prototype.bid_time = null;

        /**
         * Encodes the specified NftBid message. Does not implicitly {@link ununifi.nftmarket.NftBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.NftBid
         * @static
         * @param {ununifi.nftmarket.INftBid} message NftBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bidder);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.automatic_payment);
          if (message.paid_amount != null && Object.hasOwnProperty.call(message, 'paid_amount'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.paid_amount);
          if (message.bid_time != null && Object.hasOwnProperty.call(message, 'bid_time'))
            $root.google.protobuf.Timestamp.encode(message.bid_time, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified NftBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.NftBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.NftBid
         * @static
         * @param {ununifi.nftmarket.INftBid} message NftBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NftBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.NftBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.NftBid} NftBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.NftBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 2:
                message.bidder = reader.string();
                break;
              case 3:
                message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                message.automatic_payment = reader.bool();
                break;
              case 5:
                message.paid_amount = reader.string();
                break;
              case 6:
                message.bid_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a NftBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.NftBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.NftBid} NftBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NftBid message.
         * @function verify
         * @memberof ununifi.nftmarket.NftBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NftBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          if (message.amount != null && message.hasOwnProperty('amount')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
            if (error) return 'amount.' + error;
          }
          if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
            if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
          if (message.paid_amount != null && message.hasOwnProperty('paid_amount'))
            if (!$util.isString(message.paid_amount)) return 'paid_amount: string expected';
          if (message.bid_time != null && message.hasOwnProperty('bid_time')) {
            var error = $root.google.protobuf.Timestamp.verify(message.bid_time);
            if (error) return 'bid_time.' + error;
          }
          return null;
        };

        /**
         * Creates a NftBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.NftBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.NftBid} NftBid
         */
        NftBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.NftBid) return object;
          var message = new $root.ununifi.nftmarket.NftBid();
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.NftBid.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          if (object.bidder != null) message.bidder = String(object.bidder);
          if (object.amount != null) {
            if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.NftBid.amount: object expected');
            message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
          }
          if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
          if (object.paid_amount != null) message.paid_amount = String(object.paid_amount);
          if (object.bid_time != null) {
            if (typeof object.bid_time !== 'object') throw TypeError('.ununifi.nftmarket.NftBid.bid_time: object expected');
            message.bid_time = $root.google.protobuf.Timestamp.fromObject(object.bid_time);
          }
          return message;
        };

        /**
         * Creates a plain object from a NftBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.NftBid
         * @static
         * @param {ununifi.nftmarket.NftBid} message NftBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NftBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.nft_id = null;
            object.bidder = '';
            object.amount = null;
            object.automatic_payment = false;
            object.paid_amount = '';
            object.bid_time = null;
          }
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          if (message.amount != null && message.hasOwnProperty('amount'))
            object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
          if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
            object.automatic_payment = message.automatic_payment;
          if (message.paid_amount != null && message.hasOwnProperty('paid_amount')) object.paid_amount = message.paid_amount;
          if (message.bid_time != null && message.hasOwnProperty('bid_time'))
            object.bid_time = $root.google.protobuf.Timestamp.toObject(message.bid_time, options);
          return object;
        };

        /**
         * Converts this NftBid to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.NftBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NftBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NftBid;
      })();

      nftmarket.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.nftmarket
         * @interface IParams
         * @property {string|null} [min_staking_for_listing] Params min_staking_for_listing
         * @property {Long|null} [default_bid_active_rank] Params default_bid_active_rank
         * @property {Array.<string>|null} [bid_tokens] Params bid_tokens
         * @property {Long|null} [auto_relisting_count_if_no_bid] Params auto_relisting_count_if_no_bid
         * @property {Long|null} [nft_listing_delay_seconds] Params nft_listing_delay_seconds
         * @property {Long|null} [nft_listing_period_initial] Params nft_listing_period_initial
         * @property {Long|null} [nft_listing_cancel_required_seconds] Params nft_listing_cancel_required_seconds
         * @property {Long|null} [nft_listing_cancel_fee_percentage] Params nft_listing_cancel_fee_percentage
         * @property {Long|null} [nft_listing_gap_time] Params nft_listing_gap_time
         * @property {Long|null} [bid_cancel_required_seconds] Params bid_cancel_required_seconds
         * @property {Long|null} [bid_token_disburse_seconds_after_cancel] Params bid_token_disburse_seconds_after_cancel
         * @property {Long|null} [nft_listing_full_payment_period] Params nft_listing_full_payment_period
         * @property {Long|null} [nft_listing_nft_delivery_period] Params nft_listing_nft_delivery_period
         * @property {Long|null} [nft_creator_share_percentage] Params nft_creator_share_percentage
         * @property {string|null} [market_administrator] Params market_administrator
         * @property {Long|null} [nft_listing_commission_fee] Params nft_listing_commission_fee
         * @property {Long|null} [nft_listing_extend_seconds] Params nft_listing_extend_seconds
         * @property {cosmos.base.v1beta1.ICoin|null} [nft_listing_period_extend_fee_per_hour] Params nft_listing_period_extend_fee_per_hour
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.nftmarket.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          this.bid_tokens = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params min_staking_for_listing.
         * @member {string} min_staking_for_listing
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.min_staking_for_listing = '';

        /**
         * Params default_bid_active_rank.
         * @member {Long} default_bid_active_rank
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.default_bid_active_rank = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params bid_tokens.
         * @member {Array.<string>} bid_tokens
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.bid_tokens = $util.emptyArray;

        /**
         * Params auto_relisting_count_if_no_bid.
         * @member {Long} auto_relisting_count_if_no_bid
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.auto_relisting_count_if_no_bid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_delay_seconds.
         * @member {Long} nft_listing_delay_seconds
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_delay_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_period_initial.
         * @member {Long} nft_listing_period_initial
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_period_initial = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_cancel_required_seconds.
         * @member {Long} nft_listing_cancel_required_seconds
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_cancel_fee_percentage.
         * @member {Long} nft_listing_cancel_fee_percentage
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_cancel_fee_percentage = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_gap_time.
         * @member {Long} nft_listing_gap_time
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_gap_time = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params bid_cancel_required_seconds.
         * @member {Long} bid_cancel_required_seconds
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.bid_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params bid_token_disburse_seconds_after_cancel.
         * @member {Long} bid_token_disburse_seconds_after_cancel
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.bid_token_disburse_seconds_after_cancel = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_full_payment_period.
         * @member {Long} nft_listing_full_payment_period
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_full_payment_period = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_nft_delivery_period.
         * @member {Long} nft_listing_nft_delivery_period
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_nft_delivery_period = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_creator_share_percentage.
         * @member {Long} nft_creator_share_percentage
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_creator_share_percentage = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params market_administrator.
         * @member {string} market_administrator
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.market_administrator = '';

        /**
         * Params nft_listing_commission_fee.
         * @member {Long} nft_listing_commission_fee
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_commission_fee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_extend_seconds.
         * @member {Long} nft_listing_extend_seconds
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_extend_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params nft_listing_period_extend_fee_per_hour.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} nft_listing_period_extend_fee_per_hour
         * @memberof ununifi.nftmarket.Params
         * @instance
         */
        Params.prototype.nft_listing_period_extend_fee_per_hour = null;

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.nftmarket.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.Params
         * @static
         * @param {ununifi.nftmarket.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.min_staking_for_listing != null && Object.hasOwnProperty.call(message, 'min_staking_for_listing'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.min_staking_for_listing);
          if (message.default_bid_active_rank != null && Object.hasOwnProperty.call(message, 'default_bid_active_rank'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.default_bid_active_rank);
          if (message.bid_tokens != null && message.bid_tokens.length)
            for (var i = 0; i < message.bid_tokens.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.bid_tokens[i]);
          if (message.auto_relisting_count_if_no_bid != null && Object.hasOwnProperty.call(message, 'auto_relisting_count_if_no_bid'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.auto_relisting_count_if_no_bid);
          if (message.nft_listing_delay_seconds != null && Object.hasOwnProperty.call(message, 'nft_listing_delay_seconds'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.nft_listing_delay_seconds);
          if (message.nft_listing_period_initial != null && Object.hasOwnProperty.call(message, 'nft_listing_period_initial'))
            writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.nft_listing_period_initial);
          if (
            message.nft_listing_cancel_required_seconds != null &&
            Object.hasOwnProperty.call(message, 'nft_listing_cancel_required_seconds')
          )
            writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.nft_listing_cancel_required_seconds);
          if (message.nft_listing_cancel_fee_percentage != null && Object.hasOwnProperty.call(message, 'nft_listing_cancel_fee_percentage'))
            writer.uint32(/* id 8, wireType 0 =*/ 64).uint64(message.nft_listing_cancel_fee_percentage);
          if (message.nft_listing_gap_time != null && Object.hasOwnProperty.call(message, 'nft_listing_gap_time'))
            writer.uint32(/* id 9, wireType 0 =*/ 72).uint64(message.nft_listing_gap_time);
          if (message.bid_cancel_required_seconds != null && Object.hasOwnProperty.call(message, 'bid_cancel_required_seconds'))
            writer.uint32(/* id 10, wireType 0 =*/ 80).uint64(message.bid_cancel_required_seconds);
          if (
            message.bid_token_disburse_seconds_after_cancel != null &&
            Object.hasOwnProperty.call(message, 'bid_token_disburse_seconds_after_cancel')
          )
            writer.uint32(/* id 11, wireType 0 =*/ 88).uint64(message.bid_token_disburse_seconds_after_cancel);
          if (message.nft_listing_full_payment_period != null && Object.hasOwnProperty.call(message, 'nft_listing_full_payment_period'))
            writer.uint32(/* id 12, wireType 0 =*/ 96).uint64(message.nft_listing_full_payment_period);
          if (message.nft_listing_nft_delivery_period != null && Object.hasOwnProperty.call(message, 'nft_listing_nft_delivery_period'))
            writer.uint32(/* id 13, wireType 0 =*/ 104).uint64(message.nft_listing_nft_delivery_period);
          if (message.nft_creator_share_percentage != null && Object.hasOwnProperty.call(message, 'nft_creator_share_percentage'))
            writer.uint32(/* id 14, wireType 0 =*/ 112).uint64(message.nft_creator_share_percentage);
          if (message.market_administrator != null && Object.hasOwnProperty.call(message, 'market_administrator'))
            writer.uint32(/* id 15, wireType 2 =*/ 122).string(message.market_administrator);
          if (message.nft_listing_commission_fee != null && Object.hasOwnProperty.call(message, 'nft_listing_commission_fee'))
            writer.uint32(/* id 16, wireType 0 =*/ 128).uint64(message.nft_listing_commission_fee);
          if (message.nft_listing_extend_seconds != null && Object.hasOwnProperty.call(message, 'nft_listing_extend_seconds'))
            writer.uint32(/* id 17, wireType 0 =*/ 136).uint64(message.nft_listing_extend_seconds);
          if (
            message.nft_listing_period_extend_fee_per_hour != null &&
            Object.hasOwnProperty.call(message, 'nft_listing_period_extend_fee_per_hour')
          )
            $root.cosmos.base.v1beta1.Coin.encode(
              message.nft_listing_period_extend_fee_per_hour,
              writer.uint32(/* id 18, wireType 2 =*/ 146).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftmarket.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.Params
         * @static
         * @param {ununifi.nftmarket.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.min_staking_for_listing = reader.string();
                break;
              case 2:
                message.default_bid_active_rank = reader.uint64();
                break;
              case 3:
                if (!(message.bid_tokens && message.bid_tokens.length)) message.bid_tokens = [];
                message.bid_tokens.push(reader.string());
                break;
              case 4:
                message.auto_relisting_count_if_no_bid = reader.uint64();
                break;
              case 5:
                message.nft_listing_delay_seconds = reader.uint64();
                break;
              case 6:
                message.nft_listing_period_initial = reader.uint64();
                break;
              case 7:
                message.nft_listing_cancel_required_seconds = reader.uint64();
                break;
              case 8:
                message.nft_listing_cancel_fee_percentage = reader.uint64();
                break;
              case 9:
                message.nft_listing_gap_time = reader.uint64();
                break;
              case 10:
                message.bid_cancel_required_seconds = reader.uint64();
                break;
              case 11:
                message.bid_token_disburse_seconds_after_cancel = reader.uint64();
                break;
              case 12:
                message.nft_listing_full_payment_period = reader.uint64();
                break;
              case 13:
                message.nft_listing_nft_delivery_period = reader.uint64();
                break;
              case 14:
                message.nft_creator_share_percentage = reader.uint64();
                break;
              case 15:
                message.market_administrator = reader.string();
                break;
              case 16:
                message.nft_listing_commission_fee = reader.uint64();
                break;
              case 17:
                message.nft_listing_extend_seconds = reader.uint64();
                break;
              case 18:
                message.nft_listing_period_extend_fee_per_hour = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.nftmarket.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.min_staking_for_listing != null && message.hasOwnProperty('min_staking_for_listing'))
            if (!$util.isString(message.min_staking_for_listing)) return 'min_staking_for_listing: string expected';
          if (message.default_bid_active_rank != null && message.hasOwnProperty('default_bid_active_rank'))
            if (
              !$util.isInteger(message.default_bid_active_rank) &&
              !(
                message.default_bid_active_rank &&
                $util.isInteger(message.default_bid_active_rank.low) &&
                $util.isInteger(message.default_bid_active_rank.high)
              )
            )
              return 'default_bid_active_rank: integer|Long expected';
          if (message.bid_tokens != null && message.hasOwnProperty('bid_tokens')) {
            if (!Array.isArray(message.bid_tokens)) return 'bid_tokens: array expected';
            for (var i = 0; i < message.bid_tokens.length; ++i)
              if (!$util.isString(message.bid_tokens[i])) return 'bid_tokens: string[] expected';
          }
          if (message.auto_relisting_count_if_no_bid != null && message.hasOwnProperty('auto_relisting_count_if_no_bid'))
            if (
              !$util.isInteger(message.auto_relisting_count_if_no_bid) &&
              !(
                message.auto_relisting_count_if_no_bid &&
                $util.isInteger(message.auto_relisting_count_if_no_bid.low) &&
                $util.isInteger(message.auto_relisting_count_if_no_bid.high)
              )
            )
              return 'auto_relisting_count_if_no_bid: integer|Long expected';
          if (message.nft_listing_delay_seconds != null && message.hasOwnProperty('nft_listing_delay_seconds'))
            if (
              !$util.isInteger(message.nft_listing_delay_seconds) &&
              !(
                message.nft_listing_delay_seconds &&
                $util.isInteger(message.nft_listing_delay_seconds.low) &&
                $util.isInteger(message.nft_listing_delay_seconds.high)
              )
            )
              return 'nft_listing_delay_seconds: integer|Long expected';
          if (message.nft_listing_period_initial != null && message.hasOwnProperty('nft_listing_period_initial'))
            if (
              !$util.isInteger(message.nft_listing_period_initial) &&
              !(
                message.nft_listing_period_initial &&
                $util.isInteger(message.nft_listing_period_initial.low) &&
                $util.isInteger(message.nft_listing_period_initial.high)
              )
            )
              return 'nft_listing_period_initial: integer|Long expected';
          if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty('nft_listing_cancel_required_seconds'))
            if (
              !$util.isInteger(message.nft_listing_cancel_required_seconds) &&
              !(
                message.nft_listing_cancel_required_seconds &&
                $util.isInteger(message.nft_listing_cancel_required_seconds.low) &&
                $util.isInteger(message.nft_listing_cancel_required_seconds.high)
              )
            )
              return 'nft_listing_cancel_required_seconds: integer|Long expected';
          if (message.nft_listing_cancel_fee_percentage != null && message.hasOwnProperty('nft_listing_cancel_fee_percentage'))
            if (
              !$util.isInteger(message.nft_listing_cancel_fee_percentage) &&
              !(
                message.nft_listing_cancel_fee_percentage &&
                $util.isInteger(message.nft_listing_cancel_fee_percentage.low) &&
                $util.isInteger(message.nft_listing_cancel_fee_percentage.high)
              )
            )
              return 'nft_listing_cancel_fee_percentage: integer|Long expected';
          if (message.nft_listing_gap_time != null && message.hasOwnProperty('nft_listing_gap_time'))
            if (
              !$util.isInteger(message.nft_listing_gap_time) &&
              !(
                message.nft_listing_gap_time &&
                $util.isInteger(message.nft_listing_gap_time.low) &&
                $util.isInteger(message.nft_listing_gap_time.high)
              )
            )
              return 'nft_listing_gap_time: integer|Long expected';
          if (message.bid_cancel_required_seconds != null && message.hasOwnProperty('bid_cancel_required_seconds'))
            if (
              !$util.isInteger(message.bid_cancel_required_seconds) &&
              !(
                message.bid_cancel_required_seconds &&
                $util.isInteger(message.bid_cancel_required_seconds.low) &&
                $util.isInteger(message.bid_cancel_required_seconds.high)
              )
            )
              return 'bid_cancel_required_seconds: integer|Long expected';
          if (message.bid_token_disburse_seconds_after_cancel != null && message.hasOwnProperty('bid_token_disburse_seconds_after_cancel'))
            if (
              !$util.isInteger(message.bid_token_disburse_seconds_after_cancel) &&
              !(
                message.bid_token_disburse_seconds_after_cancel &&
                $util.isInteger(message.bid_token_disburse_seconds_after_cancel.low) &&
                $util.isInteger(message.bid_token_disburse_seconds_after_cancel.high)
              )
            )
              return 'bid_token_disburse_seconds_after_cancel: integer|Long expected';
          if (message.nft_listing_full_payment_period != null && message.hasOwnProperty('nft_listing_full_payment_period'))
            if (
              !$util.isInteger(message.nft_listing_full_payment_period) &&
              !(
                message.nft_listing_full_payment_period &&
                $util.isInteger(message.nft_listing_full_payment_period.low) &&
                $util.isInteger(message.nft_listing_full_payment_period.high)
              )
            )
              return 'nft_listing_full_payment_period: integer|Long expected';
          if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty('nft_listing_nft_delivery_period'))
            if (
              !$util.isInteger(message.nft_listing_nft_delivery_period) &&
              !(
                message.nft_listing_nft_delivery_period &&
                $util.isInteger(message.nft_listing_nft_delivery_period.low) &&
                $util.isInteger(message.nft_listing_nft_delivery_period.high)
              )
            )
              return 'nft_listing_nft_delivery_period: integer|Long expected';
          if (message.nft_creator_share_percentage != null && message.hasOwnProperty('nft_creator_share_percentage'))
            if (
              !$util.isInteger(message.nft_creator_share_percentage) &&
              !(
                message.nft_creator_share_percentage &&
                $util.isInteger(message.nft_creator_share_percentage.low) &&
                $util.isInteger(message.nft_creator_share_percentage.high)
              )
            )
              return 'nft_creator_share_percentage: integer|Long expected';
          if (message.market_administrator != null && message.hasOwnProperty('market_administrator'))
            if (!$util.isString(message.market_administrator)) return 'market_administrator: string expected';
          if (message.nft_listing_commission_fee != null && message.hasOwnProperty('nft_listing_commission_fee'))
            if (
              !$util.isInteger(message.nft_listing_commission_fee) &&
              !(
                message.nft_listing_commission_fee &&
                $util.isInteger(message.nft_listing_commission_fee.low) &&
                $util.isInteger(message.nft_listing_commission_fee.high)
              )
            )
              return 'nft_listing_commission_fee: integer|Long expected';
          if (message.nft_listing_extend_seconds != null && message.hasOwnProperty('nft_listing_extend_seconds'))
            if (
              !$util.isInteger(message.nft_listing_extend_seconds) &&
              !(
                message.nft_listing_extend_seconds &&
                $util.isInteger(message.nft_listing_extend_seconds.low) &&
                $util.isInteger(message.nft_listing_extend_seconds.high)
              )
            )
              return 'nft_listing_extend_seconds: integer|Long expected';
          if (message.nft_listing_period_extend_fee_per_hour != null && message.hasOwnProperty('nft_listing_period_extend_fee_per_hour')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.nft_listing_period_extend_fee_per_hour);
            if (error) return 'nft_listing_period_extend_fee_per_hour.' + error;
          }
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.Params) return object;
          var message = new $root.ununifi.nftmarket.Params();
          if (object.min_staking_for_listing != null) message.min_staking_for_listing = String(object.min_staking_for_listing);
          if (object.default_bid_active_rank != null)
            if ($util.Long) (message.default_bid_active_rank = $util.Long.fromValue(object.default_bid_active_rank)).unsigned = true;
            else if (typeof object.default_bid_active_rank === 'string')
              message.default_bid_active_rank = parseInt(object.default_bid_active_rank, 10);
            else if (typeof object.default_bid_active_rank === 'number') message.default_bid_active_rank = object.default_bid_active_rank;
            else if (typeof object.default_bid_active_rank === 'object')
              message.default_bid_active_rank = new $util.LongBits(
                object.default_bid_active_rank.low >>> 0,
                object.default_bid_active_rank.high >>> 0,
              ).toNumber(true);
          if (object.bid_tokens) {
            if (!Array.isArray(object.bid_tokens)) throw TypeError('.ununifi.nftmarket.Params.bid_tokens: array expected');
            message.bid_tokens = [];
            for (var i = 0; i < object.bid_tokens.length; ++i) message.bid_tokens[i] = String(object.bid_tokens[i]);
          }
          if (object.auto_relisting_count_if_no_bid != null)
            if ($util.Long)
              (message.auto_relisting_count_if_no_bid = $util.Long.fromValue(object.auto_relisting_count_if_no_bid)).unsigned = true;
            else if (typeof object.auto_relisting_count_if_no_bid === 'string')
              message.auto_relisting_count_if_no_bid = parseInt(object.auto_relisting_count_if_no_bid, 10);
            else if (typeof object.auto_relisting_count_if_no_bid === 'number')
              message.auto_relisting_count_if_no_bid = object.auto_relisting_count_if_no_bid;
            else if (typeof object.auto_relisting_count_if_no_bid === 'object')
              message.auto_relisting_count_if_no_bid = new $util.LongBits(
                object.auto_relisting_count_if_no_bid.low >>> 0,
                object.auto_relisting_count_if_no_bid.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_delay_seconds != null)
            if ($util.Long) (message.nft_listing_delay_seconds = $util.Long.fromValue(object.nft_listing_delay_seconds)).unsigned = true;
            else if (typeof object.nft_listing_delay_seconds === 'string')
              message.nft_listing_delay_seconds = parseInt(object.nft_listing_delay_seconds, 10);
            else if (typeof object.nft_listing_delay_seconds === 'number')
              message.nft_listing_delay_seconds = object.nft_listing_delay_seconds;
            else if (typeof object.nft_listing_delay_seconds === 'object')
              message.nft_listing_delay_seconds = new $util.LongBits(
                object.nft_listing_delay_seconds.low >>> 0,
                object.nft_listing_delay_seconds.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_period_initial != null)
            if ($util.Long) (message.nft_listing_period_initial = $util.Long.fromValue(object.nft_listing_period_initial)).unsigned = true;
            else if (typeof object.nft_listing_period_initial === 'string')
              message.nft_listing_period_initial = parseInt(object.nft_listing_period_initial, 10);
            else if (typeof object.nft_listing_period_initial === 'number')
              message.nft_listing_period_initial = object.nft_listing_period_initial;
            else if (typeof object.nft_listing_period_initial === 'object')
              message.nft_listing_period_initial = new $util.LongBits(
                object.nft_listing_period_initial.low >>> 0,
                object.nft_listing_period_initial.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_cancel_required_seconds != null)
            if ($util.Long)
              (message.nft_listing_cancel_required_seconds = $util.Long.fromValue(
                object.nft_listing_cancel_required_seconds,
              )).unsigned = true;
            else if (typeof object.nft_listing_cancel_required_seconds === 'string')
              message.nft_listing_cancel_required_seconds = parseInt(object.nft_listing_cancel_required_seconds, 10);
            else if (typeof object.nft_listing_cancel_required_seconds === 'number')
              message.nft_listing_cancel_required_seconds = object.nft_listing_cancel_required_seconds;
            else if (typeof object.nft_listing_cancel_required_seconds === 'object')
              message.nft_listing_cancel_required_seconds = new $util.LongBits(
                object.nft_listing_cancel_required_seconds.low >>> 0,
                object.nft_listing_cancel_required_seconds.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_cancel_fee_percentage != null)
            if ($util.Long)
              (message.nft_listing_cancel_fee_percentage = $util.Long.fromValue(object.nft_listing_cancel_fee_percentage)).unsigned = true;
            else if (typeof object.nft_listing_cancel_fee_percentage === 'string')
              message.nft_listing_cancel_fee_percentage = parseInt(object.nft_listing_cancel_fee_percentage, 10);
            else if (typeof object.nft_listing_cancel_fee_percentage === 'number')
              message.nft_listing_cancel_fee_percentage = object.nft_listing_cancel_fee_percentage;
            else if (typeof object.nft_listing_cancel_fee_percentage === 'object')
              message.nft_listing_cancel_fee_percentage = new $util.LongBits(
                object.nft_listing_cancel_fee_percentage.low >>> 0,
                object.nft_listing_cancel_fee_percentage.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_gap_time != null)
            if ($util.Long) (message.nft_listing_gap_time = $util.Long.fromValue(object.nft_listing_gap_time)).unsigned = true;
            else if (typeof object.nft_listing_gap_time === 'string')
              message.nft_listing_gap_time = parseInt(object.nft_listing_gap_time, 10);
            else if (typeof object.nft_listing_gap_time === 'number') message.nft_listing_gap_time = object.nft_listing_gap_time;
            else if (typeof object.nft_listing_gap_time === 'object')
              message.nft_listing_gap_time = new $util.LongBits(
                object.nft_listing_gap_time.low >>> 0,
                object.nft_listing_gap_time.high >>> 0,
              ).toNumber(true);
          if (object.bid_cancel_required_seconds != null)
            if ($util.Long)
              (message.bid_cancel_required_seconds = $util.Long.fromValue(object.bid_cancel_required_seconds)).unsigned = true;
            else if (typeof object.bid_cancel_required_seconds === 'string')
              message.bid_cancel_required_seconds = parseInt(object.bid_cancel_required_seconds, 10);
            else if (typeof object.bid_cancel_required_seconds === 'number')
              message.bid_cancel_required_seconds = object.bid_cancel_required_seconds;
            else if (typeof object.bid_cancel_required_seconds === 'object')
              message.bid_cancel_required_seconds = new $util.LongBits(
                object.bid_cancel_required_seconds.low >>> 0,
                object.bid_cancel_required_seconds.high >>> 0,
              ).toNumber(true);
          if (object.bid_token_disburse_seconds_after_cancel != null)
            if ($util.Long)
              (message.bid_token_disburse_seconds_after_cancel = $util.Long.fromValue(
                object.bid_token_disburse_seconds_after_cancel,
              )).unsigned = true;
            else if (typeof object.bid_token_disburse_seconds_after_cancel === 'string')
              message.bid_token_disburse_seconds_after_cancel = parseInt(object.bid_token_disburse_seconds_after_cancel, 10);
            else if (typeof object.bid_token_disburse_seconds_after_cancel === 'number')
              message.bid_token_disburse_seconds_after_cancel = object.bid_token_disburse_seconds_after_cancel;
            else if (typeof object.bid_token_disburse_seconds_after_cancel === 'object')
              message.bid_token_disburse_seconds_after_cancel = new $util.LongBits(
                object.bid_token_disburse_seconds_after_cancel.low >>> 0,
                object.bid_token_disburse_seconds_after_cancel.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_full_payment_period != null)
            if ($util.Long)
              (message.nft_listing_full_payment_period = $util.Long.fromValue(object.nft_listing_full_payment_period)).unsigned = true;
            else if (typeof object.nft_listing_full_payment_period === 'string')
              message.nft_listing_full_payment_period = parseInt(object.nft_listing_full_payment_period, 10);
            else if (typeof object.nft_listing_full_payment_period === 'number')
              message.nft_listing_full_payment_period = object.nft_listing_full_payment_period;
            else if (typeof object.nft_listing_full_payment_period === 'object')
              message.nft_listing_full_payment_period = new $util.LongBits(
                object.nft_listing_full_payment_period.low >>> 0,
                object.nft_listing_full_payment_period.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_nft_delivery_period != null)
            if ($util.Long)
              (message.nft_listing_nft_delivery_period = $util.Long.fromValue(object.nft_listing_nft_delivery_period)).unsigned = true;
            else if (typeof object.nft_listing_nft_delivery_period === 'string')
              message.nft_listing_nft_delivery_period = parseInt(object.nft_listing_nft_delivery_period, 10);
            else if (typeof object.nft_listing_nft_delivery_period === 'number')
              message.nft_listing_nft_delivery_period = object.nft_listing_nft_delivery_period;
            else if (typeof object.nft_listing_nft_delivery_period === 'object')
              message.nft_listing_nft_delivery_period = new $util.LongBits(
                object.nft_listing_nft_delivery_period.low >>> 0,
                object.nft_listing_nft_delivery_period.high >>> 0,
              ).toNumber(true);
          if (object.nft_creator_share_percentage != null)
            if ($util.Long)
              (message.nft_creator_share_percentage = $util.Long.fromValue(object.nft_creator_share_percentage)).unsigned = true;
            else if (typeof object.nft_creator_share_percentage === 'string')
              message.nft_creator_share_percentage = parseInt(object.nft_creator_share_percentage, 10);
            else if (typeof object.nft_creator_share_percentage === 'number')
              message.nft_creator_share_percentage = object.nft_creator_share_percentage;
            else if (typeof object.nft_creator_share_percentage === 'object')
              message.nft_creator_share_percentage = new $util.LongBits(
                object.nft_creator_share_percentage.low >>> 0,
                object.nft_creator_share_percentage.high >>> 0,
              ).toNumber(true);
          if (object.market_administrator != null) message.market_administrator = String(object.market_administrator);
          if (object.nft_listing_commission_fee != null)
            if ($util.Long) (message.nft_listing_commission_fee = $util.Long.fromValue(object.nft_listing_commission_fee)).unsigned = true;
            else if (typeof object.nft_listing_commission_fee === 'string')
              message.nft_listing_commission_fee = parseInt(object.nft_listing_commission_fee, 10);
            else if (typeof object.nft_listing_commission_fee === 'number')
              message.nft_listing_commission_fee = object.nft_listing_commission_fee;
            else if (typeof object.nft_listing_commission_fee === 'object')
              message.nft_listing_commission_fee = new $util.LongBits(
                object.nft_listing_commission_fee.low >>> 0,
                object.nft_listing_commission_fee.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_extend_seconds != null)
            if ($util.Long) (message.nft_listing_extend_seconds = $util.Long.fromValue(object.nft_listing_extend_seconds)).unsigned = true;
            else if (typeof object.nft_listing_extend_seconds === 'string')
              message.nft_listing_extend_seconds = parseInt(object.nft_listing_extend_seconds, 10);
            else if (typeof object.nft_listing_extend_seconds === 'number')
              message.nft_listing_extend_seconds = object.nft_listing_extend_seconds;
            else if (typeof object.nft_listing_extend_seconds === 'object')
              message.nft_listing_extend_seconds = new $util.LongBits(
                object.nft_listing_extend_seconds.low >>> 0,
                object.nft_listing_extend_seconds.high >>> 0,
              ).toNumber(true);
          if (object.nft_listing_period_extend_fee_per_hour != null) {
            if (typeof object.nft_listing_period_extend_fee_per_hour !== 'object')
              throw TypeError('.ununifi.nftmarket.Params.nft_listing_period_extend_fee_per_hour: object expected');
            message.nft_listing_period_extend_fee_per_hour = $root.cosmos.base.v1beta1.Coin.fromObject(
              object.nft_listing_period_extend_fee_per_hour,
            );
          }
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.Params
         * @static
         * @param {ununifi.nftmarket.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.bid_tokens = [];
          if (options.defaults) {
            object.min_staking_for_listing = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.default_bid_active_rank =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.default_bid_active_rank = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.auto_relisting_count_if_no_bid =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.auto_relisting_count_if_no_bid = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_delay_seconds =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_delay_seconds = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_period_initial =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_period_initial = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_cancel_required_seconds =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_cancel_required_seconds = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_cancel_fee_percentage =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_cancel_fee_percentage = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_gap_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_gap_time = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.bid_cancel_required_seconds =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.bid_cancel_required_seconds = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.bid_token_disburse_seconds_after_cancel =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.bid_token_disburse_seconds_after_cancel = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_full_payment_period =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_full_payment_period = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_nft_delivery_period =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_nft_delivery_period = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_creator_share_percentage =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_creator_share_percentage = options.longs === String ? '0' : 0;
            object.market_administrator = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_commission_fee =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_commission_fee = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.nft_listing_extend_seconds =
                options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.nft_listing_extend_seconds = options.longs === String ? '0' : 0;
            object.nft_listing_period_extend_fee_per_hour = null;
          }
          if (message.min_staking_for_listing != null && message.hasOwnProperty('min_staking_for_listing'))
            object.min_staking_for_listing = message.min_staking_for_listing;
          if (message.default_bid_active_rank != null && message.hasOwnProperty('default_bid_active_rank'))
            if (typeof message.default_bid_active_rank === 'number')
              object.default_bid_active_rank =
                options.longs === String ? String(message.default_bid_active_rank) : message.default_bid_active_rank;
            else
              object.default_bid_active_rank =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.default_bid_active_rank)
                  : options.longs === Number
                  ? new $util.LongBits(message.default_bid_active_rank.low >>> 0, message.default_bid_active_rank.high >>> 0).toNumber(true)
                  : message.default_bid_active_rank;
          if (message.bid_tokens && message.bid_tokens.length) {
            object.bid_tokens = [];
            for (var j = 0; j < message.bid_tokens.length; ++j) object.bid_tokens[j] = message.bid_tokens[j];
          }
          if (message.auto_relisting_count_if_no_bid != null && message.hasOwnProperty('auto_relisting_count_if_no_bid'))
            if (typeof message.auto_relisting_count_if_no_bid === 'number')
              object.auto_relisting_count_if_no_bid =
                options.longs === String ? String(message.auto_relisting_count_if_no_bid) : message.auto_relisting_count_if_no_bid;
            else
              object.auto_relisting_count_if_no_bid =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.auto_relisting_count_if_no_bid)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.auto_relisting_count_if_no_bid.low >>> 0,
                      message.auto_relisting_count_if_no_bid.high >>> 0,
                    ).toNumber(true)
                  : message.auto_relisting_count_if_no_bid;
          if (message.nft_listing_delay_seconds != null && message.hasOwnProperty('nft_listing_delay_seconds'))
            if (typeof message.nft_listing_delay_seconds === 'number')
              object.nft_listing_delay_seconds =
                options.longs === String ? String(message.nft_listing_delay_seconds) : message.nft_listing_delay_seconds;
            else
              object.nft_listing_delay_seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_delay_seconds)
                  : options.longs === Number
                  ? new $util.LongBits(message.nft_listing_delay_seconds.low >>> 0, message.nft_listing_delay_seconds.high >>> 0).toNumber(
                      true,
                    )
                  : message.nft_listing_delay_seconds;
          if (message.nft_listing_period_initial != null && message.hasOwnProperty('nft_listing_period_initial'))
            if (typeof message.nft_listing_period_initial === 'number')
              object.nft_listing_period_initial =
                options.longs === String ? String(message.nft_listing_period_initial) : message.nft_listing_period_initial;
            else
              object.nft_listing_period_initial =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_period_initial)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_listing_period_initial.low >>> 0,
                      message.nft_listing_period_initial.high >>> 0,
                    ).toNumber(true)
                  : message.nft_listing_period_initial;
          if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty('nft_listing_cancel_required_seconds'))
            if (typeof message.nft_listing_cancel_required_seconds === 'number')
              object.nft_listing_cancel_required_seconds =
                options.longs === String
                  ? String(message.nft_listing_cancel_required_seconds)
                  : message.nft_listing_cancel_required_seconds;
            else
              object.nft_listing_cancel_required_seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_cancel_required_seconds)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_listing_cancel_required_seconds.low >>> 0,
                      message.nft_listing_cancel_required_seconds.high >>> 0,
                    ).toNumber(true)
                  : message.nft_listing_cancel_required_seconds;
          if (message.nft_listing_cancel_fee_percentage != null && message.hasOwnProperty('nft_listing_cancel_fee_percentage'))
            if (typeof message.nft_listing_cancel_fee_percentage === 'number')
              object.nft_listing_cancel_fee_percentage =
                options.longs === String ? String(message.nft_listing_cancel_fee_percentage) : message.nft_listing_cancel_fee_percentage;
            else
              object.nft_listing_cancel_fee_percentage =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_cancel_fee_percentage)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_listing_cancel_fee_percentage.low >>> 0,
                      message.nft_listing_cancel_fee_percentage.high >>> 0,
                    ).toNumber(true)
                  : message.nft_listing_cancel_fee_percentage;
          if (message.nft_listing_gap_time != null && message.hasOwnProperty('nft_listing_gap_time'))
            if (typeof message.nft_listing_gap_time === 'number')
              object.nft_listing_gap_time = options.longs === String ? String(message.nft_listing_gap_time) : message.nft_listing_gap_time;
            else
              object.nft_listing_gap_time =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_gap_time)
                  : options.longs === Number
                  ? new $util.LongBits(message.nft_listing_gap_time.low >>> 0, message.nft_listing_gap_time.high >>> 0).toNumber(true)
                  : message.nft_listing_gap_time;
          if (message.bid_cancel_required_seconds != null && message.hasOwnProperty('bid_cancel_required_seconds'))
            if (typeof message.bid_cancel_required_seconds === 'number')
              object.bid_cancel_required_seconds =
                options.longs === String ? String(message.bid_cancel_required_seconds) : message.bid_cancel_required_seconds;
            else
              object.bid_cancel_required_seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.bid_cancel_required_seconds)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.bid_cancel_required_seconds.low >>> 0,
                      message.bid_cancel_required_seconds.high >>> 0,
                    ).toNumber(true)
                  : message.bid_cancel_required_seconds;
          if (message.bid_token_disburse_seconds_after_cancel != null && message.hasOwnProperty('bid_token_disburse_seconds_after_cancel'))
            if (typeof message.bid_token_disburse_seconds_after_cancel === 'number')
              object.bid_token_disburse_seconds_after_cancel =
                options.longs === String
                  ? String(message.bid_token_disburse_seconds_after_cancel)
                  : message.bid_token_disburse_seconds_after_cancel;
            else
              object.bid_token_disburse_seconds_after_cancel =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.bid_token_disburse_seconds_after_cancel)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.bid_token_disburse_seconds_after_cancel.low >>> 0,
                      message.bid_token_disburse_seconds_after_cancel.high >>> 0,
                    ).toNumber(true)
                  : message.bid_token_disburse_seconds_after_cancel;
          if (message.nft_listing_full_payment_period != null && message.hasOwnProperty('nft_listing_full_payment_period'))
            if (typeof message.nft_listing_full_payment_period === 'number')
              object.nft_listing_full_payment_period =
                options.longs === String ? String(message.nft_listing_full_payment_period) : message.nft_listing_full_payment_period;
            else
              object.nft_listing_full_payment_period =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_full_payment_period)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_listing_full_payment_period.low >>> 0,
                      message.nft_listing_full_payment_period.high >>> 0,
                    ).toNumber(true)
                  : message.nft_listing_full_payment_period;
          if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty('nft_listing_nft_delivery_period'))
            if (typeof message.nft_listing_nft_delivery_period === 'number')
              object.nft_listing_nft_delivery_period =
                options.longs === String ? String(message.nft_listing_nft_delivery_period) : message.nft_listing_nft_delivery_period;
            else
              object.nft_listing_nft_delivery_period =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_nft_delivery_period)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_listing_nft_delivery_period.low >>> 0,
                      message.nft_listing_nft_delivery_period.high >>> 0,
                    ).toNumber(true)
                  : message.nft_listing_nft_delivery_period;
          if (message.nft_creator_share_percentage != null && message.hasOwnProperty('nft_creator_share_percentage'))
            if (typeof message.nft_creator_share_percentage === 'number')
              object.nft_creator_share_percentage =
                options.longs === String ? String(message.nft_creator_share_percentage) : message.nft_creator_share_percentage;
            else
              object.nft_creator_share_percentage =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_creator_share_percentage)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_creator_share_percentage.low >>> 0,
                      message.nft_creator_share_percentage.high >>> 0,
                    ).toNumber(true)
                  : message.nft_creator_share_percentage;
          if (message.market_administrator != null && message.hasOwnProperty('market_administrator'))
            object.market_administrator = message.market_administrator;
          if (message.nft_listing_commission_fee != null && message.hasOwnProperty('nft_listing_commission_fee'))
            if (typeof message.nft_listing_commission_fee === 'number')
              object.nft_listing_commission_fee =
                options.longs === String ? String(message.nft_listing_commission_fee) : message.nft_listing_commission_fee;
            else
              object.nft_listing_commission_fee =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_commission_fee)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_listing_commission_fee.low >>> 0,
                      message.nft_listing_commission_fee.high >>> 0,
                    ).toNumber(true)
                  : message.nft_listing_commission_fee;
          if (message.nft_listing_extend_seconds != null && message.hasOwnProperty('nft_listing_extend_seconds'))
            if (typeof message.nft_listing_extend_seconds === 'number')
              object.nft_listing_extend_seconds =
                options.longs === String ? String(message.nft_listing_extend_seconds) : message.nft_listing_extend_seconds;
            else
              object.nft_listing_extend_seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.nft_listing_extend_seconds)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.nft_listing_extend_seconds.low >>> 0,
                      message.nft_listing_extend_seconds.high >>> 0,
                    ).toNumber(true)
                  : message.nft_listing_extend_seconds;
          if (message.nft_listing_period_extend_fee_per_hour != null && message.hasOwnProperty('nft_listing_period_extend_fee_per_hour'))
            object.nft_listing_period_extend_fee_per_hour = $root.cosmos.base.v1beta1.Coin.toObject(
              message.nft_listing_period_extend_fee_per_hour,
              options,
            );
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      nftmarket.EventListNft = (function () {
        /**
         * Properties of an EventListNft.
         * @memberof ununifi.nftmarket
         * @interface IEventListNft
         * @property {string|null} [owner] EventListNft owner
         * @property {string|null} [class_id] EventListNft class_id
         * @property {string|null} [nft_id] EventListNft nft_id
         */

        /**
         * Constructs a new EventListNft.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventListNft.
         * @implements IEventListNft
         * @constructor
         * @param {ununifi.nftmarket.IEventListNft=} [properties] Properties to set
         */
        function EventListNft(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventListNft owner.
         * @member {string} owner
         * @memberof ununifi.nftmarket.EventListNft
         * @instance
         */
        EventListNft.prototype.owner = '';

        /**
         * EventListNft class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventListNft
         * @instance
         */
        EventListNft.prototype.class_id = '';

        /**
         * EventListNft nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventListNft
         * @instance
         */
        EventListNft.prototype.nft_id = '';

        /**
         * Encodes the specified EventListNft message. Does not implicitly {@link ununifi.nftmarket.EventListNft.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventListNft
         * @static
         * @param {ununifi.nftmarket.IEventListNft} message EventListNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventListNft.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventListNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventListNft.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventListNft
         * @static
         * @param {ununifi.nftmarket.IEventListNft} message EventListNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventListNft.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventListNft message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventListNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventListNft} EventListNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventListNft.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventListNft();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventListNft message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventListNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventListNft} EventListNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventListNft.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventListNft message.
         * @function verify
         * @memberof ununifi.nftmarket.EventListNft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventListNft.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventListNft message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventListNft
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventListNft} EventListNft
         */
        EventListNft.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventListNft) return object;
          var message = new $root.ununifi.nftmarket.EventListNft();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventListNft message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventListNft
         * @static
         * @param {ununifi.nftmarket.EventListNft} message EventListNft
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventListNft.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventListNft to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventListNft
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventListNft.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventListNft;
      })();

      nftmarket.EventCancelListNfting = (function () {
        /**
         * Properties of an EventCancelListNfting.
         * @memberof ununifi.nftmarket
         * @interface IEventCancelListNfting
         * @property {string|null} [owner] EventCancelListNfting owner
         * @property {string|null} [class_id] EventCancelListNfting class_id
         * @property {string|null} [nft_id] EventCancelListNfting nft_id
         */

        /**
         * Constructs a new EventCancelListNfting.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventCancelListNfting.
         * @implements IEventCancelListNfting
         * @constructor
         * @param {ununifi.nftmarket.IEventCancelListNfting=} [properties] Properties to set
         */
        function EventCancelListNfting(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventCancelListNfting owner.
         * @member {string} owner
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @instance
         */
        EventCancelListNfting.prototype.owner = '';

        /**
         * EventCancelListNfting class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @instance
         */
        EventCancelListNfting.prototype.class_id = '';

        /**
         * EventCancelListNfting nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @instance
         */
        EventCancelListNfting.prototype.nft_id = '';

        /**
         * Encodes the specified EventCancelListNfting message. Does not implicitly {@link ununifi.nftmarket.EventCancelListNfting.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @static
         * @param {ununifi.nftmarket.IEventCancelListNfting} message EventCancelListNfting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventCancelListNfting.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventCancelListNfting message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventCancelListNfting.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @static
         * @param {ununifi.nftmarket.IEventCancelListNfting} message EventCancelListNfting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventCancelListNfting.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventCancelListNfting message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventCancelListNfting} EventCancelListNfting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventCancelListNfting.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventCancelListNfting();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventCancelListNfting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventCancelListNfting} EventCancelListNfting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventCancelListNfting.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventCancelListNfting message.
         * @function verify
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventCancelListNfting.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventCancelListNfting message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventCancelListNfting} EventCancelListNfting
         */
        EventCancelListNfting.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventCancelListNfting) return object;
          var message = new $root.ununifi.nftmarket.EventCancelListNfting();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventCancelListNfting message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @static
         * @param {ununifi.nftmarket.EventCancelListNfting} message EventCancelListNfting
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventCancelListNfting.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventCancelListNfting to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventCancelListNfting
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventCancelListNfting.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventCancelListNfting;
      })();

      nftmarket.EventExpandListingPeriod = (function () {
        /**
         * Properties of an EventExpandListingPeriod.
         * @memberof ununifi.nftmarket
         * @interface IEventExpandListingPeriod
         * @property {string|null} [owner] EventExpandListingPeriod owner
         * @property {string|null} [class_id] EventExpandListingPeriod class_id
         * @property {string|null} [nft_id] EventExpandListingPeriod nft_id
         */

        /**
         * Constructs a new EventExpandListingPeriod.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventExpandListingPeriod.
         * @implements IEventExpandListingPeriod
         * @constructor
         * @param {ununifi.nftmarket.IEventExpandListingPeriod=} [properties] Properties to set
         */
        function EventExpandListingPeriod(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventExpandListingPeriod owner.
         * @member {string} owner
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @instance
         */
        EventExpandListingPeriod.prototype.owner = '';

        /**
         * EventExpandListingPeriod class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @instance
         */
        EventExpandListingPeriod.prototype.class_id = '';

        /**
         * EventExpandListingPeriod nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @instance
         */
        EventExpandListingPeriod.prototype.nft_id = '';

        /**
         * Encodes the specified EventExpandListingPeriod message. Does not implicitly {@link ununifi.nftmarket.EventExpandListingPeriod.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @static
         * @param {ununifi.nftmarket.IEventExpandListingPeriod} message EventExpandListingPeriod message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventExpandListingPeriod.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventExpandListingPeriod message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventExpandListingPeriod.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @static
         * @param {ununifi.nftmarket.IEventExpandListingPeriod} message EventExpandListingPeriod message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventExpandListingPeriod.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventExpandListingPeriod message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventExpandListingPeriod} EventExpandListingPeriod
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventExpandListingPeriod.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventExpandListingPeriod();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventExpandListingPeriod message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventExpandListingPeriod} EventExpandListingPeriod
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventExpandListingPeriod.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventExpandListingPeriod message.
         * @function verify
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventExpandListingPeriod.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventExpandListingPeriod message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventExpandListingPeriod} EventExpandListingPeriod
         */
        EventExpandListingPeriod.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventExpandListingPeriod) return object;
          var message = new $root.ununifi.nftmarket.EventExpandListingPeriod();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventExpandListingPeriod message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @static
         * @param {ununifi.nftmarket.EventExpandListingPeriod} message EventExpandListingPeriod
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventExpandListingPeriod.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventExpandListingPeriod to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventExpandListingPeriod
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventExpandListingPeriod.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventExpandListingPeriod;
      })();

      nftmarket.EventSellingDecision = (function () {
        /**
         * Properties of an EventSellingDecision.
         * @memberof ununifi.nftmarket
         * @interface IEventSellingDecision
         * @property {string|null} [owner] EventSellingDecision owner
         * @property {string|null} [class_id] EventSellingDecision class_id
         * @property {string|null} [nft_id] EventSellingDecision nft_id
         */

        /**
         * Constructs a new EventSellingDecision.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventSellingDecision.
         * @implements IEventSellingDecision
         * @constructor
         * @param {ununifi.nftmarket.IEventSellingDecision=} [properties] Properties to set
         */
        function EventSellingDecision(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventSellingDecision owner.
         * @member {string} owner
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @instance
         */
        EventSellingDecision.prototype.owner = '';

        /**
         * EventSellingDecision class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @instance
         */
        EventSellingDecision.prototype.class_id = '';

        /**
         * EventSellingDecision nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @instance
         */
        EventSellingDecision.prototype.nft_id = '';

        /**
         * Encodes the specified EventSellingDecision message. Does not implicitly {@link ununifi.nftmarket.EventSellingDecision.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @static
         * @param {ununifi.nftmarket.IEventSellingDecision} message EventSellingDecision message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventSellingDecision.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventSellingDecision.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @static
         * @param {ununifi.nftmarket.IEventSellingDecision} message EventSellingDecision message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventSellingDecision message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventSellingDecision} EventSellingDecision
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventSellingDecision.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventSellingDecision();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventSellingDecision message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventSellingDecision} EventSellingDecision
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventSellingDecision.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventSellingDecision message.
         * @function verify
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventSellingDecision.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventSellingDecision message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventSellingDecision} EventSellingDecision
         */
        EventSellingDecision.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventSellingDecision) return object;
          var message = new $root.ununifi.nftmarket.EventSellingDecision();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventSellingDecision message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @static
         * @param {ununifi.nftmarket.EventSellingDecision} message EventSellingDecision
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventSellingDecision.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventSellingDecision to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventSellingDecision
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventSellingDecision.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventSellingDecision;
      })();

      nftmarket.EventEndListNfting = (function () {
        /**
         * Properties of an EventEndListNfting.
         * @memberof ununifi.nftmarket
         * @interface IEventEndListNfting
         * @property {string|null} [owner] EventEndListNfting owner
         * @property {string|null} [class_id] EventEndListNfting class_id
         * @property {string|null} [nft_id] EventEndListNfting nft_id
         */

        /**
         * Constructs a new EventEndListNfting.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventEndListNfting.
         * @implements IEventEndListNfting
         * @constructor
         * @param {ununifi.nftmarket.IEventEndListNfting=} [properties] Properties to set
         */
        function EventEndListNfting(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventEndListNfting owner.
         * @member {string} owner
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @instance
         */
        EventEndListNfting.prototype.owner = '';

        /**
         * EventEndListNfting class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @instance
         */
        EventEndListNfting.prototype.class_id = '';

        /**
         * EventEndListNfting nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @instance
         */
        EventEndListNfting.prototype.nft_id = '';

        /**
         * Encodes the specified EventEndListNfting message. Does not implicitly {@link ununifi.nftmarket.EventEndListNfting.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @static
         * @param {ununifi.nftmarket.IEventEndListNfting} message EventEndListNfting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventEndListNfting.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventEndListNfting message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventEndListNfting.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @static
         * @param {ununifi.nftmarket.IEventEndListNfting} message EventEndListNfting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventEndListNfting.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventEndListNfting message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventEndListNfting} EventEndListNfting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventEndListNfting.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventEndListNfting();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventEndListNfting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventEndListNfting} EventEndListNfting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventEndListNfting.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventEndListNfting message.
         * @function verify
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventEndListNfting.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventEndListNfting message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventEndListNfting} EventEndListNfting
         */
        EventEndListNfting.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventEndListNfting) return object;
          var message = new $root.ununifi.nftmarket.EventEndListNfting();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventEndListNfting message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @static
         * @param {ununifi.nftmarket.EventEndListNfting} message EventEndListNfting
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventEndListNfting.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventEndListNfting to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventEndListNfting
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventEndListNfting.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventEndListNfting;
      })();

      nftmarket.EventPlaceBid = (function () {
        /**
         * Properties of an EventPlaceBid.
         * @memberof ununifi.nftmarket
         * @interface IEventPlaceBid
         * @property {string|null} [bidder] EventPlaceBid bidder
         * @property {string|null} [class_id] EventPlaceBid class_id
         * @property {string|null} [nft_id] EventPlaceBid nft_id
         * @property {string|null} [amount] EventPlaceBid amount
         */

        /**
         * Constructs a new EventPlaceBid.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventPlaceBid.
         * @implements IEventPlaceBid
         * @constructor
         * @param {ununifi.nftmarket.IEventPlaceBid=} [properties] Properties to set
         */
        function EventPlaceBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventPlaceBid bidder.
         * @member {string} bidder
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @instance
         */
        EventPlaceBid.prototype.bidder = '';

        /**
         * EventPlaceBid class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @instance
         */
        EventPlaceBid.prototype.class_id = '';

        /**
         * EventPlaceBid nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @instance
         */
        EventPlaceBid.prototype.nft_id = '';

        /**
         * EventPlaceBid amount.
         * @member {string} amount
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @instance
         */
        EventPlaceBid.prototype.amount = '';

        /**
         * Encodes the specified EventPlaceBid message. Does not implicitly {@link ununifi.nftmarket.EventPlaceBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @static
         * @param {ununifi.nftmarket.IEventPlaceBid} message EventPlaceBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventPlaceBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified EventPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventPlaceBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @static
         * @param {ununifi.nftmarket.IEventPlaceBid} message EventPlaceBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventPlaceBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventPlaceBid} EventPlaceBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventPlaceBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventPlaceBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.bidder = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              case 4:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventPlaceBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventPlaceBid} EventPlaceBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventPlaceBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventPlaceBid message.
         * @function verify
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventPlaceBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          return null;
        };

        /**
         * Creates an EventPlaceBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventPlaceBid} EventPlaceBid
         */
        EventPlaceBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventPlaceBid) return object;
          var message = new $root.ununifi.nftmarket.EventPlaceBid();
          if (object.bidder != null) message.bidder = String(object.bidder);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          if (object.amount != null) message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from an EventPlaceBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @static
         * @param {ununifi.nftmarket.EventPlaceBid} message EventPlaceBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventPlaceBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.bidder = '';
            object.class_id = '';
            object.nft_id = '';
            object.amount = '';
          }
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          return object;
        };

        /**
         * Converts this EventPlaceBid to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventPlaceBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventPlaceBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventPlaceBid;
      })();

      nftmarket.EventCancelBid = (function () {
        /**
         * Properties of an EventCancelBid.
         * @memberof ununifi.nftmarket
         * @interface IEventCancelBid
         * @property {string|null} [bidder] EventCancelBid bidder
         * @property {string|null} [class_id] EventCancelBid class_id
         * @property {string|null} [nft_id] EventCancelBid nft_id
         */

        /**
         * Constructs a new EventCancelBid.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventCancelBid.
         * @implements IEventCancelBid
         * @constructor
         * @param {ununifi.nftmarket.IEventCancelBid=} [properties] Properties to set
         */
        function EventCancelBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventCancelBid bidder.
         * @member {string} bidder
         * @memberof ununifi.nftmarket.EventCancelBid
         * @instance
         */
        EventCancelBid.prototype.bidder = '';

        /**
         * EventCancelBid class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventCancelBid
         * @instance
         */
        EventCancelBid.prototype.class_id = '';

        /**
         * EventCancelBid nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventCancelBid
         * @instance
         */
        EventCancelBid.prototype.nft_id = '';

        /**
         * Encodes the specified EventCancelBid message. Does not implicitly {@link ununifi.nftmarket.EventCancelBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventCancelBid
         * @static
         * @param {ununifi.nftmarket.IEventCancelBid} message EventCancelBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventCancelBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventCancelBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventCancelBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventCancelBid
         * @static
         * @param {ununifi.nftmarket.IEventCancelBid} message EventCancelBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventCancelBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventCancelBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventCancelBid} EventCancelBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventCancelBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventCancelBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.bidder = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventCancelBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventCancelBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventCancelBid} EventCancelBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventCancelBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventCancelBid message.
         * @function verify
         * @memberof ununifi.nftmarket.EventCancelBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventCancelBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventCancelBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventCancelBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventCancelBid} EventCancelBid
         */
        EventCancelBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventCancelBid) return object;
          var message = new $root.ununifi.nftmarket.EventCancelBid();
          if (object.bidder != null) message.bidder = String(object.bidder);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventCancelBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventCancelBid
         * @static
         * @param {ununifi.nftmarket.EventCancelBid} message EventCancelBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventCancelBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.bidder = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventCancelBid to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventCancelBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventCancelBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventCancelBid;
      })();

      nftmarket.EventPayFullBid = (function () {
        /**
         * Properties of an EventPayFullBid.
         * @memberof ununifi.nftmarket
         * @interface IEventPayFullBid
         * @property {string|null} [bidder] EventPayFullBid bidder
         * @property {string|null} [class_id] EventPayFullBid class_id
         * @property {string|null} [nft_id] EventPayFullBid nft_id
         */

        /**
         * Constructs a new EventPayFullBid.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventPayFullBid.
         * @implements IEventPayFullBid
         * @constructor
         * @param {ununifi.nftmarket.IEventPayFullBid=} [properties] Properties to set
         */
        function EventPayFullBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventPayFullBid bidder.
         * @member {string} bidder
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @instance
         */
        EventPayFullBid.prototype.bidder = '';

        /**
         * EventPayFullBid class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @instance
         */
        EventPayFullBid.prototype.class_id = '';

        /**
         * EventPayFullBid nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @instance
         */
        EventPayFullBid.prototype.nft_id = '';

        /**
         * Encodes the specified EventPayFullBid message. Does not implicitly {@link ununifi.nftmarket.EventPayFullBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @static
         * @param {ununifi.nftmarket.IEventPayFullBid} message EventPayFullBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventPayFullBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventPayFullBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventPayFullBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @static
         * @param {ununifi.nftmarket.IEventPayFullBid} message EventPayFullBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventPayFullBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventPayFullBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventPayFullBid} EventPayFullBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventPayFullBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventPayFullBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.bidder = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventPayFullBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventPayFullBid} EventPayFullBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventPayFullBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventPayFullBid message.
         * @function verify
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventPayFullBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventPayFullBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventPayFullBid} EventPayFullBid
         */
        EventPayFullBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventPayFullBid) return object;
          var message = new $root.ununifi.nftmarket.EventPayFullBid();
          if (object.bidder != null) message.bidder = String(object.bidder);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventPayFullBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @static
         * @param {ununifi.nftmarket.EventPayFullBid} message EventPayFullBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventPayFullBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.bidder = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventPayFullBid to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventPayFullBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventPayFullBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventPayFullBid;
      })();

      nftmarket.EventBorrow = (function () {
        /**
         * Properties of an EventBorrow.
         * @memberof ununifi.nftmarket
         * @interface IEventBorrow
         * @property {string|null} [borrower] EventBorrow borrower
         * @property {string|null} [class_id] EventBorrow class_id
         * @property {string|null} [nft_id] EventBorrow nft_id
         * @property {string|null} [amount] EventBorrow amount
         */

        /**
         * Constructs a new EventBorrow.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventBorrow.
         * @implements IEventBorrow
         * @constructor
         * @param {ununifi.nftmarket.IEventBorrow=} [properties] Properties to set
         */
        function EventBorrow(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventBorrow borrower.
         * @member {string} borrower
         * @memberof ununifi.nftmarket.EventBorrow
         * @instance
         */
        EventBorrow.prototype.borrower = '';

        /**
         * EventBorrow class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventBorrow
         * @instance
         */
        EventBorrow.prototype.class_id = '';

        /**
         * EventBorrow nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventBorrow
         * @instance
         */
        EventBorrow.prototype.nft_id = '';

        /**
         * EventBorrow amount.
         * @member {string} amount
         * @memberof ununifi.nftmarket.EventBorrow
         * @instance
         */
        EventBorrow.prototype.amount = '';

        /**
         * Encodes the specified EventBorrow message. Does not implicitly {@link ununifi.nftmarket.EventBorrow.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventBorrow
         * @static
         * @param {ununifi.nftmarket.IEventBorrow} message EventBorrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventBorrow.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.borrower != null && Object.hasOwnProperty.call(message, 'borrower'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.borrower);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified EventBorrow message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventBorrow.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventBorrow
         * @static
         * @param {ununifi.nftmarket.IEventBorrow} message EventBorrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventBorrow.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventBorrow message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventBorrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventBorrow} EventBorrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventBorrow.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventBorrow();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.borrower = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              case 4:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventBorrow message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventBorrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventBorrow} EventBorrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventBorrow.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventBorrow message.
         * @function verify
         * @memberof ununifi.nftmarket.EventBorrow
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventBorrow.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.borrower != null && message.hasOwnProperty('borrower'))
            if (!$util.isString(message.borrower)) return 'borrower: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          return null;
        };

        /**
         * Creates an EventBorrow message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventBorrow
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventBorrow} EventBorrow
         */
        EventBorrow.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventBorrow) return object;
          var message = new $root.ununifi.nftmarket.EventBorrow();
          if (object.borrower != null) message.borrower = String(object.borrower);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          if (object.amount != null) message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from an EventBorrow message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventBorrow
         * @static
         * @param {ununifi.nftmarket.EventBorrow} message EventBorrow
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventBorrow.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.borrower = '';
            object.class_id = '';
            object.nft_id = '';
            object.amount = '';
          }
          if (message.borrower != null && message.hasOwnProperty('borrower')) object.borrower = message.borrower;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          return object;
        };

        /**
         * Converts this EventBorrow to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventBorrow
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventBorrow.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventBorrow;
      })();

      nftmarket.EventRepay = (function () {
        /**
         * Properties of an EventRepay.
         * @memberof ununifi.nftmarket
         * @interface IEventRepay
         * @property {string|null} [repayer] EventRepay repayer
         * @property {string|null} [class_id] EventRepay class_id
         * @property {string|null} [nft_id] EventRepay nft_id
         * @property {string|null} [amount] EventRepay amount
         */

        /**
         * Constructs a new EventRepay.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventRepay.
         * @implements IEventRepay
         * @constructor
         * @param {ununifi.nftmarket.IEventRepay=} [properties] Properties to set
         */
        function EventRepay(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventRepay repayer.
         * @member {string} repayer
         * @memberof ununifi.nftmarket.EventRepay
         * @instance
         */
        EventRepay.prototype.repayer = '';

        /**
         * EventRepay class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventRepay
         * @instance
         */
        EventRepay.prototype.class_id = '';

        /**
         * EventRepay nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventRepay
         * @instance
         */
        EventRepay.prototype.nft_id = '';

        /**
         * EventRepay amount.
         * @member {string} amount
         * @memberof ununifi.nftmarket.EventRepay
         * @instance
         */
        EventRepay.prototype.amount = '';

        /**
         * Encodes the specified EventRepay message. Does not implicitly {@link ununifi.nftmarket.EventRepay.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventRepay
         * @static
         * @param {ununifi.nftmarket.IEventRepay} message EventRepay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRepay.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.repayer != null && Object.hasOwnProperty.call(message, 'repayer'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.repayer);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified EventRepay message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventRepay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventRepay
         * @static
         * @param {ununifi.nftmarket.IEventRepay} message EventRepay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRepay.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventRepay message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventRepay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventRepay} EventRepay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRepay.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventRepay();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.repayer = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              case 4:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventRepay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventRepay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventRepay} EventRepay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRepay.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventRepay message.
         * @function verify
         * @memberof ununifi.nftmarket.EventRepay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventRepay.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.repayer != null && message.hasOwnProperty('repayer'))
            if (!$util.isString(message.repayer)) return 'repayer: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          return null;
        };

        /**
         * Creates an EventRepay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventRepay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventRepay} EventRepay
         */
        EventRepay.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventRepay) return object;
          var message = new $root.ununifi.nftmarket.EventRepay();
          if (object.repayer != null) message.repayer = String(object.repayer);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          if (object.amount != null) message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from an EventRepay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventRepay
         * @static
         * @param {ununifi.nftmarket.EventRepay} message EventRepay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventRepay.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.repayer = '';
            object.class_id = '';
            object.nft_id = '';
            object.amount = '';
          }
          if (message.repayer != null && message.hasOwnProperty('repayer')) object.repayer = message.repayer;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          return object;
        };

        /**
         * Converts this EventRepay to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventRepay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventRepay.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventRepay;
      })();

      nftmarket.EventLiquidate = (function () {
        /**
         * Properties of an EventLiquidate.
         * @memberof ununifi.nftmarket
         * @interface IEventLiquidate
         * @property {string|null} [liquidator] EventLiquidate liquidator
         * @property {string|null} [class_id] EventLiquidate class_id
         * @property {string|null} [nft_id] EventLiquidate nft_id
         */

        /**
         * Constructs a new EventLiquidate.
         * @memberof ununifi.nftmarket
         * @classdesc Represents an EventLiquidate.
         * @implements IEventLiquidate
         * @constructor
         * @param {ununifi.nftmarket.IEventLiquidate=} [properties] Properties to set
         */
        function EventLiquidate(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventLiquidate liquidator.
         * @member {string} liquidator
         * @memberof ununifi.nftmarket.EventLiquidate
         * @instance
         */
        EventLiquidate.prototype.liquidator = '';

        /**
         * EventLiquidate class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmarket.EventLiquidate
         * @instance
         */
        EventLiquidate.prototype.class_id = '';

        /**
         * EventLiquidate nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmarket.EventLiquidate
         * @instance
         */
        EventLiquidate.prototype.nft_id = '';

        /**
         * Encodes the specified EventLiquidate message. Does not implicitly {@link ununifi.nftmarket.EventLiquidate.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.EventLiquidate
         * @static
         * @param {ununifi.nftmarket.IEventLiquidate} message EventLiquidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventLiquidate.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.liquidator != null && Object.hasOwnProperty.call(message, 'liquidator'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.liquidator);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventLiquidate message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventLiquidate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.EventLiquidate
         * @static
         * @param {ununifi.nftmarket.IEventLiquidate} message EventLiquidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventLiquidate message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.EventLiquidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.EventLiquidate} EventLiquidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventLiquidate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.EventLiquidate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.liquidator = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventLiquidate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.EventLiquidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.EventLiquidate} EventLiquidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventLiquidate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventLiquidate message.
         * @function verify
         * @memberof ununifi.nftmarket.EventLiquidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventLiquidate.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.liquidator != null && message.hasOwnProperty('liquidator'))
            if (!$util.isString(message.liquidator)) return 'liquidator: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventLiquidate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.EventLiquidate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.EventLiquidate} EventLiquidate
         */
        EventLiquidate.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.EventLiquidate) return object;
          var message = new $root.ununifi.nftmarket.EventLiquidate();
          if (object.liquidator != null) message.liquidator = String(object.liquidator);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventLiquidate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.EventLiquidate
         * @static
         * @param {ununifi.nftmarket.EventLiquidate} message EventLiquidate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventLiquidate.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.liquidator = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.liquidator != null && message.hasOwnProperty('liquidator')) object.liquidator = message.liquidator;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventLiquidate to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.EventLiquidate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventLiquidate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventLiquidate;
      })();

      nftmarket.PaymentStatus = (function () {
        /**
         * Properties of a PaymentStatus.
         * @memberof ununifi.nftmarket
         * @interface IPaymentStatus
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] PaymentStatus nft_id
         * @property {string|null} [bidder] PaymentStatus bidder
         * @property {cosmos.base.v1beta1.ICoin|null} [amount] PaymentStatus amount
         * @property {boolean|null} [automatic_payment] PaymentStatus automatic_payment
         * @property {string|null} [paid_amount] PaymentStatus paid_amount
         * @property {google.protobuf.ITimestamp|null} [bid_time] PaymentStatus bid_time
         * @property {ununifi.nftmarket.ListingState|null} [state] PaymentStatus state
         * @property {boolean|null} [all_paid] PaymentStatus all_paid
         */

        /**
         * Constructs a new PaymentStatus.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a PaymentStatus.
         * @implements IPaymentStatus
         * @constructor
         * @param {ununifi.nftmarket.IPaymentStatus=} [properties] Properties to set
         */
        function PaymentStatus(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentStatus nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.nft_id = null;

        /**
         * PaymentStatus bidder.
         * @member {string} bidder
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.bidder = '';

        /**
         * PaymentStatus amount.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.amount = null;

        /**
         * PaymentStatus automatic_payment.
         * @member {boolean} automatic_payment
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.automatic_payment = false;

        /**
         * PaymentStatus paid_amount.
         * @member {string} paid_amount
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.paid_amount = '';

        /**
         * PaymentStatus bid_time.
         * @member {google.protobuf.ITimestamp|null|undefined} bid_time
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.bid_time = null;

        /**
         * PaymentStatus state.
         * @member {ununifi.nftmarket.ListingState} state
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.state = 0;

        /**
         * PaymentStatus all_paid.
         * @member {boolean} all_paid
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         */
        PaymentStatus.prototype.all_paid = false;

        /**
         * Encodes the specified PaymentStatus message. Does not implicitly {@link ununifi.nftmarket.PaymentStatus.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.PaymentStatus
         * @static
         * @param {ununifi.nftmarket.IPaymentStatus} message PaymentStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentStatus.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bidder);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.automatic_payment);
          if (message.paid_amount != null && Object.hasOwnProperty.call(message, 'paid_amount'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.paid_amount);
          if (message.bid_time != null && Object.hasOwnProperty.call(message, 'bid_time'))
            $root.google.protobuf.Timestamp.encode(message.bid_time, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
          if (message.state != null && Object.hasOwnProperty.call(message, 'state'))
            writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.state);
          if (message.all_paid != null && Object.hasOwnProperty.call(message, 'all_paid'))
            writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.all_paid);
          return writer;
        };

        /**
         * Encodes the specified PaymentStatus message, length delimited. Does not implicitly {@link ununifi.nftmarket.PaymentStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.PaymentStatus
         * @static
         * @param {ununifi.nftmarket.IPaymentStatus} message PaymentStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentStatus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentStatus message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.PaymentStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.PaymentStatus} PaymentStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentStatus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.PaymentStatus();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 2:
                message.bidder = reader.string();
                break;
              case 3:
                message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                message.automatic_payment = reader.bool();
                break;
              case 5:
                message.paid_amount = reader.string();
                break;
              case 6:
                message.bid_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 7:
                message.state = reader.int32();
                break;
              case 8:
                message.all_paid = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a PaymentStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.PaymentStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.PaymentStatus} PaymentStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentStatus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentStatus message.
         * @function verify
         * @memberof ununifi.nftmarket.PaymentStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentStatus.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.bidder != null && message.hasOwnProperty('bidder'))
            if (!$util.isString(message.bidder)) return 'bidder: string expected';
          if (message.amount != null && message.hasOwnProperty('amount')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
            if (error) return 'amount.' + error;
          }
          if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
            if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
          if (message.paid_amount != null && message.hasOwnProperty('paid_amount'))
            if (!$util.isString(message.paid_amount)) return 'paid_amount: string expected';
          if (message.bid_time != null && message.hasOwnProperty('bid_time')) {
            var error = $root.google.protobuf.Timestamp.verify(message.bid_time);
            if (error) return 'bid_time.' + error;
          }
          if (message.state != null && message.hasOwnProperty('state'))
            switch (message.state) {
              default:
                return 'state: enum value expected';
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
            }
          if (message.all_paid != null && message.hasOwnProperty('all_paid'))
            if (typeof message.all_paid !== 'boolean') return 'all_paid: boolean expected';
          return null;
        };

        /**
         * Creates a PaymentStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.PaymentStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.PaymentStatus} PaymentStatus
         */
        PaymentStatus.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.PaymentStatus) return object;
          var message = new $root.ununifi.nftmarket.PaymentStatus();
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.PaymentStatus.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          if (object.bidder != null) message.bidder = String(object.bidder);
          if (object.amount != null) {
            if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.PaymentStatus.amount: object expected');
            message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
          }
          if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
          if (object.paid_amount != null) message.paid_amount = String(object.paid_amount);
          if (object.bid_time != null) {
            if (typeof object.bid_time !== 'object') throw TypeError('.ununifi.nftmarket.PaymentStatus.bid_time: object expected');
            message.bid_time = $root.google.protobuf.Timestamp.fromObject(object.bid_time);
          }
          switch (object.state) {
            case 'LISTING':
            case 0:
              message.state = 0;
              break;
            case 'BIDDING':
            case 1:
              message.state = 1;
              break;
            case 'SELLING_DECISION':
            case 2:
              message.state = 2;
              break;
            case 'LIQUIDATION':
            case 3:
              message.state = 3;
              break;
            case 'END_LISTING':
            case 4:
              message.state = 4;
              break;
            case 'SUCCESSFUL_BID':
            case 5:
              message.state = 5;
              break;
          }
          if (object.all_paid != null) message.all_paid = Boolean(object.all_paid);
          return message;
        };

        /**
         * Creates a plain object from a PaymentStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.PaymentStatus
         * @static
         * @param {ununifi.nftmarket.PaymentStatus} message PaymentStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentStatus.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.nft_id = null;
            object.bidder = '';
            object.amount = null;
            object.automatic_payment = false;
            object.paid_amount = '';
            object.bid_time = null;
            object.state = options.enums === String ? 'LISTING' : 0;
            object.all_paid = false;
          }
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
          if (message.amount != null && message.hasOwnProperty('amount'))
            object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
          if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
            object.automatic_payment = message.automatic_payment;
          if (message.paid_amount != null && message.hasOwnProperty('paid_amount')) object.paid_amount = message.paid_amount;
          if (message.bid_time != null && message.hasOwnProperty('bid_time'))
            object.bid_time = $root.google.protobuf.Timestamp.toObject(message.bid_time, options);
          if (message.state != null && message.hasOwnProperty('state'))
            object.state = options.enums === String ? $root.ununifi.nftmarket.ListingState[message.state] : message.state;
          if (message.all_paid != null && message.hasOwnProperty('all_paid')) object.all_paid = message.all_paid;
          return object;
        };

        /**
         * Converts this PaymentStatus to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.PaymentStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentStatus.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaymentStatus;
      })();

      nftmarket.Msg = (function () {
        /**
         * Constructs a new Msg service.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a Msg
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Msg(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#mintNft}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef MintNftCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgMintNftResponse} [response] MsgMintNftResponse
         */

        /**
         * Calls MintNft.
         * @function mintNft
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgMintNft} request MsgMintNft message or plain object
         * @param {ununifi.nftmarket.Msg.MintNftCallback} callback Node-style callback called with the error, if any, and MsgMintNftResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.mintNft = function mintNft(request, callback) {
            return this.rpcCall(mintNft, $root.ununifi.nftmarket.MsgMintNft, $root.ununifi.nftmarket.MsgMintNftResponse, request, callback);
          }),
          'name',
          { value: 'MintNft' },
        );

        /**
         * Calls MintNft.
         * @function mintNft
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgMintNft} request MsgMintNft message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgMintNftResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#listNft}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef ListNftCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgListNftResponse} [response] MsgListNftResponse
         */

        /**
         * Calls ListNft.
         * @function listNft
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgListNft} request MsgListNft message or plain object
         * @param {ununifi.nftmarket.Msg.ListNftCallback} callback Node-style callback called with the error, if any, and MsgListNftResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.listNft = function listNft(request, callback) {
            return this.rpcCall(listNft, $root.ununifi.nftmarket.MsgListNft, $root.ununifi.nftmarket.MsgListNftResponse, request, callback);
          }),
          'name',
          { value: 'ListNft' },
        );

        /**
         * Calls ListNft.
         * @function listNft
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgListNft} request MsgListNft message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgListNftResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#cancelNftListing}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef CancelNftListingCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgCancelNftListingResponse} [response] MsgCancelNftListingResponse
         */

        /**
         * Calls CancelNftListing.
         * @function cancelNftListing
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgCancelNftListing} request MsgCancelNftListing message or plain object
         * @param {ununifi.nftmarket.Msg.CancelNftListingCallback} callback Node-style callback called with the error, if any, and MsgCancelNftListingResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.cancelNftListing = function cancelNftListing(request, callback) {
            return this.rpcCall(
              cancelNftListing,
              $root.ununifi.nftmarket.MsgCancelNftListing,
              $root.ununifi.nftmarket.MsgCancelNftListingResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'CancelNftListing' },
        );

        /**
         * Calls CancelNftListing.
         * @function cancelNftListing
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgCancelNftListing} request MsgCancelNftListing message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgCancelNftListingResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#expandListingPeriod}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef ExpandListingPeriodCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgExpandListingPeriodResponse} [response] MsgExpandListingPeriodResponse
         */

        /**
         * Calls ExpandListingPeriod.
         * @function expandListingPeriod
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgExpandListingPeriod} request MsgExpandListingPeriod message or plain object
         * @param {ununifi.nftmarket.Msg.ExpandListingPeriodCallback} callback Node-style callback called with the error, if any, and MsgExpandListingPeriodResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.expandListingPeriod = function expandListingPeriod(request, callback) {
            return this.rpcCall(
              expandListingPeriod,
              $root.ununifi.nftmarket.MsgExpandListingPeriod,
              $root.ununifi.nftmarket.MsgExpandListingPeriodResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ExpandListingPeriod' },
        );

        /**
         * Calls ExpandListingPeriod.
         * @function expandListingPeriod
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgExpandListingPeriod} request MsgExpandListingPeriod message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgExpandListingPeriodResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#placeBid}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef PlaceBidCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgPlaceBidResponse} [response] MsgPlaceBidResponse
         */

        /**
         * Calls PlaceBid.
         * @function placeBid
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgPlaceBid} request MsgPlaceBid message or plain object
         * @param {ununifi.nftmarket.Msg.PlaceBidCallback} callback Node-style callback called with the error, if any, and MsgPlaceBidResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.placeBid = function placeBid(request, callback) {
            return this.rpcCall(
              placeBid,
              $root.ununifi.nftmarket.MsgPlaceBid,
              $root.ununifi.nftmarket.MsgPlaceBidResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'PlaceBid' },
        );

        /**
         * Calls PlaceBid.
         * @function placeBid
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgPlaceBid} request MsgPlaceBid message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgPlaceBidResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#cancelBid}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef CancelBidCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgCancelBidResponse} [response] MsgCancelBidResponse
         */

        /**
         * Calls CancelBid.
         * @function cancelBid
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgCancelBid} request MsgCancelBid message or plain object
         * @param {ununifi.nftmarket.Msg.CancelBidCallback} callback Node-style callback called with the error, if any, and MsgCancelBidResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.cancelBid = function cancelBid(request, callback) {
            return this.rpcCall(
              cancelBid,
              $root.ununifi.nftmarket.MsgCancelBid,
              $root.ununifi.nftmarket.MsgCancelBidResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'CancelBid' },
        );

        /**
         * Calls CancelBid.
         * @function cancelBid
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgCancelBid} request MsgCancelBid message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgCancelBidResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#sellingDecision}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef SellingDecisionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgSellingDecisionResponse} [response] MsgSellingDecisionResponse
         */

        /**
         * Calls SellingDecision.
         * @function sellingDecision
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgSellingDecision} request MsgSellingDecision message or plain object
         * @param {ununifi.nftmarket.Msg.SellingDecisionCallback} callback Node-style callback called with the error, if any, and MsgSellingDecisionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.sellingDecision = function sellingDecision(request, callback) {
            return this.rpcCall(
              sellingDecision,
              $root.ununifi.nftmarket.MsgSellingDecision,
              $root.ununifi.nftmarket.MsgSellingDecisionResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'SellingDecision' },
        );

        /**
         * Calls SellingDecision.
         * @function sellingDecision
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgSellingDecision} request MsgSellingDecision message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgSellingDecisionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#endNftListing}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef EndNftListingCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgEndNftListingResponse} [response] MsgEndNftListingResponse
         */

        /**
         * Calls EndNftListing.
         * @function endNftListing
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgEndNftListing} request MsgEndNftListing message or plain object
         * @param {ununifi.nftmarket.Msg.EndNftListingCallback} callback Node-style callback called with the error, if any, and MsgEndNftListingResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.endNftListing = function endNftListing(request, callback) {
            return this.rpcCall(
              endNftListing,
              $root.ununifi.nftmarket.MsgEndNftListing,
              $root.ununifi.nftmarket.MsgEndNftListingResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'EndNftListing' },
        );

        /**
         * Calls EndNftListing.
         * @function endNftListing
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgEndNftListing} request MsgEndNftListing message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgEndNftListingResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#payFullBid}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef PayFullBidCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgPayFullBidResponse} [response] MsgPayFullBidResponse
         */

        /**
         * Calls PayFullBid.
         * @function payFullBid
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgPayFullBid} request MsgPayFullBid message or plain object
         * @param {ununifi.nftmarket.Msg.PayFullBidCallback} callback Node-style callback called with the error, if any, and MsgPayFullBidResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.payFullBid = function payFullBid(request, callback) {
            return this.rpcCall(
              payFullBid,
              $root.ununifi.nftmarket.MsgPayFullBid,
              $root.ununifi.nftmarket.MsgPayFullBidResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'PayFullBid' },
        );

        /**
         * Calls PayFullBid.
         * @function payFullBid
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgPayFullBid} request MsgPayFullBid message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgPayFullBidResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#borrow}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef BorrowCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgBorrowResponse} [response] MsgBorrowResponse
         */

        /**
         * Calls Borrow.
         * @function borrow
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgBorrow} request MsgBorrow message or plain object
         * @param {ununifi.nftmarket.Msg.BorrowCallback} callback Node-style callback called with the error, if any, and MsgBorrowResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.borrow = function borrow(request, callback) {
            return this.rpcCall(borrow, $root.ununifi.nftmarket.MsgBorrow, $root.ununifi.nftmarket.MsgBorrowResponse, request, callback);
          }),
          'name',
          { value: 'Borrow' },
        );

        /**
         * Calls Borrow.
         * @function borrow
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgBorrow} request MsgBorrow message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgBorrowResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#repay}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef RepayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgRepayResponse} [response] MsgRepayResponse
         */

        /**
         * Calls Repay.
         * @function repay
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgRepay} request MsgRepay message or plain object
         * @param {ununifi.nftmarket.Msg.RepayCallback} callback Node-style callback called with the error, if any, and MsgRepayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.repay = function repay(request, callback) {
            return this.rpcCall(repay, $root.ununifi.nftmarket.MsgRepay, $root.ununifi.nftmarket.MsgRepayResponse, request, callback);
          }),
          'name',
          { value: 'Repay' },
        );

        /**
         * Calls Repay.
         * @function repay
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgRepay} request MsgRepay message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgRepayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#mintStableCoin}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef MintStableCoinCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgMintStableCoinResponse} [response] MsgMintStableCoinResponse
         */

        /**
         * Calls MintStableCoin.
         * @function mintStableCoin
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgMintStableCoin} request MsgMintStableCoin message or plain object
         * @param {ununifi.nftmarket.Msg.MintStableCoinCallback} callback Node-style callback called with the error, if any, and MsgMintStableCoinResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.mintStableCoin = function mintStableCoin(request, callback) {
            return this.rpcCall(
              mintStableCoin,
              $root.ununifi.nftmarket.MsgMintStableCoin,
              $root.ununifi.nftmarket.MsgMintStableCoinResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'MintStableCoin' },
        );

        /**
         * Calls MintStableCoin.
         * @function mintStableCoin
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgMintStableCoin} request MsgMintStableCoin message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgMintStableCoinResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#burnStableCoin}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef BurnStableCoinCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgBurnStableCoinResponse} [response] MsgBurnStableCoinResponse
         */

        /**
         * Calls BurnStableCoin.
         * @function burnStableCoin
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgBurnStableCoin} request MsgBurnStableCoin message or plain object
         * @param {ununifi.nftmarket.Msg.BurnStableCoinCallback} callback Node-style callback called with the error, if any, and MsgBurnStableCoinResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.burnStableCoin = function burnStableCoin(request, callback) {
            return this.rpcCall(
              burnStableCoin,
              $root.ununifi.nftmarket.MsgBurnStableCoin,
              $root.ununifi.nftmarket.MsgBurnStableCoinResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'BurnStableCoin' },
        );

        /**
         * Calls BurnStableCoin.
         * @function burnStableCoin
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgBurnStableCoin} request MsgBurnStableCoin message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgBurnStableCoinResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmarket.Msg#liquidate}.
         * @memberof ununifi.nftmarket.Msg
         * @typedef LiquidateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmarket.MsgLiquidateResponse} [response] MsgLiquidateResponse
         */

        /**
         * Calls Liquidate.
         * @function liquidate
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgLiquidate} request MsgLiquidate message or plain object
         * @param {ununifi.nftmarket.Msg.LiquidateCallback} callback Node-style callback called with the error, if any, and MsgLiquidateResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.liquidate = function liquidate(request, callback) {
            return this.rpcCall(
              liquidate,
              $root.ununifi.nftmarket.MsgLiquidate,
              $root.ununifi.nftmarket.MsgLiquidateResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Liquidate' },
        );

        /**
         * Calls Liquidate.
         * @function liquidate
         * @memberof ununifi.nftmarket.Msg
         * @instance
         * @param {ununifi.nftmarket.IMsgLiquidate} request MsgLiquidate message or plain object
         * @returns {Promise<ununifi.nftmarket.MsgLiquidateResponse>} Promise
         * @variation 2
         */

        return Msg;
      })();

      nftmarket.MsgMintNft = (function () {
        /**
         * Properties of a MsgMintNft.
         * @memberof ununifi.nftmarket
         * @interface IMsgMintNft
         * @property {string|null} [sender] MsgMintNft sender
         * @property {string|null} [classId] MsgMintNft classId
         * @property {string|null} [nftId] MsgMintNft nftId
         * @property {string|null} [nftUri] MsgMintNft nftUri
         * @property {string|null} [nftUriHash] MsgMintNft nftUriHash
         */

        /**
         * Constructs a new MsgMintNft.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgMintNft.
         * @implements IMsgMintNft
         * @constructor
         * @param {ununifi.nftmarket.IMsgMintNft=} [properties] Properties to set
         */
        function MsgMintNft(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgMintNft sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgMintNft
         * @instance
         */
        MsgMintNft.prototype.sender = '';

        /**
         * MsgMintNft classId.
         * @member {string} classId
         * @memberof ununifi.nftmarket.MsgMintNft
         * @instance
         */
        MsgMintNft.prototype.classId = '';

        /**
         * MsgMintNft nftId.
         * @member {string} nftId
         * @memberof ununifi.nftmarket.MsgMintNft
         * @instance
         */
        MsgMintNft.prototype.nftId = '';

        /**
         * MsgMintNft nftUri.
         * @member {string} nftUri
         * @memberof ununifi.nftmarket.MsgMintNft
         * @instance
         */
        MsgMintNft.prototype.nftUri = '';

        /**
         * MsgMintNft nftUriHash.
         * @member {string} nftUriHash
         * @memberof ununifi.nftmarket.MsgMintNft
         * @instance
         */
        MsgMintNft.prototype.nftUriHash = '';

        /**
         * Encodes the specified MsgMintNft message. Does not implicitly {@link ununifi.nftmarket.MsgMintNft.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgMintNft
         * @static
         * @param {ununifi.nftmarket.IMsgMintNft} message MsgMintNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNft.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.classId != null && Object.hasOwnProperty.call(message, 'classId'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.classId);
          if (message.nftId != null && Object.hasOwnProperty.call(message, 'nftId'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nftId);
          if (message.nftUri != null && Object.hasOwnProperty.call(message, 'nftUri'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.nftUri);
          if (message.nftUriHash != null && Object.hasOwnProperty.call(message, 'nftUriHash'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.nftUriHash);
          return writer;
        };

        /**
         * Encodes the specified MsgMintNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintNft.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgMintNft
         * @static
         * @param {ununifi.nftmarket.IMsgMintNft} message MsgMintNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNft.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgMintNft message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgMintNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgMintNft} MsgMintNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNft.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgMintNft();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.classId = reader.string();
                break;
              case 3:
                message.nftId = reader.string();
                break;
              case 4:
                message.nftUri = reader.string();
                break;
              case 5:
                message.nftUriHash = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgMintNft message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgMintNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgMintNft} MsgMintNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNft.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgMintNft message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgMintNft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgMintNft.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.classId != null && message.hasOwnProperty('classId'))
            if (!$util.isString(message.classId)) return 'classId: string expected';
          if (message.nftId != null && message.hasOwnProperty('nftId')) if (!$util.isString(message.nftId)) return 'nftId: string expected';
          if (message.nftUri != null && message.hasOwnProperty('nftUri'))
            if (!$util.isString(message.nftUri)) return 'nftUri: string expected';
          if (message.nftUriHash != null && message.hasOwnProperty('nftUriHash'))
            if (!$util.isString(message.nftUriHash)) return 'nftUriHash: string expected';
          return null;
        };

        /**
         * Creates a MsgMintNft message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgMintNft
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgMintNft} MsgMintNft
         */
        MsgMintNft.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgMintNft) return object;
          var message = new $root.ununifi.nftmarket.MsgMintNft();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.classId != null) message.classId = String(object.classId);
          if (object.nftId != null) message.nftId = String(object.nftId);
          if (object.nftUri != null) message.nftUri = String(object.nftUri);
          if (object.nftUriHash != null) message.nftUriHash = String(object.nftUriHash);
          return message;
        };

        /**
         * Creates a plain object from a MsgMintNft message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgMintNft
         * @static
         * @param {ununifi.nftmarket.MsgMintNft} message MsgMintNft
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgMintNft.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.classId = '';
            object.nftId = '';
            object.nftUri = '';
            object.nftUriHash = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.classId != null && message.hasOwnProperty('classId')) object.classId = message.classId;
          if (message.nftId != null && message.hasOwnProperty('nftId')) object.nftId = message.nftId;
          if (message.nftUri != null && message.hasOwnProperty('nftUri')) object.nftUri = message.nftUri;
          if (message.nftUriHash != null && message.hasOwnProperty('nftUriHash')) object.nftUriHash = message.nftUriHash;
          return object;
        };

        /**
         * Converts this MsgMintNft to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgMintNft
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgMintNft.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgMintNft;
      })();

      nftmarket.MsgMintNftResponse = (function () {
        /**
         * Properties of a MsgMintNftResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgMintNftResponse
         */

        /**
         * Constructs a new MsgMintNftResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgMintNftResponse.
         * @implements IMsgMintNftResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgMintNftResponse=} [properties] Properties to set
         */
        function MsgMintNftResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgMintNftResponse message. Does not implicitly {@link ununifi.nftmarket.MsgMintNftResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @static
         * @param {ununifi.nftmarket.IMsgMintNftResponse} message MsgMintNftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNftResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgMintNftResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintNftResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @static
         * @param {ununifi.nftmarket.IMsgMintNftResponse} message MsgMintNftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNftResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgMintNftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgMintNftResponse} MsgMintNftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNftResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgMintNftResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgMintNftResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgMintNftResponse} MsgMintNftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNftResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgMintNftResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgMintNftResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgMintNftResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgMintNftResponse} MsgMintNftResponse
         */
        MsgMintNftResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgMintNftResponse) return object;
          return new $root.ununifi.nftmarket.MsgMintNftResponse();
        };

        /**
         * Creates a plain object from a MsgMintNftResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @static
         * @param {ununifi.nftmarket.MsgMintNftResponse} message MsgMintNftResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgMintNftResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgMintNftResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgMintNftResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgMintNftResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgMintNftResponse;
      })();

      nftmarket.MsgListNft = (function () {
        /**
         * Properties of a MsgListNft.
         * @memberof ununifi.nftmarket
         * @interface IMsgListNft
         * @property {string|null} [sender] MsgListNft sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgListNft nft_id
         * @property {ununifi.nftmarket.ListingType|null} [listing_type] MsgListNft listing_type
         * @property {string|null} [bid_token] MsgListNft bid_token
         * @property {string|null} [min_bid] MsgListNft min_bid
         * @property {Long|null} [bid_active_rank] MsgListNft bid_active_rank
         */

        /**
         * Constructs a new MsgListNft.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgListNft.
         * @implements IMsgListNft
         * @constructor
         * @param {ununifi.nftmarket.IMsgListNft=} [properties] Properties to set
         */
        function MsgListNft(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgListNft sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgListNft
         * @instance
         */
        MsgListNft.prototype.sender = '';

        /**
         * MsgListNft nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgListNft
         * @instance
         */
        MsgListNft.prototype.nft_id = null;

        /**
         * MsgListNft listing_type.
         * @member {ununifi.nftmarket.ListingType} listing_type
         * @memberof ununifi.nftmarket.MsgListNft
         * @instance
         */
        MsgListNft.prototype.listing_type = 0;

        /**
         * MsgListNft bid_token.
         * @member {string} bid_token
         * @memberof ununifi.nftmarket.MsgListNft
         * @instance
         */
        MsgListNft.prototype.bid_token = '';

        /**
         * MsgListNft min_bid.
         * @member {string} min_bid
         * @memberof ununifi.nftmarket.MsgListNft
         * @instance
         */
        MsgListNft.prototype.min_bid = '';

        /**
         * MsgListNft bid_active_rank.
         * @member {Long} bid_active_rank
         * @memberof ununifi.nftmarket.MsgListNft
         * @instance
         */
        MsgListNft.prototype.bid_active_rank = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified MsgListNft message. Does not implicitly {@link ununifi.nftmarket.MsgListNft.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgListNft
         * @static
         * @param {ununifi.nftmarket.IMsgListNft} message MsgListNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgListNft.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.listing_type != null && Object.hasOwnProperty.call(message, 'listing_type'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.listing_type);
          if (message.bid_token != null && Object.hasOwnProperty.call(message, 'bid_token'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.bid_token);
          if (message.min_bid != null && Object.hasOwnProperty.call(message, 'min_bid'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.min_bid);
          if (message.bid_active_rank != null && Object.hasOwnProperty.call(message, 'bid_active_rank'))
            writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.bid_active_rank);
          return writer;
        };

        /**
         * Encodes the specified MsgListNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgListNft.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgListNft
         * @static
         * @param {ununifi.nftmarket.IMsgListNft} message MsgListNft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgListNft.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgListNft message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgListNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgListNft} MsgListNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgListNft.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgListNft();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 3:
                message.listing_type = reader.int32();
                break;
              case 4:
                message.bid_token = reader.string();
                break;
              case 5:
                message.min_bid = reader.string();
                break;
              case 6:
                message.bid_active_rank = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgListNft message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgListNft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgListNft} MsgListNft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgListNft.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgListNft message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgListNft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgListNft.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.listing_type != null && message.hasOwnProperty('listing_type'))
            switch (message.listing_type) {
              default:
                return 'listing_type: enum value expected';
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.bid_token != null && message.hasOwnProperty('bid_token'))
            if (!$util.isString(message.bid_token)) return 'bid_token: string expected';
          if (message.min_bid != null && message.hasOwnProperty('min_bid'))
            if (!$util.isString(message.min_bid)) return 'min_bid: string expected';
          if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
            if (
              !$util.isInteger(message.bid_active_rank) &&
              !(message.bid_active_rank && $util.isInteger(message.bid_active_rank.low) && $util.isInteger(message.bid_active_rank.high))
            )
              return 'bid_active_rank: integer|Long expected';
          return null;
        };

        /**
         * Creates a MsgListNft message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgListNft
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgListNft} MsgListNft
         */
        MsgListNft.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgListNft) return object;
          var message = new $root.ununifi.nftmarket.MsgListNft();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgListNft.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          switch (object.listing_type) {
            case 'DIRECT_ASSET_BORROW':
            case 0:
              message.listing_type = 0;
              break;
            case 'SYNTHETIC_ASSET_CREATION':
            case 1:
              message.listing_type = 1;
              break;
            case 'LATE_SHIPPING':
            case 2:
              message.listing_type = 2;
              break;
          }
          if (object.bid_token != null) message.bid_token = String(object.bid_token);
          if (object.min_bid != null) message.min_bid = String(object.min_bid);
          if (object.bid_active_rank != null)
            if ($util.Long) (message.bid_active_rank = $util.Long.fromValue(object.bid_active_rank)).unsigned = true;
            else if (typeof object.bid_active_rank === 'string') message.bid_active_rank = parseInt(object.bid_active_rank, 10);
            else if (typeof object.bid_active_rank === 'number') message.bid_active_rank = object.bid_active_rank;
            else if (typeof object.bid_active_rank === 'object')
              message.bid_active_rank = new $util.LongBits(object.bid_active_rank.low >>> 0, object.bid_active_rank.high >>> 0).toNumber(
                true,
              );
          return message;
        };

        /**
         * Creates a plain object from a MsgListNft message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgListNft
         * @static
         * @param {ununifi.nftmarket.MsgListNft} message MsgListNft
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgListNft.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
            object.listing_type = options.enums === String ? 'DIRECT_ASSET_BORROW' : 0;
            object.bid_token = '';
            object.min_bid = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.bid_active_rank = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.bid_active_rank = options.longs === String ? '0' : 0;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.listing_type != null && message.hasOwnProperty('listing_type'))
            object.listing_type =
              options.enums === String ? $root.ununifi.nftmarket.ListingType[message.listing_type] : message.listing_type;
          if (message.bid_token != null && message.hasOwnProperty('bid_token')) object.bid_token = message.bid_token;
          if (message.min_bid != null && message.hasOwnProperty('min_bid')) object.min_bid = message.min_bid;
          if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
            if (typeof message.bid_active_rank === 'number')
              object.bid_active_rank = options.longs === String ? String(message.bid_active_rank) : message.bid_active_rank;
            else
              object.bid_active_rank =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.bid_active_rank)
                  : options.longs === Number
                  ? new $util.LongBits(message.bid_active_rank.low >>> 0, message.bid_active_rank.high >>> 0).toNumber(true)
                  : message.bid_active_rank;
          return object;
        };

        /**
         * Converts this MsgListNft to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgListNft
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgListNft.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgListNft;
      })();

      nftmarket.MsgListNftResponse = (function () {
        /**
         * Properties of a MsgListNftResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgListNftResponse
         */

        /**
         * Constructs a new MsgListNftResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgListNftResponse.
         * @implements IMsgListNftResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgListNftResponse=} [properties] Properties to set
         */
        function MsgListNftResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgListNftResponse message. Does not implicitly {@link ununifi.nftmarket.MsgListNftResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @static
         * @param {ununifi.nftmarket.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgListNftResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgListNftResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgListNftResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @static
         * @param {ununifi.nftmarket.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgListNftResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgListNftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgListNftResponse} MsgListNftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgListNftResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgListNftResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgListNftResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgListNftResponse} MsgListNftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgListNftResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgListNftResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgListNftResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgListNftResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgListNftResponse} MsgListNftResponse
         */
        MsgListNftResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgListNftResponse) return object;
          return new $root.ununifi.nftmarket.MsgListNftResponse();
        };

        /**
         * Creates a plain object from a MsgListNftResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @static
         * @param {ununifi.nftmarket.MsgListNftResponse} message MsgListNftResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgListNftResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgListNftResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgListNftResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgListNftResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgListNftResponse;
      })();

      nftmarket.MsgCancelNftListing = (function () {
        /**
         * Properties of a MsgCancelNftListing.
         * @memberof ununifi.nftmarket
         * @interface IMsgCancelNftListing
         * @property {string|null} [sender] MsgCancelNftListing sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgCancelNftListing nft_id
         */

        /**
         * Constructs a new MsgCancelNftListing.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgCancelNftListing.
         * @implements IMsgCancelNftListing
         * @constructor
         * @param {ununifi.nftmarket.IMsgCancelNftListing=} [properties] Properties to set
         */
        function MsgCancelNftListing(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgCancelNftListing sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @instance
         */
        MsgCancelNftListing.prototype.sender = '';

        /**
         * MsgCancelNftListing nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @instance
         */
        MsgCancelNftListing.prototype.nft_id = null;

        /**
         * Encodes the specified MsgCancelNftListing message. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListing.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @static
         * @param {ununifi.nftmarket.IMsgCancelNftListing} message MsgCancelNftListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelNftListing.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgCancelNftListing message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @static
         * @param {ununifi.nftmarket.IMsgCancelNftListing} message MsgCancelNftListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelNftListing.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCancelNftListing message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgCancelNftListing} MsgCancelNftListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelNftListing.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgCancelNftListing();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCancelNftListing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgCancelNftListing} MsgCancelNftListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelNftListing.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCancelNftListing message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCancelNftListing.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgCancelNftListing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgCancelNftListing} MsgCancelNftListing
         */
        MsgCancelNftListing.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgCancelNftListing) return object;
          var message = new $root.ununifi.nftmarket.MsgCancelNftListing();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgCancelNftListing.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgCancelNftListing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @static
         * @param {ununifi.nftmarket.MsgCancelNftListing} message MsgCancelNftListing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCancelNftListing.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          return object;
        };

        /**
         * Converts this MsgCancelNftListing to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgCancelNftListing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCancelNftListing.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCancelNftListing;
      })();

      nftmarket.MsgCancelNftListingResponse = (function () {
        /**
         * Properties of a MsgCancelNftListingResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgCancelNftListingResponse
         */

        /**
         * Constructs a new MsgCancelNftListingResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgCancelNftListingResponse.
         * @implements IMsgCancelNftListingResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgCancelNftListingResponse=} [properties] Properties to set
         */
        function MsgCancelNftListingResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgCancelNftListingResponse message. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListingResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @static
         * @param {ununifi.nftmarket.IMsgCancelNftListingResponse} message MsgCancelNftListingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelNftListingResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgCancelNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListingResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @static
         * @param {ununifi.nftmarket.IMsgCancelNftListingResponse} message MsgCancelNftListingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCancelNftListingResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgCancelNftListingResponse} MsgCancelNftListingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelNftListingResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgCancelNftListingResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCancelNftListingResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgCancelNftListingResponse} MsgCancelNftListingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCancelNftListingResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCancelNftListingResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgCancelNftListingResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgCancelNftListingResponse} MsgCancelNftListingResponse
         */
        MsgCancelNftListingResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgCancelNftListingResponse) return object;
          return new $root.ununifi.nftmarket.MsgCancelNftListingResponse();
        };

        /**
         * Creates a plain object from a MsgCancelNftListingResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @static
         * @param {ununifi.nftmarket.MsgCancelNftListingResponse} message MsgCancelNftListingResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCancelNftListingResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgCancelNftListingResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCancelNftListingResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCancelNftListingResponse;
      })();

      nftmarket.MsgExpandListingPeriod = (function () {
        /**
         * Properties of a MsgExpandListingPeriod.
         * @memberof ununifi.nftmarket
         * @interface IMsgExpandListingPeriod
         * @property {string|null} [sender] MsgExpandListingPeriod sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgExpandListingPeriod nft_id
         */

        /**
         * Constructs a new MsgExpandListingPeriod.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgExpandListingPeriod.
         * @implements IMsgExpandListingPeriod
         * @constructor
         * @param {ununifi.nftmarket.IMsgExpandListingPeriod=} [properties] Properties to set
         */
        function MsgExpandListingPeriod(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgExpandListingPeriod sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @instance
         */
        MsgExpandListingPeriod.prototype.sender = '';

        /**
         * MsgExpandListingPeriod nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @instance
         */
        MsgExpandListingPeriod.prototype.nft_id = null;

        /**
         * Encodes the specified MsgExpandListingPeriod message. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriod.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @static
         * @param {ununifi.nftmarket.IMsgExpandListingPeriod} message MsgExpandListingPeriod message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExpandListingPeriod.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgExpandListingPeriod message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriod.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @static
         * @param {ununifi.nftmarket.IMsgExpandListingPeriod} message MsgExpandListingPeriod message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExpandListingPeriod.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgExpandListingPeriod message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgExpandListingPeriod} MsgExpandListingPeriod
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExpandListingPeriod.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgExpandListingPeriod();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgExpandListingPeriod message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgExpandListingPeriod} MsgExpandListingPeriod
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExpandListingPeriod.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgExpandListingPeriod message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgExpandListingPeriod.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgExpandListingPeriod message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgExpandListingPeriod} MsgExpandListingPeriod
         */
        MsgExpandListingPeriod.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgExpandListingPeriod) return object;
          var message = new $root.ununifi.nftmarket.MsgExpandListingPeriod();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgExpandListingPeriod.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgExpandListingPeriod message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @static
         * @param {ununifi.nftmarket.MsgExpandListingPeriod} message MsgExpandListingPeriod
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgExpandListingPeriod.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          return object;
        };

        /**
         * Converts this MsgExpandListingPeriod to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgExpandListingPeriod
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgExpandListingPeriod.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgExpandListingPeriod;
      })();

      nftmarket.MsgExpandListingPeriodResponse = (function () {
        /**
         * Properties of a MsgExpandListingPeriodResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgExpandListingPeriodResponse
         */

        /**
         * Constructs a new MsgExpandListingPeriodResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgExpandListingPeriodResponse.
         * @implements IMsgExpandListingPeriodResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgExpandListingPeriodResponse=} [properties] Properties to set
         */
        function MsgExpandListingPeriodResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgExpandListingPeriodResponse message. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriodResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @static
         * @param {ununifi.nftmarket.IMsgExpandListingPeriodResponse} message MsgExpandListingPeriodResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExpandListingPeriodResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgExpandListingPeriodResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriodResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @static
         * @param {ununifi.nftmarket.IMsgExpandListingPeriodResponse} message MsgExpandListingPeriodResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExpandListingPeriodResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgExpandListingPeriodResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgExpandListingPeriodResponse} MsgExpandListingPeriodResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExpandListingPeriodResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgExpandListingPeriodResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgExpandListingPeriodResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgExpandListingPeriodResponse} MsgExpandListingPeriodResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExpandListingPeriodResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgExpandListingPeriodResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgExpandListingPeriodResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgExpandListingPeriodResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgExpandListingPeriodResponse} MsgExpandListingPeriodResponse
         */
        MsgExpandListingPeriodResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgExpandListingPeriodResponse) return object;
          return new $root.ununifi.nftmarket.MsgExpandListingPeriodResponse();
        };

        /**
         * Creates a plain object from a MsgExpandListingPeriodResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @static
         * @param {ununifi.nftmarket.MsgExpandListingPeriodResponse} message MsgExpandListingPeriodResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgExpandListingPeriodResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgExpandListingPeriodResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgExpandListingPeriodResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgExpandListingPeriodResponse;
      })();

      nftmarket.MsgPlaceBid = (function () {
        /**
         * Properties of a MsgPlaceBid.
         * @memberof ununifi.nftmarket
         * @interface IMsgPlaceBid
         * @property {string|null} [sender] MsgPlaceBid sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgPlaceBid nft_id
         * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgPlaceBid amount
         * @property {boolean|null} [automatic_payment] MsgPlaceBid automatic_payment
         */

        /**
         * Constructs a new MsgPlaceBid.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgPlaceBid.
         * @implements IMsgPlaceBid
         * @constructor
         * @param {ununifi.nftmarket.IMsgPlaceBid=} [properties] Properties to set
         */
        function MsgPlaceBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgPlaceBid sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @instance
         */
        MsgPlaceBid.prototype.sender = '';

        /**
         * MsgPlaceBid nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @instance
         */
        MsgPlaceBid.prototype.nft_id = null;

        /**
         * MsgPlaceBid amount.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @instance
         */
        MsgPlaceBid.prototype.amount = null;

        /**
         * MsgPlaceBid automatic_payment.
         * @member {boolean} automatic_payment
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @instance
         */
        MsgPlaceBid.prototype.automatic_payment = false;

        /**
         * Encodes the specified MsgPlaceBid message. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @static
         * @param {ununifi.nftmarket.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.automatic_payment);
          return writer;
        };

        /**
         * Encodes the specified MsgPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @static
         * @param {ununifi.nftmarket.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPlaceBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgPlaceBid} MsgPlaceBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgPlaceBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 3:
                message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              case 4:
                message.automatic_payment = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPlaceBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgPlaceBid} MsgPlaceBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPlaceBid message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPlaceBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.amount != null && message.hasOwnProperty('amount')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
            if (error) return 'amount.' + error;
          }
          if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
            if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
          return null;
        };

        /**
         * Creates a MsgPlaceBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgPlaceBid} MsgPlaceBid
         */
        MsgPlaceBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgPlaceBid) return object;
          var message = new $root.ununifi.nftmarket.MsgPlaceBid();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgPlaceBid.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          if (object.amount != null) {
            if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.MsgPlaceBid.amount: object expected');
            message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
          }
          if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
          return message;
        };

        /**
         * Creates a plain object from a MsgPlaceBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @static
         * @param {ununifi.nftmarket.MsgPlaceBid} message MsgPlaceBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPlaceBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
            object.amount = null;
            object.automatic_payment = false;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.amount != null && message.hasOwnProperty('amount'))
            object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
          if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
            object.automatic_payment = message.automatic_payment;
          return object;
        };

        /**
         * Converts this MsgPlaceBid to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgPlaceBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPlaceBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPlaceBid;
      })();

      nftmarket.MsgPlaceBidResponse = (function () {
        /**
         * Properties of a MsgPlaceBidResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgPlaceBidResponse
         */

        /**
         * Constructs a new MsgPlaceBidResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgPlaceBidResponse.
         * @implements IMsgPlaceBidResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgPlaceBidResponse=} [properties] Properties to set
         */
        function MsgPlaceBidResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgPlaceBidResponse message. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBidResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @static
         * @param {ununifi.nftmarket.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBidResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgPlaceBidResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBidResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @static
         * @param {ununifi.nftmarket.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPlaceBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPlaceBidResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgPlaceBidResponse} MsgPlaceBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBidResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgPlaceBidResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPlaceBidResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgPlaceBidResponse} MsgPlaceBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPlaceBidResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPlaceBidResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPlaceBidResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgPlaceBidResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgPlaceBidResponse} MsgPlaceBidResponse
         */
        MsgPlaceBidResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgPlaceBidResponse) return object;
          return new $root.ununifi.nftmarket.MsgPlaceBidResponse();
        };

        /**
         * Creates a plain object from a MsgPlaceBidResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @static
         * @param {ununifi.nftmarket.MsgPlaceBidResponse} message MsgPlaceBidResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPlaceBidResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgPlaceBidResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgPlaceBidResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPlaceBidResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPlaceBidResponse;
      })();

      nftmarket.MsgCancelBid = (function () {
        /**
         * Properties of a MsgCancelBid.
         * @memberof ununifi.nftmarket
         * @interface IMsgCancelBid
         * @property {string|null} [sender] MsgCancelBid sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgCancelBid nft_id
         */

        /**
         * Constructs a new MsgCancelBid.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgCancelBid.
         * @implements IMsgCancelBid
         * @constructor
         * @param {ununifi.nftmarket.IMsgCancelBid=} [properties] Properties to set
         */
        function MsgCancelBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgCancelBid sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @instance
         */
        MsgCancelBid.prototype.sender = '';

        /**
         * MsgCancelBid nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @instance
         */
        MsgCancelBid.prototype.nft_id = null;

        /**
         * Encodes the specified MsgCancelBid message. Does not implicitly {@link ununifi.nftmarket.MsgCancelBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @static
         * @param {ununifi.nftmarket.IMsgCancelBid} message MsgCancelBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgCancelBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @static
         * @param {ununifi.nftmarket.IMsgCancelBid} message MsgCancelBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCancelBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgCancelBid} MsgCancelBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgCancelBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCancelBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgCancelBid} MsgCancelBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCancelBid message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCancelBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgCancelBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgCancelBid} MsgCancelBid
         */
        MsgCancelBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgCancelBid) return object;
          var message = new $root.ununifi.nftmarket.MsgCancelBid();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgCancelBid.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgCancelBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @static
         * @param {ununifi.nftmarket.MsgCancelBid} message MsgCancelBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCancelBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          return object;
        };

        /**
         * Converts this MsgCancelBid to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgCancelBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCancelBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCancelBid;
      })();

      nftmarket.MsgCancelBidResponse = (function () {
        /**
         * Properties of a MsgCancelBidResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgCancelBidResponse
         */

        /**
         * Constructs a new MsgCancelBidResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgCancelBidResponse.
         * @implements IMsgCancelBidResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgCancelBidResponse=} [properties] Properties to set
         */
        function MsgCancelBidResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgCancelBidResponse message. Does not implicitly {@link ununifi.nftmarket.MsgCancelBidResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @static
         * @param {ununifi.nftmarket.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelBidResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgCancelBidResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelBidResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @static
         * @param {ununifi.nftmarket.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCancelBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCancelBidResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgCancelBidResponse} MsgCancelBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelBidResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgCancelBidResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCancelBidResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgCancelBidResponse} MsgCancelBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCancelBidResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCancelBidResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCancelBidResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgCancelBidResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgCancelBidResponse} MsgCancelBidResponse
         */
        MsgCancelBidResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgCancelBidResponse) return object;
          return new $root.ununifi.nftmarket.MsgCancelBidResponse();
        };

        /**
         * Creates a plain object from a MsgCancelBidResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @static
         * @param {ununifi.nftmarket.MsgCancelBidResponse} message MsgCancelBidResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCancelBidResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgCancelBidResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgCancelBidResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCancelBidResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCancelBidResponse;
      })();

      nftmarket.MsgEndNftListing = (function () {
        /**
         * Properties of a MsgEndNftListing.
         * @memberof ununifi.nftmarket
         * @interface IMsgEndNftListing
         * @property {string|null} [sender] MsgEndNftListing sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgEndNftListing nft_id
         */

        /**
         * Constructs a new MsgEndNftListing.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgEndNftListing.
         * @implements IMsgEndNftListing
         * @constructor
         * @param {ununifi.nftmarket.IMsgEndNftListing=} [properties] Properties to set
         */
        function MsgEndNftListing(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgEndNftListing sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @instance
         */
        MsgEndNftListing.prototype.sender = '';

        /**
         * MsgEndNftListing nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @instance
         */
        MsgEndNftListing.prototype.nft_id = null;

        /**
         * Encodes the specified MsgEndNftListing message. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListing.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @static
         * @param {ununifi.nftmarket.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgEndNftListing.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgEndNftListing message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @static
         * @param {ununifi.nftmarket.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgEndNftListing.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgEndNftListing message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgEndNftListing} MsgEndNftListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgEndNftListing.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgEndNftListing();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgEndNftListing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgEndNftListing} MsgEndNftListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgEndNftListing.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgEndNftListing message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgEndNftListing.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgEndNftListing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgEndNftListing} MsgEndNftListing
         */
        MsgEndNftListing.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgEndNftListing) return object;
          var message = new $root.ununifi.nftmarket.MsgEndNftListing();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgEndNftListing.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgEndNftListing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @static
         * @param {ununifi.nftmarket.MsgEndNftListing} message MsgEndNftListing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgEndNftListing.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          return object;
        };

        /**
         * Converts this MsgEndNftListing to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgEndNftListing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgEndNftListing.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgEndNftListing;
      })();

      nftmarket.MsgEndNftListingResponse = (function () {
        /**
         * Properties of a MsgEndNftListingResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgEndNftListingResponse
         */

        /**
         * Constructs a new MsgEndNftListingResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgEndNftListingResponse.
         * @implements IMsgEndNftListingResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgEndNftListingResponse=} [properties] Properties to set
         */
        function MsgEndNftListingResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgEndNftListingResponse message. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListingResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @static
         * @param {ununifi.nftmarket.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgEndNftListingResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgEndNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListingResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @static
         * @param {ununifi.nftmarket.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgEndNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgEndNftListingResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgEndNftListingResponse} MsgEndNftListingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgEndNftListingResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgEndNftListingResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgEndNftListingResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgEndNftListingResponse} MsgEndNftListingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgEndNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgEndNftListingResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgEndNftListingResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgEndNftListingResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgEndNftListingResponse} MsgEndNftListingResponse
         */
        MsgEndNftListingResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgEndNftListingResponse) return object;
          return new $root.ununifi.nftmarket.MsgEndNftListingResponse();
        };

        /**
         * Creates a plain object from a MsgEndNftListingResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @static
         * @param {ununifi.nftmarket.MsgEndNftListingResponse} message MsgEndNftListingResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgEndNftListingResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgEndNftListingResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgEndNftListingResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgEndNftListingResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgEndNftListingResponse;
      })();

      nftmarket.MsgSellingDecision = (function () {
        /**
         * Properties of a MsgSellingDecision.
         * @memberof ununifi.nftmarket
         * @interface IMsgSellingDecision
         * @property {string|null} [sender] MsgSellingDecision sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgSellingDecision nft_id
         */

        /**
         * Constructs a new MsgSellingDecision.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgSellingDecision.
         * @implements IMsgSellingDecision
         * @constructor
         * @param {ununifi.nftmarket.IMsgSellingDecision=} [properties] Properties to set
         */
        function MsgSellingDecision(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgSellingDecision sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @instance
         */
        MsgSellingDecision.prototype.sender = '';

        /**
         * MsgSellingDecision nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @instance
         */
        MsgSellingDecision.prototype.nft_id = null;

        /**
         * Encodes the specified MsgSellingDecision message. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecision.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @static
         * @param {ununifi.nftmarket.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSellingDecision.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecision.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @static
         * @param {ununifi.nftmarket.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgSellingDecision message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgSellingDecision} MsgSellingDecision
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSellingDecision.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgSellingDecision();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgSellingDecision message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgSellingDecision} MsgSellingDecision
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSellingDecision.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgSellingDecision message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgSellingDecision.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgSellingDecision message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgSellingDecision} MsgSellingDecision
         */
        MsgSellingDecision.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgSellingDecision) return object;
          var message = new $root.ununifi.nftmarket.MsgSellingDecision();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgSellingDecision.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgSellingDecision message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @static
         * @param {ununifi.nftmarket.MsgSellingDecision} message MsgSellingDecision
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgSellingDecision.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          return object;
        };

        /**
         * Converts this MsgSellingDecision to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgSellingDecision
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgSellingDecision.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgSellingDecision;
      })();

      nftmarket.MsgSellingDecisionResponse = (function () {
        /**
         * Properties of a MsgSellingDecisionResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgSellingDecisionResponse
         */

        /**
         * Constructs a new MsgSellingDecisionResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgSellingDecisionResponse.
         * @implements IMsgSellingDecisionResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgSellingDecisionResponse=} [properties] Properties to set
         */
        function MsgSellingDecisionResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgSellingDecisionResponse message. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecisionResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @static
         * @param {ununifi.nftmarket.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSellingDecisionResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgSellingDecisionResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecisionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @static
         * @param {ununifi.nftmarket.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSellingDecisionResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgSellingDecisionResponse} MsgSellingDecisionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSellingDecisionResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgSellingDecisionResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgSellingDecisionResponse} MsgSellingDecisionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSellingDecisionResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgSellingDecisionResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgSellingDecisionResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgSellingDecisionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgSellingDecisionResponse} MsgSellingDecisionResponse
         */
        MsgSellingDecisionResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgSellingDecisionResponse) return object;
          return new $root.ununifi.nftmarket.MsgSellingDecisionResponse();
        };

        /**
         * Creates a plain object from a MsgSellingDecisionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @static
         * @param {ununifi.nftmarket.MsgSellingDecisionResponse} message MsgSellingDecisionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgSellingDecisionResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgSellingDecisionResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgSellingDecisionResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgSellingDecisionResponse;
      })();

      nftmarket.MsgPayFullBid = (function () {
        /**
         * Properties of a MsgPayFullBid.
         * @memberof ununifi.nftmarket
         * @interface IMsgPayFullBid
         * @property {string|null} [sender] MsgPayFullBid sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgPayFullBid nft_id
         */

        /**
         * Constructs a new MsgPayFullBid.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgPayFullBid.
         * @implements IMsgPayFullBid
         * @constructor
         * @param {ununifi.nftmarket.IMsgPayFullBid=} [properties] Properties to set
         */
        function MsgPayFullBid(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgPayFullBid sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @instance
         */
        MsgPayFullBid.prototype.sender = '';

        /**
         * MsgPayFullBid nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @instance
         */
        MsgPayFullBid.prototype.nft_id = null;

        /**
         * Encodes the specified MsgPayFullBid message. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBid.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @static
         * @param {ununifi.nftmarket.IMsgPayFullBid} message MsgPayFullBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPayFullBid.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgPayFullBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @static
         * @param {ununifi.nftmarket.IMsgPayFullBid} message MsgPayFullBid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPayFullBid.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPayFullBid message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgPayFullBid} MsgPayFullBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPayFullBid.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgPayFullBid();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPayFullBid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgPayFullBid} MsgPayFullBid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPayFullBid.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPayFullBid message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPayFullBid.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgPayFullBid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgPayFullBid} MsgPayFullBid
         */
        MsgPayFullBid.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgPayFullBid) return object;
          var message = new $root.ununifi.nftmarket.MsgPayFullBid();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgPayFullBid.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgPayFullBid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @static
         * @param {ununifi.nftmarket.MsgPayFullBid} message MsgPayFullBid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPayFullBid.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          return object;
        };

        /**
         * Converts this MsgPayFullBid to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgPayFullBid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPayFullBid.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPayFullBid;
      })();

      nftmarket.MsgPayFullBidResponse = (function () {
        /**
         * Properties of a MsgPayFullBidResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgPayFullBidResponse
         */

        /**
         * Constructs a new MsgPayFullBidResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgPayFullBidResponse.
         * @implements IMsgPayFullBidResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgPayFullBidResponse=} [properties] Properties to set
         */
        function MsgPayFullBidResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgPayFullBidResponse message. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBidResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @static
         * @param {ununifi.nftmarket.IMsgPayFullBidResponse} message MsgPayFullBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPayFullBidResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgPayFullBidResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBidResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @static
         * @param {ununifi.nftmarket.IMsgPayFullBidResponse} message MsgPayFullBidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPayFullBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPayFullBidResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgPayFullBidResponse} MsgPayFullBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPayFullBidResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgPayFullBidResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPayFullBidResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgPayFullBidResponse} MsgPayFullBidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPayFullBidResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPayFullBidResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPayFullBidResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgPayFullBidResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgPayFullBidResponse} MsgPayFullBidResponse
         */
        MsgPayFullBidResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgPayFullBidResponse) return object;
          return new $root.ununifi.nftmarket.MsgPayFullBidResponse();
        };

        /**
         * Creates a plain object from a MsgPayFullBidResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @static
         * @param {ununifi.nftmarket.MsgPayFullBidResponse} message MsgPayFullBidResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPayFullBidResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgPayFullBidResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgPayFullBidResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPayFullBidResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPayFullBidResponse;
      })();

      nftmarket.MsgBorrow = (function () {
        /**
         * Properties of a MsgBorrow.
         * @memberof ununifi.nftmarket
         * @interface IMsgBorrow
         * @property {string|null} [sender] MsgBorrow sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgBorrow nft_id
         * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgBorrow amount
         */

        /**
         * Constructs a new MsgBorrow.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgBorrow.
         * @implements IMsgBorrow
         * @constructor
         * @param {ununifi.nftmarket.IMsgBorrow=} [properties] Properties to set
         */
        function MsgBorrow(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgBorrow sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgBorrow
         * @instance
         */
        MsgBorrow.prototype.sender = '';

        /**
         * MsgBorrow nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgBorrow
         * @instance
         */
        MsgBorrow.prototype.nft_id = null;

        /**
         * MsgBorrow amount.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
         * @memberof ununifi.nftmarket.MsgBorrow
         * @instance
         */
        MsgBorrow.prototype.amount = null;

        /**
         * Encodes the specified MsgBorrow message. Does not implicitly {@link ununifi.nftmarket.MsgBorrow.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgBorrow
         * @static
         * @param {ununifi.nftmarket.IMsgBorrow} message MsgBorrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBorrow.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgBorrow message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBorrow.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgBorrow
         * @static
         * @param {ununifi.nftmarket.IMsgBorrow} message MsgBorrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBorrow.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgBorrow message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgBorrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgBorrow} MsgBorrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBorrow.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgBorrow();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 3:
                message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgBorrow message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgBorrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgBorrow} MsgBorrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBorrow.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgBorrow message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgBorrow
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgBorrow.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.amount != null && message.hasOwnProperty('amount')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
            if (error) return 'amount.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgBorrow message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgBorrow
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgBorrow} MsgBorrow
         */
        MsgBorrow.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgBorrow) return object;
          var message = new $root.ununifi.nftmarket.MsgBorrow();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgBorrow.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          if (object.amount != null) {
            if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.MsgBorrow.amount: object expected');
            message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgBorrow message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgBorrow
         * @static
         * @param {ununifi.nftmarket.MsgBorrow} message MsgBorrow
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgBorrow.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
            object.amount = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.amount != null && message.hasOwnProperty('amount'))
            object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
          return object;
        };

        /**
         * Converts this MsgBorrow to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgBorrow
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgBorrow.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgBorrow;
      })();

      nftmarket.MsgBorrowResponse = (function () {
        /**
         * Properties of a MsgBorrowResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgBorrowResponse
         */

        /**
         * Constructs a new MsgBorrowResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgBorrowResponse.
         * @implements IMsgBorrowResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgBorrowResponse=} [properties] Properties to set
         */
        function MsgBorrowResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgBorrowResponse message. Does not implicitly {@link ununifi.nftmarket.MsgBorrowResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @static
         * @param {ununifi.nftmarket.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBorrowResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgBorrowResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBorrowResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @static
         * @param {ununifi.nftmarket.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBorrowResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgBorrowResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgBorrowResponse} MsgBorrowResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBorrowResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgBorrowResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgBorrowResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgBorrowResponse} MsgBorrowResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBorrowResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgBorrowResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgBorrowResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgBorrowResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgBorrowResponse} MsgBorrowResponse
         */
        MsgBorrowResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgBorrowResponse) return object;
          return new $root.ununifi.nftmarket.MsgBorrowResponse();
        };

        /**
         * Creates a plain object from a MsgBorrowResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @static
         * @param {ununifi.nftmarket.MsgBorrowResponse} message MsgBorrowResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgBorrowResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgBorrowResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgBorrowResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgBorrowResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgBorrowResponse;
      })();

      nftmarket.MsgRepay = (function () {
        /**
         * Properties of a MsgRepay.
         * @memberof ununifi.nftmarket
         * @interface IMsgRepay
         * @property {string|null} [sender] MsgRepay sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgRepay nft_id
         * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgRepay amount
         */

        /**
         * Constructs a new MsgRepay.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgRepay.
         * @implements IMsgRepay
         * @constructor
         * @param {ununifi.nftmarket.IMsgRepay=} [properties] Properties to set
         */
        function MsgRepay(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgRepay sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgRepay
         * @instance
         */
        MsgRepay.prototype.sender = '';

        /**
         * MsgRepay nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgRepay
         * @instance
         */
        MsgRepay.prototype.nft_id = null;

        /**
         * MsgRepay amount.
         * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
         * @memberof ununifi.nftmarket.MsgRepay
         * @instance
         */
        MsgRepay.prototype.amount = null;

        /**
         * Encodes the specified MsgRepay message. Does not implicitly {@link ununifi.nftmarket.MsgRepay.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgRepay
         * @static
         * @param {ununifi.nftmarket.IMsgRepay} message MsgRepay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepay.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgRepay message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgRepay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgRepay
         * @static
         * @param {ununifi.nftmarket.IMsgRepay} message MsgRepay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepay.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgRepay message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgRepay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgRepay} MsgRepay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepay.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgRepay();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              case 3:
                message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgRepay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgRepay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgRepay} MsgRepay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepay.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgRepay message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgRepay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgRepay.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          if (message.amount != null && message.hasOwnProperty('amount')) {
            var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
            if (error) return 'amount.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgRepay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgRepay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgRepay} MsgRepay
         */
        MsgRepay.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgRepay) return object;
          var message = new $root.ununifi.nftmarket.MsgRepay();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgRepay.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          if (object.amount != null) {
            if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.MsgRepay.amount: object expected');
            message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgRepay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgRepay
         * @static
         * @param {ununifi.nftmarket.MsgRepay} message MsgRepay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgRepay.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
            object.amount = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          if (message.amount != null && message.hasOwnProperty('amount'))
            object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
          return object;
        };

        /**
         * Converts this MsgRepay to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgRepay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgRepay.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgRepay;
      })();

      nftmarket.MsgRepayResponse = (function () {
        /**
         * Properties of a MsgRepayResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgRepayResponse
         */

        /**
         * Constructs a new MsgRepayResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgRepayResponse.
         * @implements IMsgRepayResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgRepayResponse=} [properties] Properties to set
         */
        function MsgRepayResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgRepayResponse message. Does not implicitly {@link ununifi.nftmarket.MsgRepayResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @static
         * @param {ununifi.nftmarket.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepayResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgRepayResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgRepayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @static
         * @param {ununifi.nftmarket.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRepayResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgRepayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgRepayResponse} MsgRepayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepayResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgRepayResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgRepayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgRepayResponse} MsgRepayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRepayResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgRepayResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgRepayResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgRepayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgRepayResponse} MsgRepayResponse
         */
        MsgRepayResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgRepayResponse) return object;
          return new $root.ununifi.nftmarket.MsgRepayResponse();
        };

        /**
         * Creates a plain object from a MsgRepayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @static
         * @param {ununifi.nftmarket.MsgRepayResponse} message MsgRepayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgRepayResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgRepayResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgRepayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgRepayResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgRepayResponse;
      })();

      nftmarket.MsgMintStableCoin = (function () {
        /**
         * Properties of a MsgMintStableCoin.
         * @memberof ununifi.nftmarket
         * @interface IMsgMintStableCoin
         * @property {string|null} [sender] MsgMintStableCoin sender
         */

        /**
         * Constructs a new MsgMintStableCoin.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgMintStableCoin.
         * @implements IMsgMintStableCoin
         * @constructor
         * @param {ununifi.nftmarket.IMsgMintStableCoin=} [properties] Properties to set
         */
        function MsgMintStableCoin(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgMintStableCoin sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @instance
         */
        MsgMintStableCoin.prototype.sender = '';

        /**
         * Encodes the specified MsgMintStableCoin message. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoin.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @static
         * @param {ununifi.nftmarket.IMsgMintStableCoin} message MsgMintStableCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintStableCoin.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          return writer;
        };

        /**
         * Encodes the specified MsgMintStableCoin message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @static
         * @param {ununifi.nftmarket.IMsgMintStableCoin} message MsgMintStableCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintStableCoin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgMintStableCoin message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgMintStableCoin} MsgMintStableCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintStableCoin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgMintStableCoin();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgMintStableCoin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgMintStableCoin} MsgMintStableCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintStableCoin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgMintStableCoin message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgMintStableCoin.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          return null;
        };

        /**
         * Creates a MsgMintStableCoin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgMintStableCoin} MsgMintStableCoin
         */
        MsgMintStableCoin.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgMintStableCoin) return object;
          var message = new $root.ununifi.nftmarket.MsgMintStableCoin();
          if (object.sender != null) message.sender = String(object.sender);
          return message;
        };

        /**
         * Creates a plain object from a MsgMintStableCoin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @static
         * @param {ununifi.nftmarket.MsgMintStableCoin} message MsgMintStableCoin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgMintStableCoin.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.sender = '';
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          return object;
        };

        /**
         * Converts this MsgMintStableCoin to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgMintStableCoin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgMintStableCoin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgMintStableCoin;
      })();

      nftmarket.MsgMintStableCoinResponse = (function () {
        /**
         * Properties of a MsgMintStableCoinResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgMintStableCoinResponse
         */

        /**
         * Constructs a new MsgMintStableCoinResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgMintStableCoinResponse.
         * @implements IMsgMintStableCoinResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgMintStableCoinResponse=} [properties] Properties to set
         */
        function MsgMintStableCoinResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgMintStableCoinResponse message. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoinResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @static
         * @param {ununifi.nftmarket.IMsgMintStableCoinResponse} message MsgMintStableCoinResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintStableCoinResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgMintStableCoinResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoinResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @static
         * @param {ununifi.nftmarket.IMsgMintStableCoinResponse} message MsgMintStableCoinResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintStableCoinResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgMintStableCoinResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgMintStableCoinResponse} MsgMintStableCoinResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintStableCoinResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgMintStableCoinResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgMintStableCoinResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgMintStableCoinResponse} MsgMintStableCoinResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintStableCoinResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgMintStableCoinResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgMintStableCoinResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgMintStableCoinResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgMintStableCoinResponse} MsgMintStableCoinResponse
         */
        MsgMintStableCoinResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgMintStableCoinResponse) return object;
          return new $root.ununifi.nftmarket.MsgMintStableCoinResponse();
        };

        /**
         * Creates a plain object from a MsgMintStableCoinResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @static
         * @param {ununifi.nftmarket.MsgMintStableCoinResponse} message MsgMintStableCoinResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgMintStableCoinResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgMintStableCoinResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgMintStableCoinResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgMintStableCoinResponse;
      })();

      nftmarket.MsgBurnStableCoin = (function () {
        /**
         * Properties of a MsgBurnStableCoin.
         * @memberof ununifi.nftmarket
         * @interface IMsgBurnStableCoin
         * @property {string|null} [sender] MsgBurnStableCoin sender
         */

        /**
         * Constructs a new MsgBurnStableCoin.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgBurnStableCoin.
         * @implements IMsgBurnStableCoin
         * @constructor
         * @param {ununifi.nftmarket.IMsgBurnStableCoin=} [properties] Properties to set
         */
        function MsgBurnStableCoin(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgBurnStableCoin sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @instance
         */
        MsgBurnStableCoin.prototype.sender = '';

        /**
         * Encodes the specified MsgBurnStableCoin message. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoin.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @static
         * @param {ununifi.nftmarket.IMsgBurnStableCoin} message MsgBurnStableCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnStableCoin.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          return writer;
        };

        /**
         * Encodes the specified MsgBurnStableCoin message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @static
         * @param {ununifi.nftmarket.IMsgBurnStableCoin} message MsgBurnStableCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnStableCoin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgBurnStableCoin message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgBurnStableCoin} MsgBurnStableCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnStableCoin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgBurnStableCoin();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgBurnStableCoin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgBurnStableCoin} MsgBurnStableCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnStableCoin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgBurnStableCoin message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgBurnStableCoin.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          return null;
        };

        /**
         * Creates a MsgBurnStableCoin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgBurnStableCoin} MsgBurnStableCoin
         */
        MsgBurnStableCoin.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgBurnStableCoin) return object;
          var message = new $root.ununifi.nftmarket.MsgBurnStableCoin();
          if (object.sender != null) message.sender = String(object.sender);
          return message;
        };

        /**
         * Creates a plain object from a MsgBurnStableCoin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @static
         * @param {ununifi.nftmarket.MsgBurnStableCoin} message MsgBurnStableCoin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgBurnStableCoin.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.sender = '';
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          return object;
        };

        /**
         * Converts this MsgBurnStableCoin to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgBurnStableCoin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgBurnStableCoin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgBurnStableCoin;
      })();

      nftmarket.MsgBurnStableCoinResponse = (function () {
        /**
         * Properties of a MsgBurnStableCoinResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgBurnStableCoinResponse
         */

        /**
         * Constructs a new MsgBurnStableCoinResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgBurnStableCoinResponse.
         * @implements IMsgBurnStableCoinResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgBurnStableCoinResponse=} [properties] Properties to set
         */
        function MsgBurnStableCoinResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgBurnStableCoinResponse message. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoinResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @static
         * @param {ununifi.nftmarket.IMsgBurnStableCoinResponse} message MsgBurnStableCoinResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnStableCoinResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgBurnStableCoinResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoinResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @static
         * @param {ununifi.nftmarket.IMsgBurnStableCoinResponse} message MsgBurnStableCoinResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnStableCoinResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgBurnStableCoinResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgBurnStableCoinResponse} MsgBurnStableCoinResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnStableCoinResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgBurnStableCoinResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgBurnStableCoinResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgBurnStableCoinResponse} MsgBurnStableCoinResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnStableCoinResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgBurnStableCoinResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgBurnStableCoinResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgBurnStableCoinResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgBurnStableCoinResponse} MsgBurnStableCoinResponse
         */
        MsgBurnStableCoinResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgBurnStableCoinResponse) return object;
          return new $root.ununifi.nftmarket.MsgBurnStableCoinResponse();
        };

        /**
         * Creates a plain object from a MsgBurnStableCoinResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @static
         * @param {ununifi.nftmarket.MsgBurnStableCoinResponse} message MsgBurnStableCoinResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgBurnStableCoinResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgBurnStableCoinResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgBurnStableCoinResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgBurnStableCoinResponse;
      })();

      nftmarket.MsgLiquidate = (function () {
        /**
         * Properties of a MsgLiquidate.
         * @memberof ununifi.nftmarket
         * @interface IMsgLiquidate
         * @property {string|null} [sender] MsgLiquidate sender
         * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgLiquidate nft_id
         */

        /**
         * Constructs a new MsgLiquidate.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgLiquidate.
         * @implements IMsgLiquidate
         * @constructor
         * @param {ununifi.nftmarket.IMsgLiquidate=} [properties] Properties to set
         */
        function MsgLiquidate(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgLiquidate sender.
         * @member {string} sender
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @instance
         */
        MsgLiquidate.prototype.sender = '';

        /**
         * MsgLiquidate nft_id.
         * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @instance
         */
        MsgLiquidate.prototype.nft_id = null;

        /**
         * Encodes the specified MsgLiquidate message. Does not implicitly {@link ununifi.nftmarket.MsgLiquidate.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @static
         * @param {ununifi.nftmarket.IMsgLiquidate} message MsgLiquidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidate.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgLiquidate message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgLiquidate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @static
         * @param {ununifi.nftmarket.IMsgLiquidate} message MsgLiquidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgLiquidate message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgLiquidate} MsgLiquidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgLiquidate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgLiquidate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgLiquidate} MsgLiquidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgLiquidate message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgLiquidate.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
            var error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
            if (error) return 'nft_id.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgLiquidate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgLiquidate} MsgLiquidate
         */
        MsgLiquidate.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgLiquidate) return object;
          var message = new $root.ununifi.nftmarket.MsgLiquidate();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.nft_id != null) {
            if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgLiquidate.nft_id: object expected');
            message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgLiquidate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @static
         * @param {ununifi.nftmarket.MsgLiquidate} message MsgLiquidate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgLiquidate.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.nft_id = null;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
          return object;
        };

        /**
         * Converts this MsgLiquidate to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgLiquidate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgLiquidate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgLiquidate;
      })();

      nftmarket.MsgLiquidateResponse = (function () {
        /**
         * Properties of a MsgLiquidateResponse.
         * @memberof ununifi.nftmarket
         * @interface IMsgLiquidateResponse
         */

        /**
         * Constructs a new MsgLiquidateResponse.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a MsgLiquidateResponse.
         * @implements IMsgLiquidateResponse
         * @constructor
         * @param {ununifi.nftmarket.IMsgLiquidateResponse=} [properties] Properties to set
         */
        function MsgLiquidateResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgLiquidateResponse message. Does not implicitly {@link ununifi.nftmarket.MsgLiquidateResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @static
         * @param {ununifi.nftmarket.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidateResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgLiquidateResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgLiquidateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @static
         * @param {ununifi.nftmarket.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgLiquidateResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgLiquidateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.MsgLiquidateResponse} MsgLiquidateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidateResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.MsgLiquidateResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgLiquidateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.MsgLiquidateResponse} MsgLiquidateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgLiquidateResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgLiquidateResponse message.
         * @function verify
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgLiquidateResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgLiquidateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.MsgLiquidateResponse} MsgLiquidateResponse
         */
        MsgLiquidateResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.MsgLiquidateResponse) return object;
          return new $root.ununifi.nftmarket.MsgLiquidateResponse();
        };

        /**
         * Creates a plain object from a MsgLiquidateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @static
         * @param {ununifi.nftmarket.MsgLiquidateResponse} message MsgLiquidateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgLiquidateResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgLiquidateResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.MsgLiquidateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgLiquidateResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgLiquidateResponse;
      })();

      nftmarket.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.nftmarket
         * @interface IGenesisState
         * @property {ununifi.nftmarket.IParams|null} [params] GenesisState params
         * @property {Array.<ununifi.nftmarket.INftListing>|null} [listings] GenesisState listings
         * @property {Array.<ununifi.nftmarket.INftBid>|null} [bids] GenesisState bids
         * @property {Array.<ununifi.nftmarket.INftBid>|null} [cancelled_bids] GenesisState cancelled_bids
         * @property {Array.<ununifi.nftmarket.ILoan>|null} [loans] GenesisState loans
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.nftmarket
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.nftmarket.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          this.listings = [];
          this.bids = [];
          this.cancelled_bids = [];
          this.loans = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState params.
         * @member {ununifi.nftmarket.IParams|null|undefined} params
         * @memberof ununifi.nftmarket.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * GenesisState listings.
         * @member {Array.<ununifi.nftmarket.INftListing>} listings
         * @memberof ununifi.nftmarket.GenesisState
         * @instance
         */
        GenesisState.prototype.listings = $util.emptyArray;

        /**
         * GenesisState bids.
         * @member {Array.<ununifi.nftmarket.INftBid>} bids
         * @memberof ununifi.nftmarket.GenesisState
         * @instance
         */
        GenesisState.prototype.bids = $util.emptyArray;

        /**
         * GenesisState cancelled_bids.
         * @member {Array.<ununifi.nftmarket.INftBid>} cancelled_bids
         * @memberof ununifi.nftmarket.GenesisState
         * @instance
         */
        GenesisState.prototype.cancelled_bids = $util.emptyArray;

        /**
         * GenesisState loans.
         * @member {Array.<ununifi.nftmarket.ILoan>} loans
         * @memberof ununifi.nftmarket.GenesisState
         * @instance
         */
        GenesisState.prototype.loans = $util.emptyArray;

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftmarket.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmarket.GenesisState
         * @static
         * @param {ununifi.nftmarket.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.nftmarket.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.listings != null && message.listings.length)
            for (var i = 0; i < message.listings.length; ++i)
              $root.ununifi.nftmarket.NftListing.encode(message.listings[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.bids != null && message.bids.length)
            for (var i = 0; i < message.bids.length; ++i)
              $root.ununifi.nftmarket.NftBid.encode(message.bids[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          if (message.cancelled_bids != null && message.cancelled_bids.length)
            for (var i = 0; i < message.cancelled_bids.length; ++i)
              $root.ununifi.nftmarket.NftBid.encode(message.cancelled_bids[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          if (message.loans != null && message.loans.length)
            for (var i = 0; i < message.loans.length; ++i)
              $root.ununifi.nftmarket.Loan.encode(message.loans[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftmarket.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmarket.GenesisState
         * @static
         * @param {ununifi.nftmarket.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmarket.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmarket.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmarket.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.nftmarket.Params.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message.listings && message.listings.length)) message.listings = [];
                message.listings.push($root.ununifi.nftmarket.NftListing.decode(reader, reader.uint32()));
                break;
              case 3:
                if (!(message.bids && message.bids.length)) message.bids = [];
                message.bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
                break;
              case 4:
                if (!(message.cancelled_bids && message.cancelled_bids.length)) message.cancelled_bids = [];
                message.cancelled_bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
                break;
              case 5:
                if (!(message.loans && message.loans.length)) message.loans = [];
                message.loans.push($root.ununifi.nftmarket.Loan.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmarket.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmarket.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.nftmarket.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.nftmarket.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          if (message.listings != null && message.hasOwnProperty('listings')) {
            if (!Array.isArray(message.listings)) return 'listings: array expected';
            for (var i = 0; i < message.listings.length; ++i) {
              var error = $root.ununifi.nftmarket.NftListing.verify(message.listings[i]);
              if (error) return 'listings.' + error;
            }
          }
          if (message.bids != null && message.hasOwnProperty('bids')) {
            if (!Array.isArray(message.bids)) return 'bids: array expected';
            for (var i = 0; i < message.bids.length; ++i) {
              var error = $root.ununifi.nftmarket.NftBid.verify(message.bids[i]);
              if (error) return 'bids.' + error;
            }
          }
          if (message.cancelled_bids != null && message.hasOwnProperty('cancelled_bids')) {
            if (!Array.isArray(message.cancelled_bids)) return 'cancelled_bids: array expected';
            for (var i = 0; i < message.cancelled_bids.length; ++i) {
              var error = $root.ununifi.nftmarket.NftBid.verify(message.cancelled_bids[i]);
              if (error) return 'cancelled_bids.' + error;
            }
          }
          if (message.loans != null && message.hasOwnProperty('loans')) {
            if (!Array.isArray(message.loans)) return 'loans: array expected';
            for (var i = 0; i < message.loans.length; ++i) {
              var error = $root.ununifi.nftmarket.Loan.verify(message.loans[i]);
              if (error) return 'loans.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmarket.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmarket.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmarket.GenesisState) return object;
          var message = new $root.ununifi.nftmarket.GenesisState();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.params: object expected');
            message.params = $root.ununifi.nftmarket.Params.fromObject(object.params);
          }
          if (object.listings) {
            if (!Array.isArray(object.listings)) throw TypeError('.ununifi.nftmarket.GenesisState.listings: array expected');
            message.listings = [];
            for (var i = 0; i < object.listings.length; ++i) {
              if (typeof object.listings[i] !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.listings: object expected');
              message.listings[i] = $root.ununifi.nftmarket.NftListing.fromObject(object.listings[i]);
            }
          }
          if (object.bids) {
            if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftmarket.GenesisState.bids: array expected');
            message.bids = [];
            for (var i = 0; i < object.bids.length; ++i) {
              if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.bids: object expected');
              message.bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.bids[i]);
            }
          }
          if (object.cancelled_bids) {
            if (!Array.isArray(object.cancelled_bids)) throw TypeError('.ununifi.nftmarket.GenesisState.cancelled_bids: array expected');
            message.cancelled_bids = [];
            for (var i = 0; i < object.cancelled_bids.length; ++i) {
              if (typeof object.cancelled_bids[i] !== 'object')
                throw TypeError('.ununifi.nftmarket.GenesisState.cancelled_bids: object expected');
              message.cancelled_bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.cancelled_bids[i]);
            }
          }
          if (object.loans) {
            if (!Array.isArray(object.loans)) throw TypeError('.ununifi.nftmarket.GenesisState.loans: array expected');
            message.loans = [];
            for (var i = 0; i < object.loans.length; ++i) {
              if (typeof object.loans[i] !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.loans: object expected');
              message.loans[i] = $root.ununifi.nftmarket.Loan.fromObject(object.loans[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmarket.GenesisState
         * @static
         * @param {ununifi.nftmarket.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.listings = [];
            object.bids = [];
            object.cancelled_bids = [];
            object.loans = [];
          }
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.nftmarket.Params.toObject(message.params, options);
          if (message.listings && message.listings.length) {
            object.listings = [];
            for (var j = 0; j < message.listings.length; ++j)
              object.listings[j] = $root.ununifi.nftmarket.NftListing.toObject(message.listings[j], options);
          }
          if (message.bids && message.bids.length) {
            object.bids = [];
            for (var j = 0; j < message.bids.length; ++j)
              object.bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.bids[j], options);
          }
          if (message.cancelled_bids && message.cancelled_bids.length) {
            object.cancelled_bids = [];
            for (var j = 0; j < message.cancelled_bids.length; ++j)
              object.cancelled_bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.cancelled_bids[j], options);
          }
          if (message.loans && message.loans.length) {
            object.loans = [];
            for (var j = 0; j < message.loans.length; ++j)
              object.loans[j] = $root.ununifi.nftmarket.Loan.toObject(message.loans[j], options);
          }
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.nftmarket.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      return nftmarket;
    })();

    ununifi.nftmint = (function () {
      /**
       * Namespace nftmint.
       * @memberof ununifi
       * @namespace
       */
      var nftmint = {};

      nftmint.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.nftmint
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.nftmint.Query#params}.
         * @memberof ununifi.nftmint.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.nftmint.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(
              params,
              $root.ununifi.nftmint.QueryParamsRequest,
              $root.ununifi.nftmint.QueryParamsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.nftmint.QueryParamsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Query#classAttributes}.
         * @memberof ununifi.nftmint.Query
         * @typedef ClassAttributesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.QueryClassAttributesResponse} [response] QueryClassAttributesResponse
         */

        /**
         * Calls ClassAttributes.
         * @function classAttributes
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryClassAttributesRequest} request QueryClassAttributesRequest message or plain object
         * @param {ununifi.nftmint.Query.ClassAttributesCallback} callback Node-style callback called with the error, if any, and QueryClassAttributesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.classAttributes = function classAttributes(request, callback) {
            return this.rpcCall(
              classAttributes,
              $root.ununifi.nftmint.QueryClassAttributesRequest,
              $root.ununifi.nftmint.QueryClassAttributesResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ClassAttributes' },
        );

        /**
         * Calls ClassAttributes.
         * @function classAttributes
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryClassAttributesRequest} request QueryClassAttributesRequest message or plain object
         * @returns {Promise<ununifi.nftmint.QueryClassAttributesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Query#nFTMinter}.
         * @memberof ununifi.nftmint.Query
         * @typedef NFTMinterCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.QueryNFTMinterResponse} [response] QueryNFTMinterResponse
         */

        /**
         * Calls NFTMinter.
         * @function nFTMinter
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryNFTMinterRequest} request QueryNFTMinterRequest message or plain object
         * @param {ununifi.nftmint.Query.NFTMinterCallback} callback Node-style callback called with the error, if any, and QueryNFTMinterResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.nFTMinter = function nFTMinter(request, callback) {
            return this.rpcCall(
              nFTMinter,
              $root.ununifi.nftmint.QueryNFTMinterRequest,
              $root.ununifi.nftmint.QueryNFTMinterResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'NFTMinter' },
        );

        /**
         * Calls NFTMinter.
         * @function nFTMinter
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryNFTMinterRequest} request QueryNFTMinterRequest message or plain object
         * @returns {Promise<ununifi.nftmint.QueryNFTMinterResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Query#classIdsByName}.
         * @memberof ununifi.nftmint.Query
         * @typedef ClassIdsByNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.QueryClassIdsByNameResponse} [response] QueryClassIdsByNameResponse
         */

        /**
         * Calls ClassIdsByName.
         * @function classIdsByName
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} request QueryClassIdsByNameRequest message or plain object
         * @param {ununifi.nftmint.Query.ClassIdsByNameCallback} callback Node-style callback called with the error, if any, and QueryClassIdsByNameResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.classIdsByName = function classIdsByName(request, callback) {
            return this.rpcCall(
              classIdsByName,
              $root.ununifi.nftmint.QueryClassIdsByNameRequest,
              $root.ununifi.nftmint.QueryClassIdsByNameResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ClassIdsByName' },
        );

        /**
         * Calls ClassIdsByName.
         * @function classIdsByName
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} request QueryClassIdsByNameRequest message or plain object
         * @returns {Promise<ununifi.nftmint.QueryClassIdsByNameResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Query#classIdsByOwner}.
         * @memberof ununifi.nftmint.Query
         * @typedef ClassIdsByOwnerCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.QueryClassIdsByOwnerResponse} [response] QueryClassIdsByOwnerResponse
         */

        /**
         * Calls ClassIdsByOwner.
         * @function classIdsByOwner
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} request QueryClassIdsByOwnerRequest message or plain object
         * @param {ununifi.nftmint.Query.ClassIdsByOwnerCallback} callback Node-style callback called with the error, if any, and QueryClassIdsByOwnerResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.classIdsByOwner = function classIdsByOwner(request, callback) {
            return this.rpcCall(
              classIdsByOwner,
              $root.ununifi.nftmint.QueryClassIdsByOwnerRequest,
              $root.ununifi.nftmint.QueryClassIdsByOwnerResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'ClassIdsByOwner' },
        );

        /**
         * Calls ClassIdsByOwner.
         * @function classIdsByOwner
         * @memberof ununifi.nftmint.Query
         * @instance
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} request QueryClassIdsByOwnerRequest message or plain object
         * @returns {Promise<ununifi.nftmint.QueryClassIdsByOwnerResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      nftmint.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.nftmint
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.nftmint.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftmint.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @static
         * @param {ununifi.nftmint.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @static
         * @param {ununifi.nftmint.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryParamsRequest) return object;
          return new $root.ununifi.nftmint.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @static
         * @param {ununifi.nftmint.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      nftmint.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.nftmint
         * @interface IQueryParamsResponse
         * @property {ununifi.nftmint.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.nftmint.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.nftmint.IParams|null|undefined} params
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftmint.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @static
         * @param {ununifi.nftmint.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.nftmint.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @static
         * @param {ununifi.nftmint.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.nftmint.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.nftmint.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryParamsResponse) return object;
          var message = new $root.ununifi.nftmint.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmint.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.nftmint.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @static
         * @param {ununifi.nftmint.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.nftmint.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      nftmint.QueryClassAttributesRequest = (function () {
        /**
         * Properties of a QueryClassAttributesRequest.
         * @memberof ununifi.nftmint
         * @interface IQueryClassAttributesRequest
         * @property {string|null} [class_id] QueryClassAttributesRequest class_id
         */

        /**
         * Constructs a new QueryClassAttributesRequest.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryClassAttributesRequest.
         * @implements IQueryClassAttributesRequest
         * @constructor
         * @param {ununifi.nftmint.IQueryClassAttributesRequest=} [properties] Properties to set
         */
        function QueryClassAttributesRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryClassAttributesRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @instance
         */
        QueryClassAttributesRequest.prototype.class_id = '';

        /**
         * Encodes the specified QueryClassAttributesRequest message. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @static
         * @param {ununifi.nftmint.IQueryClassAttributesRequest} message QueryClassAttributesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassAttributesRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          return writer;
        };

        /**
         * Encodes the specified QueryClassAttributesRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @static
         * @param {ununifi.nftmint.IQueryClassAttributesRequest} message QueryClassAttributesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassAttributesRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryClassAttributesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryClassAttributesRequest} QueryClassAttributesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassAttributesRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryClassAttributesRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryClassAttributesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryClassAttributesRequest} QueryClassAttributesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassAttributesRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryClassAttributesRequest message.
         * @function verify
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryClassAttributesRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          return null;
        };

        /**
         * Creates a QueryClassAttributesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryClassAttributesRequest} QueryClassAttributesRequest
         */
        QueryClassAttributesRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryClassAttributesRequest) return object;
          var message = new $root.ununifi.nftmint.QueryClassAttributesRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryClassAttributesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @static
         * @param {ununifi.nftmint.QueryClassAttributesRequest} message QueryClassAttributesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryClassAttributesRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.class_id = '';
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          return object;
        };

        /**
         * Converts this QueryClassAttributesRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryClassAttributesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryClassAttributesRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryClassAttributesRequest;
      })();

      nftmint.QueryClassAttributesResponse = (function () {
        /**
         * Properties of a QueryClassAttributesResponse.
         * @memberof ununifi.nftmint
         * @interface IQueryClassAttributesResponse
         * @property {ununifi.nftmint.IClassAttributes|null} [class_attributes] QueryClassAttributesResponse class_attributes
         */

        /**
         * Constructs a new QueryClassAttributesResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryClassAttributesResponse.
         * @implements IQueryClassAttributesResponse
         * @constructor
         * @param {ununifi.nftmint.IQueryClassAttributesResponse=} [properties] Properties to set
         */
        function QueryClassAttributesResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryClassAttributesResponse class_attributes.
         * @member {ununifi.nftmint.IClassAttributes|null|undefined} class_attributes
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @instance
         */
        QueryClassAttributesResponse.prototype.class_attributes = null;

        /**
         * Encodes the specified QueryClassAttributesResponse message. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @static
         * @param {ununifi.nftmint.IQueryClassAttributesResponse} message QueryClassAttributesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassAttributesResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_attributes != null && Object.hasOwnProperty.call(message, 'class_attributes'))
            $root.ununifi.nftmint.ClassAttributes.encode(
              message.class_attributes,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryClassAttributesResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @static
         * @param {ununifi.nftmint.IQueryClassAttributesResponse} message QueryClassAttributesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassAttributesResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryClassAttributesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryClassAttributesResponse} QueryClassAttributesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassAttributesResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryClassAttributesResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_attributes = $root.ununifi.nftmint.ClassAttributes.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryClassAttributesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryClassAttributesResponse} QueryClassAttributesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassAttributesResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryClassAttributesResponse message.
         * @function verify
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryClassAttributesResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_attributes != null && message.hasOwnProperty('class_attributes')) {
            var error = $root.ununifi.nftmint.ClassAttributes.verify(message.class_attributes);
            if (error) return 'class_attributes.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryClassAttributesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryClassAttributesResponse} QueryClassAttributesResponse
         */
        QueryClassAttributesResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryClassAttributesResponse) return object;
          var message = new $root.ununifi.nftmint.QueryClassAttributesResponse();
          if (object.class_attributes != null) {
            if (typeof object.class_attributes !== 'object')
              throw TypeError('.ununifi.nftmint.QueryClassAttributesResponse.class_attributes: object expected');
            message.class_attributes = $root.ununifi.nftmint.ClassAttributes.fromObject(object.class_attributes);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryClassAttributesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @static
         * @param {ununifi.nftmint.QueryClassAttributesResponse} message QueryClassAttributesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryClassAttributesResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.class_attributes = null;
          if (message.class_attributes != null && message.hasOwnProperty('class_attributes'))
            object.class_attributes = $root.ununifi.nftmint.ClassAttributes.toObject(message.class_attributes, options);
          return object;
        };

        /**
         * Converts this QueryClassAttributesResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryClassAttributesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryClassAttributesResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryClassAttributesResponse;
      })();

      nftmint.QueryNFTMinterRequest = (function () {
        /**
         * Properties of a QueryNFTMinterRequest.
         * @memberof ununifi.nftmint
         * @interface IQueryNFTMinterRequest
         * @property {string|null} [class_id] QueryNFTMinterRequest class_id
         * @property {string|null} [nft_id] QueryNFTMinterRequest nft_id
         */

        /**
         * Constructs a new QueryNFTMinterRequest.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryNFTMinterRequest.
         * @implements IQueryNFTMinterRequest
         * @constructor
         * @param {ununifi.nftmint.IQueryNFTMinterRequest=} [properties] Properties to set
         */
        function QueryNFTMinterRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryNFTMinterRequest class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @instance
         */
        QueryNFTMinterRequest.prototype.class_id = '';

        /**
         * QueryNFTMinterRequest nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @instance
         */
        QueryNFTMinterRequest.prototype.nft_id = '';

        /**
         * Encodes the specified QueryNFTMinterRequest message. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @static
         * @param {ununifi.nftmint.IQueryNFTMinterRequest} message QueryNFTMinterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNFTMinterRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified QueryNFTMinterRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @static
         * @param {ununifi.nftmint.IQueryNFTMinterRequest} message QueryNFTMinterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNFTMinterRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryNFTMinterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryNFTMinterRequest} QueryNFTMinterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNFTMinterRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryNFTMinterRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryNFTMinterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryNFTMinterRequest} QueryNFTMinterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNFTMinterRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryNFTMinterRequest message.
         * @function verify
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryNFTMinterRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates a QueryNFTMinterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryNFTMinterRequest} QueryNFTMinterRequest
         */
        QueryNFTMinterRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryNFTMinterRequest) return object;
          var message = new $root.ununifi.nftmint.QueryNFTMinterRequest();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryNFTMinterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @static
         * @param {ununifi.nftmint.QueryNFTMinterRequest} message QueryNFTMinterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryNFTMinterRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this QueryNFTMinterRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryNFTMinterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryNFTMinterRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryNFTMinterRequest;
      })();

      nftmint.QueryNFTMinterResponse = (function () {
        /**
         * Properties of a QueryNFTMinterResponse.
         * @memberof ununifi.nftmint
         * @interface IQueryNFTMinterResponse
         * @property {string|null} [minter] QueryNFTMinterResponse minter
         */

        /**
         * Constructs a new QueryNFTMinterResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryNFTMinterResponse.
         * @implements IQueryNFTMinterResponse
         * @constructor
         * @param {ununifi.nftmint.IQueryNFTMinterResponse=} [properties] Properties to set
         */
        function QueryNFTMinterResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryNFTMinterResponse minter.
         * @member {string} minter
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @instance
         */
        QueryNFTMinterResponse.prototype.minter = '';

        /**
         * Encodes the specified QueryNFTMinterResponse message. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @static
         * @param {ununifi.nftmint.IQueryNFTMinterResponse} message QueryNFTMinterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNFTMinterResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.minter != null && Object.hasOwnProperty.call(message, 'minter'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.minter);
          return writer;
        };

        /**
         * Encodes the specified QueryNFTMinterResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @static
         * @param {ununifi.nftmint.IQueryNFTMinterResponse} message QueryNFTMinterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryNFTMinterResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryNFTMinterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryNFTMinterResponse} QueryNFTMinterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNFTMinterResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryNFTMinterResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.minter = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryNFTMinterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryNFTMinterResponse} QueryNFTMinterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryNFTMinterResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryNFTMinterResponse message.
         * @function verify
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryNFTMinterResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.minter != null && message.hasOwnProperty('minter'))
            if (!$util.isString(message.minter)) return 'minter: string expected';
          return null;
        };

        /**
         * Creates a QueryNFTMinterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryNFTMinterResponse} QueryNFTMinterResponse
         */
        QueryNFTMinterResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryNFTMinterResponse) return object;
          var message = new $root.ununifi.nftmint.QueryNFTMinterResponse();
          if (object.minter != null) message.minter = String(object.minter);
          return message;
        };

        /**
         * Creates a plain object from a QueryNFTMinterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @static
         * @param {ununifi.nftmint.QueryNFTMinterResponse} message QueryNFTMinterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryNFTMinterResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.minter = '';
          if (message.minter != null && message.hasOwnProperty('minter')) object.minter = message.minter;
          return object;
        };

        /**
         * Converts this QueryNFTMinterResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryNFTMinterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryNFTMinterResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryNFTMinterResponse;
      })();

      nftmint.QueryClassIdsByNameRequest = (function () {
        /**
         * Properties of a QueryClassIdsByNameRequest.
         * @memberof ununifi.nftmint
         * @interface IQueryClassIdsByNameRequest
         * @property {string|null} [class_name] QueryClassIdsByNameRequest class_name
         */

        /**
         * Constructs a new QueryClassIdsByNameRequest.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryClassIdsByNameRequest.
         * @implements IQueryClassIdsByNameRequest
         * @constructor
         * @param {ununifi.nftmint.IQueryClassIdsByNameRequest=} [properties] Properties to set
         */
        function QueryClassIdsByNameRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryClassIdsByNameRequest class_name.
         * @member {string} class_name
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @instance
         */
        QueryClassIdsByNameRequest.prototype.class_name = '';

        /**
         * Encodes the specified QueryClassIdsByNameRequest message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} message QueryClassIdsByNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByNameRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_name != null && Object.hasOwnProperty.call(message, 'class_name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_name);
          return writer;
        };

        /**
         * Encodes the specified QueryClassIdsByNameRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} message QueryClassIdsByNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryClassIdsByNameRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryClassIdsByNameRequest} QueryClassIdsByNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByNameRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryClassIdsByNameRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_name = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryClassIdsByNameRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryClassIdsByNameRequest} QueryClassIdsByNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByNameRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryClassIdsByNameRequest message.
         * @function verify
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryClassIdsByNameRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_name != null && message.hasOwnProperty('class_name'))
            if (!$util.isString(message.class_name)) return 'class_name: string expected';
          return null;
        };

        /**
         * Creates a QueryClassIdsByNameRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryClassIdsByNameRequest} QueryClassIdsByNameRequest
         */
        QueryClassIdsByNameRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryClassIdsByNameRequest) return object;
          var message = new $root.ununifi.nftmint.QueryClassIdsByNameRequest();
          if (object.class_name != null) message.class_name = String(object.class_name);
          return message;
        };

        /**
         * Creates a plain object from a QueryClassIdsByNameRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @static
         * @param {ununifi.nftmint.QueryClassIdsByNameRequest} message QueryClassIdsByNameRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryClassIdsByNameRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.class_name = '';
          if (message.class_name != null && message.hasOwnProperty('class_name')) object.class_name = message.class_name;
          return object;
        };

        /**
         * Converts this QueryClassIdsByNameRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryClassIdsByNameRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryClassIdsByNameRequest;
      })();

      nftmint.QueryClassIdsByNameResponse = (function () {
        /**
         * Properties of a QueryClassIdsByNameResponse.
         * @memberof ununifi.nftmint
         * @interface IQueryClassIdsByNameResponse
         * @property {ununifi.nftmint.IClassNameIdList|null} [class_name_id_list] QueryClassIdsByNameResponse class_name_id_list
         */

        /**
         * Constructs a new QueryClassIdsByNameResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryClassIdsByNameResponse.
         * @implements IQueryClassIdsByNameResponse
         * @constructor
         * @param {ununifi.nftmint.IQueryClassIdsByNameResponse=} [properties] Properties to set
         */
        function QueryClassIdsByNameResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryClassIdsByNameResponse class_name_id_list.
         * @member {ununifi.nftmint.IClassNameIdList|null|undefined} class_name_id_list
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @instance
         */
        QueryClassIdsByNameResponse.prototype.class_name_id_list = null;

        /**
         * Encodes the specified QueryClassIdsByNameResponse message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByNameResponse} message QueryClassIdsByNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByNameResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_name_id_list != null && Object.hasOwnProperty.call(message, 'class_name_id_list'))
            $root.ununifi.nftmint.ClassNameIdList.encode(
              message.class_name_id_list,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryClassIdsByNameResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByNameResponse} message QueryClassIdsByNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryClassIdsByNameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryClassIdsByNameResponse} QueryClassIdsByNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByNameResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryClassIdsByNameResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_name_id_list = $root.ununifi.nftmint.ClassNameIdList.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryClassIdsByNameResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryClassIdsByNameResponse} QueryClassIdsByNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByNameResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryClassIdsByNameResponse message.
         * @function verify
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryClassIdsByNameResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_name_id_list != null && message.hasOwnProperty('class_name_id_list')) {
            var error = $root.ununifi.nftmint.ClassNameIdList.verify(message.class_name_id_list);
            if (error) return 'class_name_id_list.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryClassIdsByNameResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryClassIdsByNameResponse} QueryClassIdsByNameResponse
         */
        QueryClassIdsByNameResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryClassIdsByNameResponse) return object;
          var message = new $root.ununifi.nftmint.QueryClassIdsByNameResponse();
          if (object.class_name_id_list != null) {
            if (typeof object.class_name_id_list !== 'object')
              throw TypeError('.ununifi.nftmint.QueryClassIdsByNameResponse.class_name_id_list: object expected');
            message.class_name_id_list = $root.ununifi.nftmint.ClassNameIdList.fromObject(object.class_name_id_list);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryClassIdsByNameResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @static
         * @param {ununifi.nftmint.QueryClassIdsByNameResponse} message QueryClassIdsByNameResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryClassIdsByNameResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.class_name_id_list = null;
          if (message.class_name_id_list != null && message.hasOwnProperty('class_name_id_list'))
            object.class_name_id_list = $root.ununifi.nftmint.ClassNameIdList.toObject(message.class_name_id_list, options);
          return object;
        };

        /**
         * Converts this QueryClassIdsByNameResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryClassIdsByNameResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryClassIdsByNameResponse;
      })();

      nftmint.QueryClassIdsByOwnerRequest = (function () {
        /**
         * Properties of a QueryClassIdsByOwnerRequest.
         * @memberof ununifi.nftmint
         * @interface IQueryClassIdsByOwnerRequest
         * @property {string|null} [owner] QueryClassIdsByOwnerRequest owner
         */

        /**
         * Constructs a new QueryClassIdsByOwnerRequest.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryClassIdsByOwnerRequest.
         * @implements IQueryClassIdsByOwnerRequest
         * @constructor
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest=} [properties] Properties to set
         */
        function QueryClassIdsByOwnerRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryClassIdsByOwnerRequest owner.
         * @member {string} owner
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @instance
         */
        QueryClassIdsByOwnerRequest.prototype.owner = '';

        /**
         * Encodes the specified QueryClassIdsByOwnerRequest message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} message QueryClassIdsByOwnerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByOwnerRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          return writer;
        };

        /**
         * Encodes the specified QueryClassIdsByOwnerRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} message QueryClassIdsByOwnerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByOwnerRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryClassIdsByOwnerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryClassIdsByOwnerRequest} QueryClassIdsByOwnerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByOwnerRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryClassIdsByOwnerRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryClassIdsByOwnerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryClassIdsByOwnerRequest} QueryClassIdsByOwnerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByOwnerRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryClassIdsByOwnerRequest message.
         * @function verify
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryClassIdsByOwnerRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          return null;
        };

        /**
         * Creates a QueryClassIdsByOwnerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryClassIdsByOwnerRequest} QueryClassIdsByOwnerRequest
         */
        QueryClassIdsByOwnerRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryClassIdsByOwnerRequest) return object;
          var message = new $root.ununifi.nftmint.QueryClassIdsByOwnerRequest();
          if (object.owner != null) message.owner = String(object.owner);
          return message;
        };

        /**
         * Creates a plain object from a QueryClassIdsByOwnerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @static
         * @param {ununifi.nftmint.QueryClassIdsByOwnerRequest} message QueryClassIdsByOwnerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryClassIdsByOwnerRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.owner = '';
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          return object;
        };

        /**
         * Converts this QueryClassIdsByOwnerRequest to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryClassIdsByOwnerRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryClassIdsByOwnerRequest;
      })();

      nftmint.QueryClassIdsByOwnerResponse = (function () {
        /**
         * Properties of a QueryClassIdsByOwnerResponse.
         * @memberof ununifi.nftmint
         * @interface IQueryClassIdsByOwnerResponse
         * @property {ununifi.nftmint.IOwningClassIdList|null} [owning_class_id_list] QueryClassIdsByOwnerResponse owning_class_id_list
         */

        /**
         * Constructs a new QueryClassIdsByOwnerResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a QueryClassIdsByOwnerResponse.
         * @implements IQueryClassIdsByOwnerResponse
         * @constructor
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerResponse=} [properties] Properties to set
         */
        function QueryClassIdsByOwnerResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryClassIdsByOwnerResponse owning_class_id_list.
         * @member {ununifi.nftmint.IOwningClassIdList|null|undefined} owning_class_id_list
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @instance
         */
        QueryClassIdsByOwnerResponse.prototype.owning_class_id_list = null;

        /**
         * Encodes the specified QueryClassIdsByOwnerResponse message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerResponse} message QueryClassIdsByOwnerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByOwnerResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owning_class_id_list != null && Object.hasOwnProperty.call(message, 'owning_class_id_list'))
            $root.ununifi.nftmint.OwningClassIdList.encode(
              message.owning_class_id_list,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryClassIdsByOwnerResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @static
         * @param {ununifi.nftmint.IQueryClassIdsByOwnerResponse} message QueryClassIdsByOwnerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryClassIdsByOwnerResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryClassIdsByOwnerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.QueryClassIdsByOwnerResponse} QueryClassIdsByOwnerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByOwnerResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.QueryClassIdsByOwnerResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owning_class_id_list = $root.ununifi.nftmint.OwningClassIdList.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryClassIdsByOwnerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.QueryClassIdsByOwnerResponse} QueryClassIdsByOwnerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryClassIdsByOwnerResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryClassIdsByOwnerResponse message.
         * @function verify
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryClassIdsByOwnerResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owning_class_id_list != null && message.hasOwnProperty('owning_class_id_list')) {
            var error = $root.ununifi.nftmint.OwningClassIdList.verify(message.owning_class_id_list);
            if (error) return 'owning_class_id_list.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryClassIdsByOwnerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.QueryClassIdsByOwnerResponse} QueryClassIdsByOwnerResponse
         */
        QueryClassIdsByOwnerResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.QueryClassIdsByOwnerResponse) return object;
          var message = new $root.ununifi.nftmint.QueryClassIdsByOwnerResponse();
          if (object.owning_class_id_list != null) {
            if (typeof object.owning_class_id_list !== 'object')
              throw TypeError('.ununifi.nftmint.QueryClassIdsByOwnerResponse.owning_class_id_list: object expected');
            message.owning_class_id_list = $root.ununifi.nftmint.OwningClassIdList.fromObject(object.owning_class_id_list);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryClassIdsByOwnerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @static
         * @param {ununifi.nftmint.QueryClassIdsByOwnerResponse} message QueryClassIdsByOwnerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryClassIdsByOwnerResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.owning_class_id_list = null;
          if (message.owning_class_id_list != null && message.hasOwnProperty('owning_class_id_list'))
            object.owning_class_id_list = $root.ununifi.nftmint.OwningClassIdList.toObject(message.owning_class_id_list, options);
          return object;
        };

        /**
         * Converts this QueryClassIdsByOwnerResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryClassIdsByOwnerResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryClassIdsByOwnerResponse;
      })();

      /**
       * MintingPermission enum.
       * @name ununifi.nftmint.MintingPermission
       * @enum {number}
       * @property {number} OnlyOwner=0 OnlyOwner value
       * @property {number} Anyone=1 Anyone value
       */
      nftmint.MintingPermission = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'OnlyOwner')] = 0;
        values[(valuesById[1] = 'Anyone')] = 1;
        return values;
      })();

      nftmint.ClassAttributes = (function () {
        /**
         * Properties of a ClassAttributes.
         * @memberof ununifi.nftmint
         * @interface IClassAttributes
         * @property {string|null} [class_id] ClassAttributes class_id
         * @property {string|null} [owner] ClassAttributes owner
         * @property {string|null} [base_token_uri] ClassAttributes base_token_uri
         * @property {ununifi.nftmint.MintingPermission|null} [minting_permission] ClassAttributes minting_permission
         * @property {Long|null} [token_supply_cap] ClassAttributes token_supply_cap
         */

        /**
         * Constructs a new ClassAttributes.
         * @memberof ununifi.nftmint
         * @classdesc Represents a ClassAttributes.
         * @implements IClassAttributes
         * @constructor
         * @param {ununifi.nftmint.IClassAttributes=} [properties] Properties to set
         */
        function ClassAttributes(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClassAttributes class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.ClassAttributes
         * @instance
         */
        ClassAttributes.prototype.class_id = '';

        /**
         * ClassAttributes owner.
         * @member {string} owner
         * @memberof ununifi.nftmint.ClassAttributes
         * @instance
         */
        ClassAttributes.prototype.owner = '';

        /**
         * ClassAttributes base_token_uri.
         * @member {string} base_token_uri
         * @memberof ununifi.nftmint.ClassAttributes
         * @instance
         */
        ClassAttributes.prototype.base_token_uri = '';

        /**
         * ClassAttributes minting_permission.
         * @member {ununifi.nftmint.MintingPermission} minting_permission
         * @memberof ununifi.nftmint.ClassAttributes
         * @instance
         */
        ClassAttributes.prototype.minting_permission = 0;

        /**
         * ClassAttributes token_supply_cap.
         * @member {Long} token_supply_cap
         * @memberof ununifi.nftmint.ClassAttributes
         * @instance
         */
        ClassAttributes.prototype.token_supply_cap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified ClassAttributes message. Does not implicitly {@link ununifi.nftmint.ClassAttributes.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.ClassAttributes
         * @static
         * @param {ununifi.nftmint.IClassAttributes} message ClassAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClassAttributes.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
          if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
          if (message.minting_permission != null && Object.hasOwnProperty.call(message, 'minting_permission'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.minting_permission);
          if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.token_supply_cap);
          return writer;
        };

        /**
         * Encodes the specified ClassAttributes message, length delimited. Does not implicitly {@link ununifi.nftmint.ClassAttributes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.ClassAttributes
         * @static
         * @param {ununifi.nftmint.IClassAttributes} message ClassAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClassAttributes.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClassAttributes message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.ClassAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.ClassAttributes} ClassAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClassAttributes.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.ClassAttributes();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.owner = reader.string();
                break;
              case 3:
                message.base_token_uri = reader.string();
                break;
              case 4:
                message.minting_permission = reader.int32();
                break;
              case 5:
                message.token_supply_cap = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ClassAttributes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.ClassAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.ClassAttributes} ClassAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClassAttributes.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClassAttributes message.
         * @function verify
         * @memberof ununifi.nftmint.ClassAttributes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClassAttributes.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
            if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
          if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
            switch (message.minting_permission) {
              default:
                return 'minting_permission: enum value expected';
              case 0:
              case 1:
                break;
            }
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (
              !$util.isInteger(message.token_supply_cap) &&
              !(message.token_supply_cap && $util.isInteger(message.token_supply_cap.low) && $util.isInteger(message.token_supply_cap.high))
            )
              return 'token_supply_cap: integer|Long expected';
          return null;
        };

        /**
         * Creates a ClassAttributes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.ClassAttributes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.ClassAttributes} ClassAttributes
         */
        ClassAttributes.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.ClassAttributes) return object;
          var message = new $root.ununifi.nftmint.ClassAttributes();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.owner != null) message.owner = String(object.owner);
          if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
          switch (object.minting_permission) {
            case 'OnlyOwner':
            case 0:
              message.minting_permission = 0;
              break;
            case 'Anyone':
            case 1:
              message.minting_permission = 1;
              break;
          }
          if (object.token_supply_cap != null)
            if ($util.Long) (message.token_supply_cap = $util.Long.fromValue(object.token_supply_cap)).unsigned = true;
            else if (typeof object.token_supply_cap === 'string') message.token_supply_cap = parseInt(object.token_supply_cap, 10);
            else if (typeof object.token_supply_cap === 'number') message.token_supply_cap = object.token_supply_cap;
            else if (typeof object.token_supply_cap === 'object')
              message.token_supply_cap = new $util.LongBits(object.token_supply_cap.low >>> 0, object.token_supply_cap.high >>> 0).toNumber(
                true,
              );
          return message;
        };

        /**
         * Creates a plain object from a ClassAttributes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.ClassAttributes
         * @static
         * @param {ununifi.nftmint.ClassAttributes} message ClassAttributes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClassAttributes.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.owner = '';
            object.base_token_uri = '';
            object.minting_permission = options.enums === String ? 'OnlyOwner' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.token_supply_cap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.token_supply_cap = options.longs === String ? '0' : 0;
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
          if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
            object.minting_permission =
              options.enums === String ? $root.ununifi.nftmint.MintingPermission[message.minting_permission] : message.minting_permission;
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (typeof message.token_supply_cap === 'number')
              object.token_supply_cap = options.longs === String ? String(message.token_supply_cap) : message.token_supply_cap;
            else
              object.token_supply_cap =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.token_supply_cap)
                  : options.longs === Number
                  ? new $util.LongBits(message.token_supply_cap.low >>> 0, message.token_supply_cap.high >>> 0).toNumber(true)
                  : message.token_supply_cap;
          return object;
        };

        /**
         * Converts this ClassAttributes to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.ClassAttributes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClassAttributes.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClassAttributes;
      })();

      nftmint.OwningClassIdList = (function () {
        /**
         * Properties of an OwningClassIdList.
         * @memberof ununifi.nftmint
         * @interface IOwningClassIdList
         * @property {string|null} [owner] OwningClassIdList owner
         * @property {Array.<string>|null} [class_id] OwningClassIdList class_id
         */

        /**
         * Constructs a new OwningClassIdList.
         * @memberof ununifi.nftmint
         * @classdesc Represents an OwningClassIdList.
         * @implements IOwningClassIdList
         * @constructor
         * @param {ununifi.nftmint.IOwningClassIdList=} [properties] Properties to set
         */
        function OwningClassIdList(properties) {
          this.class_id = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * OwningClassIdList owner.
         * @member {string} owner
         * @memberof ununifi.nftmint.OwningClassIdList
         * @instance
         */
        OwningClassIdList.prototype.owner = '';

        /**
         * OwningClassIdList class_id.
         * @member {Array.<string>} class_id
         * @memberof ununifi.nftmint.OwningClassIdList
         * @instance
         */
        OwningClassIdList.prototype.class_id = $util.emptyArray;

        /**
         * Encodes the specified OwningClassIdList message. Does not implicitly {@link ununifi.nftmint.OwningClassIdList.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.OwningClassIdList
         * @static
         * @param {ununifi.nftmint.IOwningClassIdList} message OwningClassIdList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwningClassIdList.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && message.class_id.length)
            for (var i = 0; i < message.class_id.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id[i]);
          return writer;
        };

        /**
         * Encodes the specified OwningClassIdList message, length delimited. Does not implicitly {@link ununifi.nftmint.OwningClassIdList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.OwningClassIdList
         * @static
         * @param {ununifi.nftmint.IOwningClassIdList} message OwningClassIdList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwningClassIdList.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OwningClassIdList message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.OwningClassIdList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.OwningClassIdList} OwningClassIdList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwningClassIdList.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.OwningClassIdList();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                if (!(message.class_id && message.class_id.length)) message.class_id = [];
                message.class_id.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an OwningClassIdList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.OwningClassIdList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.OwningClassIdList} OwningClassIdList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwningClassIdList.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OwningClassIdList message.
         * @function verify
         * @memberof ununifi.nftmint.OwningClassIdList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OwningClassIdList.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id')) {
            if (!Array.isArray(message.class_id)) return 'class_id: array expected';
            for (var i = 0; i < message.class_id.length; ++i)
              if (!$util.isString(message.class_id[i])) return 'class_id: string[] expected';
          }
          return null;
        };

        /**
         * Creates an OwningClassIdList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.OwningClassIdList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.OwningClassIdList} OwningClassIdList
         */
        OwningClassIdList.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.OwningClassIdList) return object;
          var message = new $root.ununifi.nftmint.OwningClassIdList();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id) {
            if (!Array.isArray(object.class_id)) throw TypeError('.ununifi.nftmint.OwningClassIdList.class_id: array expected');
            message.class_id = [];
            for (var i = 0; i < object.class_id.length; ++i) message.class_id[i] = String(object.class_id[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from an OwningClassIdList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.OwningClassIdList
         * @static
         * @param {ununifi.nftmint.OwningClassIdList} message OwningClassIdList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OwningClassIdList.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.class_id = [];
          if (options.defaults) object.owner = '';
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id && message.class_id.length) {
            object.class_id = [];
            for (var j = 0; j < message.class_id.length; ++j) object.class_id[j] = message.class_id[j];
          }
          return object;
        };

        /**
         * Converts this OwningClassIdList to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.OwningClassIdList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OwningClassIdList.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OwningClassIdList;
      })();

      nftmint.ClassNameIdList = (function () {
        /**
         * Properties of a ClassNameIdList.
         * @memberof ununifi.nftmint
         * @interface IClassNameIdList
         * @property {string|null} [class_name] ClassNameIdList class_name
         * @property {Array.<string>|null} [class_id] ClassNameIdList class_id
         */

        /**
         * Constructs a new ClassNameIdList.
         * @memberof ununifi.nftmint
         * @classdesc Represents a ClassNameIdList.
         * @implements IClassNameIdList
         * @constructor
         * @param {ununifi.nftmint.IClassNameIdList=} [properties] Properties to set
         */
        function ClassNameIdList(properties) {
          this.class_id = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClassNameIdList class_name.
         * @member {string} class_name
         * @memberof ununifi.nftmint.ClassNameIdList
         * @instance
         */
        ClassNameIdList.prototype.class_name = '';

        /**
         * ClassNameIdList class_id.
         * @member {Array.<string>} class_id
         * @memberof ununifi.nftmint.ClassNameIdList
         * @instance
         */
        ClassNameIdList.prototype.class_id = $util.emptyArray;

        /**
         * Encodes the specified ClassNameIdList message. Does not implicitly {@link ununifi.nftmint.ClassNameIdList.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.ClassNameIdList
         * @static
         * @param {ununifi.nftmint.IClassNameIdList} message ClassNameIdList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClassNameIdList.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_name != null && Object.hasOwnProperty.call(message, 'class_name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_name);
          if (message.class_id != null && message.class_id.length)
            for (var i = 0; i < message.class_id.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id[i]);
          return writer;
        };

        /**
         * Encodes the specified ClassNameIdList message, length delimited. Does not implicitly {@link ununifi.nftmint.ClassNameIdList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.ClassNameIdList
         * @static
         * @param {ununifi.nftmint.IClassNameIdList} message ClassNameIdList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClassNameIdList.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClassNameIdList message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.ClassNameIdList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.ClassNameIdList} ClassNameIdList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClassNameIdList.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.ClassNameIdList();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_name = reader.string();
                break;
              case 2:
                if (!(message.class_id && message.class_id.length)) message.class_id = [];
                message.class_id.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ClassNameIdList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.ClassNameIdList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.ClassNameIdList} ClassNameIdList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClassNameIdList.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClassNameIdList message.
         * @function verify
         * @memberof ununifi.nftmint.ClassNameIdList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClassNameIdList.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_name != null && message.hasOwnProperty('class_name'))
            if (!$util.isString(message.class_name)) return 'class_name: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id')) {
            if (!Array.isArray(message.class_id)) return 'class_id: array expected';
            for (var i = 0; i < message.class_id.length; ++i)
              if (!$util.isString(message.class_id[i])) return 'class_id: string[] expected';
          }
          return null;
        };

        /**
         * Creates a ClassNameIdList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.ClassNameIdList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.ClassNameIdList} ClassNameIdList
         */
        ClassNameIdList.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.ClassNameIdList) return object;
          var message = new $root.ununifi.nftmint.ClassNameIdList();
          if (object.class_name != null) message.class_name = String(object.class_name);
          if (object.class_id) {
            if (!Array.isArray(object.class_id)) throw TypeError('.ununifi.nftmint.ClassNameIdList.class_id: array expected');
            message.class_id = [];
            for (var i = 0; i < object.class_id.length; ++i) message.class_id[i] = String(object.class_id[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a ClassNameIdList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.ClassNameIdList
         * @static
         * @param {ununifi.nftmint.ClassNameIdList} message ClassNameIdList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClassNameIdList.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.class_id = [];
          if (options.defaults) object.class_name = '';
          if (message.class_name != null && message.hasOwnProperty('class_name')) object.class_name = message.class_name;
          if (message.class_id && message.class_id.length) {
            object.class_id = [];
            for (var j = 0; j < message.class_id.length; ++j) object.class_id[j] = message.class_id[j];
          }
          return object;
        };

        /**
         * Converts this ClassNameIdList to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.ClassNameIdList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClassNameIdList.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClassNameIdList;
      })();

      nftmint.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.nftmint
         * @interface IParams
         * @property {Long|null} [MaxNFTSupplyCap] Params MaxNFTSupplyCap
         * @property {Long|null} [MinClassNameLen] Params MinClassNameLen
         * @property {Long|null} [MaxClassNameLen] Params MaxClassNameLen
         * @property {Long|null} [MinUriLen] Params MinUriLen
         * @property {Long|null} [MaxUriLen] Params MaxUriLen
         * @property {Long|null} [MaxSymbolLen] Params MaxSymbolLen
         * @property {Long|null} [MaxDescriptionLen] Params MaxDescriptionLen
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.nftmint
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.nftmint.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params MaxNFTSupplyCap.
         * @member {Long} MaxNFTSupplyCap
         * @memberof ununifi.nftmint.Params
         * @instance
         */
        Params.prototype.MaxNFTSupplyCap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params MinClassNameLen.
         * @member {Long} MinClassNameLen
         * @memberof ununifi.nftmint.Params
         * @instance
         */
        Params.prototype.MinClassNameLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params MaxClassNameLen.
         * @member {Long} MaxClassNameLen
         * @memberof ununifi.nftmint.Params
         * @instance
         */
        Params.prototype.MaxClassNameLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params MinUriLen.
         * @member {Long} MinUriLen
         * @memberof ununifi.nftmint.Params
         * @instance
         */
        Params.prototype.MinUriLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params MaxUriLen.
         * @member {Long} MaxUriLen
         * @memberof ununifi.nftmint.Params
         * @instance
         */
        Params.prototype.MaxUriLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params MaxSymbolLen.
         * @member {Long} MaxSymbolLen
         * @memberof ununifi.nftmint.Params
         * @instance
         */
        Params.prototype.MaxSymbolLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Params MaxDescriptionLen.
         * @member {Long} MaxDescriptionLen
         * @memberof ununifi.nftmint.Params
         * @instance
         */
        Params.prototype.MaxDescriptionLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.nftmint.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.Params
         * @static
         * @param {ununifi.nftmint.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.MaxNFTSupplyCap != null && Object.hasOwnProperty.call(message, 'MaxNFTSupplyCap'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.MaxNFTSupplyCap);
          if (message.MinClassNameLen != null && Object.hasOwnProperty.call(message, 'MinClassNameLen'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.MinClassNameLen);
          if (message.MaxClassNameLen != null && Object.hasOwnProperty.call(message, 'MaxClassNameLen'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.MaxClassNameLen);
          if (message.MinUriLen != null && Object.hasOwnProperty.call(message, 'MinUriLen'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.MinUriLen);
          if (message.MaxUriLen != null && Object.hasOwnProperty.call(message, 'MaxUriLen'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.MaxUriLen);
          if (message.MaxSymbolLen != null && Object.hasOwnProperty.call(message, 'MaxSymbolLen'))
            writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.MaxSymbolLen);
          if (message.MaxDescriptionLen != null && Object.hasOwnProperty.call(message, 'MaxDescriptionLen'))
            writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.MaxDescriptionLen);
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftmint.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.Params
         * @static
         * @param {ununifi.nftmint.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.MaxNFTSupplyCap = reader.uint64();
                break;
              case 2:
                message.MinClassNameLen = reader.uint64();
                break;
              case 3:
                message.MaxClassNameLen = reader.uint64();
                break;
              case 4:
                message.MinUriLen = reader.uint64();
                break;
              case 5:
                message.MaxUriLen = reader.uint64();
                break;
              case 6:
                message.MaxSymbolLen = reader.uint64();
                break;
              case 7:
                message.MaxDescriptionLen = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.nftmint.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.MaxNFTSupplyCap != null && message.hasOwnProperty('MaxNFTSupplyCap'))
            if (
              !$util.isInteger(message.MaxNFTSupplyCap) &&
              !(message.MaxNFTSupplyCap && $util.isInteger(message.MaxNFTSupplyCap.low) && $util.isInteger(message.MaxNFTSupplyCap.high))
            )
              return 'MaxNFTSupplyCap: integer|Long expected';
          if (message.MinClassNameLen != null && message.hasOwnProperty('MinClassNameLen'))
            if (
              !$util.isInteger(message.MinClassNameLen) &&
              !(message.MinClassNameLen && $util.isInteger(message.MinClassNameLen.low) && $util.isInteger(message.MinClassNameLen.high))
            )
              return 'MinClassNameLen: integer|Long expected';
          if (message.MaxClassNameLen != null && message.hasOwnProperty('MaxClassNameLen'))
            if (
              !$util.isInteger(message.MaxClassNameLen) &&
              !(message.MaxClassNameLen && $util.isInteger(message.MaxClassNameLen.low) && $util.isInteger(message.MaxClassNameLen.high))
            )
              return 'MaxClassNameLen: integer|Long expected';
          if (message.MinUriLen != null && message.hasOwnProperty('MinUriLen'))
            if (
              !$util.isInteger(message.MinUriLen) &&
              !(message.MinUriLen && $util.isInteger(message.MinUriLen.low) && $util.isInteger(message.MinUriLen.high))
            )
              return 'MinUriLen: integer|Long expected';
          if (message.MaxUriLen != null && message.hasOwnProperty('MaxUriLen'))
            if (
              !$util.isInteger(message.MaxUriLen) &&
              !(message.MaxUriLen && $util.isInteger(message.MaxUriLen.low) && $util.isInteger(message.MaxUriLen.high))
            )
              return 'MaxUriLen: integer|Long expected';
          if (message.MaxSymbolLen != null && message.hasOwnProperty('MaxSymbolLen'))
            if (
              !$util.isInteger(message.MaxSymbolLen) &&
              !(message.MaxSymbolLen && $util.isInteger(message.MaxSymbolLen.low) && $util.isInteger(message.MaxSymbolLen.high))
            )
              return 'MaxSymbolLen: integer|Long expected';
          if (message.MaxDescriptionLen != null && message.hasOwnProperty('MaxDescriptionLen'))
            if (
              !$util.isInteger(message.MaxDescriptionLen) &&
              !(
                message.MaxDescriptionLen &&
                $util.isInteger(message.MaxDescriptionLen.low) &&
                $util.isInteger(message.MaxDescriptionLen.high)
              )
            )
              return 'MaxDescriptionLen: integer|Long expected';
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.Params) return object;
          var message = new $root.ununifi.nftmint.Params();
          if (object.MaxNFTSupplyCap != null)
            if ($util.Long) (message.MaxNFTSupplyCap = $util.Long.fromValue(object.MaxNFTSupplyCap)).unsigned = true;
            else if (typeof object.MaxNFTSupplyCap === 'string') message.MaxNFTSupplyCap = parseInt(object.MaxNFTSupplyCap, 10);
            else if (typeof object.MaxNFTSupplyCap === 'number') message.MaxNFTSupplyCap = object.MaxNFTSupplyCap;
            else if (typeof object.MaxNFTSupplyCap === 'object')
              message.MaxNFTSupplyCap = new $util.LongBits(object.MaxNFTSupplyCap.low >>> 0, object.MaxNFTSupplyCap.high >>> 0).toNumber(
                true,
              );
          if (object.MinClassNameLen != null)
            if ($util.Long) (message.MinClassNameLen = $util.Long.fromValue(object.MinClassNameLen)).unsigned = true;
            else if (typeof object.MinClassNameLen === 'string') message.MinClassNameLen = parseInt(object.MinClassNameLen, 10);
            else if (typeof object.MinClassNameLen === 'number') message.MinClassNameLen = object.MinClassNameLen;
            else if (typeof object.MinClassNameLen === 'object')
              message.MinClassNameLen = new $util.LongBits(object.MinClassNameLen.low >>> 0, object.MinClassNameLen.high >>> 0).toNumber(
                true,
              );
          if (object.MaxClassNameLen != null)
            if ($util.Long) (message.MaxClassNameLen = $util.Long.fromValue(object.MaxClassNameLen)).unsigned = true;
            else if (typeof object.MaxClassNameLen === 'string') message.MaxClassNameLen = parseInt(object.MaxClassNameLen, 10);
            else if (typeof object.MaxClassNameLen === 'number') message.MaxClassNameLen = object.MaxClassNameLen;
            else if (typeof object.MaxClassNameLen === 'object')
              message.MaxClassNameLen = new $util.LongBits(object.MaxClassNameLen.low >>> 0, object.MaxClassNameLen.high >>> 0).toNumber(
                true,
              );
          if (object.MinUriLen != null)
            if ($util.Long) (message.MinUriLen = $util.Long.fromValue(object.MinUriLen)).unsigned = true;
            else if (typeof object.MinUriLen === 'string') message.MinUriLen = parseInt(object.MinUriLen, 10);
            else if (typeof object.MinUriLen === 'number') message.MinUriLen = object.MinUriLen;
            else if (typeof object.MinUriLen === 'object')
              message.MinUriLen = new $util.LongBits(object.MinUriLen.low >>> 0, object.MinUriLen.high >>> 0).toNumber(true);
          if (object.MaxUriLen != null)
            if ($util.Long) (message.MaxUriLen = $util.Long.fromValue(object.MaxUriLen)).unsigned = true;
            else if (typeof object.MaxUriLen === 'string') message.MaxUriLen = parseInt(object.MaxUriLen, 10);
            else if (typeof object.MaxUriLen === 'number') message.MaxUriLen = object.MaxUriLen;
            else if (typeof object.MaxUriLen === 'object')
              message.MaxUriLen = new $util.LongBits(object.MaxUriLen.low >>> 0, object.MaxUriLen.high >>> 0).toNumber(true);
          if (object.MaxSymbolLen != null)
            if ($util.Long) (message.MaxSymbolLen = $util.Long.fromValue(object.MaxSymbolLen)).unsigned = true;
            else if (typeof object.MaxSymbolLen === 'string') message.MaxSymbolLen = parseInt(object.MaxSymbolLen, 10);
            else if (typeof object.MaxSymbolLen === 'number') message.MaxSymbolLen = object.MaxSymbolLen;
            else if (typeof object.MaxSymbolLen === 'object')
              message.MaxSymbolLen = new $util.LongBits(object.MaxSymbolLen.low >>> 0, object.MaxSymbolLen.high >>> 0).toNumber(true);
          if (object.MaxDescriptionLen != null)
            if ($util.Long) (message.MaxDescriptionLen = $util.Long.fromValue(object.MaxDescriptionLen)).unsigned = true;
            else if (typeof object.MaxDescriptionLen === 'string') message.MaxDescriptionLen = parseInt(object.MaxDescriptionLen, 10);
            else if (typeof object.MaxDescriptionLen === 'number') message.MaxDescriptionLen = object.MaxDescriptionLen;
            else if (typeof object.MaxDescriptionLen === 'object')
              message.MaxDescriptionLen = new $util.LongBits(
                object.MaxDescriptionLen.low >>> 0,
                object.MaxDescriptionLen.high >>> 0,
              ).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.Params
         * @static
         * @param {ununifi.nftmint.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.MaxNFTSupplyCap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.MaxNFTSupplyCap = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.MinClassNameLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.MinClassNameLen = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.MaxClassNameLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.MaxClassNameLen = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.MinUriLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.MinUriLen = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.MaxUriLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.MaxUriLen = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.MaxSymbolLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.MaxSymbolLen = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.MaxDescriptionLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.MaxDescriptionLen = options.longs === String ? '0' : 0;
          }
          if (message.MaxNFTSupplyCap != null && message.hasOwnProperty('MaxNFTSupplyCap'))
            if (typeof message.MaxNFTSupplyCap === 'number')
              object.MaxNFTSupplyCap = options.longs === String ? String(message.MaxNFTSupplyCap) : message.MaxNFTSupplyCap;
            else
              object.MaxNFTSupplyCap =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.MaxNFTSupplyCap)
                  : options.longs === Number
                  ? new $util.LongBits(message.MaxNFTSupplyCap.low >>> 0, message.MaxNFTSupplyCap.high >>> 0).toNumber(true)
                  : message.MaxNFTSupplyCap;
          if (message.MinClassNameLen != null && message.hasOwnProperty('MinClassNameLen'))
            if (typeof message.MinClassNameLen === 'number')
              object.MinClassNameLen = options.longs === String ? String(message.MinClassNameLen) : message.MinClassNameLen;
            else
              object.MinClassNameLen =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.MinClassNameLen)
                  : options.longs === Number
                  ? new $util.LongBits(message.MinClassNameLen.low >>> 0, message.MinClassNameLen.high >>> 0).toNumber(true)
                  : message.MinClassNameLen;
          if (message.MaxClassNameLen != null && message.hasOwnProperty('MaxClassNameLen'))
            if (typeof message.MaxClassNameLen === 'number')
              object.MaxClassNameLen = options.longs === String ? String(message.MaxClassNameLen) : message.MaxClassNameLen;
            else
              object.MaxClassNameLen =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.MaxClassNameLen)
                  : options.longs === Number
                  ? new $util.LongBits(message.MaxClassNameLen.low >>> 0, message.MaxClassNameLen.high >>> 0).toNumber(true)
                  : message.MaxClassNameLen;
          if (message.MinUriLen != null && message.hasOwnProperty('MinUriLen'))
            if (typeof message.MinUriLen === 'number')
              object.MinUriLen = options.longs === String ? String(message.MinUriLen) : message.MinUriLen;
            else
              object.MinUriLen =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.MinUriLen)
                  : options.longs === Number
                  ? new $util.LongBits(message.MinUriLen.low >>> 0, message.MinUriLen.high >>> 0).toNumber(true)
                  : message.MinUriLen;
          if (message.MaxUriLen != null && message.hasOwnProperty('MaxUriLen'))
            if (typeof message.MaxUriLen === 'number')
              object.MaxUriLen = options.longs === String ? String(message.MaxUriLen) : message.MaxUriLen;
            else
              object.MaxUriLen =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.MaxUriLen)
                  : options.longs === Number
                  ? new $util.LongBits(message.MaxUriLen.low >>> 0, message.MaxUriLen.high >>> 0).toNumber(true)
                  : message.MaxUriLen;
          if (message.MaxSymbolLen != null && message.hasOwnProperty('MaxSymbolLen'))
            if (typeof message.MaxSymbolLen === 'number')
              object.MaxSymbolLen = options.longs === String ? String(message.MaxSymbolLen) : message.MaxSymbolLen;
            else
              object.MaxSymbolLen =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.MaxSymbolLen)
                  : options.longs === Number
                  ? new $util.LongBits(message.MaxSymbolLen.low >>> 0, message.MaxSymbolLen.high >>> 0).toNumber(true)
                  : message.MaxSymbolLen;
          if (message.MaxDescriptionLen != null && message.hasOwnProperty('MaxDescriptionLen'))
            if (typeof message.MaxDescriptionLen === 'number')
              object.MaxDescriptionLen = options.longs === String ? String(message.MaxDescriptionLen) : message.MaxDescriptionLen;
            else
              object.MaxDescriptionLen =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.MaxDescriptionLen)
                  : options.longs === Number
                  ? new $util.LongBits(message.MaxDescriptionLen.low >>> 0, message.MaxDescriptionLen.high >>> 0).toNumber(true)
                  : message.MaxDescriptionLen;
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      nftmint.Msg = (function () {
        /**
         * Constructs a new Msg service.
         * @memberof ununifi.nftmint
         * @classdesc Represents a Msg
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Msg(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

        /**
         * Callback as used by {@link ununifi.nftmint.Msg#createClass}.
         * @memberof ununifi.nftmint.Msg
         * @typedef CreateClassCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.MsgCreateClassResponse} [response] MsgCreateClassResponse
         */

        /**
         * Calls CreateClass.
         * @function createClass
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgCreateClass} request MsgCreateClass message or plain object
         * @param {ununifi.nftmint.Msg.CreateClassCallback} callback Node-style callback called with the error, if any, and MsgCreateClassResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.createClass = function createClass(request, callback) {
            return this.rpcCall(
              createClass,
              $root.ununifi.nftmint.MsgCreateClass,
              $root.ununifi.nftmint.MsgCreateClassResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'CreateClass' },
        );

        /**
         * Calls CreateClass.
         * @function createClass
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgCreateClass} request MsgCreateClass message or plain object
         * @returns {Promise<ununifi.nftmint.MsgCreateClassResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Msg#sendClassOwnership}.
         * @memberof ununifi.nftmint.Msg
         * @typedef SendClassOwnershipCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.MsgSendClassOwnershipResponse} [response] MsgSendClassOwnershipResponse
         */

        /**
         * Calls SendClassOwnership.
         * @function sendClassOwnership
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgSendClassOwnership} request MsgSendClassOwnership message or plain object
         * @param {ununifi.nftmint.Msg.SendClassOwnershipCallback} callback Node-style callback called with the error, if any, and MsgSendClassOwnershipResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.sendClassOwnership = function sendClassOwnership(request, callback) {
            return this.rpcCall(
              sendClassOwnership,
              $root.ununifi.nftmint.MsgSendClassOwnership,
              $root.ununifi.nftmint.MsgSendClassOwnershipResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'SendClassOwnership' },
        );

        /**
         * Calls SendClassOwnership.
         * @function sendClassOwnership
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgSendClassOwnership} request MsgSendClassOwnership message or plain object
         * @returns {Promise<ununifi.nftmint.MsgSendClassOwnershipResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Msg#updateBaseTokenUri}.
         * @memberof ununifi.nftmint.Msg
         * @typedef UpdateBaseTokenUriCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} [response] MsgUpdateBaseTokenUriResponse
         */

        /**
         * Calls UpdateBaseTokenUri.
         * @function updateBaseTokenUri
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} request MsgUpdateBaseTokenUri message or plain object
         * @param {ununifi.nftmint.Msg.UpdateBaseTokenUriCallback} callback Node-style callback called with the error, if any, and MsgUpdateBaseTokenUriResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.updateBaseTokenUri = function updateBaseTokenUri(request, callback) {
            return this.rpcCall(
              updateBaseTokenUri,
              $root.ununifi.nftmint.MsgUpdateBaseTokenUri,
              $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'UpdateBaseTokenUri' },
        );

        /**
         * Calls UpdateBaseTokenUri.
         * @function updateBaseTokenUri
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} request MsgUpdateBaseTokenUri message or plain object
         * @returns {Promise<ununifi.nftmint.MsgUpdateBaseTokenUriResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Msg#updateTokenSupplyCap}.
         * @memberof ununifi.nftmint.Msg
         * @typedef UpdateTokenSupplyCapCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} [response] MsgUpdateTokenSupplyCapResponse
         */

        /**
         * Calls UpdateTokenSupplyCap.
         * @function updateTokenSupplyCap
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} request MsgUpdateTokenSupplyCap message or plain object
         * @param {ununifi.nftmint.Msg.UpdateTokenSupplyCapCallback} callback Node-style callback called with the error, if any, and MsgUpdateTokenSupplyCapResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.updateTokenSupplyCap = function updateTokenSupplyCap(request, callback) {
            return this.rpcCall(
              updateTokenSupplyCap,
              $root.ununifi.nftmint.MsgUpdateTokenSupplyCap,
              $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'UpdateTokenSupplyCap' },
        );

        /**
         * Calls UpdateTokenSupplyCap.
         * @function updateTokenSupplyCap
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} request MsgUpdateTokenSupplyCap message or plain object
         * @returns {Promise<ununifi.nftmint.MsgUpdateTokenSupplyCapResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Msg#mintNFT}.
         * @memberof ununifi.nftmint.Msg
         * @typedef MintNFTCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.MsgMintNFTResponse} [response] MsgMintNFTResponse
         */

        /**
         * Calls MintNFT.
         * @function mintNFT
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgMintNFT} request MsgMintNFT message or plain object
         * @param {ununifi.nftmint.Msg.MintNFTCallback} callback Node-style callback called with the error, if any, and MsgMintNFTResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.mintNFT = function mintNFT(request, callback) {
            return this.rpcCall(mintNFT, $root.ununifi.nftmint.MsgMintNFT, $root.ununifi.nftmint.MsgMintNFTResponse, request, callback);
          }),
          'name',
          { value: 'MintNFT' },
        );

        /**
         * Calls MintNFT.
         * @function mintNFT
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgMintNFT} request MsgMintNFT message or plain object
         * @returns {Promise<ununifi.nftmint.MsgMintNFTResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.nftmint.Msg#burnNFT}.
         * @memberof ununifi.nftmint.Msg
         * @typedef BurnNFTCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.nftmint.MsgBurnNFTResponse} [response] MsgBurnNFTResponse
         */

        /**
         * Calls BurnNFT.
         * @function burnNFT
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgBurnNFT} request MsgBurnNFT message or plain object
         * @param {ununifi.nftmint.Msg.BurnNFTCallback} callback Node-style callback called with the error, if any, and MsgBurnNFTResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.burnNFT = function burnNFT(request, callback) {
            return this.rpcCall(burnNFT, $root.ununifi.nftmint.MsgBurnNFT, $root.ununifi.nftmint.MsgBurnNFTResponse, request, callback);
          }),
          'name',
          { value: 'BurnNFT' },
        );

        /**
         * Calls BurnNFT.
         * @function burnNFT
         * @memberof ununifi.nftmint.Msg
         * @instance
         * @param {ununifi.nftmint.IMsgBurnNFT} request MsgBurnNFT message or plain object
         * @returns {Promise<ununifi.nftmint.MsgBurnNFTResponse>} Promise
         * @variation 2
         */

        return Msg;
      })();

      nftmint.MsgCreateClass = (function () {
        /**
         * Properties of a MsgCreateClass.
         * @memberof ununifi.nftmint
         * @interface IMsgCreateClass
         * @property {string|null} [sender] MsgCreateClass sender
         * @property {string|null} [name] MsgCreateClass name
         * @property {string|null} [base_token_uri] MsgCreateClass base_token_uri
         * @property {Long|null} [token_supply_cap] MsgCreateClass token_supply_cap
         * @property {ununifi.nftmint.MintingPermission|null} [minting_permission] MsgCreateClass minting_permission
         * @property {string|null} [symbol] MsgCreateClass symbol
         * @property {string|null} [description] MsgCreateClass description
         * @property {string|null} [class_uri] MsgCreateClass class_uri
         */

        /**
         * Constructs a new MsgCreateClass.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgCreateClass.
         * @implements IMsgCreateClass
         * @constructor
         * @param {ununifi.nftmint.IMsgCreateClass=} [properties] Properties to set
         */
        function MsgCreateClass(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgCreateClass sender.
         * @member {string} sender
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.sender = '';

        /**
         * MsgCreateClass name.
         * @member {string} name
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.name = '';

        /**
         * MsgCreateClass base_token_uri.
         * @member {string} base_token_uri
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.base_token_uri = '';

        /**
         * MsgCreateClass token_supply_cap.
         * @member {Long} token_supply_cap
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.token_supply_cap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * MsgCreateClass minting_permission.
         * @member {ununifi.nftmint.MintingPermission} minting_permission
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.minting_permission = 0;

        /**
         * MsgCreateClass symbol.
         * @member {string} symbol
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.symbol = '';

        /**
         * MsgCreateClass description.
         * @member {string} description
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.description = '';

        /**
         * MsgCreateClass class_uri.
         * @member {string} class_uri
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         */
        MsgCreateClass.prototype.class_uri = '';

        /**
         * Encodes the specified MsgCreateClass message. Does not implicitly {@link ununifi.nftmint.MsgCreateClass.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgCreateClass
         * @static
         * @param {ununifi.nftmint.IMsgCreateClass} message MsgCreateClass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateClass.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
          if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
          if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.token_supply_cap);
          if (message.minting_permission != null && Object.hasOwnProperty.call(message, 'minting_permission'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.minting_permission);
          if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
            writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.symbol);
          if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.description);
          if (message.class_uri != null && Object.hasOwnProperty.call(message, 'class_uri'))
            writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.class_uri);
          return writer;
        };

        /**
         * Encodes the specified MsgCreateClass message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgCreateClass.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgCreateClass
         * @static
         * @param {ununifi.nftmint.IMsgCreateClass} message MsgCreateClass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCreateClass message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgCreateClass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgCreateClass} MsgCreateClass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateClass.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgCreateClass();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.name = reader.string();
                break;
              case 3:
                message.base_token_uri = reader.string();
                break;
              case 4:
                message.token_supply_cap = reader.uint64();
                break;
              case 5:
                message.minting_permission = reader.int32();
                break;
              case 7:
                message.symbol = reader.string();
                break;
              case 8:
                message.description = reader.string();
                break;
              case 9:
                message.class_uri = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCreateClass message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgCreateClass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgCreateClass} MsgCreateClass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateClass.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCreateClass message.
         * @function verify
         * @memberof ununifi.nftmint.MsgCreateClass
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCreateClass.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
            if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (
              !$util.isInteger(message.token_supply_cap) &&
              !(message.token_supply_cap && $util.isInteger(message.token_supply_cap.low) && $util.isInteger(message.token_supply_cap.high))
            )
              return 'token_supply_cap: integer|Long expected';
          if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
            switch (message.minting_permission) {
              default:
                return 'minting_permission: enum value expected';
              case 0:
              case 1:
                break;
            }
          if (message.symbol != null && message.hasOwnProperty('symbol'))
            if (!$util.isString(message.symbol)) return 'symbol: string expected';
          if (message.description != null && message.hasOwnProperty('description'))
            if (!$util.isString(message.description)) return 'description: string expected';
          if (message.class_uri != null && message.hasOwnProperty('class_uri'))
            if (!$util.isString(message.class_uri)) return 'class_uri: string expected';
          return null;
        };

        /**
         * Creates a MsgCreateClass message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgCreateClass
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgCreateClass} MsgCreateClass
         */
        MsgCreateClass.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgCreateClass) return object;
          var message = new $root.ununifi.nftmint.MsgCreateClass();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.name != null) message.name = String(object.name);
          if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
          if (object.token_supply_cap != null)
            if ($util.Long) (message.token_supply_cap = $util.Long.fromValue(object.token_supply_cap)).unsigned = true;
            else if (typeof object.token_supply_cap === 'string') message.token_supply_cap = parseInt(object.token_supply_cap, 10);
            else if (typeof object.token_supply_cap === 'number') message.token_supply_cap = object.token_supply_cap;
            else if (typeof object.token_supply_cap === 'object')
              message.token_supply_cap = new $util.LongBits(object.token_supply_cap.low >>> 0, object.token_supply_cap.high >>> 0).toNumber(
                true,
              );
          switch (object.minting_permission) {
            case 'OnlyOwner':
            case 0:
              message.minting_permission = 0;
              break;
            case 'Anyone':
            case 1:
              message.minting_permission = 1;
              break;
          }
          if (object.symbol != null) message.symbol = String(object.symbol);
          if (object.description != null) message.description = String(object.description);
          if (object.class_uri != null) message.class_uri = String(object.class_uri);
          return message;
        };

        /**
         * Creates a plain object from a MsgCreateClass message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgCreateClass
         * @static
         * @param {ununifi.nftmint.MsgCreateClass} message MsgCreateClass
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCreateClass.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.name = '';
            object.base_token_uri = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.token_supply_cap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.token_supply_cap = options.longs === String ? '0' : 0;
            object.minting_permission = options.enums === String ? 'OnlyOwner' : 0;
            object.symbol = '';
            object.description = '';
            object.class_uri = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (typeof message.token_supply_cap === 'number')
              object.token_supply_cap = options.longs === String ? String(message.token_supply_cap) : message.token_supply_cap;
            else
              object.token_supply_cap =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.token_supply_cap)
                  : options.longs === Number
                  ? new $util.LongBits(message.token_supply_cap.low >>> 0, message.token_supply_cap.high >>> 0).toNumber(true)
                  : message.token_supply_cap;
          if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
            object.minting_permission =
              options.enums === String ? $root.ununifi.nftmint.MintingPermission[message.minting_permission] : message.minting_permission;
          if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
          if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
          if (message.class_uri != null && message.hasOwnProperty('class_uri')) object.class_uri = message.class_uri;
          return object;
        };

        /**
         * Converts this MsgCreateClass to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgCreateClass
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCreateClass.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCreateClass;
      })();

      nftmint.MsgCreateClassResponse = (function () {
        /**
         * Properties of a MsgCreateClassResponse.
         * @memberof ununifi.nftmint
         * @interface IMsgCreateClassResponse
         */

        /**
         * Constructs a new MsgCreateClassResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgCreateClassResponse.
         * @implements IMsgCreateClassResponse
         * @constructor
         * @param {ununifi.nftmint.IMsgCreateClassResponse=} [properties] Properties to set
         */
        function MsgCreateClassResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgCreateClassResponse message. Does not implicitly {@link ununifi.nftmint.MsgCreateClassResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @static
         * @param {ununifi.nftmint.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateClassResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgCreateClassResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgCreateClassResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @static
         * @param {ununifi.nftmint.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgCreateClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgCreateClassResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgCreateClassResponse} MsgCreateClassResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateClassResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgCreateClassResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgCreateClassResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgCreateClassResponse} MsgCreateClassResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgCreateClassResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgCreateClassResponse message.
         * @function verify
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgCreateClassResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgCreateClassResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgCreateClassResponse} MsgCreateClassResponse
         */
        MsgCreateClassResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgCreateClassResponse) return object;
          return new $root.ununifi.nftmint.MsgCreateClassResponse();
        };

        /**
         * Creates a plain object from a MsgCreateClassResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @static
         * @param {ununifi.nftmint.MsgCreateClassResponse} message MsgCreateClassResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgCreateClassResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgCreateClassResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgCreateClassResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgCreateClassResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgCreateClassResponse;
      })();

      nftmint.MsgSendClassOwnership = (function () {
        /**
         * Properties of a MsgSendClassOwnership.
         * @memberof ununifi.nftmint
         * @interface IMsgSendClassOwnership
         * @property {string|null} [sender] MsgSendClassOwnership sender
         * @property {string|null} [class_id] MsgSendClassOwnership class_id
         * @property {string|null} [recipient] MsgSendClassOwnership recipient
         */

        /**
         * Constructs a new MsgSendClassOwnership.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgSendClassOwnership.
         * @implements IMsgSendClassOwnership
         * @constructor
         * @param {ununifi.nftmint.IMsgSendClassOwnership=} [properties] Properties to set
         */
        function MsgSendClassOwnership(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgSendClassOwnership sender.
         * @member {string} sender
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @instance
         */
        MsgSendClassOwnership.prototype.sender = '';

        /**
         * MsgSendClassOwnership class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @instance
         */
        MsgSendClassOwnership.prototype.class_id = '';

        /**
         * MsgSendClassOwnership recipient.
         * @member {string} recipient
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @instance
         */
        MsgSendClassOwnership.prototype.recipient = '';

        /**
         * Encodes the specified MsgSendClassOwnership message. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnership.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @static
         * @param {ununifi.nftmint.IMsgSendClassOwnership} message MsgSendClassOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSendClassOwnership.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.recipient);
          return writer;
        };

        /**
         * Encodes the specified MsgSendClassOwnership message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnership.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @static
         * @param {ununifi.nftmint.IMsgSendClassOwnership} message MsgSendClassOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSendClassOwnership.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgSendClassOwnership message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgSendClassOwnership} MsgSendClassOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSendClassOwnership.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgSendClassOwnership();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.recipient = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgSendClassOwnership message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgSendClassOwnership} MsgSendClassOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSendClassOwnership.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgSendClassOwnership message.
         * @function verify
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgSendClassOwnership.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.recipient != null && message.hasOwnProperty('recipient'))
            if (!$util.isString(message.recipient)) return 'recipient: string expected';
          return null;
        };

        /**
         * Creates a MsgSendClassOwnership message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgSendClassOwnership} MsgSendClassOwnership
         */
        MsgSendClassOwnership.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgSendClassOwnership) return object;
          var message = new $root.ununifi.nftmint.MsgSendClassOwnership();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.recipient != null) message.recipient = String(object.recipient);
          return message;
        };

        /**
         * Creates a plain object from a MsgSendClassOwnership message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @static
         * @param {ununifi.nftmint.MsgSendClassOwnership} message MsgSendClassOwnership
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgSendClassOwnership.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.class_id = '';
            object.recipient = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
          return object;
        };

        /**
         * Converts this MsgSendClassOwnership to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgSendClassOwnership
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgSendClassOwnership.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgSendClassOwnership;
      })();

      nftmint.MsgSendClassOwnershipResponse = (function () {
        /**
         * Properties of a MsgSendClassOwnershipResponse.
         * @memberof ununifi.nftmint
         * @interface IMsgSendClassOwnershipResponse
         */

        /**
         * Constructs a new MsgSendClassOwnershipResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgSendClassOwnershipResponse.
         * @implements IMsgSendClassOwnershipResponse
         * @constructor
         * @param {ununifi.nftmint.IMsgSendClassOwnershipResponse=} [properties] Properties to set
         */
        function MsgSendClassOwnershipResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgSendClassOwnershipResponse message. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnershipResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @static
         * @param {ununifi.nftmint.IMsgSendClassOwnershipResponse} message MsgSendClassOwnershipResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSendClassOwnershipResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgSendClassOwnershipResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnershipResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @static
         * @param {ununifi.nftmint.IMsgSendClassOwnershipResponse} message MsgSendClassOwnershipResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgSendClassOwnershipResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgSendClassOwnershipResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgSendClassOwnershipResponse} MsgSendClassOwnershipResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSendClassOwnershipResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgSendClassOwnershipResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgSendClassOwnershipResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgSendClassOwnershipResponse} MsgSendClassOwnershipResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgSendClassOwnershipResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgSendClassOwnershipResponse message.
         * @function verify
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgSendClassOwnershipResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgSendClassOwnershipResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgSendClassOwnershipResponse} MsgSendClassOwnershipResponse
         */
        MsgSendClassOwnershipResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgSendClassOwnershipResponse) return object;
          return new $root.ununifi.nftmint.MsgSendClassOwnershipResponse();
        };

        /**
         * Creates a plain object from a MsgSendClassOwnershipResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @static
         * @param {ununifi.nftmint.MsgSendClassOwnershipResponse} message MsgSendClassOwnershipResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgSendClassOwnershipResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgSendClassOwnershipResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgSendClassOwnershipResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgSendClassOwnershipResponse;
      })();

      nftmint.MsgUpdateBaseTokenUri = (function () {
        /**
         * Properties of a MsgUpdateBaseTokenUri.
         * @memberof ununifi.nftmint
         * @interface IMsgUpdateBaseTokenUri
         * @property {string|null} [sender] MsgUpdateBaseTokenUri sender
         * @property {string|null} [class_id] MsgUpdateBaseTokenUri class_id
         * @property {string|null} [base_token_uri] MsgUpdateBaseTokenUri base_token_uri
         */

        /**
         * Constructs a new MsgUpdateBaseTokenUri.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgUpdateBaseTokenUri.
         * @implements IMsgUpdateBaseTokenUri
         * @constructor
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri=} [properties] Properties to set
         */
        function MsgUpdateBaseTokenUri(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgUpdateBaseTokenUri sender.
         * @member {string} sender
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @instance
         */
        MsgUpdateBaseTokenUri.prototype.sender = '';

        /**
         * MsgUpdateBaseTokenUri class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @instance
         */
        MsgUpdateBaseTokenUri.prototype.class_id = '';

        /**
         * MsgUpdateBaseTokenUri base_token_uri.
         * @member {string} base_token_uri
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @instance
         */
        MsgUpdateBaseTokenUri.prototype.base_token_uri = '';

        /**
         * Encodes the specified MsgUpdateBaseTokenUri message. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUri.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @static
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} message MsgUpdateBaseTokenUri message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateBaseTokenUri.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
          return writer;
        };

        /**
         * Encodes the specified MsgUpdateBaseTokenUri message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUri.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @static
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} message MsgUpdateBaseTokenUri message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateBaseTokenUri.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgUpdateBaseTokenUri message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgUpdateBaseTokenUri} MsgUpdateBaseTokenUri
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateBaseTokenUri.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgUpdateBaseTokenUri();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.base_token_uri = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgUpdateBaseTokenUri message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgUpdateBaseTokenUri} MsgUpdateBaseTokenUri
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateBaseTokenUri.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgUpdateBaseTokenUri message.
         * @function verify
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgUpdateBaseTokenUri.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
            if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
          return null;
        };

        /**
         * Creates a MsgUpdateBaseTokenUri message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgUpdateBaseTokenUri} MsgUpdateBaseTokenUri
         */
        MsgUpdateBaseTokenUri.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgUpdateBaseTokenUri) return object;
          var message = new $root.ununifi.nftmint.MsgUpdateBaseTokenUri();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
          return message;
        };

        /**
         * Creates a plain object from a MsgUpdateBaseTokenUri message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @static
         * @param {ununifi.nftmint.MsgUpdateBaseTokenUri} message MsgUpdateBaseTokenUri
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgUpdateBaseTokenUri.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.class_id = '';
            object.base_token_uri = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
          return object;
        };

        /**
         * Converts this MsgUpdateBaseTokenUri to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgUpdateBaseTokenUri.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgUpdateBaseTokenUri;
      })();

      nftmint.MsgUpdateBaseTokenUriResponse = (function () {
        /**
         * Properties of a MsgUpdateBaseTokenUriResponse.
         * @memberof ununifi.nftmint
         * @interface IMsgUpdateBaseTokenUriResponse
         */

        /**
         * Constructs a new MsgUpdateBaseTokenUriResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgUpdateBaseTokenUriResponse.
         * @implements IMsgUpdateBaseTokenUriResponse
         * @constructor
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUriResponse=} [properties] Properties to set
         */
        function MsgUpdateBaseTokenUriResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgUpdateBaseTokenUriResponse message. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUriResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @static
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUriResponse} message MsgUpdateBaseTokenUriResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateBaseTokenUriResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgUpdateBaseTokenUriResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUriResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @static
         * @param {ununifi.nftmint.IMsgUpdateBaseTokenUriResponse} message MsgUpdateBaseTokenUriResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateBaseTokenUriResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgUpdateBaseTokenUriResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} MsgUpdateBaseTokenUriResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateBaseTokenUriResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgUpdateBaseTokenUriResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} MsgUpdateBaseTokenUriResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateBaseTokenUriResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgUpdateBaseTokenUriResponse message.
         * @function verify
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgUpdateBaseTokenUriResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgUpdateBaseTokenUriResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} MsgUpdateBaseTokenUriResponse
         */
        MsgUpdateBaseTokenUriResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse) return object;
          return new $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse();
        };

        /**
         * Creates a plain object from a MsgUpdateBaseTokenUriResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @static
         * @param {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} message MsgUpdateBaseTokenUriResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgUpdateBaseTokenUriResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgUpdateBaseTokenUriResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgUpdateBaseTokenUriResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgUpdateBaseTokenUriResponse;
      })();

      nftmint.MsgUpdateTokenSupplyCap = (function () {
        /**
         * Properties of a MsgUpdateTokenSupplyCap.
         * @memberof ununifi.nftmint
         * @interface IMsgUpdateTokenSupplyCap
         * @property {string|null} [sender] MsgUpdateTokenSupplyCap sender
         * @property {string|null} [class_id] MsgUpdateTokenSupplyCap class_id
         * @property {Long|null} [token_supply_cap] MsgUpdateTokenSupplyCap token_supply_cap
         */

        /**
         * Constructs a new MsgUpdateTokenSupplyCap.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgUpdateTokenSupplyCap.
         * @implements IMsgUpdateTokenSupplyCap
         * @constructor
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap=} [properties] Properties to set
         */
        function MsgUpdateTokenSupplyCap(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgUpdateTokenSupplyCap sender.
         * @member {string} sender
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @instance
         */
        MsgUpdateTokenSupplyCap.prototype.sender = '';

        /**
         * MsgUpdateTokenSupplyCap class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @instance
         */
        MsgUpdateTokenSupplyCap.prototype.class_id = '';

        /**
         * MsgUpdateTokenSupplyCap token_supply_cap.
         * @member {Long} token_supply_cap
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @instance
         */
        MsgUpdateTokenSupplyCap.prototype.token_supply_cap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified MsgUpdateTokenSupplyCap message. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCap.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @static
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} message MsgUpdateTokenSupplyCap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateTokenSupplyCap.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.token_supply_cap);
          return writer;
        };

        /**
         * Encodes the specified MsgUpdateTokenSupplyCap message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @static
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} message MsgUpdateTokenSupplyCap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateTokenSupplyCap.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgUpdateTokenSupplyCap message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCap} MsgUpdateTokenSupplyCap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateTokenSupplyCap.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgUpdateTokenSupplyCap();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.token_supply_cap = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgUpdateTokenSupplyCap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCap} MsgUpdateTokenSupplyCap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateTokenSupplyCap.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgUpdateTokenSupplyCap message.
         * @function verify
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgUpdateTokenSupplyCap.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (
              !$util.isInteger(message.token_supply_cap) &&
              !(message.token_supply_cap && $util.isInteger(message.token_supply_cap.low) && $util.isInteger(message.token_supply_cap.high))
            )
              return 'token_supply_cap: integer|Long expected';
          return null;
        };

        /**
         * Creates a MsgUpdateTokenSupplyCap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCap} MsgUpdateTokenSupplyCap
         */
        MsgUpdateTokenSupplyCap.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgUpdateTokenSupplyCap) return object;
          var message = new $root.ununifi.nftmint.MsgUpdateTokenSupplyCap();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.token_supply_cap != null)
            if ($util.Long) (message.token_supply_cap = $util.Long.fromValue(object.token_supply_cap)).unsigned = true;
            else if (typeof object.token_supply_cap === 'string') message.token_supply_cap = parseInt(object.token_supply_cap, 10);
            else if (typeof object.token_supply_cap === 'number') message.token_supply_cap = object.token_supply_cap;
            else if (typeof object.token_supply_cap === 'object')
              message.token_supply_cap = new $util.LongBits(object.token_supply_cap.low >>> 0, object.token_supply_cap.high >>> 0).toNumber(
                true,
              );
          return message;
        };

        /**
         * Creates a plain object from a MsgUpdateTokenSupplyCap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @static
         * @param {ununifi.nftmint.MsgUpdateTokenSupplyCap} message MsgUpdateTokenSupplyCap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgUpdateTokenSupplyCap.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.class_id = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.token_supply_cap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.token_supply_cap = options.longs === String ? '0' : 0;
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (typeof message.token_supply_cap === 'number')
              object.token_supply_cap = options.longs === String ? String(message.token_supply_cap) : message.token_supply_cap;
            else
              object.token_supply_cap =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.token_supply_cap)
                  : options.longs === Number
                  ? new $util.LongBits(message.token_supply_cap.low >>> 0, message.token_supply_cap.high >>> 0).toNumber(true)
                  : message.token_supply_cap;
          return object;
        };

        /**
         * Converts this MsgUpdateTokenSupplyCap to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgUpdateTokenSupplyCap.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgUpdateTokenSupplyCap;
      })();

      nftmint.MsgUpdateTokenSupplyCapResponse = (function () {
        /**
         * Properties of a MsgUpdateTokenSupplyCapResponse.
         * @memberof ununifi.nftmint
         * @interface IMsgUpdateTokenSupplyCapResponse
         */

        /**
         * Constructs a new MsgUpdateTokenSupplyCapResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgUpdateTokenSupplyCapResponse.
         * @implements IMsgUpdateTokenSupplyCapResponse
         * @constructor
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCapResponse=} [properties] Properties to set
         */
        function MsgUpdateTokenSupplyCapResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgUpdateTokenSupplyCapResponse message. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCapResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @static
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCapResponse} message MsgUpdateTokenSupplyCapResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateTokenSupplyCapResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgUpdateTokenSupplyCapResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCapResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @static
         * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCapResponse} message MsgUpdateTokenSupplyCapResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgUpdateTokenSupplyCapResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgUpdateTokenSupplyCapResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} MsgUpdateTokenSupplyCapResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateTokenSupplyCapResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgUpdateTokenSupplyCapResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} MsgUpdateTokenSupplyCapResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgUpdateTokenSupplyCapResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgUpdateTokenSupplyCapResponse message.
         * @function verify
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgUpdateTokenSupplyCapResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgUpdateTokenSupplyCapResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} MsgUpdateTokenSupplyCapResponse
         */
        MsgUpdateTokenSupplyCapResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse) return object;
          return new $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse();
        };

        /**
         * Creates a plain object from a MsgUpdateTokenSupplyCapResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @static
         * @param {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} message MsgUpdateTokenSupplyCapResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgUpdateTokenSupplyCapResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgUpdateTokenSupplyCapResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgUpdateTokenSupplyCapResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgUpdateTokenSupplyCapResponse;
      })();

      nftmint.MsgMintNFT = (function () {
        /**
         * Properties of a MsgMintNFT.
         * @memberof ununifi.nftmint
         * @interface IMsgMintNFT
         * @property {string|null} [sender] MsgMintNFT sender
         * @property {string|null} [class_id] MsgMintNFT class_id
         * @property {string|null} [nft_id] MsgMintNFT nft_id
         * @property {string|null} [recipient] MsgMintNFT recipient
         */

        /**
         * Constructs a new MsgMintNFT.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgMintNFT.
         * @implements IMsgMintNFT
         * @constructor
         * @param {ununifi.nftmint.IMsgMintNFT=} [properties] Properties to set
         */
        function MsgMintNFT(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgMintNFT sender.
         * @member {string} sender
         * @memberof ununifi.nftmint.MsgMintNFT
         * @instance
         */
        MsgMintNFT.prototype.sender = '';

        /**
         * MsgMintNFT class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.MsgMintNFT
         * @instance
         */
        MsgMintNFT.prototype.class_id = '';

        /**
         * MsgMintNFT nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmint.MsgMintNFT
         * @instance
         */
        MsgMintNFT.prototype.nft_id = '';

        /**
         * MsgMintNFT recipient.
         * @member {string} recipient
         * @memberof ununifi.nftmint.MsgMintNFT
         * @instance
         */
        MsgMintNFT.prototype.recipient = '';

        /**
         * Encodes the specified MsgMintNFT message. Does not implicitly {@link ununifi.nftmint.MsgMintNFT.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgMintNFT
         * @static
         * @param {ununifi.nftmint.IMsgMintNFT} message MsgMintNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNFT.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.recipient);
          return writer;
        };

        /**
         * Encodes the specified MsgMintNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgMintNFT.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgMintNFT
         * @static
         * @param {ununifi.nftmint.IMsgMintNFT} message MsgMintNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgMintNFT message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgMintNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgMintNFT} MsgMintNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNFT.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgMintNFT();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              case 4:
                message.recipient = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgMintNFT message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgMintNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgMintNFT} MsgMintNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNFT.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgMintNFT message.
         * @function verify
         * @memberof ununifi.nftmint.MsgMintNFT
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgMintNFT.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          if (message.recipient != null && message.hasOwnProperty('recipient'))
            if (!$util.isString(message.recipient)) return 'recipient: string expected';
          return null;
        };

        /**
         * Creates a MsgMintNFT message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgMintNFT
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgMintNFT} MsgMintNFT
         */
        MsgMintNFT.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgMintNFT) return object;
          var message = new $root.ununifi.nftmint.MsgMintNFT();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          if (object.recipient != null) message.recipient = String(object.recipient);
          return message;
        };

        /**
         * Creates a plain object from a MsgMintNFT message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgMintNFT
         * @static
         * @param {ununifi.nftmint.MsgMintNFT} message MsgMintNFT
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgMintNFT.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.class_id = '';
            object.nft_id = '';
            object.recipient = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
          return object;
        };

        /**
         * Converts this MsgMintNFT to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgMintNFT
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgMintNFT.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgMintNFT;
      })();

      nftmint.MsgMintNFTResponse = (function () {
        /**
         * Properties of a MsgMintNFTResponse.
         * @memberof ununifi.nftmint
         * @interface IMsgMintNFTResponse
         */

        /**
         * Constructs a new MsgMintNFTResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgMintNFTResponse.
         * @implements IMsgMintNFTResponse
         * @constructor
         * @param {ununifi.nftmint.IMsgMintNFTResponse=} [properties] Properties to set
         */
        function MsgMintNFTResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgMintNFTResponse message. Does not implicitly {@link ununifi.nftmint.MsgMintNFTResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @static
         * @param {ununifi.nftmint.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNFTResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgMintNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgMintNFTResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @static
         * @param {ununifi.nftmint.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgMintNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgMintNFTResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgMintNFTResponse} MsgMintNFTResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNFTResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgMintNFTResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgMintNFTResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgMintNFTResponse} MsgMintNFTResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgMintNFTResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgMintNFTResponse message.
         * @function verify
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgMintNFTResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgMintNFTResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgMintNFTResponse} MsgMintNFTResponse
         */
        MsgMintNFTResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgMintNFTResponse) return object;
          return new $root.ununifi.nftmint.MsgMintNFTResponse();
        };

        /**
         * Creates a plain object from a MsgMintNFTResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @static
         * @param {ununifi.nftmint.MsgMintNFTResponse} message MsgMintNFTResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgMintNFTResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgMintNFTResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgMintNFTResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgMintNFTResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgMintNFTResponse;
      })();

      nftmint.MsgBurnNFT = (function () {
        /**
         * Properties of a MsgBurnNFT.
         * @memberof ununifi.nftmint
         * @interface IMsgBurnNFT
         * @property {string|null} [sender] MsgBurnNFT sender
         * @property {string|null} [class_id] MsgBurnNFT class_id
         * @property {string|null} [nft_id] MsgBurnNFT nft_id
         */

        /**
         * Constructs a new MsgBurnNFT.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgBurnNFT.
         * @implements IMsgBurnNFT
         * @constructor
         * @param {ununifi.nftmint.IMsgBurnNFT=} [properties] Properties to set
         */
        function MsgBurnNFT(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgBurnNFT sender.
         * @member {string} sender
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @instance
         */
        MsgBurnNFT.prototype.sender = '';

        /**
         * MsgBurnNFT class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @instance
         */
        MsgBurnNFT.prototype.class_id = '';

        /**
         * MsgBurnNFT nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @instance
         */
        MsgBurnNFT.prototype.nft_id = '';

        /**
         * Encodes the specified MsgBurnNFT message. Does not implicitly {@link ununifi.nftmint.MsgBurnNFT.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @static
         * @param {ununifi.nftmint.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnNFT.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified MsgBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgBurnNFT.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @static
         * @param {ununifi.nftmint.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgBurnNFT message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgBurnNFT} MsgBurnNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnNFT.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgBurnNFT();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgBurnNFT message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgBurnNFT} MsgBurnNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnNFT.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgBurnNFT message.
         * @function verify
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgBurnNFT.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates a MsgBurnNFT message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgBurnNFT} MsgBurnNFT
         */
        MsgBurnNFT.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgBurnNFT) return object;
          var message = new $root.ununifi.nftmint.MsgBurnNFT();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from a MsgBurnNFT message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @static
         * @param {ununifi.nftmint.MsgBurnNFT} message MsgBurnNFT
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgBurnNFT.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this MsgBurnNFT to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgBurnNFT
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgBurnNFT.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgBurnNFT;
      })();

      nftmint.MsgBurnNFTResponse = (function () {
        /**
         * Properties of a MsgBurnNFTResponse.
         * @memberof ununifi.nftmint
         * @interface IMsgBurnNFTResponse
         */

        /**
         * Constructs a new MsgBurnNFTResponse.
         * @memberof ununifi.nftmint
         * @classdesc Represents a MsgBurnNFTResponse.
         * @implements IMsgBurnNFTResponse
         * @constructor
         * @param {ununifi.nftmint.IMsgBurnNFTResponse=} [properties] Properties to set
         */
        function MsgBurnNFTResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgBurnNFTResponse message. Does not implicitly {@link ununifi.nftmint.MsgBurnNFTResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @static
         * @param {ununifi.nftmint.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnNFTResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgBurnNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgBurnNFTResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @static
         * @param {ununifi.nftmint.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgBurnNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgBurnNFTResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.MsgBurnNFTResponse} MsgBurnNFTResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnNFTResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.MsgBurnNFTResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgBurnNFTResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.MsgBurnNFTResponse} MsgBurnNFTResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgBurnNFTResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgBurnNFTResponse message.
         * @function verify
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgBurnNFTResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgBurnNFTResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.MsgBurnNFTResponse} MsgBurnNFTResponse
         */
        MsgBurnNFTResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.MsgBurnNFTResponse) return object;
          return new $root.ununifi.nftmint.MsgBurnNFTResponse();
        };

        /**
         * Creates a plain object from a MsgBurnNFTResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @static
         * @param {ununifi.nftmint.MsgBurnNFTResponse} message MsgBurnNFTResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgBurnNFTResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgBurnNFTResponse to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.MsgBurnNFTResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgBurnNFTResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgBurnNFTResponse;
      })();

      nftmint.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.nftmint
         * @interface IGenesisState
         * @property {ununifi.nftmint.IParams|null} [params] GenesisState params
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.nftmint
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.nftmint.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState params.
         * @member {ununifi.nftmint.IParams|null|undefined} params
         * @memberof ununifi.nftmint.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftmint.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.GenesisState
         * @static
         * @param {ununifi.nftmint.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.nftmint.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftmint.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.GenesisState
         * @static
         * @param {ununifi.nftmint.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.nftmint.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.nftmint.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.nftmint.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.GenesisState) return object;
          var message = new $root.ununifi.nftmint.GenesisState();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmint.GenesisState.params: object expected');
            message.params = $root.ununifi.nftmint.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.GenesisState
         * @static
         * @param {ununifi.nftmint.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.nftmint.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      nftmint.EventCreateClass = (function () {
        /**
         * Properties of an EventCreateClass.
         * @memberof ununifi.nftmint
         * @interface IEventCreateClass
         * @property {string|null} [owner] EventCreateClass owner
         * @property {string|null} [class_id] EventCreateClass class_id
         * @property {string|null} [base_token_uri] EventCreateClass base_token_uri
         * @property {string|null} [token_supply_cap] EventCreateClass token_supply_cap
         * @property {ununifi.nftmint.MintingPermission|null} [minting_permission] EventCreateClass minting_permission
         */

        /**
         * Constructs a new EventCreateClass.
         * @memberof ununifi.nftmint
         * @classdesc Represents an EventCreateClass.
         * @implements IEventCreateClass
         * @constructor
         * @param {ununifi.nftmint.IEventCreateClass=} [properties] Properties to set
         */
        function EventCreateClass(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventCreateClass owner.
         * @member {string} owner
         * @memberof ununifi.nftmint.EventCreateClass
         * @instance
         */
        EventCreateClass.prototype.owner = '';

        /**
         * EventCreateClass class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.EventCreateClass
         * @instance
         */
        EventCreateClass.prototype.class_id = '';

        /**
         * EventCreateClass base_token_uri.
         * @member {string} base_token_uri
         * @memberof ununifi.nftmint.EventCreateClass
         * @instance
         */
        EventCreateClass.prototype.base_token_uri = '';

        /**
         * EventCreateClass token_supply_cap.
         * @member {string} token_supply_cap
         * @memberof ununifi.nftmint.EventCreateClass
         * @instance
         */
        EventCreateClass.prototype.token_supply_cap = '';

        /**
         * EventCreateClass minting_permission.
         * @member {ununifi.nftmint.MintingPermission} minting_permission
         * @memberof ununifi.nftmint.EventCreateClass
         * @instance
         */
        EventCreateClass.prototype.minting_permission = 0;

        /**
         * Encodes the specified EventCreateClass message. Does not implicitly {@link ununifi.nftmint.EventCreateClass.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.EventCreateClass
         * @static
         * @param {ununifi.nftmint.IEventCreateClass} message EventCreateClass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventCreateClass.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
          if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.token_supply_cap);
          if (message.minting_permission != null && Object.hasOwnProperty.call(message, 'minting_permission'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.minting_permission);
          return writer;
        };

        /**
         * Encodes the specified EventCreateClass message, length delimited. Does not implicitly {@link ununifi.nftmint.EventCreateClass.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.EventCreateClass
         * @static
         * @param {ununifi.nftmint.IEventCreateClass} message EventCreateClass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventCreateClass message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.EventCreateClass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.EventCreateClass} EventCreateClass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventCreateClass.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.EventCreateClass();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.base_token_uri = reader.string();
                break;
              case 4:
                message.token_supply_cap = reader.string();
                break;
              case 5:
                message.minting_permission = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventCreateClass message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.EventCreateClass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.EventCreateClass} EventCreateClass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventCreateClass.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventCreateClass message.
         * @function verify
         * @memberof ununifi.nftmint.EventCreateClass
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventCreateClass.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
            if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (!$util.isString(message.token_supply_cap)) return 'token_supply_cap: string expected';
          if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
            switch (message.minting_permission) {
              default:
                return 'minting_permission: enum value expected';
              case 0:
              case 1:
                break;
            }
          return null;
        };

        /**
         * Creates an EventCreateClass message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.EventCreateClass
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.EventCreateClass} EventCreateClass
         */
        EventCreateClass.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.EventCreateClass) return object;
          var message = new $root.ununifi.nftmint.EventCreateClass();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
          if (object.token_supply_cap != null) message.token_supply_cap = String(object.token_supply_cap);
          switch (object.minting_permission) {
            case 'OnlyOwner':
            case 0:
              message.minting_permission = 0;
              break;
            case 'Anyone':
            case 1:
              message.minting_permission = 1;
              break;
          }
          return message;
        };

        /**
         * Creates a plain object from an EventCreateClass message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.EventCreateClass
         * @static
         * @param {ununifi.nftmint.EventCreateClass} message EventCreateClass
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventCreateClass.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.base_token_uri = '';
            object.token_supply_cap = '';
            object.minting_permission = options.enums === String ? 'OnlyOwner' : 0;
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            object.token_supply_cap = message.token_supply_cap;
          if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
            object.minting_permission =
              options.enums === String ? $root.ununifi.nftmint.MintingPermission[message.minting_permission] : message.minting_permission;
          return object;
        };

        /**
         * Converts this EventCreateClass to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.EventCreateClass
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventCreateClass.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventCreateClass;
      })();

      nftmint.EventSendClassOwnership = (function () {
        /**
         * Properties of an EventSendClassOwnership.
         * @memberof ununifi.nftmint
         * @interface IEventSendClassOwnership
         * @property {string|null} [sender] EventSendClassOwnership sender
         * @property {string|null} [receiver] EventSendClassOwnership receiver
         * @property {string|null} [class_id] EventSendClassOwnership class_id
         */

        /**
         * Constructs a new EventSendClassOwnership.
         * @memberof ununifi.nftmint
         * @classdesc Represents an EventSendClassOwnership.
         * @implements IEventSendClassOwnership
         * @constructor
         * @param {ununifi.nftmint.IEventSendClassOwnership=} [properties] Properties to set
         */
        function EventSendClassOwnership(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventSendClassOwnership sender.
         * @member {string} sender
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @instance
         */
        EventSendClassOwnership.prototype.sender = '';

        /**
         * EventSendClassOwnership receiver.
         * @member {string} receiver
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @instance
         */
        EventSendClassOwnership.prototype.receiver = '';

        /**
         * EventSendClassOwnership class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @instance
         */
        EventSendClassOwnership.prototype.class_id = '';

        /**
         * Encodes the specified EventSendClassOwnership message. Does not implicitly {@link ununifi.nftmint.EventSendClassOwnership.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @static
         * @param {ununifi.nftmint.IEventSendClassOwnership} message EventSendClassOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventSendClassOwnership.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
          if (message.receiver != null && Object.hasOwnProperty.call(message, 'receiver'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.receiver);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.class_id);
          return writer;
        };

        /**
         * Encodes the specified EventSendClassOwnership message, length delimited. Does not implicitly {@link ununifi.nftmint.EventSendClassOwnership.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @static
         * @param {ununifi.nftmint.IEventSendClassOwnership} message EventSendClassOwnership message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventSendClassOwnership.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventSendClassOwnership message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.EventSendClassOwnership} EventSendClassOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventSendClassOwnership.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.EventSendClassOwnership();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sender = reader.string();
                break;
              case 2:
                message.receiver = reader.string();
                break;
              case 3:
                message.class_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventSendClassOwnership message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.EventSendClassOwnership} EventSendClassOwnership
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventSendClassOwnership.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventSendClassOwnership message.
         * @function verify
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventSendClassOwnership.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.sender != null && message.hasOwnProperty('sender'))
            if (!$util.isString(message.sender)) return 'sender: string expected';
          if (message.receiver != null && message.hasOwnProperty('receiver'))
            if (!$util.isString(message.receiver)) return 'receiver: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          return null;
        };

        /**
         * Creates an EventSendClassOwnership message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.EventSendClassOwnership} EventSendClassOwnership
         */
        EventSendClassOwnership.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.EventSendClassOwnership) return object;
          var message = new $root.ununifi.nftmint.EventSendClassOwnership();
          if (object.sender != null) message.sender = String(object.sender);
          if (object.receiver != null) message.receiver = String(object.receiver);
          if (object.class_id != null) message.class_id = String(object.class_id);
          return message;
        };

        /**
         * Creates a plain object from an EventSendClassOwnership message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @static
         * @param {ununifi.nftmint.EventSendClassOwnership} message EventSendClassOwnership
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventSendClassOwnership.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.sender = '';
            object.receiver = '';
            object.class_id = '';
          }
          if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
          if (message.receiver != null && message.hasOwnProperty('receiver')) object.receiver = message.receiver;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          return object;
        };

        /**
         * Converts this EventSendClassOwnership to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.EventSendClassOwnership
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventSendClassOwnership.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventSendClassOwnership;
      })();

      nftmint.EventUpdateBaseTokenUri = (function () {
        /**
         * Properties of an EventUpdateBaseTokenUri.
         * @memberof ununifi.nftmint
         * @interface IEventUpdateBaseTokenUri
         * @property {string|null} [owner] EventUpdateBaseTokenUri owner
         * @property {string|null} [class_id] EventUpdateBaseTokenUri class_id
         * @property {string|null} [base_token_uri] EventUpdateBaseTokenUri base_token_uri
         */

        /**
         * Constructs a new EventUpdateBaseTokenUri.
         * @memberof ununifi.nftmint
         * @classdesc Represents an EventUpdateBaseTokenUri.
         * @implements IEventUpdateBaseTokenUri
         * @constructor
         * @param {ununifi.nftmint.IEventUpdateBaseTokenUri=} [properties] Properties to set
         */
        function EventUpdateBaseTokenUri(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventUpdateBaseTokenUri owner.
         * @member {string} owner
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @instance
         */
        EventUpdateBaseTokenUri.prototype.owner = '';

        /**
         * EventUpdateBaseTokenUri class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @instance
         */
        EventUpdateBaseTokenUri.prototype.class_id = '';

        /**
         * EventUpdateBaseTokenUri base_token_uri.
         * @member {string} base_token_uri
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @instance
         */
        EventUpdateBaseTokenUri.prototype.base_token_uri = '';

        /**
         * Encodes the specified EventUpdateBaseTokenUri message. Does not implicitly {@link ununifi.nftmint.EventUpdateBaseTokenUri.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @static
         * @param {ununifi.nftmint.IEventUpdateBaseTokenUri} message EventUpdateBaseTokenUri message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventUpdateBaseTokenUri.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
          return writer;
        };

        /**
         * Encodes the specified EventUpdateBaseTokenUri message, length delimited. Does not implicitly {@link ununifi.nftmint.EventUpdateBaseTokenUri.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @static
         * @param {ununifi.nftmint.IEventUpdateBaseTokenUri} message EventUpdateBaseTokenUri message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventUpdateBaseTokenUri.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventUpdateBaseTokenUri message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.EventUpdateBaseTokenUri} EventUpdateBaseTokenUri
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventUpdateBaseTokenUri.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.EventUpdateBaseTokenUri();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.base_token_uri = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventUpdateBaseTokenUri message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.EventUpdateBaseTokenUri} EventUpdateBaseTokenUri
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventUpdateBaseTokenUri.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventUpdateBaseTokenUri message.
         * @function verify
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventUpdateBaseTokenUri.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
            if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
          return null;
        };

        /**
         * Creates an EventUpdateBaseTokenUri message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.EventUpdateBaseTokenUri} EventUpdateBaseTokenUri
         */
        EventUpdateBaseTokenUri.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.EventUpdateBaseTokenUri) return object;
          var message = new $root.ununifi.nftmint.EventUpdateBaseTokenUri();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
          return message;
        };

        /**
         * Creates a plain object from an EventUpdateBaseTokenUri message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @static
         * @param {ununifi.nftmint.EventUpdateBaseTokenUri} message EventUpdateBaseTokenUri
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventUpdateBaseTokenUri.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.base_token_uri = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
          return object;
        };

        /**
         * Converts this EventUpdateBaseTokenUri to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventUpdateBaseTokenUri.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventUpdateBaseTokenUri;
      })();

      nftmint.EventUpdateTokenSupplyCap = (function () {
        /**
         * Properties of an EventUpdateTokenSupplyCap.
         * @memberof ununifi.nftmint
         * @interface IEventUpdateTokenSupplyCap
         * @property {string|null} [owner] EventUpdateTokenSupplyCap owner
         * @property {string|null} [class_id] EventUpdateTokenSupplyCap class_id
         * @property {string|null} [token_supply_cap] EventUpdateTokenSupplyCap token_supply_cap
         */

        /**
         * Constructs a new EventUpdateTokenSupplyCap.
         * @memberof ununifi.nftmint
         * @classdesc Represents an EventUpdateTokenSupplyCap.
         * @implements IEventUpdateTokenSupplyCap
         * @constructor
         * @param {ununifi.nftmint.IEventUpdateTokenSupplyCap=} [properties] Properties to set
         */
        function EventUpdateTokenSupplyCap(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventUpdateTokenSupplyCap owner.
         * @member {string} owner
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @instance
         */
        EventUpdateTokenSupplyCap.prototype.owner = '';

        /**
         * EventUpdateTokenSupplyCap class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @instance
         */
        EventUpdateTokenSupplyCap.prototype.class_id = '';

        /**
         * EventUpdateTokenSupplyCap token_supply_cap.
         * @member {string} token_supply_cap
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @instance
         */
        EventUpdateTokenSupplyCap.prototype.token_supply_cap = '';

        /**
         * Encodes the specified EventUpdateTokenSupplyCap message. Does not implicitly {@link ununifi.nftmint.EventUpdateTokenSupplyCap.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @static
         * @param {ununifi.nftmint.IEventUpdateTokenSupplyCap} message EventUpdateTokenSupplyCap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventUpdateTokenSupplyCap.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_supply_cap);
          return writer;
        };

        /**
         * Encodes the specified EventUpdateTokenSupplyCap message, length delimited. Does not implicitly {@link ununifi.nftmint.EventUpdateTokenSupplyCap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @static
         * @param {ununifi.nftmint.IEventUpdateTokenSupplyCap} message EventUpdateTokenSupplyCap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventUpdateTokenSupplyCap.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventUpdateTokenSupplyCap message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.EventUpdateTokenSupplyCap} EventUpdateTokenSupplyCap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventUpdateTokenSupplyCap.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.EventUpdateTokenSupplyCap();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.owner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.token_supply_cap = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventUpdateTokenSupplyCap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.EventUpdateTokenSupplyCap} EventUpdateTokenSupplyCap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventUpdateTokenSupplyCap.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventUpdateTokenSupplyCap message.
         * @function verify
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventUpdateTokenSupplyCap.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            if (!$util.isString(message.token_supply_cap)) return 'token_supply_cap: string expected';
          return null;
        };

        /**
         * Creates an EventUpdateTokenSupplyCap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.EventUpdateTokenSupplyCap} EventUpdateTokenSupplyCap
         */
        EventUpdateTokenSupplyCap.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.EventUpdateTokenSupplyCap) return object;
          var message = new $root.ununifi.nftmint.EventUpdateTokenSupplyCap();
          if (object.owner != null) message.owner = String(object.owner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.token_supply_cap != null) message.token_supply_cap = String(object.token_supply_cap);
          return message;
        };

        /**
         * Creates a plain object from an EventUpdateTokenSupplyCap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @static
         * @param {ununifi.nftmint.EventUpdateTokenSupplyCap} message EventUpdateTokenSupplyCap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventUpdateTokenSupplyCap.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.owner = '';
            object.class_id = '';
            object.token_supply_cap = '';
          }
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
            object.token_supply_cap = message.token_supply_cap;
          return object;
        };

        /**
         * Converts this EventUpdateTokenSupplyCap to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventUpdateTokenSupplyCap.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventUpdateTokenSupplyCap;
      })();

      nftmint.EventMintNFT = (function () {
        /**
         * Properties of an EventMintNFT.
         * @memberof ununifi.nftmint
         * @interface IEventMintNFT
         * @property {string|null} [class_id] EventMintNFT class_id
         * @property {string|null} [nft_id] EventMintNFT nft_id
         * @property {string|null} [owner] EventMintNFT owner
         * @property {string|null} [minter] EventMintNFT minter
         */

        /**
         * Constructs a new EventMintNFT.
         * @memberof ununifi.nftmint
         * @classdesc Represents an EventMintNFT.
         * @implements IEventMintNFT
         * @constructor
         * @param {ununifi.nftmint.IEventMintNFT=} [properties] Properties to set
         */
        function EventMintNFT(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventMintNFT class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.EventMintNFT
         * @instance
         */
        EventMintNFT.prototype.class_id = '';

        /**
         * EventMintNFT nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmint.EventMintNFT
         * @instance
         */
        EventMintNFT.prototype.nft_id = '';

        /**
         * EventMintNFT owner.
         * @member {string} owner
         * @memberof ununifi.nftmint.EventMintNFT
         * @instance
         */
        EventMintNFT.prototype.owner = '';

        /**
         * EventMintNFT minter.
         * @member {string} minter
         * @memberof ununifi.nftmint.EventMintNFT
         * @instance
         */
        EventMintNFT.prototype.minter = '';

        /**
         * Encodes the specified EventMintNFT message. Does not implicitly {@link ununifi.nftmint.EventMintNFT.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.EventMintNFT
         * @static
         * @param {ununifi.nftmint.IEventMintNFT} message EventMintNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventMintNFT.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
          if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.owner);
          if (message.minter != null && Object.hasOwnProperty.call(message, 'minter'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.minter);
          return writer;
        };

        /**
         * Encodes the specified EventMintNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.EventMintNFT.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.EventMintNFT
         * @static
         * @param {ununifi.nftmint.IEventMintNFT} message EventMintNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventMintNFT message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.EventMintNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.EventMintNFT} EventMintNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventMintNFT.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.EventMintNFT();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.class_id = reader.string();
                break;
              case 2:
                message.nft_id = reader.string();
                break;
              case 3:
                message.owner = reader.string();
                break;
              case 4:
                message.minter = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventMintNFT message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.EventMintNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.EventMintNFT} EventMintNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventMintNFT.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventMintNFT message.
         * @function verify
         * @memberof ununifi.nftmint.EventMintNFT
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventMintNFT.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
          if (message.minter != null && message.hasOwnProperty('minter'))
            if (!$util.isString(message.minter)) return 'minter: string expected';
          return null;
        };

        /**
         * Creates an EventMintNFT message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.EventMintNFT
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.EventMintNFT} EventMintNFT
         */
        EventMintNFT.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.EventMintNFT) return object;
          var message = new $root.ununifi.nftmint.EventMintNFT();
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          if (object.owner != null) message.owner = String(object.owner);
          if (object.minter != null) message.minter = String(object.minter);
          return message;
        };

        /**
         * Creates a plain object from an EventMintNFT message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.EventMintNFT
         * @static
         * @param {ununifi.nftmint.EventMintNFT} message EventMintNFT
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventMintNFT.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.class_id = '';
            object.nft_id = '';
            object.owner = '';
            object.minter = '';
          }
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
          if (message.minter != null && message.hasOwnProperty('minter')) object.minter = message.minter;
          return object;
        };

        /**
         * Converts this EventMintNFT to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.EventMintNFT
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventMintNFT.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventMintNFT;
      })();

      nftmint.EventBurnNFT = (function () {
        /**
         * Properties of an EventBurnNFT.
         * @memberof ununifi.nftmint
         * @interface IEventBurnNFT
         * @property {string|null} [burner] EventBurnNFT burner
         * @property {string|null} [class_id] EventBurnNFT class_id
         * @property {string|null} [nft_id] EventBurnNFT nft_id
         */

        /**
         * Constructs a new EventBurnNFT.
         * @memberof ununifi.nftmint
         * @classdesc Represents an EventBurnNFT.
         * @implements IEventBurnNFT
         * @constructor
         * @param {ununifi.nftmint.IEventBurnNFT=} [properties] Properties to set
         */
        function EventBurnNFT(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventBurnNFT burner.
         * @member {string} burner
         * @memberof ununifi.nftmint.EventBurnNFT
         * @instance
         */
        EventBurnNFT.prototype.burner = '';

        /**
         * EventBurnNFT class_id.
         * @member {string} class_id
         * @memberof ununifi.nftmint.EventBurnNFT
         * @instance
         */
        EventBurnNFT.prototype.class_id = '';

        /**
         * EventBurnNFT nft_id.
         * @member {string} nft_id
         * @memberof ununifi.nftmint.EventBurnNFT
         * @instance
         */
        EventBurnNFT.prototype.nft_id = '';

        /**
         * Encodes the specified EventBurnNFT message. Does not implicitly {@link ununifi.nftmint.EventBurnNFT.verify|verify} messages.
         * @function encode
         * @memberof ununifi.nftmint.EventBurnNFT
         * @static
         * @param {ununifi.nftmint.IEventBurnNFT} message EventBurnNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventBurnNFT.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.burner != null && Object.hasOwnProperty.call(message, 'burner'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.burner);
          if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
          if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
          return writer;
        };

        /**
         * Encodes the specified EventBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.EventBurnNFT.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.nftmint.EventBurnNFT
         * @static
         * @param {ununifi.nftmint.IEventBurnNFT} message EventBurnNFT message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventBurnNFT message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.nftmint.EventBurnNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.nftmint.EventBurnNFT} EventBurnNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventBurnNFT.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.nftmint.EventBurnNFT();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.burner = reader.string();
                break;
              case 2:
                message.class_id = reader.string();
                break;
              case 3:
                message.nft_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventBurnNFT message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.nftmint.EventBurnNFT
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.nftmint.EventBurnNFT} EventBurnNFT
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventBurnNFT.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventBurnNFT message.
         * @function verify
         * @memberof ununifi.nftmint.EventBurnNFT
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventBurnNFT.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.burner != null && message.hasOwnProperty('burner'))
            if (!$util.isString(message.burner)) return 'burner: string expected';
          if (message.class_id != null && message.hasOwnProperty('class_id'))
            if (!$util.isString(message.class_id)) return 'class_id: string expected';
          if (message.nft_id != null && message.hasOwnProperty('nft_id'))
            if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
          return null;
        };

        /**
         * Creates an EventBurnNFT message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.nftmint.EventBurnNFT
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.nftmint.EventBurnNFT} EventBurnNFT
         */
        EventBurnNFT.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.nftmint.EventBurnNFT) return object;
          var message = new $root.ununifi.nftmint.EventBurnNFT();
          if (object.burner != null) message.burner = String(object.burner);
          if (object.class_id != null) message.class_id = String(object.class_id);
          if (object.nft_id != null) message.nft_id = String(object.nft_id);
          return message;
        };

        /**
         * Creates a plain object from an EventBurnNFT message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.nftmint.EventBurnNFT
         * @static
         * @param {ununifi.nftmint.EventBurnNFT} message EventBurnNFT
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventBurnNFT.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.burner = '';
            object.class_id = '';
            object.nft_id = '';
          }
          if (message.burner != null && message.hasOwnProperty('burner')) object.burner = message.burner;
          if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
          if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
          return object;
        };

        /**
         * Converts this EventBurnNFT to JSON.
         * @function toJSON
         * @memberof ununifi.nftmint.EventBurnNFT
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventBurnNFT.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventBurnNFT;
      })();

      return nftmint;
    })();

    ununifi.pricefeed = (function () {
      /**
       * Namespace pricefeed.
       * @memberof ununifi
       * @namespace
       */
      var pricefeed = {};

      pricefeed.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.pricefeed.Query#params}.
         * @memberof ununifi.pricefeed.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.pricefeed.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.pricefeed.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(
              params,
              $root.ununifi.pricefeed.QueryParamsRequest,
              $root.ununifi.pricefeed.QueryParamsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.pricefeed.QueryParamsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.pricefeed.Query#marketAll}.
         * @memberof ununifi.pricefeed.Query
         * @typedef MarketAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.pricefeed.QueryAllMarketResponse} [response] QueryAllMarketResponse
         */

        /**
         * Calls MarketAll.
         * @function marketAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
         * @param {ununifi.pricefeed.Query.MarketAllCallback} callback Node-style callback called with the error, if any, and QueryAllMarketResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.marketAll = function marketAll(request, callback) {
            return this.rpcCall(
              marketAll,
              $root.ununifi.pricefeed.QueryAllMarketRequest,
              $root.ununifi.pricefeed.QueryAllMarketResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'MarketAll' },
        );

        /**
         * Calls MarketAll.
         * @function marketAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
         * @returns {Promise<ununifi.pricefeed.QueryAllMarketResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.pricefeed.Query#oracleAll}.
         * @memberof ununifi.pricefeed.Query
         * @typedef OracleAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.pricefeed.QueryAllOracleResponse} [response] QueryAllOracleResponse
         */

        /**
         * Calls OracleAll.
         * @function oracleAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
         * @param {ununifi.pricefeed.Query.OracleAllCallback} callback Node-style callback called with the error, if any, and QueryAllOracleResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.oracleAll = function oracleAll(request, callback) {
            return this.rpcCall(
              oracleAll,
              $root.ununifi.pricefeed.QueryAllOracleRequest,
              $root.ununifi.pricefeed.QueryAllOracleResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'OracleAll' },
        );

        /**
         * Calls OracleAll.
         * @function oracleAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
         * @returns {Promise<ununifi.pricefeed.QueryAllOracleResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.pricefeed.Query#price}.
         * @memberof ununifi.pricefeed.Query
         * @typedef PriceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.pricefeed.QueryGetPriceResponse} [response] QueryGetPriceResponse
         */

        /**
         * Calls Price.
         * @function price
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
         * @param {ununifi.pricefeed.Query.PriceCallback} callback Node-style callback called with the error, if any, and QueryGetPriceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.price = function price(request, callback) {
            return this.rpcCall(
              price,
              $root.ununifi.pricefeed.QueryGetPriceRequest,
              $root.ununifi.pricefeed.QueryGetPriceResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Price' },
        );

        /**
         * Calls Price.
         * @function price
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
         * @returns {Promise<ununifi.pricefeed.QueryGetPriceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.pricefeed.Query#priceAll}.
         * @memberof ununifi.pricefeed.Query
         * @typedef PriceAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.pricefeed.QueryAllPriceResponse} [response] QueryAllPriceResponse
         */

        /**
         * Calls PriceAll.
         * @function priceAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
         * @param {ununifi.pricefeed.Query.PriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllPriceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.priceAll = function priceAll(request, callback) {
            return this.rpcCall(
              priceAll,
              $root.ununifi.pricefeed.QueryAllPriceRequest,
              $root.ununifi.pricefeed.QueryAllPriceResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'PriceAll' },
        );

        /**
         * Calls PriceAll.
         * @function priceAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
         * @returns {Promise<ununifi.pricefeed.QueryAllPriceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.pricefeed.Query#rawPriceAll}.
         * @memberof ununifi.pricefeed.Query
         * @typedef RawPriceAllCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.pricefeed.QueryAllRawPriceResponse} [response] QueryAllRawPriceResponse
         */

        /**
         * Calls RawPriceAll.
         * @function rawPriceAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
         * @param {ununifi.pricefeed.Query.RawPriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllRawPriceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.rawPriceAll = function rawPriceAll(request, callback) {
            return this.rpcCall(
              rawPriceAll,
              $root.ununifi.pricefeed.QueryAllRawPriceRequest,
              $root.ununifi.pricefeed.QueryAllRawPriceResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'RawPriceAll' },
        );

        /**
         * Calls RawPriceAll.
         * @function rawPriceAll
         * @memberof ununifi.pricefeed.Query
         * @instance
         * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
         * @returns {Promise<ununifi.pricefeed.QueryAllRawPriceResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      pricefeed.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.pricefeed
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.pricefeed.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @static
         * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @static
         * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryParamsRequest) return object;
          return new $root.ununifi.pricefeed.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @static
         * @param {ununifi.pricefeed.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      pricefeed.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.pricefeed
         * @interface IQueryParamsResponse
         * @property {ununifi.pricefeed.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.pricefeed.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.pricefeed.IParams|null|undefined} params
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @static
         * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @static
         * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.pricefeed.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryParamsResponse) return object;
          var message = new $root.ununifi.pricefeed.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.pricefeed.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @static
         * @param {ununifi.pricefeed.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      pricefeed.QueryAllMarketRequest = (function () {
        /**
         * Properties of a QueryAllMarketRequest.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllMarketRequest
         * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllMarketRequest pagination
         */

        /**
         * Constructs a new QueryAllMarketRequest.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllMarketRequest.
         * @implements IQueryAllMarketRequest
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllMarketRequest=} [properties] Properties to set
         */
        function QueryAllMarketRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllMarketRequest pagination.
         * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @instance
         */
        QueryAllMarketRequest.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllMarketRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllMarketRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageRequest.encode(
              message.pagination,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllMarketRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllMarketRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllMarketRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllMarketRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllMarketRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllMarketRequest message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllMarketRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllMarketRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
         */
        QueryAllMarketRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllMarketRequest) return object;
          var message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllMarketRequest.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllMarketRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @static
         * @param {ununifi.pricefeed.QueryAllMarketRequest} message QueryAllMarketRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllMarketRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.pagination = null;
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllMarketRequest to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllMarketRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllMarketRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllMarketRequest;
      })();

      pricefeed.QueryAllMarketResponse = (function () {
        /**
         * Properties of a QueryAllMarketResponse.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllMarketResponse
         * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] QueryAllMarketResponse markets
         * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllMarketResponse pagination
         */

        /**
         * Constructs a new QueryAllMarketResponse.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllMarketResponse.
         * @implements IQueryAllMarketResponse
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllMarketResponse=} [properties] Properties to set
         */
        function QueryAllMarketResponse(properties) {
          this.markets = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllMarketResponse markets.
         * @member {Array.<ununifi.pricefeed.IMarket>} markets
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @instance
         */
        QueryAllMarketResponse.prototype.markets = $util.emptyArray;

        /**
         * QueryAllMarketResponse pagination.
         * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @instance
         */
        QueryAllMarketResponse.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllMarketResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllMarketResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.markets != null && message.markets.length)
            for (var i = 0; i < message.markets.length; ++i)
              $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageResponse.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllMarketResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllMarketResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllMarketResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.markets && message.markets.length)) message.markets = [];
                message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllMarketResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllMarketResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllMarketResponse message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllMarketResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.markets != null && message.hasOwnProperty('markets')) {
            if (!Array.isArray(message.markets)) return 'markets: array expected';
            for (var i = 0; i < message.markets.length; ++i) {
              var error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
              if (error) return 'markets.' + error;
            }
          }
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllMarketResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
         */
        QueryAllMarketResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllMarketResponse) return object;
          var message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
          if (object.markets) {
            if (!Array.isArray(object.markets)) throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.markets: array expected');
            message.markets = [];
            for (var i = 0; i < object.markets.length; ++i) {
              if (typeof object.markets[i] !== 'object')
                throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.markets: object expected');
              message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
            }
          }
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllMarketResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @static
         * @param {ununifi.pricefeed.QueryAllMarketResponse} message QueryAllMarketResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllMarketResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.markets = [];
          if (options.defaults) object.pagination = null;
          if (message.markets && message.markets.length) {
            object.markets = [];
            for (var j = 0; j < message.markets.length; ++j)
              object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
          }
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllMarketResponse to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllMarketResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllMarketResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllMarketResponse;
      })();

      pricefeed.QueryAllOracleRequest = (function () {
        /**
         * Properties of a QueryAllOracleRequest.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllOracleRequest
         * @property {string|null} [market_id] QueryAllOracleRequest market_id
         * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllOracleRequest pagination
         */

        /**
         * Constructs a new QueryAllOracleRequest.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllOracleRequest.
         * @implements IQueryAllOracleRequest
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllOracleRequest=} [properties] Properties to set
         */
        function QueryAllOracleRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllOracleRequest market_id.
         * @member {string} market_id
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @instance
         */
        QueryAllOracleRequest.prototype.market_id = '';

        /**
         * QueryAllOracleRequest pagination.
         * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @instance
         */
        QueryAllOracleRequest.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllOracleRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllOracleRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageRequest.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllOracleRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllOracleRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllOracleRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllOracleRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.market_id = reader.string();
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllOracleRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllOracleRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllOracleRequest message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllOracleRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.market_id != null && message.hasOwnProperty('market_id'))
            if (!$util.isString(message.market_id)) return 'market_id: string expected';
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllOracleRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
         */
        QueryAllOracleRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllOracleRequest) return object;
          var message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
          if (object.market_id != null) message.market_id = String(object.market_id);
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllOracleRequest.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllOracleRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @static
         * @param {ununifi.pricefeed.QueryAllOracleRequest} message QueryAllOracleRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllOracleRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.market_id = '';
            object.pagination = null;
          }
          if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllOracleRequest to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllOracleRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllOracleRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllOracleRequest;
      })();

      pricefeed.QueryAllOracleResponse = (function () {
        /**
         * Properties of a QueryAllOracleResponse.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllOracleResponse
         * @property {Array.<string>|null} [oracles] QueryAllOracleResponse oracles
         * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllOracleResponse pagination
         */

        /**
         * Constructs a new QueryAllOracleResponse.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllOracleResponse.
         * @implements IQueryAllOracleResponse
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllOracleResponse=} [properties] Properties to set
         */
        function QueryAllOracleResponse(properties) {
          this.oracles = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllOracleResponse oracles.
         * @member {Array.<string>} oracles
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @instance
         */
        QueryAllOracleResponse.prototype.oracles = $util.emptyArray;

        /**
         * QueryAllOracleResponse pagination.
         * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @instance
         */
        QueryAllOracleResponse.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllOracleResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllOracleResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.oracles != null && message.oracles.length)
            for (var i = 0; i < message.oracles.length; ++i) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.oracles[i]);
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageResponse.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllOracleResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllOracleResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllOracleResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllOracleResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.oracles && message.oracles.length)) message.oracles = [];
                message.oracles.push(reader.string());
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllOracleResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllOracleResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllOracleResponse message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllOracleResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.oracles != null && message.hasOwnProperty('oracles')) {
            if (!Array.isArray(message.oracles)) return 'oracles: array expected';
            for (var i = 0; i < message.oracles.length; ++i) if (!$util.isString(message.oracles[i])) return 'oracles: string[] expected';
          }
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllOracleResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
         */
        QueryAllOracleResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllOracleResponse) return object;
          var message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
          if (object.oracles) {
            if (!Array.isArray(object.oracles)) throw TypeError('.ununifi.pricefeed.QueryAllOracleResponse.oracles: array expected');
            message.oracles = [];
            for (var i = 0; i < object.oracles.length; ++i) message.oracles[i] = String(object.oracles[i]);
          }
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllOracleResponse.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllOracleResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @static
         * @param {ununifi.pricefeed.QueryAllOracleResponse} message QueryAllOracleResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllOracleResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.oracles = [];
          if (options.defaults) object.pagination = null;
          if (message.oracles && message.oracles.length) {
            object.oracles = [];
            for (var j = 0; j < message.oracles.length; ++j) object.oracles[j] = message.oracles[j];
          }
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllOracleResponse to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllOracleResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllOracleResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllOracleResponse;
      })();

      pricefeed.QueryGetPriceRequest = (function () {
        /**
         * Properties of a QueryGetPriceRequest.
         * @memberof ununifi.pricefeed
         * @interface IQueryGetPriceRequest
         * @property {string|null} [market_id] QueryGetPriceRequest market_id
         */

        /**
         * Constructs a new QueryGetPriceRequest.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryGetPriceRequest.
         * @implements IQueryGetPriceRequest
         * @constructor
         * @param {ununifi.pricefeed.IQueryGetPriceRequest=} [properties] Properties to set
         */
        function QueryGetPriceRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGetPriceRequest market_id.
         * @member {string} market_id
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @instance
         */
        QueryGetPriceRequest.prototype.market_id = '';

        /**
         * Encodes the specified QueryGetPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @static
         * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetPriceRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
          return writer;
        };

        /**
         * Encodes the specified QueryGetPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @static
         * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetPriceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetPriceRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.market_id = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetPriceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetPriceRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetPriceRequest message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetPriceRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.market_id != null && message.hasOwnProperty('market_id'))
            if (!$util.isString(message.market_id)) return 'market_id: string expected';
          return null;
        };

        /**
         * Creates a QueryGetPriceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
         */
        QueryGetPriceRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryGetPriceRequest) return object;
          var message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
          if (object.market_id != null) message.market_id = String(object.market_id);
          return message;
        };

        /**
         * Creates a plain object from a QueryGetPriceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @static
         * @param {ununifi.pricefeed.QueryGetPriceRequest} message QueryGetPriceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetPriceRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.market_id = '';
          if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
          return object;
        };

        /**
         * Converts this QueryGetPriceRequest to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryGetPriceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetPriceRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetPriceRequest;
      })();

      pricefeed.QueryGetPriceResponse = (function () {
        /**
         * Properties of a QueryGetPriceResponse.
         * @memberof ununifi.pricefeed
         * @interface IQueryGetPriceResponse
         * @property {ununifi.pricefeed.ICurrentPrice|null} [price] QueryGetPriceResponse price
         */

        /**
         * Constructs a new QueryGetPriceResponse.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryGetPriceResponse.
         * @implements IQueryGetPriceResponse
         * @constructor
         * @param {ununifi.pricefeed.IQueryGetPriceResponse=} [properties] Properties to set
         */
        function QueryGetPriceResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGetPriceResponse price.
         * @member {ununifi.pricefeed.ICurrentPrice|null|undefined} price
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @instance
         */
        QueryGetPriceResponse.prototype.price = null;

        /**
         * Encodes the specified QueryGetPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @static
         * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetPriceResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
            $root.ununifi.pricefeed.CurrentPrice.encode(message.price, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryGetPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @static
         * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetPriceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetPriceResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.price = $root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetPriceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetPriceResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetPriceResponse message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetPriceResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.price != null && message.hasOwnProperty('price')) {
            var error = $root.ununifi.pricefeed.CurrentPrice.verify(message.price);
            if (error) return 'price.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryGetPriceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
         */
        QueryGetPriceResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryGetPriceResponse) return object;
          var message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
          if (object.price != null) {
            if (typeof object.price !== 'object') throw TypeError('.ununifi.pricefeed.QueryGetPriceResponse.price: object expected');
            message.price = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.price);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryGetPriceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @static
         * @param {ununifi.pricefeed.QueryGetPriceResponse} message QueryGetPriceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetPriceResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.price = null;
          if (message.price != null && message.hasOwnProperty('price'))
            object.price = $root.ununifi.pricefeed.CurrentPrice.toObject(message.price, options);
          return object;
        };

        /**
         * Converts this QueryGetPriceResponse to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryGetPriceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetPriceResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetPriceResponse;
      })();

      pricefeed.QueryAllPriceRequest = (function () {
        /**
         * Properties of a QueryAllPriceRequest.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllPriceRequest
         * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllPriceRequest pagination
         */

        /**
         * Constructs a new QueryAllPriceRequest.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllPriceRequest.
         * @implements IQueryAllPriceRequest
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllPriceRequest=} [properties] Properties to set
         */
        function QueryAllPriceRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllPriceRequest pagination.
         * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @instance
         */
        QueryAllPriceRequest.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllPriceRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageRequest.encode(
              message.pagination,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllPriceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllPriceRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllPriceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllPriceRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllPriceRequest message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllPriceRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllPriceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
         */
        QueryAllPriceRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllPriceRequest) return object;
          var message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllPriceRequest.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllPriceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @static
         * @param {ununifi.pricefeed.QueryAllPriceRequest} message QueryAllPriceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllPriceRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.pagination = null;
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllPriceRequest to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllPriceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllPriceRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllPriceRequest;
      })();

      pricefeed.QueryAllPriceResponse = (function () {
        /**
         * Properties of a QueryAllPriceResponse.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllPriceResponse
         * @property {Array.<ununifi.pricefeed.ICurrentPrice>|null} [prices] QueryAllPriceResponse prices
         * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllPriceResponse pagination
         */

        /**
         * Constructs a new QueryAllPriceResponse.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllPriceResponse.
         * @implements IQueryAllPriceResponse
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllPriceResponse=} [properties] Properties to set
         */
        function QueryAllPriceResponse(properties) {
          this.prices = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllPriceResponse prices.
         * @member {Array.<ununifi.pricefeed.ICurrentPrice>} prices
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @instance
         */
        QueryAllPriceResponse.prototype.prices = $util.emptyArray;

        /**
         * QueryAllPriceResponse pagination.
         * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @instance
         */
        QueryAllPriceResponse.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllPriceResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.prices != null && message.prices.length)
            for (var i = 0; i < message.prices.length; ++i)
              $root.ununifi.pricefeed.CurrentPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageResponse.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllPriceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllPriceResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.prices && message.prices.length)) message.prices = [];
                message.prices.push($root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32()));
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllPriceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllPriceResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllPriceResponse message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllPriceResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.prices != null && message.hasOwnProperty('prices')) {
            if (!Array.isArray(message.prices)) return 'prices: array expected';
            for (var i = 0; i < message.prices.length; ++i) {
              var error = $root.ununifi.pricefeed.CurrentPrice.verify(message.prices[i]);
              if (error) return 'prices.' + error;
            }
          }
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllPriceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
         */
        QueryAllPriceResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllPriceResponse) return object;
          var message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
          if (object.prices) {
            if (!Array.isArray(object.prices)) throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.prices: array expected');
            message.prices = [];
            for (var i = 0; i < object.prices.length; ++i) {
              if (typeof object.prices[i] !== 'object') throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.prices: object expected');
              message.prices[i] = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.prices[i]);
            }
          }
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllPriceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @static
         * @param {ununifi.pricefeed.QueryAllPriceResponse} message QueryAllPriceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllPriceResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.prices = [];
          if (options.defaults) object.pagination = null;
          if (message.prices && message.prices.length) {
            object.prices = [];
            for (var j = 0; j < message.prices.length; ++j)
              object.prices[j] = $root.ununifi.pricefeed.CurrentPrice.toObject(message.prices[j], options);
          }
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllPriceResponse to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllPriceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllPriceResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllPriceResponse;
      })();

      pricefeed.QueryAllRawPriceRequest = (function () {
        /**
         * Properties of a QueryAllRawPriceRequest.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllRawPriceRequest
         * @property {string|null} [market_id] QueryAllRawPriceRequest market_id
         * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllRawPriceRequest pagination
         */

        /**
         * Constructs a new QueryAllRawPriceRequest.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllRawPriceRequest.
         * @implements IQueryAllRawPriceRequest
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllRawPriceRequest=} [properties] Properties to set
         */
        function QueryAllRawPriceRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllRawPriceRequest market_id.
         * @member {string} market_id
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @instance
         */
        QueryAllRawPriceRequest.prototype.market_id = '';

        /**
         * QueryAllRawPriceRequest pagination.
         * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @instance
         */
        QueryAllRawPriceRequest.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllRawPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRawPriceRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageRequest.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllRawPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @static
         * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRawPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRawPriceRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.market_id = reader.string();
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRawPriceRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllRawPriceRequest message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllRawPriceRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.market_id != null && message.hasOwnProperty('market_id'))
            if (!$util.isString(message.market_id)) return 'market_id: string expected';
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllRawPriceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
         */
        QueryAllRawPriceRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceRequest) return object;
          var message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
          if (object.market_id != null) message.market_id = String(object.market_id);
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllRawPriceRequest.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllRawPriceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @static
         * @param {ununifi.pricefeed.QueryAllRawPriceRequest} message QueryAllRawPriceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllRawPriceRequest.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.market_id = '';
            object.pagination = null;
          }
          if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllRawPriceRequest to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllRawPriceRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllRawPriceRequest;
      })();

      pricefeed.QueryAllRawPriceResponse = (function () {
        /**
         * Properties of a QueryAllRawPriceResponse.
         * @memberof ununifi.pricefeed
         * @interface IQueryAllRawPriceResponse
         * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [prices] QueryAllRawPriceResponse prices
         * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllRawPriceResponse pagination
         */

        /**
         * Constructs a new QueryAllRawPriceResponse.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a QueryAllRawPriceResponse.
         * @implements IQueryAllRawPriceResponse
         * @constructor
         * @param {ununifi.pricefeed.IQueryAllRawPriceResponse=} [properties] Properties to set
         */
        function QueryAllRawPriceResponse(properties) {
          this.prices = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryAllRawPriceResponse prices.
         * @member {Array.<ununifi.pricefeed.IPostedPrice>} prices
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @instance
         */
        QueryAllRawPriceResponse.prototype.prices = $util.emptyArray;

        /**
         * QueryAllRawPriceResponse pagination.
         * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @instance
         */
        QueryAllRawPriceResponse.prototype.pagination = null;

        /**
         * Encodes the specified QueryAllRawPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRawPriceResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.prices != null && message.prices.length)
            for (var i = 0; i < message.prices.length; ++i)
              $root.ununifi.pricefeed.PostedPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
            $root.cosmos.base.query.v1beta1.PageResponse.encode(
              message.pagination,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryAllRawPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @static
         * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryAllRawPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRawPriceResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.prices && message.prices.length)) message.prices = [];
                message.prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
                break;
              case 2:
                message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryAllRawPriceResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryAllRawPriceResponse message.
         * @function verify
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryAllRawPriceResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.prices != null && message.hasOwnProperty('prices')) {
            if (!Array.isArray(message.prices)) return 'prices: array expected';
            for (var i = 0; i < message.prices.length; ++i) {
              var error = $root.ununifi.pricefeed.PostedPrice.verify(message.prices[i]);
              if (error) return 'prices.' + error;
            }
          }
          if (message.pagination != null && message.hasOwnProperty('pagination')) {
            var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
            if (error) return 'pagination.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryAllRawPriceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
         */
        QueryAllRawPriceResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceResponse) return object;
          var message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
          if (object.prices) {
            if (!Array.isArray(object.prices)) throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.prices: array expected');
            message.prices = [];
            for (var i = 0; i < object.prices.length; ++i) {
              if (typeof object.prices[i] !== 'object')
                throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.prices: object expected');
              message.prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.prices[i]);
            }
          }
          if (object.pagination != null) {
            if (typeof object.pagination !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.pagination: object expected');
            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryAllRawPriceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @static
         * @param {ununifi.pricefeed.QueryAllRawPriceResponse} message QueryAllRawPriceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryAllRawPriceResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.prices = [];
          if (options.defaults) object.pagination = null;
          if (message.prices && message.prices.length) {
            object.prices = [];
            for (var j = 0; j < message.prices.length; ++j)
              object.prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.prices[j], options);
          }
          if (message.pagination != null && message.hasOwnProperty('pagination'))
            object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
          return object;
        };

        /**
         * Converts this QueryAllRawPriceResponse to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryAllRawPriceResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryAllRawPriceResponse;
      })();

      pricefeed.Market = (function () {
        /**
         * Properties of a Market.
         * @memberof ununifi.pricefeed
         * @interface IMarket
         * @property {string|null} [market_id] Market market_id
         * @property {string|null} [base_asset] Market base_asset
         * @property {string|null} [quote_asset] Market quote_asset
         * @property {Array.<string>|null} [oracles] Market oracles
         * @property {boolean|null} [active] Market active
         */

        /**
         * Constructs a new Market.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a Market.
         * @implements IMarket
         * @constructor
         * @param {ununifi.pricefeed.IMarket=} [properties] Properties to set
         */
        function Market(properties) {
          this.oracles = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Market market_id.
         * @member {string} market_id
         * @memberof ununifi.pricefeed.Market
         * @instance
         */
        Market.prototype.market_id = '';

        /**
         * Market base_asset.
         * @member {string} base_asset
         * @memberof ununifi.pricefeed.Market
         * @instance
         */
        Market.prototype.base_asset = '';

        /**
         * Market quote_asset.
         * @member {string} quote_asset
         * @memberof ununifi.pricefeed.Market
         * @instance
         */
        Market.prototype.quote_asset = '';

        /**
         * Market oracles.
         * @member {Array.<string>} oracles
         * @memberof ununifi.pricefeed.Market
         * @instance
         */
        Market.prototype.oracles = $util.emptyArray;

        /**
         * Market active.
         * @member {boolean} active
         * @memberof ununifi.pricefeed.Market
         * @instance
         */
        Market.prototype.active = false;

        /**
         * Encodes the specified Market message. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.Market
         * @static
         * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Market.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
          if (message.base_asset != null && Object.hasOwnProperty.call(message, 'base_asset'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.base_asset);
          if (message.quote_asset != null && Object.hasOwnProperty.call(message, 'quote_asset'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.quote_asset);
          if (message.oracles != null && message.oracles.length)
            for (var i = 0; i < message.oracles.length; ++i) writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.oracles[i]);
          if (message.active != null && Object.hasOwnProperty.call(message, 'active'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.active);
          return writer;
        };

        /**
         * Encodes the specified Market message, length delimited. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.Market
         * @static
         * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Market.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Market message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.Market
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.Market} Market
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Market.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.Market();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.market_id = reader.string();
                break;
              case 2:
                message.base_asset = reader.string();
                break;
              case 3:
                message.quote_asset = reader.string();
                break;
              case 4:
                if (!(message.oracles && message.oracles.length)) message.oracles = [];
                message.oracles.push(reader.string());
                break;
              case 5:
                message.active = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Market message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.Market
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.Market} Market
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Market.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Market message.
         * @function verify
         * @memberof ununifi.pricefeed.Market
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Market.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.market_id != null && message.hasOwnProperty('market_id'))
            if (!$util.isString(message.market_id)) return 'market_id: string expected';
          if (message.base_asset != null && message.hasOwnProperty('base_asset'))
            if (!$util.isString(message.base_asset)) return 'base_asset: string expected';
          if (message.quote_asset != null && message.hasOwnProperty('quote_asset'))
            if (!$util.isString(message.quote_asset)) return 'quote_asset: string expected';
          if (message.oracles != null && message.hasOwnProperty('oracles')) {
            if (!Array.isArray(message.oracles)) return 'oracles: array expected';
            for (var i = 0; i < message.oracles.length; ++i) if (!$util.isString(message.oracles[i])) return 'oracles: string[] expected';
          }
          if (message.active != null && message.hasOwnProperty('active'))
            if (typeof message.active !== 'boolean') return 'active: boolean expected';
          return null;
        };

        /**
         * Creates a Market message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.Market
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.Market} Market
         */
        Market.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.Market) return object;
          var message = new $root.ununifi.pricefeed.Market();
          if (object.market_id != null) message.market_id = String(object.market_id);
          if (object.base_asset != null) message.base_asset = String(object.base_asset);
          if (object.quote_asset != null) message.quote_asset = String(object.quote_asset);
          if (object.oracles) {
            if (!Array.isArray(object.oracles)) throw TypeError('.ununifi.pricefeed.Market.oracles: array expected');
            message.oracles = [];
            for (var i = 0; i < object.oracles.length; ++i) message.oracles[i] = String(object.oracles[i]);
          }
          if (object.active != null) message.active = Boolean(object.active);
          return message;
        };

        /**
         * Creates a plain object from a Market message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.Market
         * @static
         * @param {ununifi.pricefeed.Market} message Market
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Market.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.oracles = [];
          if (options.defaults) {
            object.market_id = '';
            object.base_asset = '';
            object.quote_asset = '';
            object.active = false;
          }
          if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
          if (message.base_asset != null && message.hasOwnProperty('base_asset')) object.base_asset = message.base_asset;
          if (message.quote_asset != null && message.hasOwnProperty('quote_asset')) object.quote_asset = message.quote_asset;
          if (message.oracles && message.oracles.length) {
            object.oracles = [];
            for (var j = 0; j < message.oracles.length; ++j) object.oracles[j] = message.oracles[j];
          }
          if (message.active != null && message.hasOwnProperty('active')) object.active = message.active;
          return object;
        };

        /**
         * Converts this Market to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.Market
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Market.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Market;
      })();

      pricefeed.CurrentPrice = (function () {
        /**
         * Properties of a CurrentPrice.
         * @memberof ununifi.pricefeed
         * @interface ICurrentPrice
         * @property {string|null} [market_id] CurrentPrice market_id
         * @property {string|null} [price] CurrentPrice price
         */

        /**
         * Constructs a new CurrentPrice.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a CurrentPrice.
         * @implements ICurrentPrice
         * @constructor
         * @param {ununifi.pricefeed.ICurrentPrice=} [properties] Properties to set
         */
        function CurrentPrice(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * CurrentPrice market_id.
         * @member {string} market_id
         * @memberof ununifi.pricefeed.CurrentPrice
         * @instance
         */
        CurrentPrice.prototype.market_id = '';

        /**
         * CurrentPrice price.
         * @member {string} price
         * @memberof ununifi.pricefeed.CurrentPrice
         * @instance
         */
        CurrentPrice.prototype.price = '';

        /**
         * Encodes the specified CurrentPrice message. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.CurrentPrice
         * @static
         * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentPrice.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
          if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.price);
          return writer;
        };

        /**
         * Encodes the specified CurrentPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.CurrentPrice
         * @static
         * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentPrice.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CurrentPrice message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.CurrentPrice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentPrice.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.CurrentPrice();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.market_id = reader.string();
                break;
              case 2:
                message.price = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a CurrentPrice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.CurrentPrice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentPrice.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CurrentPrice message.
         * @function verify
         * @memberof ununifi.pricefeed.CurrentPrice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CurrentPrice.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.market_id != null && message.hasOwnProperty('market_id'))
            if (!$util.isString(message.market_id)) return 'market_id: string expected';
          if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
          return null;
        };

        /**
         * Creates a CurrentPrice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.CurrentPrice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
         */
        CurrentPrice.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.CurrentPrice) return object;
          var message = new $root.ununifi.pricefeed.CurrentPrice();
          if (object.market_id != null) message.market_id = String(object.market_id);
          if (object.price != null) message.price = String(object.price);
          return message;
        };

        /**
         * Creates a plain object from a CurrentPrice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.CurrentPrice
         * @static
         * @param {ununifi.pricefeed.CurrentPrice} message CurrentPrice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CurrentPrice.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.market_id = '';
            object.price = '';
          }
          if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
          if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
          return object;
        };

        /**
         * Converts this CurrentPrice to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.CurrentPrice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CurrentPrice.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CurrentPrice;
      })();

      pricefeed.PostedPrice = (function () {
        /**
         * Properties of a PostedPrice.
         * @memberof ununifi.pricefeed
         * @interface IPostedPrice
         * @property {string|null} [market_id] PostedPrice market_id
         * @property {string|null} [oracle_address] PostedPrice oracle_address
         * @property {string|null} [price] PostedPrice price
         * @property {google.protobuf.ITimestamp|null} [expiry] PostedPrice expiry
         */

        /**
         * Constructs a new PostedPrice.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a PostedPrice.
         * @implements IPostedPrice
         * @constructor
         * @param {ununifi.pricefeed.IPostedPrice=} [properties] Properties to set
         */
        function PostedPrice(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostedPrice market_id.
         * @member {string} market_id
         * @memberof ununifi.pricefeed.PostedPrice
         * @instance
         */
        PostedPrice.prototype.market_id = '';

        /**
         * PostedPrice oracle_address.
         * @member {string} oracle_address
         * @memberof ununifi.pricefeed.PostedPrice
         * @instance
         */
        PostedPrice.prototype.oracle_address = '';

        /**
         * PostedPrice price.
         * @member {string} price
         * @memberof ununifi.pricefeed.PostedPrice
         * @instance
         */
        PostedPrice.prototype.price = '';

        /**
         * PostedPrice expiry.
         * @member {google.protobuf.ITimestamp|null|undefined} expiry
         * @memberof ununifi.pricefeed.PostedPrice
         * @instance
         */
        PostedPrice.prototype.expiry = null;

        /**
         * Encodes the specified PostedPrice message. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.PostedPrice
         * @static
         * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostedPrice.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
          if (message.oracle_address != null && Object.hasOwnProperty.call(message, 'oracle_address'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.oracle_address);
          if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
          if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
            $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified PostedPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.PostedPrice
         * @static
         * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostedPrice.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostedPrice message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.PostedPrice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostedPrice.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.PostedPrice();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.market_id = reader.string();
                break;
              case 2:
                message.oracle_address = reader.string();
                break;
              case 3:
                message.price = reader.string();
                break;
              case 4:
                message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a PostedPrice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.PostedPrice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostedPrice.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostedPrice message.
         * @function verify
         * @memberof ununifi.pricefeed.PostedPrice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostedPrice.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.market_id != null && message.hasOwnProperty('market_id'))
            if (!$util.isString(message.market_id)) return 'market_id: string expected';
          if (message.oracle_address != null && message.hasOwnProperty('oracle_address'))
            if (!$util.isString(message.oracle_address)) return 'oracle_address: string expected';
          if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
          if (message.expiry != null && message.hasOwnProperty('expiry')) {
            var error = $root.google.protobuf.Timestamp.verify(message.expiry);
            if (error) return 'expiry.' + error;
          }
          return null;
        };

        /**
         * Creates a PostedPrice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.PostedPrice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
         */
        PostedPrice.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.PostedPrice) return object;
          var message = new $root.ununifi.pricefeed.PostedPrice();
          if (object.market_id != null) message.market_id = String(object.market_id);
          if (object.oracle_address != null) message.oracle_address = String(object.oracle_address);
          if (object.price != null) message.price = String(object.price);
          if (object.expiry != null) {
            if (typeof object.expiry !== 'object') throw TypeError('.ununifi.pricefeed.PostedPrice.expiry: object expected');
            message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
          }
          return message;
        };

        /**
         * Creates a plain object from a PostedPrice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.PostedPrice
         * @static
         * @param {ununifi.pricefeed.PostedPrice} message PostedPrice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostedPrice.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.market_id = '';
            object.oracle_address = '';
            object.price = '';
            object.expiry = null;
          }
          if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
          if (message.oracle_address != null && message.hasOwnProperty('oracle_address')) object.oracle_address = message.oracle_address;
          if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
          if (message.expiry != null && message.hasOwnProperty('expiry'))
            object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
          return object;
        };

        /**
         * Converts this PostedPrice to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.PostedPrice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostedPrice.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PostedPrice;
      })();

      pricefeed.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.pricefeed
         * @interface IParams
         * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] Params markets
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.pricefeed.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          this.markets = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params markets.
         * @member {Array.<ununifi.pricefeed.IMarket>} markets
         * @memberof ununifi.pricefeed.Params
         * @instance
         */
        Params.prototype.markets = $util.emptyArray;

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.Params
         * @static
         * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.markets != null && message.markets.length)
            for (var i = 0; i < message.markets.length; ++i)
              $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.Params
         * @static
         * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.markets && message.markets.length)) message.markets = [];
                message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.pricefeed.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.markets != null && message.hasOwnProperty('markets')) {
            if (!Array.isArray(message.markets)) return 'markets: array expected';
            for (var i = 0; i < message.markets.length; ++i) {
              var error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
              if (error) return 'markets.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.Params) return object;
          var message = new $root.ununifi.pricefeed.Params();
          if (object.markets) {
            if (!Array.isArray(object.markets)) throw TypeError('.ununifi.pricefeed.Params.markets: array expected');
            message.markets = [];
            for (var i = 0; i < object.markets.length; ++i) {
              if (typeof object.markets[i] !== 'object') throw TypeError('.ununifi.pricefeed.Params.markets: object expected');
              message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.Params
         * @static
         * @param {ununifi.pricefeed.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.markets = [];
          if (message.markets && message.markets.length) {
            object.markets = [];
            for (var j = 0; j < message.markets.length; ++j)
              object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
          }
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      pricefeed.Msg = (function () {
        /**
         * Constructs a new Msg service.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a Msg
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Msg(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

        /**
         * Callback as used by {@link ununifi.pricefeed.Msg#postPrice}.
         * @memberof ununifi.pricefeed.Msg
         * @typedef PostPriceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.pricefeed.MsgPostPriceResponse} [response] MsgPostPriceResponse
         */

        /**
         * Calls PostPrice.
         * @function postPrice
         * @memberof ununifi.pricefeed.Msg
         * @instance
         * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
         * @param {ununifi.pricefeed.Msg.PostPriceCallback} callback Node-style callback called with the error, if any, and MsgPostPriceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Msg.prototype.postPrice = function postPrice(request, callback) {
            return this.rpcCall(
              postPrice,
              $root.ununifi.pricefeed.MsgPostPrice,
              $root.ununifi.pricefeed.MsgPostPriceResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'PostPrice' },
        );

        /**
         * Calls PostPrice.
         * @function postPrice
         * @memberof ununifi.pricefeed.Msg
         * @instance
         * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
         * @returns {Promise<ununifi.pricefeed.MsgPostPriceResponse>} Promise
         * @variation 2
         */

        return Msg;
      })();

      pricefeed.MsgPostPrice = (function () {
        /**
         * Properties of a MsgPostPrice.
         * @memberof ununifi.pricefeed
         * @interface IMsgPostPrice
         * @property {string|null} [from] MsgPostPrice from
         * @property {string|null} [market_id] MsgPostPrice market_id
         * @property {string|null} [price] MsgPostPrice price
         * @property {google.protobuf.ITimestamp|null} [expiry] MsgPostPrice expiry
         */

        /**
         * Constructs a new MsgPostPrice.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a MsgPostPrice.
         * @implements IMsgPostPrice
         * @constructor
         * @param {ununifi.pricefeed.IMsgPostPrice=} [properties] Properties to set
         */
        function MsgPostPrice(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgPostPrice from.
         * @member {string} from
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @instance
         */
        MsgPostPrice.prototype.from = '';

        /**
         * MsgPostPrice market_id.
         * @member {string} market_id
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @instance
         */
        MsgPostPrice.prototype.market_id = '';

        /**
         * MsgPostPrice price.
         * @member {string} price
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @instance
         */
        MsgPostPrice.prototype.price = '';

        /**
         * MsgPostPrice expiry.
         * @member {google.protobuf.ITimestamp|null|undefined} expiry
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @instance
         */
        MsgPostPrice.prototype.expiry = null;

        /**
         * Encodes the specified MsgPostPrice message. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @static
         * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPostPrice.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.from != null && Object.hasOwnProperty.call(message, 'from'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.from);
          if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.market_id);
          if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
          if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
            $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MsgPostPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @static
         * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPostPrice.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPostPrice message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPostPrice.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.MsgPostPrice();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.from = reader.string();
                break;
              case 2:
                message.market_id = reader.string();
                break;
              case 3:
                message.price = reader.string();
                break;
              case 4:
                message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPostPrice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPostPrice.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPostPrice message.
         * @function verify
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPostPrice.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.from != null && message.hasOwnProperty('from')) if (!$util.isString(message.from)) return 'from: string expected';
          if (message.market_id != null && message.hasOwnProperty('market_id'))
            if (!$util.isString(message.market_id)) return 'market_id: string expected';
          if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
          if (message.expiry != null && message.hasOwnProperty('expiry')) {
            var error = $root.google.protobuf.Timestamp.verify(message.expiry);
            if (error) return 'expiry.' + error;
          }
          return null;
        };

        /**
         * Creates a MsgPostPrice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
         */
        MsgPostPrice.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.MsgPostPrice) return object;
          var message = new $root.ununifi.pricefeed.MsgPostPrice();
          if (object.from != null) message.from = String(object.from);
          if (object.market_id != null) message.market_id = String(object.market_id);
          if (object.price != null) message.price = String(object.price);
          if (object.expiry != null) {
            if (typeof object.expiry !== 'object') throw TypeError('.ununifi.pricefeed.MsgPostPrice.expiry: object expected');
            message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
          }
          return message;
        };

        /**
         * Creates a plain object from a MsgPostPrice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @static
         * @param {ununifi.pricefeed.MsgPostPrice} message MsgPostPrice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPostPrice.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.from = '';
            object.market_id = '';
            object.price = '';
            object.expiry = null;
          }
          if (message.from != null && message.hasOwnProperty('from')) object.from = message.from;
          if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
          if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
          if (message.expiry != null && message.hasOwnProperty('expiry'))
            object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
          return object;
        };

        /**
         * Converts this MsgPostPrice to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.MsgPostPrice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPostPrice.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPostPrice;
      })();

      pricefeed.MsgPostPriceResponse = (function () {
        /**
         * Properties of a MsgPostPriceResponse.
         * @memberof ununifi.pricefeed
         * @interface IMsgPostPriceResponse
         */

        /**
         * Constructs a new MsgPostPriceResponse.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a MsgPostPriceResponse.
         * @implements IMsgPostPriceResponse
         * @constructor
         * @param {ununifi.pricefeed.IMsgPostPriceResponse=} [properties] Properties to set
         */
        function MsgPostPriceResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MsgPostPriceResponse message. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @static
         * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPostPriceResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified MsgPostPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @static
         * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgPostPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgPostPriceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPostPriceResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.MsgPostPriceResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MsgPostPriceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgPostPriceResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgPostPriceResponse message.
         * @function verify
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgPostPriceResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a MsgPostPriceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
         */
        MsgPostPriceResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.MsgPostPriceResponse) return object;
          return new $root.ununifi.pricefeed.MsgPostPriceResponse();
        };

        /**
         * Creates a plain object from a MsgPostPriceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @static
         * @param {ununifi.pricefeed.MsgPostPriceResponse} message MsgPostPriceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgPostPriceResponse.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this MsgPostPriceResponse to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.MsgPostPriceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgPostPriceResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgPostPriceResponse;
      })();

      pricefeed.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.pricefeed
         * @interface IGenesisState
         * @property {ununifi.pricefeed.IParams|null} [params] GenesisState params
         * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [posted_prices] GenesisState posted_prices
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.pricefeed
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.pricefeed.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          this.posted_prices = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState params.
         * @member {ununifi.pricefeed.IParams|null|undefined} params
         * @memberof ununifi.pricefeed.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * GenesisState posted_prices.
         * @member {Array.<ununifi.pricefeed.IPostedPrice>} posted_prices
         * @memberof ununifi.pricefeed.GenesisState
         * @instance
         */
        GenesisState.prototype.posted_prices = $util.emptyArray;

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.pricefeed.GenesisState
         * @static
         * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.posted_prices != null && message.posted_prices.length)
            for (var i = 0; i < message.posted_prices.length; ++i)
              $root.ununifi.pricefeed.PostedPrice.encode(
                message.posted_prices[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.pricefeed.GenesisState
         * @static
         * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.pricefeed.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.pricefeed.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.pricefeed.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
                break;
              case 2:
                if (!(message.posted_prices && message.posted_prices.length)) message.posted_prices = [];
                message.posted_prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.pricefeed.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.pricefeed.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.pricefeed.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.pricefeed.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          if (message.posted_prices != null && message.hasOwnProperty('posted_prices')) {
            if (!Array.isArray(message.posted_prices)) return 'posted_prices: array expected';
            for (var i = 0; i < message.posted_prices.length; ++i) {
              var error = $root.ununifi.pricefeed.PostedPrice.verify(message.posted_prices[i]);
              if (error) return 'posted_prices.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.pricefeed.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.pricefeed.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.pricefeed.GenesisState) return object;
          var message = new $root.ununifi.pricefeed.GenesisState();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.pricefeed.GenesisState.params: object expected');
            message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
          }
          if (object.posted_prices) {
            if (!Array.isArray(object.posted_prices)) throw TypeError('.ununifi.pricefeed.GenesisState.posted_prices: array expected');
            message.posted_prices = [];
            for (var i = 0; i < object.posted_prices.length; ++i) {
              if (typeof object.posted_prices[i] !== 'object')
                throw TypeError('.ununifi.pricefeed.GenesisState.posted_prices: object expected');
              message.posted_prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.posted_prices[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.pricefeed.GenesisState
         * @static
         * @param {ununifi.pricefeed.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.posted_prices = [];
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
          if (message.posted_prices && message.posted_prices.length) {
            object.posted_prices = [];
            for (var j = 0; j < message.posted_prices.length; ++j)
              object.posted_prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.posted_prices[j], options);
          }
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.pricefeed.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      return pricefeed;
    })();

    ununifi.ununifidist = (function () {
      /**
       * Namespace ununifidist.
       * @memberof ununifi
       * @namespace
       */
      var ununifidist = {};

      ununifidist.Query = (function () {
        /**
         * Constructs a new Query service.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a Query
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Query(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

        /**
         * Callback as used by {@link ununifi.ununifidist.Query#params}.
         * @memberof ununifi.ununifidist.Query
         * @typedef ParamsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ununifidist.QueryParamsResponse} [response] QueryParamsResponse
         */

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.ununifidist.Query
         * @instance
         * @param {ununifi.ununifidist.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @param {ununifi.ununifidist.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.params = function params(request, callback) {
            return this.rpcCall(
              params,
              $root.ununifi.ununifidist.QueryParamsRequest,
              $root.ununifi.ununifidist.QueryParamsResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Params' },
        );

        /**
         * Calls Params.
         * @function params
         * @memberof ununifi.ununifidist.Query
         * @instance
         * @param {ununifi.ununifidist.IQueryParamsRequest} request QueryParamsRequest message or plain object
         * @returns {Promise<ununifi.ununifidist.QueryParamsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ununifi.ununifidist.Query#balances}.
         * @memberof ununifi.ununifidist.Query
         * @typedef BalancesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ununifi.ununifidist.QueryGetBalancesResponse} [response] QueryGetBalancesResponse
         */

        /**
         * Calls Balances.
         * @function balances
         * @memberof ununifi.ununifidist.Query
         * @instance
         * @param {ununifi.ununifidist.IQueryGetBalancesRequest} request QueryGetBalancesRequest message or plain object
         * @param {ununifi.ununifidist.Query.BalancesCallback} callback Node-style callback called with the error, if any, and QueryGetBalancesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (Query.prototype.balances = function balances(request, callback) {
            return this.rpcCall(
              balances,
              $root.ununifi.ununifidist.QueryGetBalancesRequest,
              $root.ununifi.ununifidist.QueryGetBalancesResponse,
              request,
              callback,
            );
          }),
          'name',
          { value: 'Balances' },
        );

        /**
         * Calls Balances.
         * @function balances
         * @memberof ununifi.ununifidist.Query
         * @instance
         * @param {ununifi.ununifidist.IQueryGetBalancesRequest} request QueryGetBalancesRequest message or plain object
         * @returns {Promise<ununifi.ununifidist.QueryGetBalancesResponse>} Promise
         * @variation 2
         */

        return Query;
      })();

      ununifidist.QueryParamsRequest = (function () {
        /**
         * Properties of a QueryParamsRequest.
         * @memberof ununifi.ununifidist
         * @interface IQueryParamsRequest
         */

        /**
         * Constructs a new QueryParamsRequest.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a QueryParamsRequest.
         * @implements IQueryParamsRequest
         * @constructor
         * @param {ununifi.ununifidist.IQueryParamsRequest=} [properties] Properties to set
         */
        function QueryParamsRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.ununifidist.QueryParamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @static
         * @param {ununifi.ununifidist.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryParamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @static
         * @param {ununifi.ununifidist.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ununifidist.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ununifidist.QueryParamsRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ununifidist.QueryParamsRequest} QueryParamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsRequest message.
         * @function verify
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ununifidist.QueryParamsRequest} QueryParamsRequest
         */
        QueryParamsRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ununifidist.QueryParamsRequest) return object;
          return new $root.ununifi.ununifidist.QueryParamsRequest();
        };

        /**
         * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @static
         * @param {ununifi.ununifidist.QueryParamsRequest} message QueryParamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryParamsRequest to JSON.
         * @function toJSON
         * @memberof ununifi.ununifidist.QueryParamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsRequest;
      })();

      ununifidist.QueryParamsResponse = (function () {
        /**
         * Properties of a QueryParamsResponse.
         * @memberof ununifi.ununifidist
         * @interface IQueryParamsResponse
         * @property {ununifi.ununifidist.IParams|null} [params] QueryParamsResponse params
         */

        /**
         * Constructs a new QueryParamsResponse.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a QueryParamsResponse.
         * @implements IQueryParamsResponse
         * @constructor
         * @param {ununifi.ununifidist.IQueryParamsResponse=} [properties] Properties to set
         */
        function QueryParamsResponse(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryParamsResponse params.
         * @member {ununifi.ununifidist.IParams|null|undefined} params
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @instance
         */
        QueryParamsResponse.prototype.params = null;

        /**
         * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.ununifidist.QueryParamsResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @static
         * @param {ununifi.ununifidist.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.ununifidist.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryParamsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @static
         * @param {ununifi.ununifidist.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ununifidist.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ununifidist.QueryParamsResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.ununifidist.Params.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ununifidist.QueryParamsResponse} QueryParamsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryParamsResponse message.
         * @function verify
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryParamsResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.ununifidist.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          return null;
        };

        /**
         * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ununifidist.QueryParamsResponse} QueryParamsResponse
         */
        QueryParamsResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ununifidist.QueryParamsResponse) return object;
          var message = new $root.ununifi.ununifidist.QueryParamsResponse();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.ununifidist.QueryParamsResponse.params: object expected');
            message.params = $root.ununifi.ununifidist.Params.fromObject(object.params);
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @static
         * @param {ununifi.ununifidist.QueryParamsResponse} message QueryParamsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryParamsResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.params = null;
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.ununifidist.Params.toObject(message.params, options);
          return object;
        };

        /**
         * Converts this QueryParamsResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ununifidist.QueryParamsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryParamsResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryParamsResponse;
      })();

      ununifidist.QueryGetBalancesRequest = (function () {
        /**
         * Properties of a QueryGetBalancesRequest.
         * @memberof ununifi.ununifidist
         * @interface IQueryGetBalancesRequest
         */

        /**
         * Constructs a new QueryGetBalancesRequest.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a QueryGetBalancesRequest.
         * @implements IQueryGetBalancesRequest
         * @constructor
         * @param {ununifi.ununifidist.IQueryGetBalancesRequest=} [properties] Properties to set
         */
        function QueryGetBalancesRequest(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified QueryGetBalancesRequest message. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesRequest.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @static
         * @param {ununifi.ununifidist.IQueryGetBalancesRequest} message QueryGetBalancesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetBalancesRequest.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified QueryGetBalancesRequest message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @static
         * @param {ununifi.ununifidist.IQueryGetBalancesRequest} message QueryGetBalancesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetBalancesRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetBalancesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ununifidist.QueryGetBalancesRequest} QueryGetBalancesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetBalancesRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ununifidist.QueryGetBalancesRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetBalancesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ununifidist.QueryGetBalancesRequest} QueryGetBalancesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetBalancesRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetBalancesRequest message.
         * @function verify
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetBalancesRequest.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          return null;
        };

        /**
         * Creates a QueryGetBalancesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ununifidist.QueryGetBalancesRequest} QueryGetBalancesRequest
         */
        QueryGetBalancesRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ununifidist.QueryGetBalancesRequest) return object;
          return new $root.ununifi.ununifidist.QueryGetBalancesRequest();
        };

        /**
         * Creates a plain object from a QueryGetBalancesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @static
         * @param {ununifi.ununifidist.QueryGetBalancesRequest} message QueryGetBalancesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetBalancesRequest.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this QueryGetBalancesRequest to JSON.
         * @function toJSON
         * @memberof ununifi.ununifidist.QueryGetBalancesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetBalancesRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetBalancesRequest;
      })();

      ununifidist.QueryGetBalancesResponse = (function () {
        /**
         * Properties of a QueryGetBalancesResponse.
         * @memberof ununifi.ununifidist
         * @interface IQueryGetBalancesResponse
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [balances] QueryGetBalancesResponse balances
         */

        /**
         * Constructs a new QueryGetBalancesResponse.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a QueryGetBalancesResponse.
         * @implements IQueryGetBalancesResponse
         * @constructor
         * @param {ununifi.ununifidist.IQueryGetBalancesResponse=} [properties] Properties to set
         */
        function QueryGetBalancesResponse(properties) {
          this.balances = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryGetBalancesResponse balances.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} balances
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @instance
         */
        QueryGetBalancesResponse.prototype.balances = $util.emptyArray;

        /**
         * Encodes the specified QueryGetBalancesResponse message. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesResponse.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @static
         * @param {ununifi.ununifidist.IQueryGetBalancesResponse} message QueryGetBalancesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetBalancesResponse.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.balances != null && message.balances.length)
            for (var i = 0; i < message.balances.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.balances[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified QueryGetBalancesResponse message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @static
         * @param {ununifi.ununifidist.IQueryGetBalancesResponse} message QueryGetBalancesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryGetBalancesResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryGetBalancesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ununifidist.QueryGetBalancesResponse} QueryGetBalancesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetBalancesResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ununifidist.QueryGetBalancesResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.balances && message.balances.length)) message.balances = [];
                message.balances.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a QueryGetBalancesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ununifidist.QueryGetBalancesResponse} QueryGetBalancesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryGetBalancesResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryGetBalancesResponse message.
         * @function verify
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryGetBalancesResponse.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.balances != null && message.hasOwnProperty('balances')) {
            if (!Array.isArray(message.balances)) return 'balances: array expected';
            for (var i = 0; i < message.balances.length; ++i) {
              var error = $root.cosmos.base.v1beta1.Coin.verify(message.balances[i]);
              if (error) return 'balances.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a QueryGetBalancesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ununifidist.QueryGetBalancesResponse} QueryGetBalancesResponse
         */
        QueryGetBalancesResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ununifidist.QueryGetBalancesResponse) return object;
          var message = new $root.ununifi.ununifidist.QueryGetBalancesResponse();
          if (object.balances) {
            if (!Array.isArray(object.balances)) throw TypeError('.ununifi.ununifidist.QueryGetBalancesResponse.balances: array expected');
            message.balances = [];
            for (var i = 0; i < object.balances.length; ++i) {
              if (typeof object.balances[i] !== 'object')
                throw TypeError('.ununifi.ununifidist.QueryGetBalancesResponse.balances: object expected');
              message.balances[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.balances[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a QueryGetBalancesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @static
         * @param {ununifi.ununifidist.QueryGetBalancesResponse} message QueryGetBalancesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryGetBalancesResponse.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.balances = [];
          if (message.balances && message.balances.length) {
            object.balances = [];
            for (var j = 0; j < message.balances.length; ++j)
              object.balances[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.balances[j], options);
          }
          return object;
        };

        /**
         * Converts this QueryGetBalancesResponse to JSON.
         * @function toJSON
         * @memberof ununifi.ununifidist.QueryGetBalancesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryGetBalancesResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryGetBalancesResponse;
      })();

      ununifidist.Params = (function () {
        /**
         * Properties of a Params.
         * @memberof ununifi.ununifidist
         * @interface IParams
         * @property {boolean|null} [active] Params active
         * @property {Array.<ununifi.ununifidist.IPeriod>|null} [periods] Params periods
         */

        /**
         * Constructs a new Params.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {ununifi.ununifidist.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          this.periods = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params active.
         * @member {boolean} active
         * @memberof ununifi.ununifidist.Params
         * @instance
         */
        Params.prototype.active = false;

        /**
         * Params periods.
         * @member {Array.<ununifi.ununifidist.IPeriod>} periods
         * @memberof ununifi.ununifidist.Params
         * @instance
         */
        Params.prototype.periods = $util.emptyArray;

        /**
         * Encodes the specified Params message. Does not implicitly {@link ununifi.ununifidist.Params.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ununifidist.Params
         * @static
         * @param {ununifi.ununifidist.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.active != null && Object.hasOwnProperty.call(message, 'active'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.active);
          if (message.periods != null && message.periods.length)
            for (var i = 0; i < message.periods.length; ++i)
              $root.ununifi.ununifidist.Period.encode(message.periods[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.ununifidist.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ununifidist.Params
         * @static
         * @param {ununifi.ununifidist.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ununifidist.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ununifidist.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ununifidist.Params();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.active = reader.bool();
                break;
              case 2:
                if (!(message.periods && message.periods.length)) message.periods = [];
                message.periods.push($root.ununifi.ununifidist.Period.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ununifidist.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ununifidist.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof ununifi.ununifidist.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.active != null && message.hasOwnProperty('active'))
            if (typeof message.active !== 'boolean') return 'active: boolean expected';
          if (message.periods != null && message.hasOwnProperty('periods')) {
            if (!Array.isArray(message.periods)) return 'periods: array expected';
            for (var i = 0; i < message.periods.length; ++i) {
              var error = $root.ununifi.ununifidist.Period.verify(message.periods[i]);
              if (error) return 'periods.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ununifidist.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ununifidist.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ununifidist.Params) return object;
          var message = new $root.ununifi.ununifidist.Params();
          if (object.active != null) message.active = Boolean(object.active);
          if (object.periods) {
            if (!Array.isArray(object.periods)) throw TypeError('.ununifi.ununifidist.Params.periods: array expected');
            message.periods = [];
            for (var i = 0; i < object.periods.length; ++i) {
              if (typeof object.periods[i] !== 'object') throw TypeError('.ununifi.ununifidist.Params.periods: object expected');
              message.periods[i] = $root.ununifi.ununifidist.Period.fromObject(object.periods[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ununifidist.Params
         * @static
         * @param {ununifi.ununifidist.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.periods = [];
          if (options.defaults) object.active = false;
          if (message.active != null && message.hasOwnProperty('active')) object.active = message.active;
          if (message.periods && message.periods.length) {
            object.periods = [];
            for (var j = 0; j < message.periods.length; ++j)
              object.periods[j] = $root.ununifi.ununifidist.Period.toObject(message.periods[j], options);
          }
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof ununifi.ununifidist.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      ununifidist.Period = (function () {
        /**
         * Properties of a Period.
         * @memberof ununifi.ununifidist
         * @interface IPeriod
         * @property {google.protobuf.ITimestamp|null} [start] Period start
         * @property {google.protobuf.ITimestamp|null} [end] Period end
         * @property {string|null} [inflation] Period inflation
         */

        /**
         * Constructs a new Period.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a Period.
         * @implements IPeriod
         * @constructor
         * @param {ununifi.ununifidist.IPeriod=} [properties] Properties to set
         */
        function Period(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Period start.
         * @member {google.protobuf.ITimestamp|null|undefined} start
         * @memberof ununifi.ununifidist.Period
         * @instance
         */
        Period.prototype.start = null;

        /**
         * Period end.
         * @member {google.protobuf.ITimestamp|null|undefined} end
         * @memberof ununifi.ununifidist.Period
         * @instance
         */
        Period.prototype.end = null;

        /**
         * Period inflation.
         * @member {string} inflation
         * @memberof ununifi.ununifidist.Period
         * @instance
         */
        Period.prototype.inflation = '';

        /**
         * Encodes the specified Period message. Does not implicitly {@link ununifi.ununifidist.Period.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ununifidist.Period
         * @static
         * @param {ununifi.ununifidist.IPeriod} message Period message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Period.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
            $root.google.protobuf.Timestamp.encode(message.start, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            $root.google.protobuf.Timestamp.encode(message.end, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.inflation != null && Object.hasOwnProperty.call(message, 'inflation'))
            writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.inflation);
          return writer;
        };

        /**
         * Encodes the specified Period message, length delimited. Does not implicitly {@link ununifi.ununifidist.Period.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ununifidist.Period
         * @static
         * @param {ununifi.ununifidist.IPeriod} message Period message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Period.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Period message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ununifidist.Period
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ununifidist.Period} Period
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Period.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ununifidist.Period();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.start = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 2:
                message.end = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 11:
                message.inflation = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Period message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ununifidist.Period
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ununifidist.Period} Period
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Period.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Period message.
         * @function verify
         * @memberof ununifi.ununifidist.Period
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Period.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.start != null && message.hasOwnProperty('start')) {
            var error = $root.google.protobuf.Timestamp.verify(message.start);
            if (error) return 'start.' + error;
          }
          if (message.end != null && message.hasOwnProperty('end')) {
            var error = $root.google.protobuf.Timestamp.verify(message.end);
            if (error) return 'end.' + error;
          }
          if (message.inflation != null && message.hasOwnProperty('inflation'))
            if (!$util.isString(message.inflation)) return 'inflation: string expected';
          return null;
        };

        /**
         * Creates a Period message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ununifidist.Period
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ununifidist.Period} Period
         */
        Period.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ununifidist.Period) return object;
          var message = new $root.ununifi.ununifidist.Period();
          if (object.start != null) {
            if (typeof object.start !== 'object') throw TypeError('.ununifi.ununifidist.Period.start: object expected');
            message.start = $root.google.protobuf.Timestamp.fromObject(object.start);
          }
          if (object.end != null) {
            if (typeof object.end !== 'object') throw TypeError('.ununifi.ununifidist.Period.end: object expected');
            message.end = $root.google.protobuf.Timestamp.fromObject(object.end);
          }
          if (object.inflation != null) message.inflation = String(object.inflation);
          return message;
        };

        /**
         * Creates a plain object from a Period message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ununifidist.Period
         * @static
         * @param {ununifi.ununifidist.Period} message Period
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Period.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.start = null;
            object.end = null;
            object.inflation = '';
          }
          if (message.start != null && message.hasOwnProperty('start'))
            object.start = $root.google.protobuf.Timestamp.toObject(message.start, options);
          if (message.end != null && message.hasOwnProperty('end'))
            object.end = $root.google.protobuf.Timestamp.toObject(message.end, options);
          if (message.inflation != null && message.hasOwnProperty('inflation')) object.inflation = message.inflation;
          return object;
        };

        /**
         * Converts this Period to JSON.
         * @function toJSON
         * @memberof ununifi.ununifidist.Period
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Period.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Period;
      })();

      ununifidist.GenesisState = (function () {
        /**
         * Properties of a GenesisState.
         * @memberof ununifi.ununifidist
         * @interface IGenesisState
         * @property {ununifi.ununifidist.IParams|null} [params] GenesisState params
         * @property {google.protobuf.ITimestamp|null} [previous_block_time] GenesisState previous_block_time
         * @property {string|null} [gov_denom] GenesisState gov_denom
         */

        /**
         * Constructs a new GenesisState.
         * @memberof ununifi.ununifidist
         * @classdesc Represents a GenesisState.
         * @implements IGenesisState
         * @constructor
         * @param {ununifi.ununifidist.IGenesisState=} [properties] Properties to set
         */
        function GenesisState(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisState params.
         * @member {ununifi.ununifidist.IParams|null|undefined} params
         * @memberof ununifi.ununifidist.GenesisState
         * @instance
         */
        GenesisState.prototype.params = null;

        /**
         * GenesisState previous_block_time.
         * @member {google.protobuf.ITimestamp|null|undefined} previous_block_time
         * @memberof ununifi.ununifidist.GenesisState
         * @instance
         */
        GenesisState.prototype.previous_block_time = null;

        /**
         * GenesisState gov_denom.
         * @member {string} gov_denom
         * @memberof ununifi.ununifidist.GenesisState
         * @instance
         */
        GenesisState.prototype.gov_denom = '';

        /**
         * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.ununifidist.GenesisState.verify|verify} messages.
         * @function encode
         * @memberof ununifi.ununifidist.GenesisState
         * @static
         * @param {ununifi.ununifidist.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
            $root.ununifi.ununifidist.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.previous_block_time != null && Object.hasOwnProperty.call(message, 'previous_block_time'))
            $root.google.protobuf.Timestamp.encode(message.previous_block_time, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.gov_denom != null && Object.hasOwnProperty.call(message, 'gov_denom'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.gov_denom);
          return writer;
        };

        /**
         * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.ununifidist.GenesisState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.ununifidist.GenesisState
         * @static
         * @param {ununifi.ununifidist.IGenesisState} message GenesisState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.ununifidist.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.ununifidist.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.ununifidist.GenesisState();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.params = $root.ununifi.ununifidist.Params.decode(reader, reader.uint32());
                break;
              case 2:
                message.previous_block_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 3:
                message.gov_denom = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GenesisState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.ununifidist.GenesisState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.ununifidist.GenesisState} GenesisState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisState.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisState message.
         * @function verify
         * @memberof ununifi.ununifidist.GenesisState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisState.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.params != null && message.hasOwnProperty('params')) {
            var error = $root.ununifi.ununifidist.Params.verify(message.params);
            if (error) return 'params.' + error;
          }
          if (message.previous_block_time != null && message.hasOwnProperty('previous_block_time')) {
            var error = $root.google.protobuf.Timestamp.verify(message.previous_block_time);
            if (error) return 'previous_block_time.' + error;
          }
          if (message.gov_denom != null && message.hasOwnProperty('gov_denom'))
            if (!$util.isString(message.gov_denom)) return 'gov_denom: string expected';
          return null;
        };

        /**
         * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.ununifidist.GenesisState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.ununifidist.GenesisState} GenesisState
         */
        GenesisState.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.ununifidist.GenesisState) return object;
          var message = new $root.ununifi.ununifidist.GenesisState();
          if (object.params != null) {
            if (typeof object.params !== 'object') throw TypeError('.ununifi.ununifidist.GenesisState.params: object expected');
            message.params = $root.ununifi.ununifidist.Params.fromObject(object.params);
          }
          if (object.previous_block_time != null) {
            if (typeof object.previous_block_time !== 'object')
              throw TypeError('.ununifi.ununifidist.GenesisState.previous_block_time: object expected');
            message.previous_block_time = $root.google.protobuf.Timestamp.fromObject(object.previous_block_time);
          }
          if (object.gov_denom != null) message.gov_denom = String(object.gov_denom);
          return message;
        };

        /**
         * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.ununifidist.GenesisState
         * @static
         * @param {ununifi.ununifidist.GenesisState} message GenesisState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisState.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.params = null;
            object.previous_block_time = null;
            object.gov_denom = '';
          }
          if (message.params != null && message.hasOwnProperty('params'))
            object.params = $root.ununifi.ununifidist.Params.toObject(message.params, options);
          if (message.previous_block_time != null && message.hasOwnProperty('previous_block_time'))
            object.previous_block_time = $root.google.protobuf.Timestamp.toObject(message.previous_block_time, options);
          if (message.gov_denom != null && message.hasOwnProperty('gov_denom')) object.gov_denom = message.gov_denom;
          return object;
        };

        /**
         * Converts this GenesisState to JSON.
         * @function toJSON
         * @memberof ununifi.ununifidist.GenesisState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisState.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisState;
      })();

      return ununifidist;
    })();

    return ununifi;
  })();

  $root.cosmos = (function () {
    /**
     * Namespace cosmos.
     * @exports cosmos
     * @namespace
     */
    var cosmos = {};

    cosmos.base = (function () {
      /**
       * Namespace base.
       * @memberof cosmos
       * @namespace
       */
      var base = {};

      base.query = (function () {
        /**
         * Namespace query.
         * @memberof cosmos.base
         * @namespace
         */
        var query = {};

        query.v1beta1 = (function () {
          /**
           * Namespace v1beta1.
           * @memberof cosmos.base.query
           * @namespace
           */
          var v1beta1 = {};

          v1beta1.PageRequest = (function () {
            /**
             * Properties of a PageRequest.
             * @memberof cosmos.base.query.v1beta1
             * @interface IPageRequest
             * @property {Uint8Array|null} [key] PageRequest key
             * @property {Long|null} [offset] PageRequest offset
             * @property {Long|null} [limit] PageRequest limit
             * @property {boolean|null} [count_total] PageRequest count_total
             */

            /**
             * Constructs a new PageRequest.
             * @memberof cosmos.base.query.v1beta1
             * @classdesc Represents a PageRequest.
             * @implements IPageRequest
             * @constructor
             * @param {cosmos.base.query.v1beta1.IPageRequest=} [properties] Properties to set
             */
            function PageRequest(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * PageRequest key.
             * @member {Uint8Array} key
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @instance
             */
            PageRequest.prototype.key = $util.newBuffer([]);

            /**
             * PageRequest offset.
             * @member {Long} offset
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @instance
             */
            PageRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * PageRequest limit.
             * @member {Long} limit
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @instance
             */
            PageRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * PageRequest count_total.
             * @member {boolean} count_total
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @instance
             */
            PageRequest.prototype.count_total = false;

            /**
             * Encodes the specified PageRequest message. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @static
             * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PageRequest.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.key != null && Object.hasOwnProperty.call(message, 'key'))
                writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.key);
              if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.offset);
              if (message.limit != null && Object.hasOwnProperty.call(message, 'limit'))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.limit);
              if (message.count_total != null && Object.hasOwnProperty.call(message, 'count_total'))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.count_total);
              return writer;
            };

            /**
             * Encodes the specified PageRequest message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @static
             * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PageRequest.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PageRequest.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.query.v1beta1.PageRequest();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.key = reader.bytes();
                    break;
                  case 2:
                    message.offset = reader.uint64();
                    break;
                  case 3:
                    message.limit = reader.uint64();
                    break;
                  case 4:
                    message.count_total = reader.bool();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a PageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PageRequest.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PageRequest message.
             * @function verify
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PageRequest.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.key != null && message.hasOwnProperty('key'))
                if (!((message.key && typeof message.key.length === 'number') || $util.isString(message.key)))
                  return 'key: buffer expected';
              if (message.offset != null && message.hasOwnProperty('offset'))
                if (
                  !$util.isInteger(message.offset) &&
                  !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high))
                )
                  return 'offset: integer|Long expected';
              if (message.limit != null && message.hasOwnProperty('limit'))
                if (
                  !$util.isInteger(message.limit) &&
                  !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high))
                )
                  return 'limit: integer|Long expected';
              if (message.count_total != null && message.hasOwnProperty('count_total'))
                if (typeof message.count_total !== 'boolean') return 'count_total: boolean expected';
              return null;
            };

            /**
             * Creates a PageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
             */
            PageRequest.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.query.v1beta1.PageRequest) return object;
              var message = new $root.cosmos.base.query.v1beta1.PageRequest();
              if (object.key != null)
                if (typeof object.key === 'string')
                  $util.base64.decode(object.key, (message.key = $util.newBuffer($util.base64.length(object.key))), 0);
                else if (object.key.length) message.key = object.key;
              if (object.offset != null)
                if ($util.Long) (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
                else if (typeof object.offset === 'string') message.offset = parseInt(object.offset, 10);
                else if (typeof object.offset === 'number') message.offset = object.offset;
                else if (typeof object.offset === 'object')
                  message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
              if (object.limit != null)
                if ($util.Long) (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                else if (typeof object.limit === 'string') message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === 'number') message.limit = object.limit;
                else if (typeof object.limit === 'object')
                  message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
              if (object.count_total != null) message.count_total = Boolean(object.count_total);
              return message;
            };

            /**
             * Creates a plain object from a PageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @static
             * @param {cosmos.base.query.v1beta1.PageRequest} message PageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PageRequest.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                if (options.bytes === String) object.key = '';
                else {
                  object.key = [];
                  if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
                }
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else object.offset = options.longs === String ? '0' : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else object.limit = options.longs === String ? '0' : 0;
                object.count_total = false;
              }
              if (message.key != null && message.hasOwnProperty('key'))
                object.key =
                  options.bytes === String
                    ? $util.base64.encode(message.key, 0, message.key.length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.key)
                    : message.key;
              if (message.offset != null && message.hasOwnProperty('offset'))
                if (typeof message.offset === 'number') object.offset = options.longs === String ? String(message.offset) : message.offset;
                else
                  object.offset =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.offset)
                      : options.longs === Number
                      ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true)
                      : message.offset;
              if (message.limit != null && message.hasOwnProperty('limit'))
                if (typeof message.limit === 'number') object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                  object.limit =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.limit)
                      : options.longs === Number
                      ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true)
                      : message.limit;
              if (message.count_total != null && message.hasOwnProperty('count_total')) object.count_total = message.count_total;
              return object;
            };

            /**
             * Converts this PageRequest to JSON.
             * @function toJSON
             * @memberof cosmos.base.query.v1beta1.PageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PageRequest.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PageRequest;
          })();

          v1beta1.PageResponse = (function () {
            /**
             * Properties of a PageResponse.
             * @memberof cosmos.base.query.v1beta1
             * @interface IPageResponse
             * @property {Uint8Array|null} [next_key] PageResponse next_key
             * @property {Long|null} [total] PageResponse total
             */

            /**
             * Constructs a new PageResponse.
             * @memberof cosmos.base.query.v1beta1
             * @classdesc Represents a PageResponse.
             * @implements IPageResponse
             * @constructor
             * @param {cosmos.base.query.v1beta1.IPageResponse=} [properties] Properties to set
             */
            function PageResponse(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * PageResponse next_key.
             * @member {Uint8Array} next_key
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @instance
             */
            PageResponse.prototype.next_key = $util.newBuffer([]);

            /**
             * PageResponse total.
             * @member {Long} total
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @instance
             */
            PageResponse.prototype.total = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * Encodes the specified PageResponse message. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @static
             * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PageResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.next_key != null && Object.hasOwnProperty.call(message, 'next_key'))
                writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.next_key);
              if (message.total != null && Object.hasOwnProperty.call(message, 'total'))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.total);
              return writer;
            };

            /**
             * Encodes the specified PageResponse message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @static
             * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PageResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PageResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.query.v1beta1.PageResponse();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.next_key = reader.bytes();
                    break;
                  case 2:
                    message.total = reader.uint64();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a PageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PageResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PageResponse message.
             * @function verify
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PageResponse.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.next_key != null && message.hasOwnProperty('next_key'))
                if (!((message.next_key && typeof message.next_key.length === 'number') || $util.isString(message.next_key)))
                  return 'next_key: buffer expected';
              if (message.total != null && message.hasOwnProperty('total'))
                if (
                  !$util.isInteger(message.total) &&
                  !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high))
                )
                  return 'total: integer|Long expected';
              return null;
            };

            /**
             * Creates a PageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
             */
            PageResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.query.v1beta1.PageResponse) return object;
              var message = new $root.cosmos.base.query.v1beta1.PageResponse();
              if (object.next_key != null)
                if (typeof object.next_key === 'string')
                  $util.base64.decode(object.next_key, (message.next_key = $util.newBuffer($util.base64.length(object.next_key))), 0);
                else if (object.next_key.length) message.next_key = object.next_key;
              if (object.total != null)
                if ($util.Long) (message.total = $util.Long.fromValue(object.total)).unsigned = true;
                else if (typeof object.total === 'string') message.total = parseInt(object.total, 10);
                else if (typeof object.total === 'number') message.total = object.total;
                else if (typeof object.total === 'object')
                  message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
              return message;
            };

            /**
             * Creates a plain object from a PageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @static
             * @param {cosmos.base.query.v1beta1.PageResponse} message PageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PageResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                if (options.bytes === String) object.next_key = '';
                else {
                  object.next_key = [];
                  if (options.bytes !== Array) object.next_key = $util.newBuffer(object.next_key);
                }
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else object.total = options.longs === String ? '0' : 0;
              }
              if (message.next_key != null && message.hasOwnProperty('next_key'))
                object.next_key =
                  options.bytes === String
                    ? $util.base64.encode(message.next_key, 0, message.next_key.length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.next_key)
                    : message.next_key;
              if (message.total != null && message.hasOwnProperty('total'))
                if (typeof message.total === 'number') object.total = options.longs === String ? String(message.total) : message.total;
                else
                  object.total =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.total)
                      : options.longs === Number
                      ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true)
                      : message.total;
              return object;
            };

            /**
             * Converts this PageResponse to JSON.
             * @function toJSON
             * @memberof cosmos.base.query.v1beta1.PageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PageResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PageResponse;
          })();

          return v1beta1;
        })();

        return query;
      })();

      base.v1beta1 = (function () {
        /**
         * Namespace v1beta1.
         * @memberof cosmos.base
         * @namespace
         */
        var v1beta1 = {};

        v1beta1.Coin = (function () {
          /**
           * Properties of a Coin.
           * @memberof cosmos.base.v1beta1
           * @interface ICoin
           * @property {string|null} [denom] Coin denom
           * @property {string|null} [amount] Coin amount
           */

          /**
           * Constructs a new Coin.
           * @memberof cosmos.base.v1beta1
           * @classdesc Represents a Coin.
           * @implements ICoin
           * @constructor
           * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set
           */
          function Coin(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Coin denom.
           * @member {string} denom
           * @memberof cosmos.base.v1beta1.Coin
           * @instance
           */
          Coin.prototype.denom = '';

          /**
           * Coin amount.
           * @member {string} amount
           * @memberof cosmos.base.v1beta1.Coin
           * @instance
           */
          Coin.prototype.amount = '';

          /**
           * Encodes the specified Coin message. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.v1beta1.Coin
           * @static
           * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Coin.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
            if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
            return writer;
          };

          /**
           * Encodes the specified Coin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.v1beta1.Coin
           * @static
           * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Coin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Coin message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.v1beta1.Coin
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.v1beta1.Coin} Coin
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Coin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.v1beta1.Coin();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.denom = reader.string();
                  break;
                case 2:
                  message.amount = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Coin message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.v1beta1.Coin
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.v1beta1.Coin} Coin
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Coin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Coin message.
           * @function verify
           * @memberof cosmos.base.v1beta1.Coin
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Coin.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.denom != null && message.hasOwnProperty('denom'))
              if (!$util.isString(message.denom)) return 'denom: string expected';
            if (message.amount != null && message.hasOwnProperty('amount'))
              if (!$util.isString(message.amount)) return 'amount: string expected';
            return null;
          };

          /**
           * Creates a Coin message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.v1beta1.Coin
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.v1beta1.Coin} Coin
           */
          Coin.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.v1beta1.Coin) return object;
            var message = new $root.cosmos.base.v1beta1.Coin();
            if (object.denom != null) message.denom = String(object.denom);
            if (object.amount != null) message.amount = String(object.amount);
            return message;
          };

          /**
           * Creates a plain object from a Coin message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.v1beta1.Coin
           * @static
           * @param {cosmos.base.v1beta1.Coin} message Coin
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Coin.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.denom = '';
              object.amount = '';
            }
            if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
            if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
            return object;
          };

          /**
           * Converts this Coin to JSON.
           * @function toJSON
           * @memberof cosmos.base.v1beta1.Coin
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Coin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Coin;
        })();

        v1beta1.DecCoin = (function () {
          /**
           * Properties of a DecCoin.
           * @memberof cosmos.base.v1beta1
           * @interface IDecCoin
           * @property {string|null} [denom] DecCoin denom
           * @property {string|null} [amount] DecCoin amount
           */

          /**
           * Constructs a new DecCoin.
           * @memberof cosmos.base.v1beta1
           * @classdesc Represents a DecCoin.
           * @implements IDecCoin
           * @constructor
           * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set
           */
          function DecCoin(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * DecCoin denom.
           * @member {string} denom
           * @memberof cosmos.base.v1beta1.DecCoin
           * @instance
           */
          DecCoin.prototype.denom = '';

          /**
           * DecCoin amount.
           * @member {string} amount
           * @memberof cosmos.base.v1beta1.DecCoin
           * @instance
           */
          DecCoin.prototype.amount = '';

          /**
           * Encodes the specified DecCoin message. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.v1beta1.DecCoin
           * @static
           * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DecCoin.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
            if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
            return writer;
          };

          /**
           * Encodes the specified DecCoin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.v1beta1.DecCoin
           * @static
           * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DecCoin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DecCoin message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.v1beta1.DecCoin
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DecCoin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.v1beta1.DecCoin();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.denom = reader.string();
                  break;
                case 2:
                  message.amount = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a DecCoin message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.v1beta1.DecCoin
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DecCoin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DecCoin message.
           * @function verify
           * @memberof cosmos.base.v1beta1.DecCoin
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DecCoin.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.denom != null && message.hasOwnProperty('denom'))
              if (!$util.isString(message.denom)) return 'denom: string expected';
            if (message.amount != null && message.hasOwnProperty('amount'))
              if (!$util.isString(message.amount)) return 'amount: string expected';
            return null;
          };

          /**
           * Creates a DecCoin message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.v1beta1.DecCoin
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
           */
          DecCoin.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.v1beta1.DecCoin) return object;
            var message = new $root.cosmos.base.v1beta1.DecCoin();
            if (object.denom != null) message.denom = String(object.denom);
            if (object.amount != null) message.amount = String(object.amount);
            return message;
          };

          /**
           * Creates a plain object from a DecCoin message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.v1beta1.DecCoin
           * @static
           * @param {cosmos.base.v1beta1.DecCoin} message DecCoin
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DecCoin.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.denom = '';
              object.amount = '';
            }
            if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
            if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
            return object;
          };

          /**
           * Converts this DecCoin to JSON.
           * @function toJSON
           * @memberof cosmos.base.v1beta1.DecCoin
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DecCoin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return DecCoin;
        })();

        v1beta1.IntProto = (function () {
          /**
           * Properties of an IntProto.
           * @memberof cosmos.base.v1beta1
           * @interface IIntProto
           * @property {string|null} [int] IntProto int
           */

          /**
           * Constructs a new IntProto.
           * @memberof cosmos.base.v1beta1
           * @classdesc Represents an IntProto.
           * @implements IIntProto
           * @constructor
           * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set
           */
          function IntProto(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * IntProto int.
           * @member {string} int
           * @memberof cosmos.base.v1beta1.IntProto
           * @instance
           */
          IntProto.prototype.int = '';

          /**
           * Encodes the specified IntProto message. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.v1beta1.IntProto
           * @static
           * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          IntProto.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.int != null && Object.hasOwnProperty.call(message, 'int'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.int);
            return writer;
          };

          /**
           * Encodes the specified IntProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.v1beta1.IntProto
           * @static
           * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          IntProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an IntProto message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.v1beta1.IntProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.v1beta1.IntProto} IntProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          IntProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.v1beta1.IntProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.int = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an IntProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.v1beta1.IntProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.v1beta1.IntProto} IntProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          IntProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an IntProto message.
           * @function verify
           * @memberof cosmos.base.v1beta1.IntProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          IntProto.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.int != null && message.hasOwnProperty('int')) if (!$util.isString(message.int)) return 'int: string expected';
            return null;
          };

          /**
           * Creates an IntProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.v1beta1.IntProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.v1beta1.IntProto} IntProto
           */
          IntProto.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.v1beta1.IntProto) return object;
            var message = new $root.cosmos.base.v1beta1.IntProto();
            if (object.int != null) message.int = String(object.int);
            return message;
          };

          /**
           * Creates a plain object from an IntProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.v1beta1.IntProto
           * @static
           * @param {cosmos.base.v1beta1.IntProto} message IntProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          IntProto.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) object.int = '';
            if (message.int != null && message.hasOwnProperty('int')) object.int = message.int;
            return object;
          };

          /**
           * Converts this IntProto to JSON.
           * @function toJSON
           * @memberof cosmos.base.v1beta1.IntProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          IntProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return IntProto;
        })();

        v1beta1.DecProto = (function () {
          /**
           * Properties of a DecProto.
           * @memberof cosmos.base.v1beta1
           * @interface IDecProto
           * @property {string|null} [dec] DecProto dec
           */

          /**
           * Constructs a new DecProto.
           * @memberof cosmos.base.v1beta1
           * @classdesc Represents a DecProto.
           * @implements IDecProto
           * @constructor
           * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set
           */
          function DecProto(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * DecProto dec.
           * @member {string} dec
           * @memberof cosmos.base.v1beta1.DecProto
           * @instance
           */
          DecProto.prototype.dec = '';

          /**
           * Encodes the specified DecProto message. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.v1beta1.DecProto
           * @static
           * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DecProto.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.dec != null && Object.hasOwnProperty.call(message, 'dec'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.dec);
            return writer;
          };

          /**
           * Encodes the specified DecProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.v1beta1.DecProto
           * @static
           * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DecProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DecProto message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.v1beta1.DecProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.v1beta1.DecProto} DecProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DecProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.v1beta1.DecProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.dec = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a DecProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.v1beta1.DecProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.v1beta1.DecProto} DecProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DecProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DecProto message.
           * @function verify
           * @memberof cosmos.base.v1beta1.DecProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DecProto.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.dec != null && message.hasOwnProperty('dec')) if (!$util.isString(message.dec)) return 'dec: string expected';
            return null;
          };

          /**
           * Creates a DecProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.v1beta1.DecProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.v1beta1.DecProto} DecProto
           */
          DecProto.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.v1beta1.DecProto) return object;
            var message = new $root.cosmos.base.v1beta1.DecProto();
            if (object.dec != null) message.dec = String(object.dec);
            return message;
          };

          /**
           * Creates a plain object from a DecProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.v1beta1.DecProto
           * @static
           * @param {cosmos.base.v1beta1.DecProto} message DecProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DecProto.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) object.dec = '';
            if (message.dec != null && message.hasOwnProperty('dec')) object.dec = message.dec;
            return object;
          };

          /**
           * Converts this DecProto to JSON.
           * @function toJSON
           * @memberof cosmos.base.v1beta1.DecProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DecProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return DecProto;
        })();

        return v1beta1;
      })();

      return base;
    })();

    cosmos.tx = (function () {
      /**
       * Namespace tx.
       * @memberof cosmos
       * @namespace
       */
      var tx = {};

      tx.v1beta1 = (function () {
        /**
         * Namespace v1beta1.
         * @memberof cosmos.tx
         * @namespace
         */
        var v1beta1 = {};

        v1beta1.Tx = (function () {
          /**
           * Properties of a Tx.
           * @memberof cosmos.tx.v1beta1
           * @interface ITx
           * @property {cosmos.tx.v1beta1.ITxBody|null} [body] Tx body
           * @property {cosmos.tx.v1beta1.IAuthInfo|null} [auth_info] Tx auth_info
           * @property {Array.<Uint8Array>|null} [signatures] Tx signatures
           */

          /**
           * Constructs a new Tx.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a Tx.
           * @implements ITx
           * @constructor
           * @param {cosmos.tx.v1beta1.ITx=} [properties] Properties to set
           */
          function Tx(properties) {
            this.signatures = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Tx body.
           * @member {cosmos.tx.v1beta1.ITxBody|null|undefined} body
           * @memberof cosmos.tx.v1beta1.Tx
           * @instance
           */
          Tx.prototype.body = null;

          /**
           * Tx auth_info.
           * @member {cosmos.tx.v1beta1.IAuthInfo|null|undefined} auth_info
           * @memberof cosmos.tx.v1beta1.Tx
           * @instance
           */
          Tx.prototype.auth_info = null;

          /**
           * Tx signatures.
           * @member {Array.<Uint8Array>} signatures
           * @memberof cosmos.tx.v1beta1.Tx
           * @instance
           */
          Tx.prototype.signatures = $util.emptyArray;

          /**
           * Encodes the specified Tx message. Does not implicitly {@link cosmos.tx.v1beta1.Tx.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.Tx
           * @static
           * @param {cosmos.tx.v1beta1.ITx} message Tx message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Tx.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, 'body'))
              $root.cosmos.tx.v1beta1.TxBody.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.auth_info != null && Object.hasOwnProperty.call(message, 'auth_info'))
              $root.cosmos.tx.v1beta1.AuthInfo.encode(message.auth_info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.signatures != null && message.signatures.length)
              for (var i = 0; i < message.signatures.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.signatures[i]);
            return writer;
          };

          /**
           * Encodes the specified Tx message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.Tx.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.Tx
           * @static
           * @param {cosmos.tx.v1beta1.ITx} message Tx message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Tx.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Tx message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.Tx
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.Tx} Tx
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Tx.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.Tx();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.body = $root.cosmos.tx.v1beta1.TxBody.decode(reader, reader.uint32());
                  break;
                case 2:
                  message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.decode(reader, reader.uint32());
                  break;
                case 3:
                  if (!(message.signatures && message.signatures.length)) message.signatures = [];
                  message.signatures.push(reader.bytes());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Tx message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.Tx
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.Tx} Tx
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Tx.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Tx message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.Tx
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Tx.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.body != null && message.hasOwnProperty('body')) {
              var error = $root.cosmos.tx.v1beta1.TxBody.verify(message.body);
              if (error) return 'body.' + error;
            }
            if (message.auth_info != null && message.hasOwnProperty('auth_info')) {
              var error = $root.cosmos.tx.v1beta1.AuthInfo.verify(message.auth_info);
              if (error) return 'auth_info.' + error;
            }
            if (message.signatures != null && message.hasOwnProperty('signatures')) {
              if (!Array.isArray(message.signatures)) return 'signatures: array expected';
              for (var i = 0; i < message.signatures.length; ++i)
                if (!((message.signatures[i] && typeof message.signatures[i].length === 'number') || $util.isString(message.signatures[i])))
                  return 'signatures: buffer[] expected';
            }
            return null;
          };

          /**
           * Creates a Tx message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.Tx
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.Tx} Tx
           */
          Tx.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.Tx) return object;
            var message = new $root.cosmos.tx.v1beta1.Tx();
            if (object.body != null) {
              if (typeof object.body !== 'object') throw TypeError('.cosmos.tx.v1beta1.Tx.body: object expected');
              message.body = $root.cosmos.tx.v1beta1.TxBody.fromObject(object.body);
            }
            if (object.auth_info != null) {
              if (typeof object.auth_info !== 'object') throw TypeError('.cosmos.tx.v1beta1.Tx.auth_info: object expected');
              message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.fromObject(object.auth_info);
            }
            if (object.signatures) {
              if (!Array.isArray(object.signatures)) throw TypeError('.cosmos.tx.v1beta1.Tx.signatures: array expected');
              message.signatures = [];
              for (var i = 0; i < object.signatures.length; ++i)
                if (typeof object.signatures[i] === 'string')
                  $util.base64.decode(
                    object.signatures[i],
                    (message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i]))),
                    0,
                  );
                else if (object.signatures[i].length) message.signatures[i] = object.signatures[i];
            }
            return message;
          };

          /**
           * Creates a plain object from a Tx message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.Tx
           * @static
           * @param {cosmos.tx.v1beta1.Tx} message Tx
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Tx.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) object.signatures = [];
            if (options.defaults) {
              object.body = null;
              object.auth_info = null;
            }
            if (message.body != null && message.hasOwnProperty('body'))
              object.body = $root.cosmos.tx.v1beta1.TxBody.toObject(message.body, options);
            if (message.auth_info != null && message.hasOwnProperty('auth_info'))
              object.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.toObject(message.auth_info, options);
            if (message.signatures && message.signatures.length) {
              object.signatures = [];
              for (var j = 0; j < message.signatures.length; ++j)
                object.signatures[j] =
                  options.bytes === String
                    ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.signatures[j])
                    : message.signatures[j];
            }
            return object;
          };

          /**
           * Converts this Tx to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.Tx
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Tx.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Tx;
        })();

        v1beta1.TxRaw = (function () {
          /**
           * Properties of a TxRaw.
           * @memberof cosmos.tx.v1beta1
           * @interface ITxRaw
           * @property {Uint8Array|null} [body_bytes] TxRaw body_bytes
           * @property {Uint8Array|null} [auth_info_bytes] TxRaw auth_info_bytes
           * @property {Array.<Uint8Array>|null} [signatures] TxRaw signatures
           */

          /**
           * Constructs a new TxRaw.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a TxRaw.
           * @implements ITxRaw
           * @constructor
           * @param {cosmos.tx.v1beta1.ITxRaw=} [properties] Properties to set
           */
          function TxRaw(properties) {
            this.signatures = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * TxRaw body_bytes.
           * @member {Uint8Array} body_bytes
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @instance
           */
          TxRaw.prototype.body_bytes = $util.newBuffer([]);

          /**
           * TxRaw auth_info_bytes.
           * @member {Uint8Array} auth_info_bytes
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @instance
           */
          TxRaw.prototype.auth_info_bytes = $util.newBuffer([]);

          /**
           * TxRaw signatures.
           * @member {Array.<Uint8Array>} signatures
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @instance
           */
          TxRaw.prototype.signatures = $util.emptyArray;

          /**
           * Encodes the specified TxRaw message. Does not implicitly {@link cosmos.tx.v1beta1.TxRaw.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @static
           * @param {cosmos.tx.v1beta1.ITxRaw} message TxRaw message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TxRaw.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.body_bytes != null && Object.hasOwnProperty.call(message, 'body_bytes'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.body_bytes);
            if (message.auth_info_bytes != null && Object.hasOwnProperty.call(message, 'auth_info_bytes'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.auth_info_bytes);
            if (message.signatures != null && message.signatures.length)
              for (var i = 0; i < message.signatures.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.signatures[i]);
            return writer;
          };

          /**
           * Encodes the specified TxRaw message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.TxRaw.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @static
           * @param {cosmos.tx.v1beta1.ITxRaw} message TxRaw message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TxRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a TxRaw message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.TxRaw} TxRaw
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TxRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.TxRaw();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.body_bytes = reader.bytes();
                  break;
                case 2:
                  message.auth_info_bytes = reader.bytes();
                  break;
                case 3:
                  if (!(message.signatures && message.signatures.length)) message.signatures = [];
                  message.signatures.push(reader.bytes());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a TxRaw message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.TxRaw} TxRaw
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TxRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a TxRaw message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          TxRaw.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
              if (!((message.body_bytes && typeof message.body_bytes.length === 'number') || $util.isString(message.body_bytes)))
                return 'body_bytes: buffer expected';
            if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
              if (
                !(
                  (message.auth_info_bytes && typeof message.auth_info_bytes.length === 'number') ||
                  $util.isString(message.auth_info_bytes)
                )
              )
                return 'auth_info_bytes: buffer expected';
            if (message.signatures != null && message.hasOwnProperty('signatures')) {
              if (!Array.isArray(message.signatures)) return 'signatures: array expected';
              for (var i = 0; i < message.signatures.length; ++i)
                if (!((message.signatures[i] && typeof message.signatures[i].length === 'number') || $util.isString(message.signatures[i])))
                  return 'signatures: buffer[] expected';
            }
            return null;
          };

          /**
           * Creates a TxRaw message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.TxRaw} TxRaw
           */
          TxRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.TxRaw) return object;
            var message = new $root.cosmos.tx.v1beta1.TxRaw();
            if (object.body_bytes != null)
              if (typeof object.body_bytes === 'string')
                $util.base64.decode(object.body_bytes, (message.body_bytes = $util.newBuffer($util.base64.length(object.body_bytes))), 0);
              else if (object.body_bytes.length) message.body_bytes = object.body_bytes;
            if (object.auth_info_bytes != null)
              if (typeof object.auth_info_bytes === 'string')
                $util.base64.decode(
                  object.auth_info_bytes,
                  (message.auth_info_bytes = $util.newBuffer($util.base64.length(object.auth_info_bytes))),
                  0,
                );
              else if (object.auth_info_bytes.length) message.auth_info_bytes = object.auth_info_bytes;
            if (object.signatures) {
              if (!Array.isArray(object.signatures)) throw TypeError('.cosmos.tx.v1beta1.TxRaw.signatures: array expected');
              message.signatures = [];
              for (var i = 0; i < object.signatures.length; ++i)
                if (typeof object.signatures[i] === 'string')
                  $util.base64.decode(
                    object.signatures[i],
                    (message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i]))),
                    0,
                  );
                else if (object.signatures[i].length) message.signatures[i] = object.signatures[i];
            }
            return message;
          };

          /**
           * Creates a plain object from a TxRaw message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @static
           * @param {cosmos.tx.v1beta1.TxRaw} message TxRaw
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          TxRaw.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) object.signatures = [];
            if (options.defaults) {
              if (options.bytes === String) object.body_bytes = '';
              else {
                object.body_bytes = [];
                if (options.bytes !== Array) object.body_bytes = $util.newBuffer(object.body_bytes);
              }
              if (options.bytes === String) object.auth_info_bytes = '';
              else {
                object.auth_info_bytes = [];
                if (options.bytes !== Array) object.auth_info_bytes = $util.newBuffer(object.auth_info_bytes);
              }
            }
            if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
              object.body_bytes =
                options.bytes === String
                  ? $util.base64.encode(message.body_bytes, 0, message.body_bytes.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.body_bytes)
                  : message.body_bytes;
            if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
              object.auth_info_bytes =
                options.bytes === String
                  ? $util.base64.encode(message.auth_info_bytes, 0, message.auth_info_bytes.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.auth_info_bytes)
                  : message.auth_info_bytes;
            if (message.signatures && message.signatures.length) {
              object.signatures = [];
              for (var j = 0; j < message.signatures.length; ++j)
                object.signatures[j] =
                  options.bytes === String
                    ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.signatures[j])
                    : message.signatures[j];
            }
            return object;
          };

          /**
           * Converts this TxRaw to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.TxRaw
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          TxRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return TxRaw;
        })();

        v1beta1.SignDoc = (function () {
          /**
           * Properties of a SignDoc.
           * @memberof cosmos.tx.v1beta1
           * @interface ISignDoc
           * @property {Uint8Array|null} [body_bytes] SignDoc body_bytes
           * @property {Uint8Array|null} [auth_info_bytes] SignDoc auth_info_bytes
           * @property {string|null} [chain_id] SignDoc chain_id
           * @property {Long|null} [account_number] SignDoc account_number
           */

          /**
           * Constructs a new SignDoc.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a SignDoc.
           * @implements ISignDoc
           * @constructor
           * @param {cosmos.tx.v1beta1.ISignDoc=} [properties] Properties to set
           */
          function SignDoc(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * SignDoc body_bytes.
           * @member {Uint8Array} body_bytes
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @instance
           */
          SignDoc.prototype.body_bytes = $util.newBuffer([]);

          /**
           * SignDoc auth_info_bytes.
           * @member {Uint8Array} auth_info_bytes
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @instance
           */
          SignDoc.prototype.auth_info_bytes = $util.newBuffer([]);

          /**
           * SignDoc chain_id.
           * @member {string} chain_id
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @instance
           */
          SignDoc.prototype.chain_id = '';

          /**
           * SignDoc account_number.
           * @member {Long} account_number
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @instance
           */
          SignDoc.prototype.account_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * Encodes the specified SignDoc message. Does not implicitly {@link cosmos.tx.v1beta1.SignDoc.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @static
           * @param {cosmos.tx.v1beta1.ISignDoc} message SignDoc message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignDoc.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.body_bytes != null && Object.hasOwnProperty.call(message, 'body_bytes'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.body_bytes);
            if (message.auth_info_bytes != null && Object.hasOwnProperty.call(message, 'auth_info_bytes'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.auth_info_bytes);
            if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.chain_id);
            if (message.account_number != null && Object.hasOwnProperty.call(message, 'account_number'))
              writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.account_number);
            return writer;
          };

          /**
           * Encodes the specified SignDoc message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.SignDoc.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @static
           * @param {cosmos.tx.v1beta1.ISignDoc} message SignDoc message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignDoc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SignDoc message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.SignDoc} SignDoc
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignDoc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.SignDoc();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.body_bytes = reader.bytes();
                  break;
                case 2:
                  message.auth_info_bytes = reader.bytes();
                  break;
                case 3:
                  message.chain_id = reader.string();
                  break;
                case 4:
                  message.account_number = reader.uint64();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SignDoc message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.SignDoc} SignDoc
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignDoc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SignDoc message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SignDoc.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
              if (!((message.body_bytes && typeof message.body_bytes.length === 'number') || $util.isString(message.body_bytes)))
                return 'body_bytes: buffer expected';
            if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
              if (
                !(
                  (message.auth_info_bytes && typeof message.auth_info_bytes.length === 'number') ||
                  $util.isString(message.auth_info_bytes)
                )
              )
                return 'auth_info_bytes: buffer expected';
            if (message.chain_id != null && message.hasOwnProperty('chain_id'))
              if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
            if (message.account_number != null && message.hasOwnProperty('account_number'))
              if (
                !$util.isInteger(message.account_number) &&
                !(message.account_number && $util.isInteger(message.account_number.low) && $util.isInteger(message.account_number.high))
              )
                return 'account_number: integer|Long expected';
            return null;
          };

          /**
           * Creates a SignDoc message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.SignDoc} SignDoc
           */
          SignDoc.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.SignDoc) return object;
            var message = new $root.cosmos.tx.v1beta1.SignDoc();
            if (object.body_bytes != null)
              if (typeof object.body_bytes === 'string')
                $util.base64.decode(object.body_bytes, (message.body_bytes = $util.newBuffer($util.base64.length(object.body_bytes))), 0);
              else if (object.body_bytes.length) message.body_bytes = object.body_bytes;
            if (object.auth_info_bytes != null)
              if (typeof object.auth_info_bytes === 'string')
                $util.base64.decode(
                  object.auth_info_bytes,
                  (message.auth_info_bytes = $util.newBuffer($util.base64.length(object.auth_info_bytes))),
                  0,
                );
              else if (object.auth_info_bytes.length) message.auth_info_bytes = object.auth_info_bytes;
            if (object.chain_id != null) message.chain_id = String(object.chain_id);
            if (object.account_number != null)
              if ($util.Long) (message.account_number = $util.Long.fromValue(object.account_number)).unsigned = true;
              else if (typeof object.account_number === 'string') message.account_number = parseInt(object.account_number, 10);
              else if (typeof object.account_number === 'number') message.account_number = object.account_number;
              else if (typeof object.account_number === 'object')
                message.account_number = new $util.LongBits(object.account_number.low >>> 0, object.account_number.high >>> 0).toNumber(
                  true,
                );
            return message;
          };

          /**
           * Creates a plain object from a SignDoc message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @static
           * @param {cosmos.tx.v1beta1.SignDoc} message SignDoc
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SignDoc.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              if (options.bytes === String) object.body_bytes = '';
              else {
                object.body_bytes = [];
                if (options.bytes !== Array) object.body_bytes = $util.newBuffer(object.body_bytes);
              }
              if (options.bytes === String) object.auth_info_bytes = '';
              else {
                object.auth_info_bytes = [];
                if (options.bytes !== Array) object.auth_info_bytes = $util.newBuffer(object.auth_info_bytes);
              }
              object.chain_id = '';
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.account_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.account_number = options.longs === String ? '0' : 0;
            }
            if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
              object.body_bytes =
                options.bytes === String
                  ? $util.base64.encode(message.body_bytes, 0, message.body_bytes.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.body_bytes)
                  : message.body_bytes;
            if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
              object.auth_info_bytes =
                options.bytes === String
                  ? $util.base64.encode(message.auth_info_bytes, 0, message.auth_info_bytes.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.auth_info_bytes)
                  : message.auth_info_bytes;
            if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
            if (message.account_number != null && message.hasOwnProperty('account_number'))
              if (typeof message.account_number === 'number')
                object.account_number = options.longs === String ? String(message.account_number) : message.account_number;
              else
                object.account_number =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.account_number)
                    : options.longs === Number
                    ? new $util.LongBits(message.account_number.low >>> 0, message.account_number.high >>> 0).toNumber(true)
                    : message.account_number;
            return object;
          };

          /**
           * Converts this SignDoc to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.SignDoc
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SignDoc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return SignDoc;
        })();

        v1beta1.SignDocDirectAux = (function () {
          /**
           * Properties of a SignDocDirectAux.
           * @memberof cosmos.tx.v1beta1
           * @interface ISignDocDirectAux
           * @property {Uint8Array|null} [body_bytes] SignDocDirectAux body_bytes
           * @property {google.protobuf.IAny|null} [public_key] SignDocDirectAux public_key
           * @property {string|null} [chain_id] SignDocDirectAux chain_id
           * @property {Long|null} [account_number] SignDocDirectAux account_number
           * @property {Long|null} [sequence] SignDocDirectAux sequence
           * @property {cosmos.tx.v1beta1.ITip|null} [tip] SignDocDirectAux tip
           */

          /**
           * Constructs a new SignDocDirectAux.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a SignDocDirectAux.
           * @implements ISignDocDirectAux
           * @constructor
           * @param {cosmos.tx.v1beta1.ISignDocDirectAux=} [properties] Properties to set
           */
          function SignDocDirectAux(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * SignDocDirectAux body_bytes.
           * @member {Uint8Array} body_bytes
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @instance
           */
          SignDocDirectAux.prototype.body_bytes = $util.newBuffer([]);

          /**
           * SignDocDirectAux public_key.
           * @member {google.protobuf.IAny|null|undefined} public_key
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @instance
           */
          SignDocDirectAux.prototype.public_key = null;

          /**
           * SignDocDirectAux chain_id.
           * @member {string} chain_id
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @instance
           */
          SignDocDirectAux.prototype.chain_id = '';

          /**
           * SignDocDirectAux account_number.
           * @member {Long} account_number
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @instance
           */
          SignDocDirectAux.prototype.account_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * SignDocDirectAux sequence.
           * @member {Long} sequence
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @instance
           */
          SignDocDirectAux.prototype.sequence = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * SignDocDirectAux tip.
           * @member {cosmos.tx.v1beta1.ITip|null|undefined} tip
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @instance
           */
          SignDocDirectAux.prototype.tip = null;

          /**
           * Encodes the specified SignDocDirectAux message. Does not implicitly {@link cosmos.tx.v1beta1.SignDocDirectAux.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @static
           * @param {cosmos.tx.v1beta1.ISignDocDirectAux} message SignDocDirectAux message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignDocDirectAux.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.body_bytes != null && Object.hasOwnProperty.call(message, 'body_bytes'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.body_bytes);
            if (message.public_key != null && Object.hasOwnProperty.call(message, 'public_key'))
              $root.google.protobuf.Any.encode(message.public_key, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.chain_id);
            if (message.account_number != null && Object.hasOwnProperty.call(message, 'account_number'))
              writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.account_number);
            if (message.sequence != null && Object.hasOwnProperty.call(message, 'sequence'))
              writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.sequence);
            if (message.tip != null && Object.hasOwnProperty.call(message, 'tip'))
              $root.cosmos.tx.v1beta1.Tip.encode(message.tip, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            return writer;
          };

          /**
           * Encodes the specified SignDocDirectAux message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.SignDocDirectAux.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @static
           * @param {cosmos.tx.v1beta1.ISignDocDirectAux} message SignDocDirectAux message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignDocDirectAux.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SignDocDirectAux message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.SignDocDirectAux} SignDocDirectAux
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignDocDirectAux.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.SignDocDirectAux();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.body_bytes = reader.bytes();
                  break;
                case 2:
                  message.public_key = $root.google.protobuf.Any.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.chain_id = reader.string();
                  break;
                case 4:
                  message.account_number = reader.uint64();
                  break;
                case 5:
                  message.sequence = reader.uint64();
                  break;
                case 6:
                  message.tip = $root.cosmos.tx.v1beta1.Tip.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SignDocDirectAux message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.SignDocDirectAux} SignDocDirectAux
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignDocDirectAux.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SignDocDirectAux message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SignDocDirectAux.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
              if (!((message.body_bytes && typeof message.body_bytes.length === 'number') || $util.isString(message.body_bytes)))
                return 'body_bytes: buffer expected';
            if (message.public_key != null && message.hasOwnProperty('public_key')) {
              var error = $root.google.protobuf.Any.verify(message.public_key);
              if (error) return 'public_key.' + error;
            }
            if (message.chain_id != null && message.hasOwnProperty('chain_id'))
              if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
            if (message.account_number != null && message.hasOwnProperty('account_number'))
              if (
                !$util.isInteger(message.account_number) &&
                !(message.account_number && $util.isInteger(message.account_number.low) && $util.isInteger(message.account_number.high))
              )
                return 'account_number: integer|Long expected';
            if (message.sequence != null && message.hasOwnProperty('sequence'))
              if (
                !$util.isInteger(message.sequence) &&
                !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high))
              )
                return 'sequence: integer|Long expected';
            if (message.tip != null && message.hasOwnProperty('tip')) {
              var error = $root.cosmos.tx.v1beta1.Tip.verify(message.tip);
              if (error) return 'tip.' + error;
            }
            return null;
          };

          /**
           * Creates a SignDocDirectAux message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.SignDocDirectAux} SignDocDirectAux
           */
          SignDocDirectAux.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.SignDocDirectAux) return object;
            var message = new $root.cosmos.tx.v1beta1.SignDocDirectAux();
            if (object.body_bytes != null)
              if (typeof object.body_bytes === 'string')
                $util.base64.decode(object.body_bytes, (message.body_bytes = $util.newBuffer($util.base64.length(object.body_bytes))), 0);
              else if (object.body_bytes.length) message.body_bytes = object.body_bytes;
            if (object.public_key != null) {
              if (typeof object.public_key !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignDocDirectAux.public_key: object expected');
              message.public_key = $root.google.protobuf.Any.fromObject(object.public_key);
            }
            if (object.chain_id != null) message.chain_id = String(object.chain_id);
            if (object.account_number != null)
              if ($util.Long) (message.account_number = $util.Long.fromValue(object.account_number)).unsigned = true;
              else if (typeof object.account_number === 'string') message.account_number = parseInt(object.account_number, 10);
              else if (typeof object.account_number === 'number') message.account_number = object.account_number;
              else if (typeof object.account_number === 'object')
                message.account_number = new $util.LongBits(object.account_number.low >>> 0, object.account_number.high >>> 0).toNumber(
                  true,
                );
            if (object.sequence != null)
              if ($util.Long) (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
              else if (typeof object.sequence === 'string') message.sequence = parseInt(object.sequence, 10);
              else if (typeof object.sequence === 'number') message.sequence = object.sequence;
              else if (typeof object.sequence === 'object')
                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
            if (object.tip != null) {
              if (typeof object.tip !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignDocDirectAux.tip: object expected');
              message.tip = $root.cosmos.tx.v1beta1.Tip.fromObject(object.tip);
            }
            return message;
          };

          /**
           * Creates a plain object from a SignDocDirectAux message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @static
           * @param {cosmos.tx.v1beta1.SignDocDirectAux} message SignDocDirectAux
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SignDocDirectAux.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              if (options.bytes === String) object.body_bytes = '';
              else {
                object.body_bytes = [];
                if (options.bytes !== Array) object.body_bytes = $util.newBuffer(object.body_bytes);
              }
              object.public_key = null;
              object.chain_id = '';
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.account_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.account_number = options.longs === String ? '0' : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.sequence = options.longs === String ? '0' : 0;
              object.tip = null;
            }
            if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
              object.body_bytes =
                options.bytes === String
                  ? $util.base64.encode(message.body_bytes, 0, message.body_bytes.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.body_bytes)
                  : message.body_bytes;
            if (message.public_key != null && message.hasOwnProperty('public_key'))
              object.public_key = $root.google.protobuf.Any.toObject(message.public_key, options);
            if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
            if (message.account_number != null && message.hasOwnProperty('account_number'))
              if (typeof message.account_number === 'number')
                object.account_number = options.longs === String ? String(message.account_number) : message.account_number;
              else
                object.account_number =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.account_number)
                    : options.longs === Number
                    ? new $util.LongBits(message.account_number.low >>> 0, message.account_number.high >>> 0).toNumber(true)
                    : message.account_number;
            if (message.sequence != null && message.hasOwnProperty('sequence'))
              if (typeof message.sequence === 'number')
                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
              else
                object.sequence =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.sequence)
                    : options.longs === Number
                    ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true)
                    : message.sequence;
            if (message.tip != null && message.hasOwnProperty('tip'))
              object.tip = $root.cosmos.tx.v1beta1.Tip.toObject(message.tip, options);
            return object;
          };

          /**
           * Converts this SignDocDirectAux to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.SignDocDirectAux
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SignDocDirectAux.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return SignDocDirectAux;
        })();

        v1beta1.TxBody = (function () {
          /**
           * Properties of a TxBody.
           * @memberof cosmos.tx.v1beta1
           * @interface ITxBody
           * @property {Array.<google.protobuf.IAny>|null} [messages] TxBody messages
           * @property {string|null} [memo] TxBody memo
           * @property {Long|null} [timeout_height] TxBody timeout_height
           * @property {Array.<google.protobuf.IAny>|null} [extension_options] TxBody extension_options
           * @property {Array.<google.protobuf.IAny>|null} [non_critical_extension_options] TxBody non_critical_extension_options
           */

          /**
           * Constructs a new TxBody.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a TxBody.
           * @implements ITxBody
           * @constructor
           * @param {cosmos.tx.v1beta1.ITxBody=} [properties] Properties to set
           */
          function TxBody(properties) {
            this.messages = [];
            this.extension_options = [];
            this.non_critical_extension_options = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * TxBody messages.
           * @member {Array.<google.protobuf.IAny>} messages
           * @memberof cosmos.tx.v1beta1.TxBody
           * @instance
           */
          TxBody.prototype.messages = $util.emptyArray;

          /**
           * TxBody memo.
           * @member {string} memo
           * @memberof cosmos.tx.v1beta1.TxBody
           * @instance
           */
          TxBody.prototype.memo = '';

          /**
           * TxBody timeout_height.
           * @member {Long} timeout_height
           * @memberof cosmos.tx.v1beta1.TxBody
           * @instance
           */
          TxBody.prototype.timeout_height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * TxBody extension_options.
           * @member {Array.<google.protobuf.IAny>} extension_options
           * @memberof cosmos.tx.v1beta1.TxBody
           * @instance
           */
          TxBody.prototype.extension_options = $util.emptyArray;

          /**
           * TxBody non_critical_extension_options.
           * @member {Array.<google.protobuf.IAny>} non_critical_extension_options
           * @memberof cosmos.tx.v1beta1.TxBody
           * @instance
           */
          TxBody.prototype.non_critical_extension_options = $util.emptyArray;

          /**
           * Encodes the specified TxBody message. Does not implicitly {@link cosmos.tx.v1beta1.TxBody.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.TxBody
           * @static
           * @param {cosmos.tx.v1beta1.ITxBody} message TxBody message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TxBody.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.messages != null && message.messages.length)
              for (var i = 0; i < message.messages.length; ++i)
                $root.google.protobuf.Any.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.memo != null && Object.hasOwnProperty.call(message, 'memo'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.memo);
            if (message.timeout_height != null && Object.hasOwnProperty.call(message, 'timeout_height'))
              writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.timeout_height);
            if (message.extension_options != null && message.extension_options.length)
              for (var i = 0; i < message.extension_options.length; ++i)
                $root.google.protobuf.Any.encode(
                  message.extension_options[i],
                  writer.uint32(/* id 1023, wireType 2 =*/ 8186).fork(),
                ).ldelim();
            if (message.non_critical_extension_options != null && message.non_critical_extension_options.length)
              for (var i = 0; i < message.non_critical_extension_options.length; ++i)
                $root.google.protobuf.Any.encode(
                  message.non_critical_extension_options[i],
                  writer.uint32(/* id 2047, wireType 2 =*/ 16378).fork(),
                ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified TxBody message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.TxBody.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.TxBody
           * @static
           * @param {cosmos.tx.v1beta1.ITxBody} message TxBody message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TxBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a TxBody message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.TxBody
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.TxBody} TxBody
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TxBody.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.TxBody();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.messages && message.messages.length)) message.messages = [];
                  message.messages.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.memo = reader.string();
                  break;
                case 3:
                  message.timeout_height = reader.uint64();
                  break;
                case 1023:
                  if (!(message.extension_options && message.extension_options.length)) message.extension_options = [];
                  message.extension_options.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                  break;
                case 2047:
                  if (!(message.non_critical_extension_options && message.non_critical_extension_options.length))
                    message.non_critical_extension_options = [];
                  message.non_critical_extension_options.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a TxBody message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.TxBody
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.TxBody} TxBody
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TxBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a TxBody message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.TxBody
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          TxBody.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.messages != null && message.hasOwnProperty('messages')) {
              if (!Array.isArray(message.messages)) return 'messages: array expected';
              for (var i = 0; i < message.messages.length; ++i) {
                var error = $root.google.protobuf.Any.verify(message.messages[i]);
                if (error) return 'messages.' + error;
              }
            }
            if (message.memo != null && message.hasOwnProperty('memo')) if (!$util.isString(message.memo)) return 'memo: string expected';
            if (message.timeout_height != null && message.hasOwnProperty('timeout_height'))
              if (
                !$util.isInteger(message.timeout_height) &&
                !(message.timeout_height && $util.isInteger(message.timeout_height.low) && $util.isInteger(message.timeout_height.high))
              )
                return 'timeout_height: integer|Long expected';
            if (message.extension_options != null && message.hasOwnProperty('extension_options')) {
              if (!Array.isArray(message.extension_options)) return 'extension_options: array expected';
              for (var i = 0; i < message.extension_options.length; ++i) {
                var error = $root.google.protobuf.Any.verify(message.extension_options[i]);
                if (error) return 'extension_options.' + error;
              }
            }
            if (message.non_critical_extension_options != null && message.hasOwnProperty('non_critical_extension_options')) {
              if (!Array.isArray(message.non_critical_extension_options)) return 'non_critical_extension_options: array expected';
              for (var i = 0; i < message.non_critical_extension_options.length; ++i) {
                var error = $root.google.protobuf.Any.verify(message.non_critical_extension_options[i]);
                if (error) return 'non_critical_extension_options.' + error;
              }
            }
            return null;
          };

          /**
           * Creates a TxBody message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.TxBody
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.TxBody} TxBody
           */
          TxBody.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.TxBody) return object;
            var message = new $root.cosmos.tx.v1beta1.TxBody();
            if (object.messages) {
              if (!Array.isArray(object.messages)) throw TypeError('.cosmos.tx.v1beta1.TxBody.messages: array expected');
              message.messages = [];
              for (var i = 0; i < object.messages.length; ++i) {
                if (typeof object.messages[i] !== 'object') throw TypeError('.cosmos.tx.v1beta1.TxBody.messages: object expected');
                message.messages[i] = $root.google.protobuf.Any.fromObject(object.messages[i]);
              }
            }
            if (object.memo != null) message.memo = String(object.memo);
            if (object.timeout_height != null)
              if ($util.Long) (message.timeout_height = $util.Long.fromValue(object.timeout_height)).unsigned = true;
              else if (typeof object.timeout_height === 'string') message.timeout_height = parseInt(object.timeout_height, 10);
              else if (typeof object.timeout_height === 'number') message.timeout_height = object.timeout_height;
              else if (typeof object.timeout_height === 'object')
                message.timeout_height = new $util.LongBits(object.timeout_height.low >>> 0, object.timeout_height.high >>> 0).toNumber(
                  true,
                );
            if (object.extension_options) {
              if (!Array.isArray(object.extension_options)) throw TypeError('.cosmos.tx.v1beta1.TxBody.extension_options: array expected');
              message.extension_options = [];
              for (var i = 0; i < object.extension_options.length; ++i) {
                if (typeof object.extension_options[i] !== 'object')
                  throw TypeError('.cosmos.tx.v1beta1.TxBody.extension_options: object expected');
                message.extension_options[i] = $root.google.protobuf.Any.fromObject(object.extension_options[i]);
              }
            }
            if (object.non_critical_extension_options) {
              if (!Array.isArray(object.non_critical_extension_options))
                throw TypeError('.cosmos.tx.v1beta1.TxBody.non_critical_extension_options: array expected');
              message.non_critical_extension_options = [];
              for (var i = 0; i < object.non_critical_extension_options.length; ++i) {
                if (typeof object.non_critical_extension_options[i] !== 'object')
                  throw TypeError('.cosmos.tx.v1beta1.TxBody.non_critical_extension_options: object expected');
                message.non_critical_extension_options[i] = $root.google.protobuf.Any.fromObject(object.non_critical_extension_options[i]);
              }
            }
            return message;
          };

          /**
           * Creates a plain object from a TxBody message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.TxBody
           * @static
           * @param {cosmos.tx.v1beta1.TxBody} message TxBody
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          TxBody.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.messages = [];
              object.extension_options = [];
              object.non_critical_extension_options = [];
            }
            if (options.defaults) {
              object.memo = '';
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.timeout_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.timeout_height = options.longs === String ? '0' : 0;
            }
            if (message.messages && message.messages.length) {
              object.messages = [];
              for (var j = 0; j < message.messages.length; ++j)
                object.messages[j] = $root.google.protobuf.Any.toObject(message.messages[j], options);
            }
            if (message.memo != null && message.hasOwnProperty('memo')) object.memo = message.memo;
            if (message.timeout_height != null && message.hasOwnProperty('timeout_height'))
              if (typeof message.timeout_height === 'number')
                object.timeout_height = options.longs === String ? String(message.timeout_height) : message.timeout_height;
              else
                object.timeout_height =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.timeout_height)
                    : options.longs === Number
                    ? new $util.LongBits(message.timeout_height.low >>> 0, message.timeout_height.high >>> 0).toNumber(true)
                    : message.timeout_height;
            if (message.extension_options && message.extension_options.length) {
              object.extension_options = [];
              for (var j = 0; j < message.extension_options.length; ++j)
                object.extension_options[j] = $root.google.protobuf.Any.toObject(message.extension_options[j], options);
            }
            if (message.non_critical_extension_options && message.non_critical_extension_options.length) {
              object.non_critical_extension_options = [];
              for (var j = 0; j < message.non_critical_extension_options.length; ++j)
                object.non_critical_extension_options[j] = $root.google.protobuf.Any.toObject(
                  message.non_critical_extension_options[j],
                  options,
                );
            }
            return object;
          };

          /**
           * Converts this TxBody to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.TxBody
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          TxBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return TxBody;
        })();

        v1beta1.AuthInfo = (function () {
          /**
           * Properties of an AuthInfo.
           * @memberof cosmos.tx.v1beta1
           * @interface IAuthInfo
           * @property {Array.<cosmos.tx.v1beta1.ISignerInfo>|null} [signer_infos] AuthInfo signer_infos
           * @property {cosmos.tx.v1beta1.IFee|null} [fee] AuthInfo fee
           * @property {cosmos.tx.v1beta1.ITip|null} [tip] AuthInfo tip
           */

          /**
           * Constructs a new AuthInfo.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents an AuthInfo.
           * @implements IAuthInfo
           * @constructor
           * @param {cosmos.tx.v1beta1.IAuthInfo=} [properties] Properties to set
           */
          function AuthInfo(properties) {
            this.signer_infos = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * AuthInfo signer_infos.
           * @member {Array.<cosmos.tx.v1beta1.ISignerInfo>} signer_infos
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @instance
           */
          AuthInfo.prototype.signer_infos = $util.emptyArray;

          /**
           * AuthInfo fee.
           * @member {cosmos.tx.v1beta1.IFee|null|undefined} fee
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @instance
           */
          AuthInfo.prototype.fee = null;

          /**
           * AuthInfo tip.
           * @member {cosmos.tx.v1beta1.ITip|null|undefined} tip
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @instance
           */
          AuthInfo.prototype.tip = null;

          /**
           * Encodes the specified AuthInfo message. Does not implicitly {@link cosmos.tx.v1beta1.AuthInfo.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @static
           * @param {cosmos.tx.v1beta1.IAuthInfo} message AuthInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          AuthInfo.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.signer_infos != null && message.signer_infos.length)
              for (var i = 0; i < message.signer_infos.length; ++i)
                $root.cosmos.tx.v1beta1.SignerInfo.encode(
                  message.signer_infos[i],
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
            if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
              $root.cosmos.tx.v1beta1.Fee.encode(message.fee, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.tip != null && Object.hasOwnProperty.call(message, 'tip'))
              $root.cosmos.tx.v1beta1.Tip.encode(message.tip, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
          };

          /**
           * Encodes the specified AuthInfo message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.AuthInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @static
           * @param {cosmos.tx.v1beta1.IAuthInfo} message AuthInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          AuthInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an AuthInfo message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.AuthInfo} AuthInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          AuthInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.AuthInfo();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.signer_infos && message.signer_infos.length)) message.signer_infos = [];
                  message.signer_infos.push($root.cosmos.tx.v1beta1.SignerInfo.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.fee = $root.cosmos.tx.v1beta1.Fee.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.tip = $root.cosmos.tx.v1beta1.Tip.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an AuthInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.AuthInfo} AuthInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          AuthInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an AuthInfo message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          AuthInfo.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.signer_infos != null && message.hasOwnProperty('signer_infos')) {
              if (!Array.isArray(message.signer_infos)) return 'signer_infos: array expected';
              for (var i = 0; i < message.signer_infos.length; ++i) {
                var error = $root.cosmos.tx.v1beta1.SignerInfo.verify(message.signer_infos[i]);
                if (error) return 'signer_infos.' + error;
              }
            }
            if (message.fee != null && message.hasOwnProperty('fee')) {
              var error = $root.cosmos.tx.v1beta1.Fee.verify(message.fee);
              if (error) return 'fee.' + error;
            }
            if (message.tip != null && message.hasOwnProperty('tip')) {
              var error = $root.cosmos.tx.v1beta1.Tip.verify(message.tip);
              if (error) return 'tip.' + error;
            }
            return null;
          };

          /**
           * Creates an AuthInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.AuthInfo} AuthInfo
           */
          AuthInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.AuthInfo) return object;
            var message = new $root.cosmos.tx.v1beta1.AuthInfo();
            if (object.signer_infos) {
              if (!Array.isArray(object.signer_infos)) throw TypeError('.cosmos.tx.v1beta1.AuthInfo.signer_infos: array expected');
              message.signer_infos = [];
              for (var i = 0; i < object.signer_infos.length; ++i) {
                if (typeof object.signer_infos[i] !== 'object')
                  throw TypeError('.cosmos.tx.v1beta1.AuthInfo.signer_infos: object expected');
                message.signer_infos[i] = $root.cosmos.tx.v1beta1.SignerInfo.fromObject(object.signer_infos[i]);
              }
            }
            if (object.fee != null) {
              if (typeof object.fee !== 'object') throw TypeError('.cosmos.tx.v1beta1.AuthInfo.fee: object expected');
              message.fee = $root.cosmos.tx.v1beta1.Fee.fromObject(object.fee);
            }
            if (object.tip != null) {
              if (typeof object.tip !== 'object') throw TypeError('.cosmos.tx.v1beta1.AuthInfo.tip: object expected');
              message.tip = $root.cosmos.tx.v1beta1.Tip.fromObject(object.tip);
            }
            return message;
          };

          /**
           * Creates a plain object from an AuthInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @static
           * @param {cosmos.tx.v1beta1.AuthInfo} message AuthInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          AuthInfo.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) object.signer_infos = [];
            if (options.defaults) {
              object.fee = null;
              object.tip = null;
            }
            if (message.signer_infos && message.signer_infos.length) {
              object.signer_infos = [];
              for (var j = 0; j < message.signer_infos.length; ++j)
                object.signer_infos[j] = $root.cosmos.tx.v1beta1.SignerInfo.toObject(message.signer_infos[j], options);
            }
            if (message.fee != null && message.hasOwnProperty('fee'))
              object.fee = $root.cosmos.tx.v1beta1.Fee.toObject(message.fee, options);
            if (message.tip != null && message.hasOwnProperty('tip'))
              object.tip = $root.cosmos.tx.v1beta1.Tip.toObject(message.tip, options);
            return object;
          };

          /**
           * Converts this AuthInfo to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.AuthInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          AuthInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return AuthInfo;
        })();

        v1beta1.SignerInfo = (function () {
          /**
           * Properties of a SignerInfo.
           * @memberof cosmos.tx.v1beta1
           * @interface ISignerInfo
           * @property {google.protobuf.IAny|null} [public_key] SignerInfo public_key
           * @property {cosmos.tx.v1beta1.IModeInfo|null} [mode_info] SignerInfo mode_info
           * @property {Long|null} [sequence] SignerInfo sequence
           */

          /**
           * Constructs a new SignerInfo.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a SignerInfo.
           * @implements ISignerInfo
           * @constructor
           * @param {cosmos.tx.v1beta1.ISignerInfo=} [properties] Properties to set
           */
          function SignerInfo(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * SignerInfo public_key.
           * @member {google.protobuf.IAny|null|undefined} public_key
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @instance
           */
          SignerInfo.prototype.public_key = null;

          /**
           * SignerInfo mode_info.
           * @member {cosmos.tx.v1beta1.IModeInfo|null|undefined} mode_info
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @instance
           */
          SignerInfo.prototype.mode_info = null;

          /**
           * SignerInfo sequence.
           * @member {Long} sequence
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @instance
           */
          SignerInfo.prototype.sequence = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * Encodes the specified SignerInfo message. Does not implicitly {@link cosmos.tx.v1beta1.SignerInfo.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @static
           * @param {cosmos.tx.v1beta1.ISignerInfo} message SignerInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignerInfo.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.public_key != null && Object.hasOwnProperty.call(message, 'public_key'))
              $root.google.protobuf.Any.encode(message.public_key, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.mode_info != null && Object.hasOwnProperty.call(message, 'mode_info'))
              $root.cosmos.tx.v1beta1.ModeInfo.encode(message.mode_info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.sequence != null && Object.hasOwnProperty.call(message, 'sequence'))
              writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.sequence);
            return writer;
          };

          /**
           * Encodes the specified SignerInfo message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.SignerInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @static
           * @param {cosmos.tx.v1beta1.ISignerInfo} message SignerInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SignerInfo message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.SignerInfo} SignerInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.SignerInfo();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.public_key = $root.google.protobuf.Any.decode(reader, reader.uint32());
                  break;
                case 2:
                  message.mode_info = $root.cosmos.tx.v1beta1.ModeInfo.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.sequence = reader.uint64();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SignerInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.SignerInfo} SignerInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SignerInfo message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SignerInfo.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.public_key != null && message.hasOwnProperty('public_key')) {
              var error = $root.google.protobuf.Any.verify(message.public_key);
              if (error) return 'public_key.' + error;
            }
            if (message.mode_info != null && message.hasOwnProperty('mode_info')) {
              var error = $root.cosmos.tx.v1beta1.ModeInfo.verify(message.mode_info);
              if (error) return 'mode_info.' + error;
            }
            if (message.sequence != null && message.hasOwnProperty('sequence'))
              if (
                !$util.isInteger(message.sequence) &&
                !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high))
              )
                return 'sequence: integer|Long expected';
            return null;
          };

          /**
           * Creates a SignerInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.SignerInfo} SignerInfo
           */
          SignerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.SignerInfo) return object;
            var message = new $root.cosmos.tx.v1beta1.SignerInfo();
            if (object.public_key != null) {
              if (typeof object.public_key !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignerInfo.public_key: object expected');
              message.public_key = $root.google.protobuf.Any.fromObject(object.public_key);
            }
            if (object.mode_info != null) {
              if (typeof object.mode_info !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignerInfo.mode_info: object expected');
              message.mode_info = $root.cosmos.tx.v1beta1.ModeInfo.fromObject(object.mode_info);
            }
            if (object.sequence != null)
              if ($util.Long) (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
              else if (typeof object.sequence === 'string') message.sequence = parseInt(object.sequence, 10);
              else if (typeof object.sequence === 'number') message.sequence = object.sequence;
              else if (typeof object.sequence === 'object')
                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
            return message;
          };

          /**
           * Creates a plain object from a SignerInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @static
           * @param {cosmos.tx.v1beta1.SignerInfo} message SignerInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SignerInfo.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.public_key = null;
              object.mode_info = null;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.sequence = options.longs === String ? '0' : 0;
            }
            if (message.public_key != null && message.hasOwnProperty('public_key'))
              object.public_key = $root.google.protobuf.Any.toObject(message.public_key, options);
            if (message.mode_info != null && message.hasOwnProperty('mode_info'))
              object.mode_info = $root.cosmos.tx.v1beta1.ModeInfo.toObject(message.mode_info, options);
            if (message.sequence != null && message.hasOwnProperty('sequence'))
              if (typeof message.sequence === 'number')
                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
              else
                object.sequence =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.sequence)
                    : options.longs === Number
                    ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true)
                    : message.sequence;
            return object;
          };

          /**
           * Converts this SignerInfo to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.SignerInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SignerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return SignerInfo;
        })();

        v1beta1.ModeInfo = (function () {
          /**
           * Properties of a ModeInfo.
           * @memberof cosmos.tx.v1beta1
           * @interface IModeInfo
           * @property {cosmos.tx.v1beta1.ModeInfo.ISingle|null} [single] ModeInfo single
           * @property {cosmos.tx.v1beta1.ModeInfo.IMulti|null} [multi] ModeInfo multi
           */

          /**
           * Constructs a new ModeInfo.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a ModeInfo.
           * @implements IModeInfo
           * @constructor
           * @param {cosmos.tx.v1beta1.IModeInfo=} [properties] Properties to set
           */
          function ModeInfo(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * ModeInfo single.
           * @member {cosmos.tx.v1beta1.ModeInfo.ISingle|null|undefined} single
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @instance
           */
          ModeInfo.prototype.single = null;

          /**
           * ModeInfo multi.
           * @member {cosmos.tx.v1beta1.ModeInfo.IMulti|null|undefined} multi
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @instance
           */
          ModeInfo.prototype.multi = null;

          // OneOf field names bound to virtual getters and setters
          var $oneOfFields;

          /**
           * ModeInfo sum.
           * @member {"single"|"multi"|undefined} sum
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @instance
           */
          Object.defineProperty(ModeInfo.prototype, 'sum', {
            get: $util.oneOfGetter(($oneOfFields = ['single', 'multi'])),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Encodes the specified ModeInfo message. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @static
           * @param {cosmos.tx.v1beta1.IModeInfo} message ModeInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ModeInfo.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.single != null && Object.hasOwnProperty.call(message, 'single'))
              $root.cosmos.tx.v1beta1.ModeInfo.Single.encode(message.single, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.multi != null && Object.hasOwnProperty.call(message, 'multi'))
              $root.cosmos.tx.v1beta1.ModeInfo.Multi.encode(message.multi, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
          };

          /**
           * Encodes the specified ModeInfo message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @static
           * @param {cosmos.tx.v1beta1.IModeInfo} message ModeInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ModeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ModeInfo message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.ModeInfo} ModeInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ModeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.ModeInfo();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.single = $root.cosmos.tx.v1beta1.ModeInfo.Single.decode(reader, reader.uint32());
                  break;
                case 2:
                  message.multi = $root.cosmos.tx.v1beta1.ModeInfo.Multi.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a ModeInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.ModeInfo} ModeInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ModeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ModeInfo message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ModeInfo.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            var properties = {};
            if (message.single != null && message.hasOwnProperty('single')) {
              properties.sum = 1;
              {
                var error = $root.cosmos.tx.v1beta1.ModeInfo.Single.verify(message.single);
                if (error) return 'single.' + error;
              }
            }
            if (message.multi != null && message.hasOwnProperty('multi')) {
              if (properties.sum === 1) return 'sum: multiple values';
              properties.sum = 1;
              {
                var error = $root.cosmos.tx.v1beta1.ModeInfo.Multi.verify(message.multi);
                if (error) return 'multi.' + error;
              }
            }
            return null;
          };

          /**
           * Creates a ModeInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.ModeInfo} ModeInfo
           */
          ModeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.ModeInfo) return object;
            var message = new $root.cosmos.tx.v1beta1.ModeInfo();
            if (object.single != null) {
              if (typeof object.single !== 'object') throw TypeError('.cosmos.tx.v1beta1.ModeInfo.single: object expected');
              message.single = $root.cosmos.tx.v1beta1.ModeInfo.Single.fromObject(object.single);
            }
            if (object.multi != null) {
              if (typeof object.multi !== 'object') throw TypeError('.cosmos.tx.v1beta1.ModeInfo.multi: object expected');
              message.multi = $root.cosmos.tx.v1beta1.ModeInfo.Multi.fromObject(object.multi);
            }
            return message;
          };

          /**
           * Creates a plain object from a ModeInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @static
           * @param {cosmos.tx.v1beta1.ModeInfo} message ModeInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ModeInfo.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (message.single != null && message.hasOwnProperty('single')) {
              object.single = $root.cosmos.tx.v1beta1.ModeInfo.Single.toObject(message.single, options);
              if (options.oneofs) object.sum = 'single';
            }
            if (message.multi != null && message.hasOwnProperty('multi')) {
              object.multi = $root.cosmos.tx.v1beta1.ModeInfo.Multi.toObject(message.multi, options);
              if (options.oneofs) object.sum = 'multi';
            }
            return object;
          };

          /**
           * Converts this ModeInfo to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ModeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          ModeInfo.Single = (function () {
            /**
             * Properties of a Single.
             * @memberof cosmos.tx.v1beta1.ModeInfo
             * @interface ISingle
             * @property {cosmos.tx.signing.v1beta1.SignMode|null} [mode] Single mode
             */

            /**
             * Constructs a new Single.
             * @memberof cosmos.tx.v1beta1.ModeInfo
             * @classdesc Represents a Single.
             * @implements ISingle
             * @constructor
             * @param {cosmos.tx.v1beta1.ModeInfo.ISingle=} [properties] Properties to set
             */
            function Single(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * Single mode.
             * @member {cosmos.tx.signing.v1beta1.SignMode} mode
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @instance
             */
            Single.prototype.mode = 0;

            /**
             * Encodes the specified Single message. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Single.verify|verify} messages.
             * @function encode
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @static
             * @param {cosmos.tx.v1beta1.ModeInfo.ISingle} message Single message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Single.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.mode != null && Object.hasOwnProperty.call(message, 'mode'))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.mode);
              return writer;
            };

            /**
             * Encodes the specified Single message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Single.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @static
             * @param {cosmos.tx.v1beta1.ModeInfo.ISingle} message Single message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Single.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Single message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.tx.v1beta1.ModeInfo.Single} Single
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Single.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.tx.v1beta1.ModeInfo.Single();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.mode = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Single message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.tx.v1beta1.ModeInfo.Single} Single
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Single.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Single message.
             * @function verify
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Single.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.mode != null && message.hasOwnProperty('mode'))
                switch (message.mode) {
                  default:
                    return 'mode: enum value expected';
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 127:
                  case 191:
                    break;
                }
              return null;
            };

            /**
             * Creates a Single message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.tx.v1beta1.ModeInfo.Single} Single
             */
            Single.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.tx.v1beta1.ModeInfo.Single) return object;
              var message = new $root.cosmos.tx.v1beta1.ModeInfo.Single();
              switch (object.mode) {
                case 'SIGN_MODE_UNSPECIFIED':
                case 0:
                  message.mode = 0;
                  break;
                case 'SIGN_MODE_DIRECT':
                case 1:
                  message.mode = 1;
                  break;
                case 'SIGN_MODE_TEXTUAL':
                case 2:
                  message.mode = 2;
                  break;
                case 'SIGN_MODE_DIRECT_AUX':
                case 3:
                  message.mode = 3;
                  break;
                case 'SIGN_MODE_LEGACY_AMINO_JSON':
                case 127:
                  message.mode = 127;
                  break;
                case 'SIGN_MODE_EIP_191':
                case 191:
                  message.mode = 191;
                  break;
              }
              return message;
            };

            /**
             * Creates a plain object from a Single message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @static
             * @param {cosmos.tx.v1beta1.ModeInfo.Single} message Single
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Single.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.mode = options.enums === String ? 'SIGN_MODE_UNSPECIFIED' : 0;
              if (message.mode != null && message.hasOwnProperty('mode'))
                object.mode = options.enums === String ? $root.cosmos.tx.signing.v1beta1.SignMode[message.mode] : message.mode;
              return object;
            };

            /**
             * Converts this Single to JSON.
             * @function toJSON
             * @memberof cosmos.tx.v1beta1.ModeInfo.Single
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Single.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Single;
          })();

          ModeInfo.Multi = (function () {
            /**
             * Properties of a Multi.
             * @memberof cosmos.tx.v1beta1.ModeInfo
             * @interface IMulti
             * @property {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null} [bitarray] Multi bitarray
             * @property {Array.<cosmos.tx.v1beta1.IModeInfo>|null} [mode_infos] Multi mode_infos
             */

            /**
             * Constructs a new Multi.
             * @memberof cosmos.tx.v1beta1.ModeInfo
             * @classdesc Represents a Multi.
             * @implements IMulti
             * @constructor
             * @param {cosmos.tx.v1beta1.ModeInfo.IMulti=} [properties] Properties to set
             */
            function Multi(properties) {
              this.mode_infos = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * Multi bitarray.
             * @member {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null|undefined} bitarray
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @instance
             */
            Multi.prototype.bitarray = null;

            /**
             * Multi mode_infos.
             * @member {Array.<cosmos.tx.v1beta1.IModeInfo>} mode_infos
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @instance
             */
            Multi.prototype.mode_infos = $util.emptyArray;

            /**
             * Encodes the specified Multi message. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Multi.verify|verify} messages.
             * @function encode
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @static
             * @param {cosmos.tx.v1beta1.ModeInfo.IMulti} message Multi message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Multi.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.bitarray != null && Object.hasOwnProperty.call(message, 'bitarray'))
                $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.encode(
                  message.bitarray,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (message.mode_infos != null && message.mode_infos.length)
                for (var i = 0; i < message.mode_infos.length; ++i)
                  $root.cosmos.tx.v1beta1.ModeInfo.encode(message.mode_infos[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Multi message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Multi.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @static
             * @param {cosmos.tx.v1beta1.ModeInfo.IMulti} message Multi message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Multi.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Multi message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.tx.v1beta1.ModeInfo.Multi} Multi
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Multi.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.tx.v1beta1.ModeInfo.Multi();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.decode(reader, reader.uint32());
                    break;
                  case 2:
                    if (!(message.mode_infos && message.mode_infos.length)) message.mode_infos = [];
                    message.mode_infos.push($root.cosmos.tx.v1beta1.ModeInfo.decode(reader, reader.uint32()));
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Multi message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.tx.v1beta1.ModeInfo.Multi} Multi
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Multi.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Multi message.
             * @function verify
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Multi.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.bitarray != null && message.hasOwnProperty('bitarray')) {
                var error = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.verify(message.bitarray);
                if (error) return 'bitarray.' + error;
              }
              if (message.mode_infos != null && message.hasOwnProperty('mode_infos')) {
                if (!Array.isArray(message.mode_infos)) return 'mode_infos: array expected';
                for (var i = 0; i < message.mode_infos.length; ++i) {
                  var error = $root.cosmos.tx.v1beta1.ModeInfo.verify(message.mode_infos[i]);
                  if (error) return 'mode_infos.' + error;
                }
              }
              return null;
            };

            /**
             * Creates a Multi message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.tx.v1beta1.ModeInfo.Multi} Multi
             */
            Multi.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.tx.v1beta1.ModeInfo.Multi) return object;
              var message = new $root.cosmos.tx.v1beta1.ModeInfo.Multi();
              if (object.bitarray != null) {
                if (typeof object.bitarray !== 'object') throw TypeError('.cosmos.tx.v1beta1.ModeInfo.Multi.bitarray: object expected');
                message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.fromObject(object.bitarray);
              }
              if (object.mode_infos) {
                if (!Array.isArray(object.mode_infos)) throw TypeError('.cosmos.tx.v1beta1.ModeInfo.Multi.mode_infos: array expected');
                message.mode_infos = [];
                for (var i = 0; i < object.mode_infos.length; ++i) {
                  if (typeof object.mode_infos[i] !== 'object')
                    throw TypeError('.cosmos.tx.v1beta1.ModeInfo.Multi.mode_infos: object expected');
                  message.mode_infos[i] = $root.cosmos.tx.v1beta1.ModeInfo.fromObject(object.mode_infos[i]);
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a Multi message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @static
             * @param {cosmos.tx.v1beta1.ModeInfo.Multi} message Multi
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Multi.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.mode_infos = [];
              if (options.defaults) object.bitarray = null;
              if (message.bitarray != null && message.hasOwnProperty('bitarray'))
                object.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.toObject(message.bitarray, options);
              if (message.mode_infos && message.mode_infos.length) {
                object.mode_infos = [];
                for (var j = 0; j < message.mode_infos.length; ++j)
                  object.mode_infos[j] = $root.cosmos.tx.v1beta1.ModeInfo.toObject(message.mode_infos[j], options);
              }
              return object;
            };

            /**
             * Converts this Multi to JSON.
             * @function toJSON
             * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Multi.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Multi;
          })();

          return ModeInfo;
        })();

        v1beta1.Fee = (function () {
          /**
           * Properties of a Fee.
           * @memberof cosmos.tx.v1beta1
           * @interface IFee
           * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [amount] Fee amount
           * @property {Long|null} [gas_limit] Fee gas_limit
           * @property {string|null} [payer] Fee payer
           * @property {string|null} [granter] Fee granter
           */

          /**
           * Constructs a new Fee.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a Fee.
           * @implements IFee
           * @constructor
           * @param {cosmos.tx.v1beta1.IFee=} [properties] Properties to set
           */
          function Fee(properties) {
            this.amount = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Fee amount.
           * @member {Array.<cosmos.base.v1beta1.ICoin>} amount
           * @memberof cosmos.tx.v1beta1.Fee
           * @instance
           */
          Fee.prototype.amount = $util.emptyArray;

          /**
           * Fee gas_limit.
           * @member {Long} gas_limit
           * @memberof cosmos.tx.v1beta1.Fee
           * @instance
           */
          Fee.prototype.gas_limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * Fee payer.
           * @member {string} payer
           * @memberof cosmos.tx.v1beta1.Fee
           * @instance
           */
          Fee.prototype.payer = '';

          /**
           * Fee granter.
           * @member {string} granter
           * @memberof cosmos.tx.v1beta1.Fee
           * @instance
           */
          Fee.prototype.granter = '';

          /**
           * Encodes the specified Fee message. Does not implicitly {@link cosmos.tx.v1beta1.Fee.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.Fee
           * @static
           * @param {cosmos.tx.v1beta1.IFee} message Fee message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Fee.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.amount != null && message.amount.length)
              for (var i = 0; i < message.amount.length; ++i)
                $root.cosmos.base.v1beta1.Coin.encode(message.amount[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.gas_limit != null && Object.hasOwnProperty.call(message, 'gas_limit'))
              writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.gas_limit);
            if (message.payer != null && Object.hasOwnProperty.call(message, 'payer'))
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.payer);
            if (message.granter != null && Object.hasOwnProperty.call(message, 'granter'))
              writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.granter);
            return writer;
          };

          /**
           * Encodes the specified Fee message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.Fee.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.Fee
           * @static
           * @param {cosmos.tx.v1beta1.IFee} message Fee message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Fee.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Fee message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.Fee
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.Fee} Fee
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Fee.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.Fee();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.amount && message.amount.length)) message.amount = [];
                  message.amount.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.gas_limit = reader.uint64();
                  break;
                case 3:
                  message.payer = reader.string();
                  break;
                case 4:
                  message.granter = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Fee message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.Fee
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.Fee} Fee
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Fee.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Fee message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.Fee
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Fee.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.amount != null && message.hasOwnProperty('amount')) {
              if (!Array.isArray(message.amount)) return 'amount: array expected';
              for (var i = 0; i < message.amount.length; ++i) {
                var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount[i]);
                if (error) return 'amount.' + error;
              }
            }
            if (message.gas_limit != null && message.hasOwnProperty('gas_limit'))
              if (
                !$util.isInteger(message.gas_limit) &&
                !(message.gas_limit && $util.isInteger(message.gas_limit.low) && $util.isInteger(message.gas_limit.high))
              )
                return 'gas_limit: integer|Long expected';
            if (message.payer != null && message.hasOwnProperty('payer'))
              if (!$util.isString(message.payer)) return 'payer: string expected';
            if (message.granter != null && message.hasOwnProperty('granter'))
              if (!$util.isString(message.granter)) return 'granter: string expected';
            return null;
          };

          /**
           * Creates a Fee message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.Fee
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.Fee} Fee
           */
          Fee.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.Fee) return object;
            var message = new $root.cosmos.tx.v1beta1.Fee();
            if (object.amount) {
              if (!Array.isArray(object.amount)) throw TypeError('.cosmos.tx.v1beta1.Fee.amount: array expected');
              message.amount = [];
              for (var i = 0; i < object.amount.length; ++i) {
                if (typeof object.amount[i] !== 'object') throw TypeError('.cosmos.tx.v1beta1.Fee.amount: object expected');
                message.amount[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount[i]);
              }
            }
            if (object.gas_limit != null)
              if ($util.Long) (message.gas_limit = $util.Long.fromValue(object.gas_limit)).unsigned = true;
              else if (typeof object.gas_limit === 'string') message.gas_limit = parseInt(object.gas_limit, 10);
              else if (typeof object.gas_limit === 'number') message.gas_limit = object.gas_limit;
              else if (typeof object.gas_limit === 'object')
                message.gas_limit = new $util.LongBits(object.gas_limit.low >>> 0, object.gas_limit.high >>> 0).toNumber(true);
            if (object.payer != null) message.payer = String(object.payer);
            if (object.granter != null) message.granter = String(object.granter);
            return message;
          };

          /**
           * Creates a plain object from a Fee message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.Fee
           * @static
           * @param {cosmos.tx.v1beta1.Fee} message Fee
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Fee.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) object.amount = [];
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.gas_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.gas_limit = options.longs === String ? '0' : 0;
              object.payer = '';
              object.granter = '';
            }
            if (message.amount && message.amount.length) {
              object.amount = [];
              for (var j = 0; j < message.amount.length; ++j)
                object.amount[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.amount[j], options);
            }
            if (message.gas_limit != null && message.hasOwnProperty('gas_limit'))
              if (typeof message.gas_limit === 'number')
                object.gas_limit = options.longs === String ? String(message.gas_limit) : message.gas_limit;
              else
                object.gas_limit =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.gas_limit)
                    : options.longs === Number
                    ? new $util.LongBits(message.gas_limit.low >>> 0, message.gas_limit.high >>> 0).toNumber(true)
                    : message.gas_limit;
            if (message.payer != null && message.hasOwnProperty('payer')) object.payer = message.payer;
            if (message.granter != null && message.hasOwnProperty('granter')) object.granter = message.granter;
            return object;
          };

          /**
           * Converts this Fee to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.Fee
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Fee.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Fee;
        })();

        v1beta1.Tip = (function () {
          /**
           * Properties of a Tip.
           * @memberof cosmos.tx.v1beta1
           * @interface ITip
           * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [amount] Tip amount
           * @property {string|null} [tipper] Tip tipper
           */

          /**
           * Constructs a new Tip.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents a Tip.
           * @implements ITip
           * @constructor
           * @param {cosmos.tx.v1beta1.ITip=} [properties] Properties to set
           */
          function Tip(properties) {
            this.amount = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Tip amount.
           * @member {Array.<cosmos.base.v1beta1.ICoin>} amount
           * @memberof cosmos.tx.v1beta1.Tip
           * @instance
           */
          Tip.prototype.amount = $util.emptyArray;

          /**
           * Tip tipper.
           * @member {string} tipper
           * @memberof cosmos.tx.v1beta1.Tip
           * @instance
           */
          Tip.prototype.tipper = '';

          /**
           * Encodes the specified Tip message. Does not implicitly {@link cosmos.tx.v1beta1.Tip.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.Tip
           * @static
           * @param {cosmos.tx.v1beta1.ITip} message Tip message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Tip.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.amount != null && message.amount.length)
              for (var i = 0; i < message.amount.length; ++i)
                $root.cosmos.base.v1beta1.Coin.encode(message.amount[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.tipper != null && Object.hasOwnProperty.call(message, 'tipper'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.tipper);
            return writer;
          };

          /**
           * Encodes the specified Tip message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.Tip.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.Tip
           * @static
           * @param {cosmos.tx.v1beta1.ITip} message Tip message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Tip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Tip message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.Tip
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.Tip} Tip
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Tip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.Tip();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.amount && message.amount.length)) message.amount = [];
                  message.amount.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.tipper = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Tip message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.Tip
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.Tip} Tip
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Tip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Tip message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.Tip
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Tip.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.amount != null && message.hasOwnProperty('amount')) {
              if (!Array.isArray(message.amount)) return 'amount: array expected';
              for (var i = 0; i < message.amount.length; ++i) {
                var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount[i]);
                if (error) return 'amount.' + error;
              }
            }
            if (message.tipper != null && message.hasOwnProperty('tipper'))
              if (!$util.isString(message.tipper)) return 'tipper: string expected';
            return null;
          };

          /**
           * Creates a Tip message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.Tip
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.Tip} Tip
           */
          Tip.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.Tip) return object;
            var message = new $root.cosmos.tx.v1beta1.Tip();
            if (object.amount) {
              if (!Array.isArray(object.amount)) throw TypeError('.cosmos.tx.v1beta1.Tip.amount: array expected');
              message.amount = [];
              for (var i = 0; i < object.amount.length; ++i) {
                if (typeof object.amount[i] !== 'object') throw TypeError('.cosmos.tx.v1beta1.Tip.amount: object expected');
                message.amount[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount[i]);
              }
            }
            if (object.tipper != null) message.tipper = String(object.tipper);
            return message;
          };

          /**
           * Creates a plain object from a Tip message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.Tip
           * @static
           * @param {cosmos.tx.v1beta1.Tip} message Tip
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Tip.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) object.amount = [];
            if (options.defaults) object.tipper = '';
            if (message.amount && message.amount.length) {
              object.amount = [];
              for (var j = 0; j < message.amount.length; ++j)
                object.amount[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.amount[j], options);
            }
            if (message.tipper != null && message.hasOwnProperty('tipper')) object.tipper = message.tipper;
            return object;
          };

          /**
           * Converts this Tip to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.Tip
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Tip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Tip;
        })();

        v1beta1.AuxSignerData = (function () {
          /**
           * Properties of an AuxSignerData.
           * @memberof cosmos.tx.v1beta1
           * @interface IAuxSignerData
           * @property {string|null} [address] AuxSignerData address
           * @property {cosmos.tx.v1beta1.ISignDocDirectAux|null} [sign_doc] AuxSignerData sign_doc
           * @property {cosmos.tx.signing.v1beta1.SignMode|null} [mode] AuxSignerData mode
           * @property {Uint8Array|null} [sig] AuxSignerData sig
           */

          /**
           * Constructs a new AuxSignerData.
           * @memberof cosmos.tx.v1beta1
           * @classdesc Represents an AuxSignerData.
           * @implements IAuxSignerData
           * @constructor
           * @param {cosmos.tx.v1beta1.IAuxSignerData=} [properties] Properties to set
           */
          function AuxSignerData(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * AuxSignerData address.
           * @member {string} address
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @instance
           */
          AuxSignerData.prototype.address = '';

          /**
           * AuxSignerData sign_doc.
           * @member {cosmos.tx.v1beta1.ISignDocDirectAux|null|undefined} sign_doc
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @instance
           */
          AuxSignerData.prototype.sign_doc = null;

          /**
           * AuxSignerData mode.
           * @member {cosmos.tx.signing.v1beta1.SignMode} mode
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @instance
           */
          AuxSignerData.prototype.mode = 0;

          /**
           * AuxSignerData sig.
           * @member {Uint8Array} sig
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @instance
           */
          AuxSignerData.prototype.sig = $util.newBuffer([]);

          /**
           * Encodes the specified AuxSignerData message. Does not implicitly {@link cosmos.tx.v1beta1.AuxSignerData.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @static
           * @param {cosmos.tx.v1beta1.IAuxSignerData} message AuxSignerData message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          AuxSignerData.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
            if (message.sign_doc != null && Object.hasOwnProperty.call(message, 'sign_doc'))
              $root.cosmos.tx.v1beta1.SignDocDirectAux.encode(message.sign_doc, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.mode != null && Object.hasOwnProperty.call(message, 'mode'))
              writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.mode);
            if (message.sig != null && Object.hasOwnProperty.call(message, 'sig'))
              writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.sig);
            return writer;
          };

          /**
           * Encodes the specified AuxSignerData message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.AuxSignerData.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @static
           * @param {cosmos.tx.v1beta1.IAuxSignerData} message AuxSignerData message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          AuxSignerData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an AuxSignerData message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.AuxSignerData} AuxSignerData
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          AuxSignerData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.AuxSignerData();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.address = reader.string();
                  break;
                case 2:
                  message.sign_doc = $root.cosmos.tx.v1beta1.SignDocDirectAux.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.mode = reader.int32();
                  break;
                case 4:
                  message.sig = reader.bytes();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an AuxSignerData message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.AuxSignerData} AuxSignerData
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          AuxSignerData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an AuxSignerData message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          AuxSignerData.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.address != null && message.hasOwnProperty('address'))
              if (!$util.isString(message.address)) return 'address: string expected';
            if (message.sign_doc != null && message.hasOwnProperty('sign_doc')) {
              var error = $root.cosmos.tx.v1beta1.SignDocDirectAux.verify(message.sign_doc);
              if (error) return 'sign_doc.' + error;
            }
            if (message.mode != null && message.hasOwnProperty('mode'))
              switch (message.mode) {
                default:
                  return 'mode: enum value expected';
                case 0:
                case 1:
                case 2:
                case 3:
                case 127:
                case 191:
                  break;
              }
            if (message.sig != null && message.hasOwnProperty('sig'))
              if (!((message.sig && typeof message.sig.length === 'number') || $util.isString(message.sig))) return 'sig: buffer expected';
            return null;
          };

          /**
           * Creates an AuxSignerData message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.AuxSignerData} AuxSignerData
           */
          AuxSignerData.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.AuxSignerData) return object;
            var message = new $root.cosmos.tx.v1beta1.AuxSignerData();
            if (object.address != null) message.address = String(object.address);
            if (object.sign_doc != null) {
              if (typeof object.sign_doc !== 'object') throw TypeError('.cosmos.tx.v1beta1.AuxSignerData.sign_doc: object expected');
              message.sign_doc = $root.cosmos.tx.v1beta1.SignDocDirectAux.fromObject(object.sign_doc);
            }
            switch (object.mode) {
              case 'SIGN_MODE_UNSPECIFIED':
              case 0:
                message.mode = 0;
                break;
              case 'SIGN_MODE_DIRECT':
              case 1:
                message.mode = 1;
                break;
              case 'SIGN_MODE_TEXTUAL':
              case 2:
                message.mode = 2;
                break;
              case 'SIGN_MODE_DIRECT_AUX':
              case 3:
                message.mode = 3;
                break;
              case 'SIGN_MODE_LEGACY_AMINO_JSON':
              case 127:
                message.mode = 127;
                break;
              case 'SIGN_MODE_EIP_191':
              case 191:
                message.mode = 191;
                break;
            }
            if (object.sig != null)
              if (typeof object.sig === 'string')
                $util.base64.decode(object.sig, (message.sig = $util.newBuffer($util.base64.length(object.sig))), 0);
              else if (object.sig.length) message.sig = object.sig;
            return message;
          };

          /**
           * Creates a plain object from an AuxSignerData message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @static
           * @param {cosmos.tx.v1beta1.AuxSignerData} message AuxSignerData
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          AuxSignerData.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.address = '';
              object.sign_doc = null;
              object.mode = options.enums === String ? 'SIGN_MODE_UNSPECIFIED' : 0;
              if (options.bytes === String) object.sig = '';
              else {
                object.sig = [];
                if (options.bytes !== Array) object.sig = $util.newBuffer(object.sig);
              }
            }
            if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
            if (message.sign_doc != null && message.hasOwnProperty('sign_doc'))
              object.sign_doc = $root.cosmos.tx.v1beta1.SignDocDirectAux.toObject(message.sign_doc, options);
            if (message.mode != null && message.hasOwnProperty('mode'))
              object.mode = options.enums === String ? $root.cosmos.tx.signing.v1beta1.SignMode[message.mode] : message.mode;
            if (message.sig != null && message.hasOwnProperty('sig'))
              object.sig =
                options.bytes === String
                  ? $util.base64.encode(message.sig, 0, message.sig.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.sig)
                  : message.sig;
            return object;
          };

          /**
           * Converts this AuxSignerData to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.AuxSignerData
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          AuxSignerData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return AuxSignerData;
        })();

        return v1beta1;
      })();

      tx.signing = (function () {
        /**
         * Namespace signing.
         * @memberof cosmos.tx
         * @namespace
         */
        var signing = {};

        signing.v1beta1 = (function () {
          /**
           * Namespace v1beta1.
           * @memberof cosmos.tx.signing
           * @namespace
           */
          var v1beta1 = {};

          /**
           * SignMode enum.
           * @name cosmos.tx.signing.v1beta1.SignMode
           * @enum {number}
           * @property {number} SIGN_MODE_UNSPECIFIED=0 SIGN_MODE_UNSPECIFIED value
           * @property {number} SIGN_MODE_DIRECT=1 SIGN_MODE_DIRECT value
           * @property {number} SIGN_MODE_TEXTUAL=2 SIGN_MODE_TEXTUAL value
           * @property {number} SIGN_MODE_DIRECT_AUX=3 SIGN_MODE_DIRECT_AUX value
           * @property {number} SIGN_MODE_LEGACY_AMINO_JSON=127 SIGN_MODE_LEGACY_AMINO_JSON value
           * @property {number} SIGN_MODE_EIP_191=191 SIGN_MODE_EIP_191 value
           */
          v1beta1.SignMode = (function () {
            var valuesById = {},
              values = Object.create(valuesById);
            values[(valuesById[0] = 'SIGN_MODE_UNSPECIFIED')] = 0;
            values[(valuesById[1] = 'SIGN_MODE_DIRECT')] = 1;
            values[(valuesById[2] = 'SIGN_MODE_TEXTUAL')] = 2;
            values[(valuesById[3] = 'SIGN_MODE_DIRECT_AUX')] = 3;
            values[(valuesById[127] = 'SIGN_MODE_LEGACY_AMINO_JSON')] = 127;
            values[(valuesById[191] = 'SIGN_MODE_EIP_191')] = 191;
            return values;
          })();

          v1beta1.SignatureDescriptors = (function () {
            /**
             * Properties of a SignatureDescriptors.
             * @memberof cosmos.tx.signing.v1beta1
             * @interface ISignatureDescriptors
             * @property {Array.<cosmos.tx.signing.v1beta1.ISignatureDescriptor>|null} [signatures] SignatureDescriptors signatures
             */

            /**
             * Constructs a new SignatureDescriptors.
             * @memberof cosmos.tx.signing.v1beta1
             * @classdesc Represents a SignatureDescriptors.
             * @implements ISignatureDescriptors
             * @constructor
             * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptors=} [properties] Properties to set
             */
            function SignatureDescriptors(properties) {
              this.signatures = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignatureDescriptors signatures.
             * @member {Array.<cosmos.tx.signing.v1beta1.ISignatureDescriptor>} signatures
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @instance
             */
            SignatureDescriptors.prototype.signatures = $util.emptyArray;

            /**
             * Encodes the specified SignatureDescriptors message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptors.verify|verify} messages.
             * @function encode
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @static
             * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptors} message SignatureDescriptors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureDescriptors.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.signatures != null && message.signatures.length)
                for (var i = 0; i < message.signatures.length; ++i)
                  $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.encode(
                    message.signatures[i],
                    writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified SignatureDescriptors message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptors.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @static
             * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptors} message SignatureDescriptors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureDescriptors.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignatureDescriptors message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptors} SignatureDescriptors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureDescriptors.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptors();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    if (!(message.signatures && message.signatures.length)) message.signatures = [];
                    message.signatures.push($root.cosmos.tx.signing.v1beta1.SignatureDescriptor.decode(reader, reader.uint32()));
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a SignatureDescriptors message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptors} SignatureDescriptors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureDescriptors.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignatureDescriptors message.
             * @function verify
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignatureDescriptors.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.signatures != null && message.hasOwnProperty('signatures')) {
                if (!Array.isArray(message.signatures)) return 'signatures: array expected';
                for (var i = 0; i < message.signatures.length; ++i) {
                  var error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.verify(message.signatures[i]);
                  if (error) return 'signatures.' + error;
                }
              }
              return null;
            };

            /**
             * Creates a SignatureDescriptors message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptors} SignatureDescriptors
             */
            SignatureDescriptors.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptors) return object;
              var message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptors();
              if (object.signatures) {
                if (!Array.isArray(object.signatures))
                  throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptors.signatures: array expected');
                message.signatures = [];
                for (var i = 0; i < object.signatures.length; ++i) {
                  if (typeof object.signatures[i] !== 'object')
                    throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptors.signatures: object expected');
                  message.signatures[i] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.fromObject(object.signatures[i]);
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a SignatureDescriptors message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @static
             * @param {cosmos.tx.signing.v1beta1.SignatureDescriptors} message SignatureDescriptors
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignatureDescriptors.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.signatures = [];
              if (message.signatures && message.signatures.length) {
                object.signatures = [];
                for (var j = 0; j < message.signatures.length; ++j)
                  object.signatures[j] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.toObject(message.signatures[j], options);
              }
              return object;
            };

            /**
             * Converts this SignatureDescriptors to JSON.
             * @function toJSON
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignatureDescriptors.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SignatureDescriptors;
          })();

          v1beta1.SignatureDescriptor = (function () {
            /**
             * Properties of a SignatureDescriptor.
             * @memberof cosmos.tx.signing.v1beta1
             * @interface ISignatureDescriptor
             * @property {google.protobuf.IAny|null} [public_key] SignatureDescriptor public_key
             * @property {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData|null} [data] SignatureDescriptor data
             * @property {Long|null} [sequence] SignatureDescriptor sequence
             */

            /**
             * Constructs a new SignatureDescriptor.
             * @memberof cosmos.tx.signing.v1beta1
             * @classdesc Represents a SignatureDescriptor.
             * @implements ISignatureDescriptor
             * @constructor
             * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptor=} [properties] Properties to set
             */
            function SignatureDescriptor(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignatureDescriptor public_key.
             * @member {google.protobuf.IAny|null|undefined} public_key
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @instance
             */
            SignatureDescriptor.prototype.public_key = null;

            /**
             * SignatureDescriptor data.
             * @member {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData|null|undefined} data
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @instance
             */
            SignatureDescriptor.prototype.data = null;

            /**
             * SignatureDescriptor sequence.
             * @member {Long} sequence
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @instance
             */
            SignatureDescriptor.prototype.sequence = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * Encodes the specified SignatureDescriptor message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.verify|verify} messages.
             * @function encode
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @static
             * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptor} message SignatureDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureDescriptor.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.public_key != null && Object.hasOwnProperty.call(message, 'public_key'))
                $root.google.protobuf.Any.encode(message.public_key, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
              if (message.data != null && Object.hasOwnProperty.call(message, 'data'))
                $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.encode(
                  message.data,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (message.sequence != null && Object.hasOwnProperty.call(message, 'sequence'))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.sequence);
              return writer;
            };

            /**
             * Encodes the specified SignatureDescriptor message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @static
             * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptor} message SignatureDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignatureDescriptor message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor} SignatureDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureDescriptor.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.public_key = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                  case 2:
                    message.data = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.decode(reader, reader.uint32());
                    break;
                  case 3:
                    message.sequence = reader.uint64();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a SignatureDescriptor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor} SignatureDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureDescriptor.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignatureDescriptor message.
             * @function verify
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignatureDescriptor.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.public_key != null && message.hasOwnProperty('public_key')) {
                var error = $root.google.protobuf.Any.verify(message.public_key);
                if (error) return 'public_key.' + error;
              }
              if (message.data != null && message.hasOwnProperty('data')) {
                var error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify(message.data);
                if (error) return 'data.' + error;
              }
              if (message.sequence != null && message.hasOwnProperty('sequence'))
                if (
                  !$util.isInteger(message.sequence) &&
                  !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high))
                )
                  return 'sequence: integer|Long expected';
              return null;
            };

            /**
             * Creates a SignatureDescriptor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor} SignatureDescriptor
             */
            SignatureDescriptor.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor) return object;
              var message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor();
              if (object.public_key != null) {
                if (typeof object.public_key !== 'object')
                  throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.public_key: object expected');
                message.public_key = $root.google.protobuf.Any.fromObject(object.public_key);
              }
              if (object.data != null) {
                if (typeof object.data !== 'object')
                  throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.data: object expected');
                message.data = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.fromObject(object.data);
              }
              if (object.sequence != null)
                if ($util.Long) (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                else if (typeof object.sequence === 'string') message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === 'number') message.sequence = object.sequence;
                else if (typeof object.sequence === 'object')
                  message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
              return message;
            };

            /**
             * Creates a plain object from a SignatureDescriptor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @static
             * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor} message SignatureDescriptor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignatureDescriptor.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                object.public_key = null;
                object.data = null;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else object.sequence = options.longs === String ? '0' : 0;
              }
              if (message.public_key != null && message.hasOwnProperty('public_key'))
                object.public_key = $root.google.protobuf.Any.toObject(message.public_key, options);
              if (message.data != null && message.hasOwnProperty('data'))
                object.data = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.toObject(message.data, options);
              if (message.sequence != null && message.hasOwnProperty('sequence'))
                if (typeof message.sequence === 'number')
                  object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                  object.sequence =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.sequence)
                      : options.longs === Number
                      ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true)
                      : message.sequence;
              return object;
            };

            /**
             * Converts this SignatureDescriptor to JSON.
             * @function toJSON
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignatureDescriptor.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SignatureDescriptor.Data = (function () {
              /**
               * Properties of a Data.
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
               * @interface IData
               * @property {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle|null} [single] Data single
               * @property {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti|null} [multi] Data multi
               */

              /**
               * Constructs a new Data.
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
               * @classdesc Represents a Data.
               * @implements IData
               * @constructor
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData=} [properties] Properties to set
               */
              function Data(properties) {
                if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }

              /**
               * Data single.
               * @member {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle|null|undefined} single
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @instance
               */
              Data.prototype.single = null;

              /**
               * Data multi.
               * @member {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti|null|undefined} multi
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @instance
               */
              Data.prototype.multi = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * Data sum.
               * @member {"single"|"multi"|undefined} sum
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @instance
               */
              Object.defineProperty(Data.prototype, 'sum', {
                get: $util.oneOfGetter(($oneOfFields = ['single', 'multi'])),
                set: $util.oneOfSetter($oneOfFields),
              });

              /**
               * Encodes the specified Data message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify|verify} messages.
               * @function encode
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData} message Data message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Data.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.single != null && Object.hasOwnProperty.call(message, 'single'))
                  $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.encode(
                    message.single,
                    writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                  ).ldelim();
                if (message.multi != null && Object.hasOwnProperty.call(message, 'multi'))
                  $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.encode(
                    message.multi,
                    writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                  ).ldelim();
                return writer;
              };

              /**
               * Encodes the specified Data message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify|verify} messages.
               * @function encodeDelimited
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData} message Data message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Data.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a Data message from the specified reader or buffer.
               * @function decode
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} Data
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Data.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data();
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1:
                      message.single = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.decode(reader, reader.uint32());
                      break;
                    case 2:
                      message.multi = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.decode(reader, reader.uint32());
                      break;
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };

              /**
               * Decodes a Data message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} Data
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Data.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a Data message.
               * @function verify
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              Data.verify = function verify(message) {
                if (typeof message !== 'object' || message === null) return 'object expected';
                var properties = {};
                if (message.single != null && message.hasOwnProperty('single')) {
                  properties.sum = 1;
                  {
                    var error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.verify(message.single);
                    if (error) return 'single.' + error;
                  }
                }
                if (message.multi != null && message.hasOwnProperty('multi')) {
                  if (properties.sum === 1) return 'sum: multiple values';
                  properties.sum = 1;
                  {
                    var error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.verify(message.multi);
                    if (error) return 'multi.' + error;
                  }
                }
                return null;
              };

              /**
               * Creates a Data message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} Data
               */
              Data.fromObject = function fromObject(object) {
                if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data) return object;
                var message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data();
                if (object.single != null) {
                  if (typeof object.single !== 'object')
                    throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.single: object expected');
                  message.single = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.fromObject(object.single);
                }
                if (object.multi != null) {
                  if (typeof object.multi !== 'object')
                    throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.multi: object expected');
                  message.multi = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.fromObject(object.multi);
                }
                return message;
              };

              /**
               * Creates a plain object from a Data message. Also converts values to other types if specified.
               * @function toObject
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} message Data
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              Data.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};
                if (message.single != null && message.hasOwnProperty('single')) {
                  object.single = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.toObject(message.single, options);
                  if (options.oneofs) object.sum = 'single';
                }
                if (message.multi != null && message.hasOwnProperty('multi')) {
                  object.multi = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.toObject(message.multi, options);
                  if (options.oneofs) object.sum = 'multi';
                }
                return object;
              };

              /**
               * Converts this Data to JSON.
               * @function toJSON
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              Data.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };

              Data.Single = (function () {
                /**
                 * Properties of a Single.
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
                 * @interface ISingle
                 * @property {cosmos.tx.signing.v1beta1.SignMode|null} [mode] Single mode
                 * @property {Uint8Array|null} [signature] Single signature
                 */

                /**
                 * Constructs a new Single.
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
                 * @classdesc Represents a Single.
                 * @implements ISingle
                 * @constructor
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle=} [properties] Properties to set
                 */
                function Single(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Single mode.
                 * @member {cosmos.tx.signing.v1beta1.SignMode} mode
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @instance
                 */
                Single.prototype.mode = 0;

                /**
                 * Single signature.
                 * @member {Uint8Array} signature
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @instance
                 */
                Single.prototype.signature = $util.newBuffer([]);

                /**
                 * Encodes the specified Single message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.verify|verify} messages.
                 * @function encode
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @static
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle} message Single message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Single.encode = function encode(message, writer) {
                  if (!writer) writer = $Writer.create();
                  if (message.mode != null && Object.hasOwnProperty.call(message, 'mode'))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.mode);
                  if (message.signature != null && Object.hasOwnProperty.call(message, 'signature'))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.signature);
                  return writer;
                };

                /**
                 * Encodes the specified Single message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @static
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle} message Single message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Single.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Single message from the specified reader or buffer.
                 * @function decode
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} Single
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Single.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single();
                  while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1:
                        message.mode = reader.int32();
                        break;
                      case 2:
                        message.signature = reader.bytes();
                        break;
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                };

                /**
                 * Decodes a Single message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} Single
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Single.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Single message.
                 * @function verify
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Single.verify = function verify(message) {
                  if (typeof message !== 'object' || message === null) return 'object expected';
                  if (message.mode != null && message.hasOwnProperty('mode'))
                    switch (message.mode) {
                      default:
                        return 'mode: enum value expected';
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 127:
                      case 191:
                        break;
                    }
                  if (message.signature != null && message.hasOwnProperty('signature'))
                    if (!((message.signature && typeof message.signature.length === 'number') || $util.isString(message.signature)))
                      return 'signature: buffer expected';
                  return null;
                };

                /**
                 * Creates a Single message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} Single
                 */
                Single.fromObject = function fromObject(object) {
                  if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single) return object;
                  var message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single();
                  switch (object.mode) {
                    case 'SIGN_MODE_UNSPECIFIED':
                    case 0:
                      message.mode = 0;
                      break;
                    case 'SIGN_MODE_DIRECT':
                    case 1:
                      message.mode = 1;
                      break;
                    case 'SIGN_MODE_TEXTUAL':
                    case 2:
                      message.mode = 2;
                      break;
                    case 'SIGN_MODE_DIRECT_AUX':
                    case 3:
                      message.mode = 3;
                      break;
                    case 'SIGN_MODE_LEGACY_AMINO_JSON':
                    case 127:
                      message.mode = 127;
                      break;
                    case 'SIGN_MODE_EIP_191':
                    case 191:
                      message.mode = 191;
                      break;
                  }
                  if (object.signature != null)
                    if (typeof object.signature === 'string')
                      $util.base64.decode(
                        object.signature,
                        (message.signature = $util.newBuffer($util.base64.length(object.signature))),
                        0,
                      );
                    else if (object.signature.length) message.signature = object.signature;
                  return message;
                };

                /**
                 * Creates a plain object from a Single message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @static
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} message Single
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Single.toObject = function toObject(message, options) {
                  if (!options) options = {};
                  var object = {};
                  if (options.defaults) {
                    object.mode = options.enums === String ? 'SIGN_MODE_UNSPECIFIED' : 0;
                    if (options.bytes === String) object.signature = '';
                    else {
                      object.signature = [];
                      if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);
                    }
                  }
                  if (message.mode != null && message.hasOwnProperty('mode'))
                    object.mode = options.enums === String ? $root.cosmos.tx.signing.v1beta1.SignMode[message.mode] : message.mode;
                  if (message.signature != null && message.hasOwnProperty('signature'))
                    object.signature =
                      options.bytes === String
                        ? $util.base64.encode(message.signature, 0, message.signature.length)
                        : options.bytes === Array
                        ? Array.prototype.slice.call(message.signature)
                        : message.signature;
                  return object;
                };

                /**
                 * Converts this Single to JSON.
                 * @function toJSON
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Single.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Single;
              })();

              Data.Multi = (function () {
                /**
                 * Properties of a Multi.
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
                 * @interface IMulti
                 * @property {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null} [bitarray] Multi bitarray
                 * @property {Array.<cosmos.tx.signing.v1beta1.SignatureDescriptor.IData>|null} [signatures] Multi signatures
                 */

                /**
                 * Constructs a new Multi.
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
                 * @classdesc Represents a Multi.
                 * @implements IMulti
                 * @constructor
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti=} [properties] Properties to set
                 */
                function Multi(properties) {
                  this.signatures = [];
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Multi bitarray.
                 * @member {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null|undefined} bitarray
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @instance
                 */
                Multi.prototype.bitarray = null;

                /**
                 * Multi signatures.
                 * @member {Array.<cosmos.tx.signing.v1beta1.SignatureDescriptor.IData>} signatures
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @instance
                 */
                Multi.prototype.signatures = $util.emptyArray;

                /**
                 * Encodes the specified Multi message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.verify|verify} messages.
                 * @function encode
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @static
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti} message Multi message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Multi.encode = function encode(message, writer) {
                  if (!writer) writer = $Writer.create();
                  if (message.bitarray != null && Object.hasOwnProperty.call(message, 'bitarray'))
                    $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.encode(
                      message.bitarray,
                      writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                    ).ldelim();
                  if (message.signatures != null && message.signatures.length)
                    for (var i = 0; i < message.signatures.length; ++i)
                      $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.encode(
                        message.signatures[i],
                        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                      ).ldelim();
                  return writer;
                };

                /**
                 * Encodes the specified Multi message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @static
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti} message Multi message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Multi.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Multi message from the specified reader or buffer.
                 * @function decode
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} Multi
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Multi.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi();
                  while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1:
                        message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.decode(reader, reader.uint32());
                        break;
                      case 2:
                        if (!(message.signatures && message.signatures.length)) message.signatures = [];
                        message.signatures.push($root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.decode(reader, reader.uint32()));
                        break;
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                };

                /**
                 * Decodes a Multi message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} Multi
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Multi.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Multi message.
                 * @function verify
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Multi.verify = function verify(message) {
                  if (typeof message !== 'object' || message === null) return 'object expected';
                  if (message.bitarray != null && message.hasOwnProperty('bitarray')) {
                    var error = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.verify(message.bitarray);
                    if (error) return 'bitarray.' + error;
                  }
                  if (message.signatures != null && message.hasOwnProperty('signatures')) {
                    if (!Array.isArray(message.signatures)) return 'signatures: array expected';
                    for (var i = 0; i < message.signatures.length; ++i) {
                      var error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify(message.signatures[i]);
                      if (error) return 'signatures.' + error;
                    }
                  }
                  return null;
                };

                /**
                 * Creates a Multi message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} Multi
                 */
                Multi.fromObject = function fromObject(object) {
                  if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi) return object;
                  var message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi();
                  if (object.bitarray != null) {
                    if (typeof object.bitarray !== 'object')
                      throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.bitarray: object expected');
                    message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.fromObject(object.bitarray);
                  }
                  if (object.signatures) {
                    if (!Array.isArray(object.signatures))
                      throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.signatures: array expected');
                    message.signatures = [];
                    for (var i = 0; i < object.signatures.length; ++i) {
                      if (typeof object.signatures[i] !== 'object')
                        throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.signatures: object expected');
                      message.signatures[i] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.fromObject(object.signatures[i]);
                    }
                  }
                  return message;
                };

                /**
                 * Creates a plain object from a Multi message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @static
                 * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} message Multi
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Multi.toObject = function toObject(message, options) {
                  if (!options) options = {};
                  var object = {};
                  if (options.arrays || options.defaults) object.signatures = [];
                  if (options.defaults) object.bitarray = null;
                  if (message.bitarray != null && message.hasOwnProperty('bitarray'))
                    object.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.toObject(message.bitarray, options);
                  if (message.signatures && message.signatures.length) {
                    object.signatures = [];
                    for (var j = 0; j < message.signatures.length; ++j)
                      object.signatures[j] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.toObject(
                        message.signatures[j],
                        options,
                      );
                  }
                  return object;
                };

                /**
                 * Converts this Multi to JSON.
                 * @function toJSON
                 * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Multi.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Multi;
              })();

              return Data;
            })();

            return SignatureDescriptor;
          })();

          return v1beta1;
        })();

        return signing;
      })();

      return tx;
    })();

    cosmos.crypto = (function () {
      /**
       * Namespace crypto.
       * @memberof cosmos
       * @namespace
       */
      var crypto = {};

      crypto.multisig = (function () {
        /**
         * Namespace multisig.
         * @memberof cosmos.crypto
         * @namespace
         */
        var multisig = {};

        multisig.v1beta1 = (function () {
          /**
           * Namespace v1beta1.
           * @memberof cosmos.crypto.multisig
           * @namespace
           */
          var v1beta1 = {};

          v1beta1.MultiSignature = (function () {
            /**
             * Properties of a MultiSignature.
             * @memberof cosmos.crypto.multisig.v1beta1
             * @interface IMultiSignature
             * @property {Array.<Uint8Array>|null} [signatures] MultiSignature signatures
             */

            /**
             * Constructs a new MultiSignature.
             * @memberof cosmos.crypto.multisig.v1beta1
             * @classdesc Represents a MultiSignature.
             * @implements IMultiSignature
             * @constructor
             * @param {cosmos.crypto.multisig.v1beta1.IMultiSignature=} [properties] Properties to set
             */
            function MultiSignature(properties) {
              this.signatures = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * MultiSignature signatures.
             * @member {Array.<Uint8Array>} signatures
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @instance
             */
            MultiSignature.prototype.signatures = $util.emptyArray;

            /**
             * Encodes the specified MultiSignature message. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.MultiSignature.verify|verify} messages.
             * @function encode
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @static
             * @param {cosmos.crypto.multisig.v1beta1.IMultiSignature} message MultiSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiSignature.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.signatures != null && message.signatures.length)
                for (var i = 0; i < message.signatures.length; ++i) writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.signatures[i]);
              return writer;
            };

            /**
             * Encodes the specified MultiSignature message, length delimited. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.MultiSignature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @static
             * @param {cosmos.crypto.multisig.v1beta1.IMultiSignature} message MultiSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiSignature.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MultiSignature message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.crypto.multisig.v1beta1.MultiSignature} MultiSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiSignature.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.crypto.multisig.v1beta1.MultiSignature();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    if (!(message.signatures && message.signatures.length)) message.signatures = [];
                    message.signatures.push(reader.bytes());
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a MultiSignature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.crypto.multisig.v1beta1.MultiSignature} MultiSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiSignature.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MultiSignature message.
             * @function verify
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MultiSignature.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.signatures != null && message.hasOwnProperty('signatures')) {
                if (!Array.isArray(message.signatures)) return 'signatures: array expected';
                for (var i = 0; i < message.signatures.length; ++i)
                  if (
                    !((message.signatures[i] && typeof message.signatures[i].length === 'number') || $util.isString(message.signatures[i]))
                  )
                    return 'signatures: buffer[] expected';
              }
              return null;
            };

            /**
             * Creates a MultiSignature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.crypto.multisig.v1beta1.MultiSignature} MultiSignature
             */
            MultiSignature.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.crypto.multisig.v1beta1.MultiSignature) return object;
              var message = new $root.cosmos.crypto.multisig.v1beta1.MultiSignature();
              if (object.signatures) {
                if (!Array.isArray(object.signatures))
                  throw TypeError('.cosmos.crypto.multisig.v1beta1.MultiSignature.signatures: array expected');
                message.signatures = [];
                for (var i = 0; i < object.signatures.length; ++i)
                  if (typeof object.signatures[i] === 'string')
                    $util.base64.decode(
                      object.signatures[i],
                      (message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i]))),
                      0,
                    );
                  else if (object.signatures[i].length) message.signatures[i] = object.signatures[i];
              }
              return message;
            };

            /**
             * Creates a plain object from a MultiSignature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @static
             * @param {cosmos.crypto.multisig.v1beta1.MultiSignature} message MultiSignature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MultiSignature.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.signatures = [];
              if (message.signatures && message.signatures.length) {
                object.signatures = [];
                for (var j = 0; j < message.signatures.length; ++j)
                  object.signatures[j] =
                    options.bytes === String
                      ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length)
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.signatures[j])
                      : message.signatures[j];
              }
              return object;
            };

            /**
             * Converts this MultiSignature to JSON.
             * @function toJSON
             * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MultiSignature.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MultiSignature;
          })();

          v1beta1.CompactBitArray = (function () {
            /**
             * Properties of a CompactBitArray.
             * @memberof cosmos.crypto.multisig.v1beta1
             * @interface ICompactBitArray
             * @property {number|null} [extra_bits_stored] CompactBitArray extra_bits_stored
             * @property {Uint8Array|null} [elems] CompactBitArray elems
             */

            /**
             * Constructs a new CompactBitArray.
             * @memberof cosmos.crypto.multisig.v1beta1
             * @classdesc Represents a CompactBitArray.
             * @implements ICompactBitArray
             * @constructor
             * @param {cosmos.crypto.multisig.v1beta1.ICompactBitArray=} [properties] Properties to set
             */
            function CompactBitArray(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompactBitArray extra_bits_stored.
             * @member {number} extra_bits_stored
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @instance
             */
            CompactBitArray.prototype.extra_bits_stored = 0;

            /**
             * CompactBitArray elems.
             * @member {Uint8Array} elems
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @instance
             */
            CompactBitArray.prototype.elems = $util.newBuffer([]);

            /**
             * Encodes the specified CompactBitArray message. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.CompactBitArray.verify|verify} messages.
             * @function encode
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @static
             * @param {cosmos.crypto.multisig.v1beta1.ICompactBitArray} message CompactBitArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactBitArray.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.extra_bits_stored != null && Object.hasOwnProperty.call(message, 'extra_bits_stored'))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.extra_bits_stored);
              if (message.elems != null && Object.hasOwnProperty.call(message, 'elems'))
                writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.elems);
              return writer;
            };

            /**
             * Encodes the specified CompactBitArray message, length delimited. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.CompactBitArray.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @static
             * @param {cosmos.crypto.multisig.v1beta1.ICompactBitArray} message CompactBitArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactBitArray.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompactBitArray message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.crypto.multisig.v1beta1.CompactBitArray} CompactBitArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactBitArray.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.crypto.multisig.v1beta1.CompactBitArray();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.extra_bits_stored = reader.uint32();
                    break;
                  case 2:
                    message.elems = reader.bytes();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a CompactBitArray message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.crypto.multisig.v1beta1.CompactBitArray} CompactBitArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactBitArray.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompactBitArray message.
             * @function verify
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompactBitArray.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              if (message.extra_bits_stored != null && message.hasOwnProperty('extra_bits_stored'))
                if (!$util.isInteger(message.extra_bits_stored)) return 'extra_bits_stored: integer expected';
              if (message.elems != null && message.hasOwnProperty('elems'))
                if (!((message.elems && typeof message.elems.length === 'number') || $util.isString(message.elems)))
                  return 'elems: buffer expected';
              return null;
            };

            /**
             * Creates a CompactBitArray message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.crypto.multisig.v1beta1.CompactBitArray} CompactBitArray
             */
            CompactBitArray.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.crypto.multisig.v1beta1.CompactBitArray) return object;
              var message = new $root.cosmos.crypto.multisig.v1beta1.CompactBitArray();
              if (object.extra_bits_stored != null) message.extra_bits_stored = object.extra_bits_stored >>> 0;
              if (object.elems != null)
                if (typeof object.elems === 'string')
                  $util.base64.decode(object.elems, (message.elems = $util.newBuffer($util.base64.length(object.elems))), 0);
                else if (object.elems.length) message.elems = object.elems;
              return message;
            };

            /**
             * Creates a plain object from a CompactBitArray message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @static
             * @param {cosmos.crypto.multisig.v1beta1.CompactBitArray} message CompactBitArray
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompactBitArray.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                object.extra_bits_stored = 0;
                if (options.bytes === String) object.elems = '';
                else {
                  object.elems = [];
                  if (options.bytes !== Array) object.elems = $util.newBuffer(object.elems);
                }
              }
              if (message.extra_bits_stored != null && message.hasOwnProperty('extra_bits_stored'))
                object.extra_bits_stored = message.extra_bits_stored;
              if (message.elems != null && message.hasOwnProperty('elems'))
                object.elems =
                  options.bytes === String
                    ? $util.base64.encode(message.elems, 0, message.elems.length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.elems)
                    : message.elems;
              return object;
            };

            /**
             * Converts this CompactBitArray to JSON.
             * @function toJSON
             * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompactBitArray.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompactBitArray;
          })();

          return v1beta1;
        })();

        return multisig;
      })();

      return crypto;
    })();

    return cosmos;
  })();

  $root.cosmos_proto = (function () {
    /**
     * Namespace cosmos_proto.
     * @exports cosmos_proto
     * @namespace
     */
    var cosmos_proto = {};

    return cosmos_proto;
  })();

  $root.gogoproto = (function () {
    /**
     * Namespace gogoproto.
     * @exports gogoproto
     * @namespace
     */
    var gogoproto = {};

    return gogoproto;
  })();

  $root.google = (function () {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.api = (function () {
      /**
       * Namespace api.
       * @memberof google
       * @namespace
       */
      var api = {};

      api.Http = (function () {
        /**
         * Properties of a Http.
         * @memberof google.api
         * @interface IHttp
         * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
         * @property {boolean|null} [fully_decode_reserved_expansion] Http fully_decode_reserved_expansion
         */

        /**
         * Constructs a new Http.
         * @memberof google.api
         * @classdesc Represents a Http.
         * @implements IHttp
         * @constructor
         * @param {google.api.IHttp=} [properties] Properties to set
         */
        function Http(properties) {
          this.rules = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Http rules.
         * @member {Array.<google.api.IHttpRule>} rules
         * @memberof google.api.Http
         * @instance
         */
        Http.prototype.rules = $util.emptyArray;

        /**
         * Http fully_decode_reserved_expansion.
         * @member {boolean} fully_decode_reserved_expansion
         * @memberof google.api.Http
         * @instance
         */
        Http.prototype.fully_decode_reserved_expansion = false;

        /**
         * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
         * @function encode
         * @memberof google.api.Http
         * @static
         * @param {google.api.IHttp} message Http message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Http.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.rules != null && message.rules.length)
            for (var i = 0; i < message.rules.length; ++i)
              $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.fully_decode_reserved_expansion != null && Object.hasOwnProperty.call(message, 'fully_decode_reserved_expansion'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.fully_decode_reserved_expansion);
          return writer;
        };

        /**
         * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.api.Http
         * @static
         * @param {google.api.IHttp} message Http message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Http.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Http message from the specified reader or buffer.
         * @function decode
         * @memberof google.api.Http
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.api.Http} Http
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Http.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.api.Http();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.rules && message.rules.length)) message.rules = [];
                message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                break;
              case 2:
                message.fully_decode_reserved_expansion = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Http message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.api.Http
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.api.Http} Http
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Http.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Http message.
         * @function verify
         * @memberof google.api.Http
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Http.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.rules != null && message.hasOwnProperty('rules')) {
            if (!Array.isArray(message.rules)) return 'rules: array expected';
            for (var i = 0; i < message.rules.length; ++i) {
              var error = $root.google.api.HttpRule.verify(message.rules[i]);
              if (error) return 'rules.' + error;
            }
          }
          if (message.fully_decode_reserved_expansion != null && message.hasOwnProperty('fully_decode_reserved_expansion'))
            if (typeof message.fully_decode_reserved_expansion !== 'boolean') return 'fully_decode_reserved_expansion: boolean expected';
          return null;
        };

        /**
         * Creates a Http message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.api.Http
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.api.Http} Http
         */
        Http.fromObject = function fromObject(object) {
          if (object instanceof $root.google.api.Http) return object;
          var message = new $root.google.api.Http();
          if (object.rules) {
            if (!Array.isArray(object.rules)) throw TypeError('.google.api.Http.rules: array expected');
            message.rules = [];
            for (var i = 0; i < object.rules.length; ++i) {
              if (typeof object.rules[i] !== 'object') throw TypeError('.google.api.Http.rules: object expected');
              message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
            }
          }
          if (object.fully_decode_reserved_expansion != null)
            message.fully_decode_reserved_expansion = Boolean(object.fully_decode_reserved_expansion);
          return message;
        };

        /**
         * Creates a plain object from a Http message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.api.Http
         * @static
         * @param {google.api.Http} message Http
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Http.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.rules = [];
          if (options.defaults) object.fully_decode_reserved_expansion = false;
          if (message.rules && message.rules.length) {
            object.rules = [];
            for (var j = 0; j < message.rules.length; ++j) object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
          }
          if (message.fully_decode_reserved_expansion != null && message.hasOwnProperty('fully_decode_reserved_expansion'))
            object.fully_decode_reserved_expansion = message.fully_decode_reserved_expansion;
          return object;
        };

        /**
         * Converts this Http to JSON.
         * @function toJSON
         * @memberof google.api.Http
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Http.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Http;
      })();

      api.HttpRule = (function () {
        /**
         * Properties of a HttpRule.
         * @memberof google.api
         * @interface IHttpRule
         * @property {string|null} [selector] HttpRule selector
         * @property {string|null} [get] HttpRule get
         * @property {string|null} [put] HttpRule put
         * @property {string|null} [post] HttpRule post
         * @property {string|null} ["delete"] HttpRule delete
         * @property {string|null} [patch] HttpRule patch
         * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
         * @property {string|null} [body] HttpRule body
         * @property {string|null} [response_body] HttpRule response_body
         * @property {Array.<google.api.IHttpRule>|null} [additional_bindings] HttpRule additional_bindings
         */

        /**
         * Constructs a new HttpRule.
         * @memberof google.api
         * @classdesc Represents a HttpRule.
         * @implements IHttpRule
         * @constructor
         * @param {google.api.IHttpRule=} [properties] Properties to set
         */
        function HttpRule(properties) {
          this.additional_bindings = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * HttpRule selector.
         * @member {string} selector
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.selector = '';

        /**
         * HttpRule get.
         * @member {string|null|undefined} get
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.get = null;

        /**
         * HttpRule put.
         * @member {string|null|undefined} put
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.put = null;

        /**
         * HttpRule post.
         * @member {string|null|undefined} post
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.post = null;

        /**
         * HttpRule delete.
         * @member {string|null|undefined} delete
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype['delete'] = null;

        /**
         * HttpRule patch.
         * @member {string|null|undefined} patch
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.patch = null;

        /**
         * HttpRule custom.
         * @member {google.api.ICustomHttpPattern|null|undefined} custom
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.custom = null;

        /**
         * HttpRule body.
         * @member {string} body
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.body = '';

        /**
         * HttpRule response_body.
         * @member {string} response_body
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.response_body = '';

        /**
         * HttpRule additional_bindings.
         * @member {Array.<google.api.IHttpRule>} additional_bindings
         * @memberof google.api.HttpRule
         * @instance
         */
        HttpRule.prototype.additional_bindings = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HttpRule pattern.
         * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
         * @memberof google.api.HttpRule
         * @instance
         */
        Object.defineProperty(HttpRule.prototype, 'pattern', {
          get: $util.oneOfGetter(($oneOfFields = ['get', 'put', 'post', 'delete', 'patch', 'custom'])),
          set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
         * @function encode
         * @memberof google.api.HttpRule
         * @static
         * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HttpRule.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.selector != null && Object.hasOwnProperty.call(message, 'selector'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.selector);
          if (message.get != null && Object.hasOwnProperty.call(message, 'get'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.get);
          if (message.put != null && Object.hasOwnProperty.call(message, 'put'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.put);
          if (message.post != null && Object.hasOwnProperty.call(message, 'post'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.post);
          if (message['delete'] != null && Object.hasOwnProperty.call(message, 'delete'))
            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message['delete']);
          if (message.patch != null && Object.hasOwnProperty.call(message, 'patch'))
            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.patch);
          if (message.body != null && Object.hasOwnProperty.call(message, 'body'))
            writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.body);
          if (message.custom != null && Object.hasOwnProperty.call(message, 'custom'))
            $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
          if (message.additional_bindings != null && message.additional_bindings.length)
            for (var i = 0; i < message.additional_bindings.length; ++i)
              $root.google.api.HttpRule.encode(message.additional_bindings[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
          if (message.response_body != null && Object.hasOwnProperty.call(message, 'response_body'))
            writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.response_body);
          return writer;
        };

        /**
         * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.api.HttpRule
         * @static
         * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HttpRule message from the specified reader or buffer.
         * @function decode
         * @memberof google.api.HttpRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.api.HttpRule} HttpRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HttpRule.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.api.HttpRule();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.selector = reader.string();
                break;
              case 2:
                message.get = reader.string();
                break;
              case 3:
                message.put = reader.string();
                break;
              case 4:
                message.post = reader.string();
                break;
              case 5:
                message['delete'] = reader.string();
                break;
              case 6:
                message.patch = reader.string();
                break;
              case 8:
                message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                break;
              case 7:
                message.body = reader.string();
                break;
              case 12:
                message.response_body = reader.string();
                break;
              case 11:
                if (!(message.additional_bindings && message.additional_bindings.length)) message.additional_bindings = [];
                message.additional_bindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a HttpRule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.api.HttpRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.api.HttpRule} HttpRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HttpRule.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HttpRule message.
         * @function verify
         * @memberof google.api.HttpRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HttpRule.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          var properties = {};
          if (message.selector != null && message.hasOwnProperty('selector'))
            if (!$util.isString(message.selector)) return 'selector: string expected';
          if (message.get != null && message.hasOwnProperty('get')) {
            properties.pattern = 1;
            if (!$util.isString(message.get)) return 'get: string expected';
          }
          if (message.put != null && message.hasOwnProperty('put')) {
            if (properties.pattern === 1) return 'pattern: multiple values';
            properties.pattern = 1;
            if (!$util.isString(message.put)) return 'put: string expected';
          }
          if (message.post != null && message.hasOwnProperty('post')) {
            if (properties.pattern === 1) return 'pattern: multiple values';
            properties.pattern = 1;
            if (!$util.isString(message.post)) return 'post: string expected';
          }
          if (message['delete'] != null && message.hasOwnProperty('delete')) {
            if (properties.pattern === 1) return 'pattern: multiple values';
            properties.pattern = 1;
            if (!$util.isString(message['delete'])) return 'delete: string expected';
          }
          if (message.patch != null && message.hasOwnProperty('patch')) {
            if (properties.pattern === 1) return 'pattern: multiple values';
            properties.pattern = 1;
            if (!$util.isString(message.patch)) return 'patch: string expected';
          }
          if (message.custom != null && message.hasOwnProperty('custom')) {
            if (properties.pattern === 1) return 'pattern: multiple values';
            properties.pattern = 1;
            {
              var error = $root.google.api.CustomHttpPattern.verify(message.custom);
              if (error) return 'custom.' + error;
            }
          }
          if (message.body != null && message.hasOwnProperty('body')) if (!$util.isString(message.body)) return 'body: string expected';
          if (message.response_body != null && message.hasOwnProperty('response_body'))
            if (!$util.isString(message.response_body)) return 'response_body: string expected';
          if (message.additional_bindings != null && message.hasOwnProperty('additional_bindings')) {
            if (!Array.isArray(message.additional_bindings)) return 'additional_bindings: array expected';
            for (var i = 0; i < message.additional_bindings.length; ++i) {
              var error = $root.google.api.HttpRule.verify(message.additional_bindings[i]);
              if (error) return 'additional_bindings.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.api.HttpRule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.api.HttpRule} HttpRule
         */
        HttpRule.fromObject = function fromObject(object) {
          if (object instanceof $root.google.api.HttpRule) return object;
          var message = new $root.google.api.HttpRule();
          if (object.selector != null) message.selector = String(object.selector);
          if (object.get != null) message.get = String(object.get);
          if (object.put != null) message.put = String(object.put);
          if (object.post != null) message.post = String(object.post);
          if (object['delete'] != null) message['delete'] = String(object['delete']);
          if (object.patch != null) message.patch = String(object.patch);
          if (object.custom != null) {
            if (typeof object.custom !== 'object') throw TypeError('.google.api.HttpRule.custom: object expected');
            message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
          }
          if (object.body != null) message.body = String(object.body);
          if (object.response_body != null) message.response_body = String(object.response_body);
          if (object.additional_bindings) {
            if (!Array.isArray(object.additional_bindings)) throw TypeError('.google.api.HttpRule.additional_bindings: array expected');
            message.additional_bindings = [];
            for (var i = 0; i < object.additional_bindings.length; ++i) {
              if (typeof object.additional_bindings[i] !== 'object')
                throw TypeError('.google.api.HttpRule.additional_bindings: object expected');
              message.additional_bindings[i] = $root.google.api.HttpRule.fromObject(object.additional_bindings[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.api.HttpRule
         * @static
         * @param {google.api.HttpRule} message HttpRule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HttpRule.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.additional_bindings = [];
          if (options.defaults) {
            object.selector = '';
            object.body = '';
            object.response_body = '';
          }
          if (message.selector != null && message.hasOwnProperty('selector')) object.selector = message.selector;
          if (message.get != null && message.hasOwnProperty('get')) {
            object.get = message.get;
            if (options.oneofs) object.pattern = 'get';
          }
          if (message.put != null && message.hasOwnProperty('put')) {
            object.put = message.put;
            if (options.oneofs) object.pattern = 'put';
          }
          if (message.post != null && message.hasOwnProperty('post')) {
            object.post = message.post;
            if (options.oneofs) object.pattern = 'post';
          }
          if (message['delete'] != null && message.hasOwnProperty('delete')) {
            object['delete'] = message['delete'];
            if (options.oneofs) object.pattern = 'delete';
          }
          if (message.patch != null && message.hasOwnProperty('patch')) {
            object.patch = message.patch;
            if (options.oneofs) object.pattern = 'patch';
          }
          if (message.body != null && message.hasOwnProperty('body')) object.body = message.body;
          if (message.custom != null && message.hasOwnProperty('custom')) {
            object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
            if (options.oneofs) object.pattern = 'custom';
          }
          if (message.additional_bindings && message.additional_bindings.length) {
            object.additional_bindings = [];
            for (var j = 0; j < message.additional_bindings.length; ++j)
              object.additional_bindings[j] = $root.google.api.HttpRule.toObject(message.additional_bindings[j], options);
          }
          if (message.response_body != null && message.hasOwnProperty('response_body')) object.response_body = message.response_body;
          return object;
        };

        /**
         * Converts this HttpRule to JSON.
         * @function toJSON
         * @memberof google.api.HttpRule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HttpRule.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HttpRule;
      })();

      api.CustomHttpPattern = (function () {
        /**
         * Properties of a CustomHttpPattern.
         * @memberof google.api
         * @interface ICustomHttpPattern
         * @property {string|null} [kind] CustomHttpPattern kind
         * @property {string|null} [path] CustomHttpPattern path
         */

        /**
         * Constructs a new CustomHttpPattern.
         * @memberof google.api
         * @classdesc Represents a CustomHttpPattern.
         * @implements ICustomHttpPattern
         * @constructor
         * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
         */
        function CustomHttpPattern(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * CustomHttpPattern kind.
         * @member {string} kind
         * @memberof google.api.CustomHttpPattern
         * @instance
         */
        CustomHttpPattern.prototype.kind = '';

        /**
         * CustomHttpPattern path.
         * @member {string} path
         * @memberof google.api.CustomHttpPattern
         * @instance
         */
        CustomHttpPattern.prototype.path = '';

        /**
         * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
         * @function encode
         * @memberof google.api.CustomHttpPattern
         * @static
         * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CustomHttpPattern.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.kind != null && Object.hasOwnProperty.call(message, 'kind'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.kind);
          if (message.path != null && Object.hasOwnProperty.call(message, 'path'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.path);
          return writer;
        };

        /**
         * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.api.CustomHttpPattern
         * @static
         * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CustomHttpPattern message from the specified reader or buffer.
         * @function decode
         * @memberof google.api.CustomHttpPattern
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.api.CustomHttpPattern} CustomHttpPattern
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CustomHttpPattern.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.api.CustomHttpPattern();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.kind = reader.string();
                break;
              case 2:
                message.path = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.api.CustomHttpPattern
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.api.CustomHttpPattern} CustomHttpPattern
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CustomHttpPattern message.
         * @function verify
         * @memberof google.api.CustomHttpPattern
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CustomHttpPattern.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.kind != null && message.hasOwnProperty('kind')) if (!$util.isString(message.kind)) return 'kind: string expected';
          if (message.path != null && message.hasOwnProperty('path')) if (!$util.isString(message.path)) return 'path: string expected';
          return null;
        };

        /**
         * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.api.CustomHttpPattern
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.api.CustomHttpPattern} CustomHttpPattern
         */
        CustomHttpPattern.fromObject = function fromObject(object) {
          if (object instanceof $root.google.api.CustomHttpPattern) return object;
          var message = new $root.google.api.CustomHttpPattern();
          if (object.kind != null) message.kind = String(object.kind);
          if (object.path != null) message.path = String(object.path);
          return message;
        };

        /**
         * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.api.CustomHttpPattern
         * @static
         * @param {google.api.CustomHttpPattern} message CustomHttpPattern
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CustomHttpPattern.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.kind = '';
            object.path = '';
          }
          if (message.kind != null && message.hasOwnProperty('kind')) object.kind = message.kind;
          if (message.path != null && message.hasOwnProperty('path')) object.path = message.path;
          return object;
        };

        /**
         * Converts this CustomHttpPattern to JSON.
         * @function toJSON
         * @memberof google.api.CustomHttpPattern
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CustomHttpPattern.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CustomHttpPattern;
      })();

      return api;
    })();

    google.protobuf = (function () {
      /**
       * Namespace protobuf.
       * @memberof google
       * @namespace
       */
      var protobuf = {};

      protobuf.FileDescriptorSet = (function () {
        /**
         * Properties of a FileDescriptorSet.
         * @memberof google.protobuf
         * @interface IFileDescriptorSet
         * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
         */

        /**
         * Constructs a new FileDescriptorSet.
         * @memberof google.protobuf
         * @classdesc Represents a FileDescriptorSet.
         * @implements IFileDescriptorSet
         * @constructor
         * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
         */
        function FileDescriptorSet(properties) {
          this.file = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileDescriptorSet file.
         * @member {Array.<google.protobuf.IFileDescriptorProto>} file
         * @memberof google.protobuf.FileDescriptorSet
         * @instance
         */
        FileDescriptorSet.prototype.file = $util.emptyArray;

        /**
         * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorSet.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.file != null && message.file.length)
            for (var i = 0; i < message.file.length; ++i)
              $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileDescriptorSet message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorSet.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FileDescriptorSet();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.file && message.file.length)) message.file = [];
                message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileDescriptorSet message.
         * @function verify
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileDescriptorSet.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.file != null && message.hasOwnProperty('file')) {
            if (!Array.isArray(message.file)) return 'file: array expected';
            for (var i = 0; i < message.file.length; ++i) {
              var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
              if (error) return 'file.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
         */
        FileDescriptorSet.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FileDescriptorSet) return object;
          var message = new $root.google.protobuf.FileDescriptorSet();
          if (object.file) {
            if (!Array.isArray(object.file)) throw TypeError('.google.protobuf.FileDescriptorSet.file: array expected');
            message.file = [];
            for (var i = 0; i < object.file.length; ++i) {
              if (typeof object.file[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorSet.file: object expected');
              message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileDescriptorSet.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.file = [];
          if (message.file && message.file.length) {
            object.file = [];
            for (var j = 0; j < message.file.length; ++j)
              object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
          }
          return object;
        };

        /**
         * Converts this FileDescriptorSet to JSON.
         * @function toJSON
         * @memberof google.protobuf.FileDescriptorSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileDescriptorSet.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileDescriptorSet;
      })();

      protobuf.FileDescriptorProto = (function () {
        /**
         * Properties of a FileDescriptorProto.
         * @memberof google.protobuf
         * @interface IFileDescriptorProto
         * @property {string|null} [name] FileDescriptorProto name
         * @property {string|null} ["package"] FileDescriptorProto package
         * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
         * @property {Array.<number>|null} [public_dependency] FileDescriptorProto public_dependency
         * @property {Array.<number>|null} [weak_dependency] FileDescriptorProto weak_dependency
         * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
         * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
         * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
         * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
         * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
         * @property {string|null} [syntax] FileDescriptorProto syntax
         */

        /**
         * Constructs a new FileDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a FileDescriptorProto.
         * @implements IFileDescriptorProto
         * @constructor
         * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
         */
        function FileDescriptorProto(properties) {
          this.dependency = [];
          this.public_dependency = [];
          this.weak_dependency = [];
          this.message_type = [];
          this.enum_type = [];
          this.service = [];
          this.extension = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.name = '';

        /**
         * FileDescriptorProto package.
         * @member {string} package
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype['package'] = '';

        /**
         * FileDescriptorProto dependency.
         * @member {Array.<string>} dependency
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.dependency = $util.emptyArray;

        /**
         * FileDescriptorProto public_dependency.
         * @member {Array.<number>} public_dependency
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.public_dependency = $util.emptyArray;

        /**
         * FileDescriptorProto weak_dependency.
         * @member {Array.<number>} weak_dependency
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.weak_dependency = $util.emptyArray;

        /**
         * FileDescriptorProto message_type.
         * @member {Array.<google.protobuf.IDescriptorProto>} message_type
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.message_type = $util.emptyArray;

        /**
         * FileDescriptorProto enum_type.
         * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.enum_type = $util.emptyArray;

        /**
         * FileDescriptorProto service.
         * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.service = $util.emptyArray;

        /**
         * FileDescriptorProto extension.
         * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.extension = $util.emptyArray;

        /**
         * FileDescriptorProto options.
         * @member {google.protobuf.IFileOptions|null|undefined} options
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.options = null;

        /**
         * FileDescriptorProto source_code_info.
         * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.source_code_info = null;

        /**
         * FileDescriptorProto syntax.
         * @member {string} syntax
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.syntax = '';

        /**
         * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message['package'] != null && Object.hasOwnProperty.call(message, 'package'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message['package']);
          if (message.dependency != null && message.dependency.length)
            for (var i = 0; i < message.dependency.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.dependency[i]);
          if (message.message_type != null && message.message_type.length)
            for (var i = 0; i < message.message_type.length; ++i)
              $root.google.protobuf.DescriptorProto.encode(
                message.message_type[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          if (message.enum_type != null && message.enum_type.length)
            for (var i = 0; i < message.enum_type.length; ++i)
              $root.google.protobuf.EnumDescriptorProto.encode(
                message.enum_type[i],
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
          if (message.service != null && message.service.length)
            for (var i = 0; i < message.service.length; ++i)
              $root.google.protobuf.ServiceDescriptorProto.encode(
                message.service[i],
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
          if (message.extension != null && message.extension.length)
            for (var i = 0; i < message.extension.length; ++i)
              $root.google.protobuf.FieldDescriptorProto.encode(
                message.extension[i],
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
          if (message.source_code_info != null && Object.hasOwnProperty.call(message, 'source_code_info'))
            $root.google.protobuf.SourceCodeInfo.encode(
              message.source_code_info,
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
          if (message.public_dependency != null && message.public_dependency.length)
            for (var i = 0; i < message.public_dependency.length; ++i)
              writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.public_dependency[i]);
          if (message.weak_dependency != null && message.weak_dependency.length)
            for (var i = 0; i < message.weak_dependency.length; ++i)
              writer.uint32(/* id 11, wireType 0 =*/ 88).int32(message.weak_dependency[i]);
          if (message.syntax != null && Object.hasOwnProperty.call(message, 'syntax'))
            writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.syntax);
          return writer;
        };

        /**
         * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FileDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message['package'] = reader.string();
                break;
              case 3:
                if (!(message.dependency && message.dependency.length)) message.dependency = [];
                message.dependency.push(reader.string());
                break;
              case 10:
                if (!(message.public_dependency && message.public_dependency.length)) message.public_dependency = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.public_dependency.push(reader.int32());
                } else message.public_dependency.push(reader.int32());
                break;
              case 11:
                if (!(message.weak_dependency && message.weak_dependency.length)) message.weak_dependency = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.weak_dependency.push(reader.int32());
                } else message.weak_dependency.push(reader.int32());
                break;
              case 4:
                if (!(message.message_type && message.message_type.length)) message.message_type = [];
                message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                break;
              case 5:
                if (!(message.enum_type && message.enum_type.length)) message.enum_type = [];
                message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 6:
                if (!(message.service && message.service.length)) message.service = [];
                message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 7:
                if (!(message.extension && message.extension.length)) message.extension = [];
                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 8:
                message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                break;
              case 9:
                message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                break;
              case 12:
                message.syntax = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileDescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message['package'] != null && message.hasOwnProperty('package'))
            if (!$util.isString(message['package'])) return 'package: string expected';
          if (message.dependency != null && message.hasOwnProperty('dependency')) {
            if (!Array.isArray(message.dependency)) return 'dependency: array expected';
            for (var i = 0; i < message.dependency.length; ++i)
              if (!$util.isString(message.dependency[i])) return 'dependency: string[] expected';
          }
          if (message.public_dependency != null && message.hasOwnProperty('public_dependency')) {
            if (!Array.isArray(message.public_dependency)) return 'public_dependency: array expected';
            for (var i = 0; i < message.public_dependency.length; ++i)
              if (!$util.isInteger(message.public_dependency[i])) return 'public_dependency: integer[] expected';
          }
          if (message.weak_dependency != null && message.hasOwnProperty('weak_dependency')) {
            if (!Array.isArray(message.weak_dependency)) return 'weak_dependency: array expected';
            for (var i = 0; i < message.weak_dependency.length; ++i)
              if (!$util.isInteger(message.weak_dependency[i])) return 'weak_dependency: integer[] expected';
          }
          if (message.message_type != null && message.hasOwnProperty('message_type')) {
            if (!Array.isArray(message.message_type)) return 'message_type: array expected';
            for (var i = 0; i < message.message_type.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
              if (error) return 'message_type.' + error;
            }
          }
          if (message.enum_type != null && message.hasOwnProperty('enum_type')) {
            if (!Array.isArray(message.enum_type)) return 'enum_type: array expected';
            for (var i = 0; i < message.enum_type.length; ++i) {
              var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
              if (error) return 'enum_type.' + error;
            }
          }
          if (message.service != null && message.hasOwnProperty('service')) {
            if (!Array.isArray(message.service)) return 'service: array expected';
            for (var i = 0; i < message.service.length; ++i) {
              var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
              if (error) return 'service.' + error;
            }
          }
          if (message.extension != null && message.hasOwnProperty('extension')) {
            if (!Array.isArray(message.extension)) return 'extension: array expected';
            for (var i = 0; i < message.extension.length; ++i) {
              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
              if (error) return 'extension.' + error;
            }
          }
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.FileOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          if (message.source_code_info != null && message.hasOwnProperty('source_code_info')) {
            var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
            if (error) return 'source_code_info.' + error;
          }
          if (message.syntax != null && message.hasOwnProperty('syntax'))
            if (!$util.isString(message.syntax)) return 'syntax: string expected';
          return null;
        };

        /**
         * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
         */
        FileDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FileDescriptorProto) return object;
          var message = new $root.google.protobuf.FileDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object['package'] != null) message['package'] = String(object['package']);
          if (object.dependency) {
            if (!Array.isArray(object.dependency)) throw TypeError('.google.protobuf.FileDescriptorProto.dependency: array expected');
            message.dependency = [];
            for (var i = 0; i < object.dependency.length; ++i) message.dependency[i] = String(object.dependency[i]);
          }
          if (object.public_dependency) {
            if (!Array.isArray(object.public_dependency))
              throw TypeError('.google.protobuf.FileDescriptorProto.public_dependency: array expected');
            message.public_dependency = [];
            for (var i = 0; i < object.public_dependency.length; ++i) message.public_dependency[i] = object.public_dependency[i] | 0;
          }
          if (object.weak_dependency) {
            if (!Array.isArray(object.weak_dependency))
              throw TypeError('.google.protobuf.FileDescriptorProto.weak_dependency: array expected');
            message.weak_dependency = [];
            for (var i = 0; i < object.weak_dependency.length; ++i) message.weak_dependency[i] = object.weak_dependency[i] | 0;
          }
          if (object.message_type) {
            if (!Array.isArray(object.message_type)) throw TypeError('.google.protobuf.FileDescriptorProto.message_type: array expected');
            message.message_type = [];
            for (var i = 0; i < object.message_type.length; ++i) {
              if (typeof object.message_type[i] !== 'object')
                throw TypeError('.google.protobuf.FileDescriptorProto.message_type: object expected');
              message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
            }
          }
          if (object.enum_type) {
            if (!Array.isArray(object.enum_type)) throw TypeError('.google.protobuf.FileDescriptorProto.enum_type: array expected');
            message.enum_type = [];
            for (var i = 0; i < object.enum_type.length; ++i) {
              if (typeof object.enum_type[i] !== 'object')
                throw TypeError('.google.protobuf.FileDescriptorProto.enum_type: object expected');
              message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
            }
          }
          if (object.service) {
            if (!Array.isArray(object.service)) throw TypeError('.google.protobuf.FileDescriptorProto.service: array expected');
            message.service = [];
            for (var i = 0; i < object.service.length; ++i) {
              if (typeof object.service[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.service: object expected');
              message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
            }
          }
          if (object.extension) {
            if (!Array.isArray(object.extension)) throw TypeError('.google.protobuf.FileDescriptorProto.extension: array expected');
            message.extension = [];
            for (var i = 0; i < object.extension.length; ++i) {
              if (typeof object.extension[i] !== 'object')
                throw TypeError('.google.protobuf.FileDescriptorProto.extension: object expected');
              message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
            }
          }
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.options: object expected');
            message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
          }
          if (object.source_code_info != null) {
            if (typeof object.source_code_info !== 'object')
              throw TypeError('.google.protobuf.FileDescriptorProto.source_code_info: object expected');
            message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
          }
          if (object.syntax != null) message.syntax = String(object.syntax);
          return message;
        };

        /**
         * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.dependency = [];
            object.message_type = [];
            object.enum_type = [];
            object.service = [];
            object.extension = [];
            object.public_dependency = [];
            object.weak_dependency = [];
          }
          if (options.defaults) {
            object.name = '';
            object['package'] = '';
            object.options = null;
            object.source_code_info = null;
            object.syntax = '';
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message['package'] != null && message.hasOwnProperty('package')) object['package'] = message['package'];
          if (message.dependency && message.dependency.length) {
            object.dependency = [];
            for (var j = 0; j < message.dependency.length; ++j) object.dependency[j] = message.dependency[j];
          }
          if (message.message_type && message.message_type.length) {
            object.message_type = [];
            for (var j = 0; j < message.message_type.length; ++j)
              object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
          }
          if (message.enum_type && message.enum_type.length) {
            object.enum_type = [];
            for (var j = 0; j < message.enum_type.length; ++j)
              object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
          }
          if (message.service && message.service.length) {
            object.service = [];
            for (var j = 0; j < message.service.length; ++j)
              object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
          }
          if (message.extension && message.extension.length) {
            object.extension = [];
            for (var j = 0; j < message.extension.length; ++j)
              object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
          }
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
          if (message.source_code_info != null && message.hasOwnProperty('source_code_info'))
            object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
          if (message.public_dependency && message.public_dependency.length) {
            object.public_dependency = [];
            for (var j = 0; j < message.public_dependency.length; ++j) object.public_dependency[j] = message.public_dependency[j];
          }
          if (message.weak_dependency && message.weak_dependency.length) {
            object.weak_dependency = [];
            for (var j = 0; j < message.weak_dependency.length; ++j) object.weak_dependency[j] = message.weak_dependency[j];
          }
          if (message.syntax != null && message.hasOwnProperty('syntax')) object.syntax = message.syntax;
          return object;
        };

        /**
         * Converts this FileDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileDescriptorProto;
      })();

      protobuf.DescriptorProto = (function () {
        /**
         * Properties of a DescriptorProto.
         * @memberof google.protobuf
         * @interface IDescriptorProto
         * @property {string|null} [name] DescriptorProto name
         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
         * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
         * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
         * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
         * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneof_decl] DescriptorProto oneof_decl
         * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
         * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reserved_range] DescriptorProto reserved_range
         * @property {Array.<string>|null} [reserved_name] DescriptorProto reserved_name
         */

        /**
         * Constructs a new DescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a DescriptorProto.
         * @implements IDescriptorProto
         * @constructor
         * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
         */
        function DescriptorProto(properties) {
          this.field = [];
          this.extension = [];
          this.nested_type = [];
          this.enum_type = [];
          this.extension_range = [];
          this.oneof_decl = [];
          this.reserved_range = [];
          this.reserved_name = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.name = '';

        /**
         * DescriptorProto field.
         * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.field = $util.emptyArray;

        /**
         * DescriptorProto extension.
         * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.extension = $util.emptyArray;

        /**
         * DescriptorProto nested_type.
         * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.nested_type = $util.emptyArray;

        /**
         * DescriptorProto enum_type.
         * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.enum_type = $util.emptyArray;

        /**
         * DescriptorProto extension_range.
         * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.extension_range = $util.emptyArray;

        /**
         * DescriptorProto oneof_decl.
         * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneof_decl
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.oneof_decl = $util.emptyArray;

        /**
         * DescriptorProto options.
         * @member {google.protobuf.IMessageOptions|null|undefined} options
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.options = null;

        /**
         * DescriptorProto reserved_range.
         * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reserved_range
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.reserved_range = $util.emptyArray;

        /**
         * DescriptorProto reserved_name.
         * @member {Array.<string>} reserved_name
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.reserved_name = $util.emptyArray;

        /**
         * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.field != null && message.field.length)
            for (var i = 0; i < message.field.length; ++i)
              $root.google.protobuf.FieldDescriptorProto.encode(
                message.field[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.nested_type != null && message.nested_type.length)
            for (var i = 0; i < message.nested_type.length; ++i)
              $root.google.protobuf.DescriptorProto.encode(
                message.nested_type[i],
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
          if (message.enum_type != null && message.enum_type.length)
            for (var i = 0; i < message.enum_type.length; ++i)
              $root.google.protobuf.EnumDescriptorProto.encode(
                message.enum_type[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          if (message.extension_range != null && message.extension_range.length)
            for (var i = 0; i < message.extension_range.length; ++i)
              $root.google.protobuf.DescriptorProto.ExtensionRange.encode(
                message.extension_range[i],
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
          if (message.extension != null && message.extension.length)
            for (var i = 0; i < message.extension.length; ++i)
              $root.google.protobuf.FieldDescriptorProto.encode(
                message.extension[i],
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
          if (message.oneof_decl != null && message.oneof_decl.length)
            for (var i = 0; i < message.oneof_decl.length; ++i)
              $root.google.protobuf.OneofDescriptorProto.encode(
                message.oneof_decl[i],
                writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
              ).ldelim();
          if (message.reserved_range != null && message.reserved_range.length)
            for (var i = 0; i < message.reserved_range.length; ++i)
              $root.google.protobuf.DescriptorProto.ReservedRange.encode(
                message.reserved_range[i],
                writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
              ).ldelim();
          if (message.reserved_name != null && message.reserved_name.length)
            for (var i = 0; i < message.reserved_name.length; ++i)
              writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.reserved_name[i]);
          return writer;
        };

        /**
         * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto} DescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.DescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                if (!(message.field && message.field.length)) message.field = [];
                message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 6:
                if (!(message.extension && message.extension.length)) message.extension = [];
                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 3:
                if (!(message.nested_type && message.nested_type.length)) message.nested_type = [];
                message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                break;
              case 4:
                if (!(message.enum_type && message.enum_type.length)) message.enum_type = [];
                message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 5:
                if (!(message.extension_range && message.extension_range.length)) message.extension_range = [];
                message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                break;
              case 8:
                if (!(message.oneof_decl && message.oneof_decl.length)) message.oneof_decl = [];
                message.oneof_decl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 7:
                message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                break;
              case 9:
                if (!(message.reserved_range && message.reserved_range.length)) message.reserved_range = [];
                message.reserved_range.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                break;
              case 10:
                if (!(message.reserved_name && message.reserved_name.length)) message.reserved_name = [];
                message.reserved_name.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto} DescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DescriptorProto message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.field != null && message.hasOwnProperty('field')) {
            if (!Array.isArray(message.field)) return 'field: array expected';
            for (var i = 0; i < message.field.length; ++i) {
              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
              if (error) return 'field.' + error;
            }
          }
          if (message.extension != null && message.hasOwnProperty('extension')) {
            if (!Array.isArray(message.extension)) return 'extension: array expected';
            for (var i = 0; i < message.extension.length; ++i) {
              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
              if (error) return 'extension.' + error;
            }
          }
          if (message.nested_type != null && message.hasOwnProperty('nested_type')) {
            if (!Array.isArray(message.nested_type)) return 'nested_type: array expected';
            for (var i = 0; i < message.nested_type.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
              if (error) return 'nested_type.' + error;
            }
          }
          if (message.enum_type != null && message.hasOwnProperty('enum_type')) {
            if (!Array.isArray(message.enum_type)) return 'enum_type: array expected';
            for (var i = 0; i < message.enum_type.length; ++i) {
              var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
              if (error) return 'enum_type.' + error;
            }
          }
          if (message.extension_range != null && message.hasOwnProperty('extension_range')) {
            if (!Array.isArray(message.extension_range)) return 'extension_range: array expected';
            for (var i = 0; i < message.extension_range.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
              if (error) return 'extension_range.' + error;
            }
          }
          if (message.oneof_decl != null && message.hasOwnProperty('oneof_decl')) {
            if (!Array.isArray(message.oneof_decl)) return 'oneof_decl: array expected';
            for (var i = 0; i < message.oneof_decl.length; ++i) {
              var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneof_decl[i]);
              if (error) return 'oneof_decl.' + error;
            }
          }
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.MessageOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          if (message.reserved_range != null && message.hasOwnProperty('reserved_range')) {
            if (!Array.isArray(message.reserved_range)) return 'reserved_range: array expected';
            for (var i = 0; i < message.reserved_range.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reserved_range[i]);
              if (error) return 'reserved_range.' + error;
            }
          }
          if (message.reserved_name != null && message.hasOwnProperty('reserved_name')) {
            if (!Array.isArray(message.reserved_name)) return 'reserved_name: array expected';
            for (var i = 0; i < message.reserved_name.length; ++i)
              if (!$util.isString(message.reserved_name[i])) return 'reserved_name: string[] expected';
          }
          return null;
        };

        /**
         * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto} DescriptorProto
         */
        DescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto) return object;
          var message = new $root.google.protobuf.DescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.field) {
            if (!Array.isArray(object.field)) throw TypeError('.google.protobuf.DescriptorProto.field: array expected');
            message.field = [];
            for (var i = 0; i < object.field.length; ++i) {
              if (typeof object.field[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.field: object expected');
              message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
            }
          }
          if (object.extension) {
            if (!Array.isArray(object.extension)) throw TypeError('.google.protobuf.DescriptorProto.extension: array expected');
            message.extension = [];
            for (var i = 0; i < object.extension.length; ++i) {
              if (typeof object.extension[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.extension: object expected');
              message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
            }
          }
          if (object.nested_type) {
            if (!Array.isArray(object.nested_type)) throw TypeError('.google.protobuf.DescriptorProto.nested_type: array expected');
            message.nested_type = [];
            for (var i = 0; i < object.nested_type.length; ++i) {
              if (typeof object.nested_type[i] !== 'object')
                throw TypeError('.google.protobuf.DescriptorProto.nested_type: object expected');
              message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
            }
          }
          if (object.enum_type) {
            if (!Array.isArray(object.enum_type)) throw TypeError('.google.protobuf.DescriptorProto.enum_type: array expected');
            message.enum_type = [];
            for (var i = 0; i < object.enum_type.length; ++i) {
              if (typeof object.enum_type[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.enum_type: object expected');
              message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
            }
          }
          if (object.extension_range) {
            if (!Array.isArray(object.extension_range)) throw TypeError('.google.protobuf.DescriptorProto.extension_range: array expected');
            message.extension_range = [];
            for (var i = 0; i < object.extension_range.length; ++i) {
              if (typeof object.extension_range[i] !== 'object')
                throw TypeError('.google.protobuf.DescriptorProto.extension_range: object expected');
              message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
            }
          }
          if (object.oneof_decl) {
            if (!Array.isArray(object.oneof_decl)) throw TypeError('.google.protobuf.DescriptorProto.oneof_decl: array expected');
            message.oneof_decl = [];
            for (var i = 0; i < object.oneof_decl.length; ++i) {
              if (typeof object.oneof_decl[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.oneof_decl: object expected');
              message.oneof_decl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneof_decl[i]);
            }
          }
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.DescriptorProto.options: object expected');
            message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
          }
          if (object.reserved_range) {
            if (!Array.isArray(object.reserved_range)) throw TypeError('.google.protobuf.DescriptorProto.reserved_range: array expected');
            message.reserved_range = [];
            for (var i = 0; i < object.reserved_range.length; ++i) {
              if (typeof object.reserved_range[i] !== 'object')
                throw TypeError('.google.protobuf.DescriptorProto.reserved_range: object expected');
              message.reserved_range[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reserved_range[i]);
            }
          }
          if (object.reserved_name) {
            if (!Array.isArray(object.reserved_name)) throw TypeError('.google.protobuf.DescriptorProto.reserved_name: array expected');
            message.reserved_name = [];
            for (var i = 0; i < object.reserved_name.length; ++i) message.reserved_name[i] = String(object.reserved_name[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {google.protobuf.DescriptorProto} message DescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.field = [];
            object.nested_type = [];
            object.enum_type = [];
            object.extension_range = [];
            object.extension = [];
            object.oneof_decl = [];
            object.reserved_range = [];
            object.reserved_name = [];
          }
          if (options.defaults) {
            object.name = '';
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.field && message.field.length) {
            object.field = [];
            for (var j = 0; j < message.field.length; ++j)
              object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
          }
          if (message.nested_type && message.nested_type.length) {
            object.nested_type = [];
            for (var j = 0; j < message.nested_type.length; ++j)
              object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
          }
          if (message.enum_type && message.enum_type.length) {
            object.enum_type = [];
            for (var j = 0; j < message.enum_type.length; ++j)
              object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
          }
          if (message.extension_range && message.extension_range.length) {
            object.extension_range = [];
            for (var j = 0; j < message.extension_range.length; ++j)
              object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(
                message.extension_range[j],
                options,
              );
          }
          if (message.extension && message.extension.length) {
            object.extension = [];
            for (var j = 0; j < message.extension.length; ++j)
              object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
          }
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
          if (message.oneof_decl && message.oneof_decl.length) {
            object.oneof_decl = [];
            for (var j = 0; j < message.oneof_decl.length; ++j)
              object.oneof_decl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneof_decl[j], options);
          }
          if (message.reserved_range && message.reserved_range.length) {
            object.reserved_range = [];
            for (var j = 0; j < message.reserved_range.length; ++j)
              object.reserved_range[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reserved_range[j], options);
          }
          if (message.reserved_name && message.reserved_name.length) {
            object.reserved_name = [];
            for (var j = 0; j < message.reserved_name.length; ++j) object.reserved_name[j] = message.reserved_name[j];
          }
          return object;
        };

        /**
         * Converts this DescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        DescriptorProto.ExtensionRange = (function () {
          /**
           * Properties of an ExtensionRange.
           * @memberof google.protobuf.DescriptorProto
           * @interface IExtensionRange
           * @property {number|null} [start] ExtensionRange start
           * @property {number|null} [end] ExtensionRange end
           */

          /**
           * Constructs a new ExtensionRange.
           * @memberof google.protobuf.DescriptorProto
           * @classdesc Represents an ExtensionRange.
           * @implements IExtensionRange
           * @constructor
           * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
           */
          function ExtensionRange(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * ExtensionRange start.
           * @member {number} start
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @instance
           */
          ExtensionRange.prototype.start = 0;

          /**
           * ExtensionRange end.
           * @member {number} end
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @instance
           */
          ExtensionRange.prototype.end = 0;

          /**
           * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ExtensionRange.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
              writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
              writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
            return writer;
          };

          /**
           * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an ExtensionRange message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ExtensionRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.start = reader.int32();
                  break;
                case 2:
                  message.end = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an ExtensionRange message.
           * @function verify
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ExtensionRange.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.start != null && message.hasOwnProperty('start'))
              if (!$util.isInteger(message.start)) return 'start: integer expected';
            if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
            return null;
          };

          /**
           * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
           */
          ExtensionRange.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange) return object;
            var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
            if (object.start != null) message.start = object.start | 0;
            if (object.end != null) message.end = object.end | 0;
            return message;
          };

          /**
           * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ExtensionRange.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.start = 0;
              object.end = 0;
            }
            if (message.start != null && message.hasOwnProperty('start')) object.start = message.start;
            if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
            return object;
          };

          /**
           * Converts this ExtensionRange to JSON.
           * @function toJSON
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ExtensionRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return ExtensionRange;
        })();

        DescriptorProto.ReservedRange = (function () {
          /**
           * Properties of a ReservedRange.
           * @memberof google.protobuf.DescriptorProto
           * @interface IReservedRange
           * @property {number|null} [start] ReservedRange start
           * @property {number|null} [end] ReservedRange end
           */

          /**
           * Constructs a new ReservedRange.
           * @memberof google.protobuf.DescriptorProto
           * @classdesc Represents a ReservedRange.
           * @implements IReservedRange
           * @constructor
           * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
           */
          function ReservedRange(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * ReservedRange start.
           * @member {number} start
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @instance
           */
          ReservedRange.prototype.start = 0;

          /**
           * ReservedRange end.
           * @member {number} end
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @instance
           */
          ReservedRange.prototype.end = 0;

          /**
           * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReservedRange.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
              writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
              writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
            return writer;
          };

          /**
           * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ReservedRange message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReservedRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.DescriptorProto.ReservedRange();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.start = reader.int32();
                  break;
                case 2:
                  message.end = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReservedRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ReservedRange message.
           * @function verify
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ReservedRange.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.start != null && message.hasOwnProperty('start'))
              if (!$util.isInteger(message.start)) return 'start: integer expected';
            if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
            return null;
          };

          /**
           * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
           */
          ReservedRange.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange) return object;
            var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
            if (object.start != null) message.start = object.start | 0;
            if (object.end != null) message.end = object.end | 0;
            return message;
          };

          /**
           * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ReservedRange.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.start = 0;
              object.end = 0;
            }
            if (message.start != null && message.hasOwnProperty('start')) object.start = message.start;
            if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
            return object;
          };

          /**
           * Converts this ReservedRange to JSON.
           * @function toJSON
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ReservedRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return ReservedRange;
        })();

        return DescriptorProto;
      })();

      protobuf.FieldDescriptorProto = (function () {
        /**
         * Properties of a FieldDescriptorProto.
         * @memberof google.protobuf
         * @interface IFieldDescriptorProto
         * @property {string|null} [name] FieldDescriptorProto name
         * @property {number|null} [number] FieldDescriptorProto number
         * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
         * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
         * @property {string|null} [type_name] FieldDescriptorProto type_name
         * @property {string|null} [extendee] FieldDescriptorProto extendee
         * @property {string|null} [default_value] FieldDescriptorProto default_value
         * @property {number|null} [oneof_index] FieldDescriptorProto oneof_index
         * @property {string|null} [json_name] FieldDescriptorProto json_name
         * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
         */

        /**
         * Constructs a new FieldDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a FieldDescriptorProto.
         * @implements IFieldDescriptorProto
         * @constructor
         * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
         */
        function FieldDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FieldDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.name = '';

        /**
         * FieldDescriptorProto number.
         * @member {number} number
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.number = 0;

        /**
         * FieldDescriptorProto label.
         * @member {google.protobuf.FieldDescriptorProto.Label} label
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.label = 1;

        /**
         * FieldDescriptorProto type.
         * @member {google.protobuf.FieldDescriptorProto.Type} type
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.type = 1;

        /**
         * FieldDescriptorProto type_name.
         * @member {string} type_name
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.type_name = '';

        /**
         * FieldDescriptorProto extendee.
         * @member {string} extendee
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.extendee = '';

        /**
         * FieldDescriptorProto default_value.
         * @member {string} default_value
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.default_value = '';

        /**
         * FieldDescriptorProto oneof_index.
         * @member {number} oneof_index
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.oneof_index = 0;

        /**
         * FieldDescriptorProto json_name.
         * @member {string} json_name
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.json_name = '';

        /**
         * FieldDescriptorProto options.
         * @member {google.protobuf.IFieldOptions|null|undefined} options
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.options = null;

        /**
         * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.extendee != null && Object.hasOwnProperty.call(message, 'extendee'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.extendee);
          if (message.number != null && Object.hasOwnProperty.call(message, 'number'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.number);
          if (message.label != null && Object.hasOwnProperty.call(message, 'label'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.label);
          if (message.type != null && Object.hasOwnProperty.call(message, 'type'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.type);
          if (message.type_name != null && Object.hasOwnProperty.call(message, 'type_name'))
            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.type_name);
          if (message.default_value != null && Object.hasOwnProperty.call(message, 'default_value'))
            writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.default_value);
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
          if (message.oneof_index != null && Object.hasOwnProperty.call(message, 'oneof_index'))
            writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.oneof_index);
          if (message.json_name != null && Object.hasOwnProperty.call(message, 'json_name'))
            writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.json_name);
          return writer;
        };

        /**
         * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FieldDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FieldDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 3:
                message.number = reader.int32();
                break;
              case 4:
                message.label = reader.int32();
                break;
              case 5:
                message.type = reader.int32();
                break;
              case 6:
                message.type_name = reader.string();
                break;
              case 2:
                message.extendee = reader.string();
                break;
              case 7:
                message.default_value = reader.string();
                break;
              case 9:
                message.oneof_index = reader.int32();
                break;
              case 10:
                message.json_name = reader.string();
                break;
              case 8:
                message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FieldDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldDescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.number != null && message.hasOwnProperty('number'))
            if (!$util.isInteger(message.number)) return 'number: integer expected';
          if (message.label != null && message.hasOwnProperty('label'))
            switch (message.label) {
              default:
                return 'label: enum value expected';
              case 1:
              case 2:
              case 3:
                break;
            }
          if (message.type != null && message.hasOwnProperty('type'))
            switch (message.type) {
              default:
                return 'type: enum value expected';
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
                break;
            }
          if (message.type_name != null && message.hasOwnProperty('type_name'))
            if (!$util.isString(message.type_name)) return 'type_name: string expected';
          if (message.extendee != null && message.hasOwnProperty('extendee'))
            if (!$util.isString(message.extendee)) return 'extendee: string expected';
          if (message.default_value != null && message.hasOwnProperty('default_value'))
            if (!$util.isString(message.default_value)) return 'default_value: string expected';
          if (message.oneof_index != null && message.hasOwnProperty('oneof_index'))
            if (!$util.isInteger(message.oneof_index)) return 'oneof_index: integer expected';
          if (message.json_name != null && message.hasOwnProperty('json_name'))
            if (!$util.isString(message.json_name)) return 'json_name: string expected';
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.FieldOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          return null;
        };

        /**
         * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
         */
        FieldDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FieldDescriptorProto) return object;
          var message = new $root.google.protobuf.FieldDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.number != null) message.number = object.number | 0;
          switch (object.label) {
            case 'LABEL_OPTIONAL':
            case 1:
              message.label = 1;
              break;
            case 'LABEL_REQUIRED':
            case 2:
              message.label = 2;
              break;
            case 'LABEL_REPEATED':
            case 3:
              message.label = 3;
              break;
          }
          switch (object.type) {
            case 'TYPE_DOUBLE':
            case 1:
              message.type = 1;
              break;
            case 'TYPE_FLOAT':
            case 2:
              message.type = 2;
              break;
            case 'TYPE_INT64':
            case 3:
              message.type = 3;
              break;
            case 'TYPE_UINT64':
            case 4:
              message.type = 4;
              break;
            case 'TYPE_INT32':
            case 5:
              message.type = 5;
              break;
            case 'TYPE_FIXED64':
            case 6:
              message.type = 6;
              break;
            case 'TYPE_FIXED32':
            case 7:
              message.type = 7;
              break;
            case 'TYPE_BOOL':
            case 8:
              message.type = 8;
              break;
            case 'TYPE_STRING':
            case 9:
              message.type = 9;
              break;
            case 'TYPE_GROUP':
            case 10:
              message.type = 10;
              break;
            case 'TYPE_MESSAGE':
            case 11:
              message.type = 11;
              break;
            case 'TYPE_BYTES':
            case 12:
              message.type = 12;
              break;
            case 'TYPE_UINT32':
            case 13:
              message.type = 13;
              break;
            case 'TYPE_ENUM':
            case 14:
              message.type = 14;
              break;
            case 'TYPE_SFIXED32':
            case 15:
              message.type = 15;
              break;
            case 'TYPE_SFIXED64':
            case 16:
              message.type = 16;
              break;
            case 'TYPE_SINT32':
            case 17:
              message.type = 17;
              break;
            case 'TYPE_SINT64':
            case 18:
              message.type = 18;
              break;
          }
          if (object.type_name != null) message.type_name = String(object.type_name);
          if (object.extendee != null) message.extendee = String(object.extendee);
          if (object.default_value != null) message.default_value = String(object.default_value);
          if (object.oneof_index != null) message.oneof_index = object.oneof_index | 0;
          if (object.json_name != null) message.json_name = String(object.json_name);
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.FieldDescriptorProto.options: object expected');
            message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = '';
            object.extendee = '';
            object.number = 0;
            object.label = options.enums === String ? 'LABEL_OPTIONAL' : 1;
            object.type = options.enums === String ? 'TYPE_DOUBLE' : 1;
            object.type_name = '';
            object.default_value = '';
            object.options = null;
            object.oneof_index = 0;
            object.json_name = '';
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.extendee != null && message.hasOwnProperty('extendee')) object.extendee = message.extendee;
          if (message.number != null && message.hasOwnProperty('number')) object.number = message.number;
          if (message.label != null && message.hasOwnProperty('label'))
            object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
          if (message.type != null && message.hasOwnProperty('type'))
            object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
          if (message.type_name != null && message.hasOwnProperty('type_name')) object.type_name = message.type_name;
          if (message.default_value != null && message.hasOwnProperty('default_value')) object.default_value = message.default_value;
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
          if (message.oneof_index != null && message.hasOwnProperty('oneof_index')) object.oneof_index = message.oneof_index;
          if (message.json_name != null && message.hasOwnProperty('json_name')) object.json_name = message.json_name;
          return object;
        };

        /**
         * Converts this FieldDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name google.protobuf.FieldDescriptorProto.Type
         * @enum {number}
         * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
         * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
         * @property {number} TYPE_INT64=3 TYPE_INT64 value
         * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
         * @property {number} TYPE_INT32=5 TYPE_INT32 value
         * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
         * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
         * @property {number} TYPE_BOOL=8 TYPE_BOOL value
         * @property {number} TYPE_STRING=9 TYPE_STRING value
         * @property {number} TYPE_GROUP=10 TYPE_GROUP value
         * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
         * @property {number} TYPE_BYTES=12 TYPE_BYTES value
         * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
         * @property {number} TYPE_ENUM=14 TYPE_ENUM value
         * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
         * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
         * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
         * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
         */
        FieldDescriptorProto.Type = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[1] = 'TYPE_DOUBLE')] = 1;
          values[(valuesById[2] = 'TYPE_FLOAT')] = 2;
          values[(valuesById[3] = 'TYPE_INT64')] = 3;
          values[(valuesById[4] = 'TYPE_UINT64')] = 4;
          values[(valuesById[5] = 'TYPE_INT32')] = 5;
          values[(valuesById[6] = 'TYPE_FIXED64')] = 6;
          values[(valuesById[7] = 'TYPE_FIXED32')] = 7;
          values[(valuesById[8] = 'TYPE_BOOL')] = 8;
          values[(valuesById[9] = 'TYPE_STRING')] = 9;
          values[(valuesById[10] = 'TYPE_GROUP')] = 10;
          values[(valuesById[11] = 'TYPE_MESSAGE')] = 11;
          values[(valuesById[12] = 'TYPE_BYTES')] = 12;
          values[(valuesById[13] = 'TYPE_UINT32')] = 13;
          values[(valuesById[14] = 'TYPE_ENUM')] = 14;
          values[(valuesById[15] = 'TYPE_SFIXED32')] = 15;
          values[(valuesById[16] = 'TYPE_SFIXED64')] = 16;
          values[(valuesById[17] = 'TYPE_SINT32')] = 17;
          values[(valuesById[18] = 'TYPE_SINT64')] = 18;
          return values;
        })();

        /**
         * Label enum.
         * @name google.protobuf.FieldDescriptorProto.Label
         * @enum {number}
         * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
         * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
         * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
         */
        FieldDescriptorProto.Label = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[1] = 'LABEL_OPTIONAL')] = 1;
          values[(valuesById[2] = 'LABEL_REQUIRED')] = 2;
          values[(valuesById[3] = 'LABEL_REPEATED')] = 3;
          return values;
        })();

        return FieldDescriptorProto;
      })();

      protobuf.OneofDescriptorProto = (function () {
        /**
         * Properties of an OneofDescriptorProto.
         * @memberof google.protobuf
         * @interface IOneofDescriptorProto
         * @property {string|null} [name] OneofDescriptorProto name
         * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
         */

        /**
         * Constructs a new OneofDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents an OneofDescriptorProto.
         * @implements IOneofDescriptorProto
         * @constructor
         * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
         */
        function OneofDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * OneofDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.OneofDescriptorProto
         * @instance
         */
        OneofDescriptorProto.prototype.name = '';

        /**
         * OneofDescriptorProto options.
         * @member {google.protobuf.IOneofOptions|null|undefined} options
         * @memberof google.protobuf.OneofDescriptorProto
         * @instance
         */
        OneofDescriptorProto.prototype.options = null;

        /**
         * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OneofDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.OneofDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OneofDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OneofDescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.OneofOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          return null;
        };

        /**
         * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
         */
        OneofDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.OneofDescriptorProto) return object;
          var message = new $root.google.protobuf.OneofDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.OneofDescriptorProto.options: object expected');
            message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OneofDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = '';
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this OneofDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.OneofDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OneofDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OneofDescriptorProto;
      })();

      protobuf.EnumDescriptorProto = (function () {
        /**
         * Properties of an EnumDescriptorProto.
         * @memberof google.protobuf
         * @interface IEnumDescriptorProto
         * @property {string|null} [name] EnumDescriptorProto name
         * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
         * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
         */

        /**
         * Constructs a new EnumDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents an EnumDescriptorProto.
         * @implements IEnumDescriptorProto
         * @constructor
         * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
         */
        function EnumDescriptorProto(properties) {
          this.value = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         */
        EnumDescriptorProto.prototype.name = '';

        /**
         * EnumDescriptorProto value.
         * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         */
        EnumDescriptorProto.prototype.value = $util.emptyArray;

        /**
         * EnumDescriptorProto options.
         * @member {google.protobuf.IEnumOptions|null|undefined} options
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         */
        EnumDescriptorProto.prototype.options = null;

        /**
         * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.value != null && message.value.length)
            for (var i = 0; i < message.value.length; ++i)
              $root.google.protobuf.EnumValueDescriptorProto.encode(
                message.value[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                if (!(message.value && message.value.length)) message.value = [];
                message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 3:
                message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumDescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.value != null && message.hasOwnProperty('value')) {
            if (!Array.isArray(message.value)) return 'value: array expected';
            for (var i = 0; i < message.value.length; ++i) {
              var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
              if (error) return 'value.' + error;
            }
          }
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.EnumOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          return null;
        };

        /**
         * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
         */
        EnumDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumDescriptorProto) return object;
          var message = new $root.google.protobuf.EnumDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.value) {
            if (!Array.isArray(object.value)) throw TypeError('.google.protobuf.EnumDescriptorProto.value: array expected');
            message.value = [];
            for (var i = 0; i < object.value.length; ++i) {
              if (typeof object.value[i] !== 'object') throw TypeError('.google.protobuf.EnumDescriptorProto.value: object expected');
              message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
            }
          }
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.EnumDescriptorProto.options: object expected');
            message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.value = [];
          if (options.defaults) {
            object.name = '';
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.value && message.value.length) {
            object.value = [];
            for (var j = 0; j < message.value.length; ++j)
              object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
          }
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this EnumDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumDescriptorProto;
      })();

      protobuf.EnumValueDescriptorProto = (function () {
        /**
         * Properties of an EnumValueDescriptorProto.
         * @memberof google.protobuf
         * @interface IEnumValueDescriptorProto
         * @property {string|null} [name] EnumValueDescriptorProto name
         * @property {number|null} [number] EnumValueDescriptorProto number
         * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
         */

        /**
         * Constructs a new EnumValueDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents an EnumValueDescriptorProto.
         * @implements IEnumValueDescriptorProto
         * @constructor
         * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
         */
        function EnumValueDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumValueDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         */
        EnumValueDescriptorProto.prototype.name = '';

        /**
         * EnumValueDescriptorProto number.
         * @member {number} number
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         */
        EnumValueDescriptorProto.prototype.number = 0;

        /**
         * EnumValueDescriptorProto options.
         * @member {google.protobuf.IEnumValueOptions|null|undefined} options
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         */
        EnumValueDescriptorProto.prototype.options = null;

        /**
         * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.number != null && Object.hasOwnProperty.call(message, 'number'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.number);
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumValueDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message.number = reader.int32();
                break;
              case 3:
                message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumValueDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumValueDescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.number != null && message.hasOwnProperty('number'))
            if (!$util.isInteger(message.number)) return 'number: integer expected';
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          return null;
        };

        /**
         * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
         */
        EnumValueDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumValueDescriptorProto) return object;
          var message = new $root.google.protobuf.EnumValueDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.number != null) message.number = object.number | 0;
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.EnumValueDescriptorProto.options: object expected');
            message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumValueDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = '';
            object.number = 0;
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.number != null && message.hasOwnProperty('number')) object.number = message.number;
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this EnumValueDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumValueDescriptorProto;
      })();

      protobuf.ServiceDescriptorProto = (function () {
        /**
         * Properties of a ServiceDescriptorProto.
         * @memberof google.protobuf
         * @interface IServiceDescriptorProto
         * @property {string|null} [name] ServiceDescriptorProto name
         * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
         * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
         */

        /**
         * Constructs a new ServiceDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a ServiceDescriptorProto.
         * @implements IServiceDescriptorProto
         * @constructor
         * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
         */
        function ServiceDescriptorProto(properties) {
          this.method = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         */
        ServiceDescriptorProto.prototype.name = '';

        /**
         * ServiceDescriptorProto method.
         * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         */
        ServiceDescriptorProto.prototype.method = $util.emptyArray;

        /**
         * ServiceDescriptorProto options.
         * @member {google.protobuf.IServiceOptions|null|undefined} options
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         */
        ServiceDescriptorProto.prototype.options = null;

        /**
         * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.method != null && message.method.length)
            for (var i = 0; i < message.method.length; ++i)
              $root.google.protobuf.MethodDescriptorProto.encode(
                message.method[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.ServiceDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                if (!(message.method && message.method.length)) message.method = [];
                message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                break;
              case 3:
                message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceDescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.method != null && message.hasOwnProperty('method')) {
            if (!Array.isArray(message.method)) return 'method: array expected';
            for (var i = 0; i < message.method.length; ++i) {
              var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
              if (error) return 'method.' + error;
            }
          }
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.ServiceOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          return null;
        };

        /**
         * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
         */
        ServiceDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.ServiceDescriptorProto) return object;
          var message = new $root.google.protobuf.ServiceDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.method) {
            if (!Array.isArray(object.method)) throw TypeError('.google.protobuf.ServiceDescriptorProto.method: array expected');
            message.method = [];
            for (var i = 0; i < object.method.length; ++i) {
              if (typeof object.method[i] !== 'object') throw TypeError('.google.protobuf.ServiceDescriptorProto.method: object expected');
              message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
            }
          }
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.ServiceDescriptorProto.options: object expected');
            message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.method = [];
          if (options.defaults) {
            object.name = '';
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.method && message.method.length) {
            object.method = [];
            for (var j = 0; j < message.method.length; ++j)
              object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
          }
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this ServiceDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceDescriptorProto;
      })();

      protobuf.MethodDescriptorProto = (function () {
        /**
         * Properties of a MethodDescriptorProto.
         * @memberof google.protobuf
         * @interface IMethodDescriptorProto
         * @property {string|null} [name] MethodDescriptorProto name
         * @property {string|null} [input_type] MethodDescriptorProto input_type
         * @property {string|null} [output_type] MethodDescriptorProto output_type
         * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
         * @property {boolean|null} [client_streaming] MethodDescriptorProto client_streaming
         * @property {boolean|null} [server_streaming] MethodDescriptorProto server_streaming
         */

        /**
         * Constructs a new MethodDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a MethodDescriptorProto.
         * @implements IMethodDescriptorProto
         * @constructor
         * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
         */
        function MethodDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MethodDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.name = '';

        /**
         * MethodDescriptorProto input_type.
         * @member {string} input_type
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.input_type = '';

        /**
         * MethodDescriptorProto output_type.
         * @member {string} output_type
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.output_type = '';

        /**
         * MethodDescriptorProto options.
         * @member {google.protobuf.IMethodOptions|null|undefined} options
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.options = null;

        /**
         * MethodDescriptorProto client_streaming.
         * @member {boolean} client_streaming
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.client_streaming = false;

        /**
         * MethodDescriptorProto server_streaming.
         * @member {boolean} server_streaming
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.server_streaming = false;

        /**
         * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.input_type != null && Object.hasOwnProperty.call(message, 'input_type'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.input_type);
          if (message.output_type != null && Object.hasOwnProperty.call(message, 'output_type'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.output_type);
          if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
            $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
          if (message.client_streaming != null && Object.hasOwnProperty.call(message, 'client_streaming'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.client_streaming);
          if (message.server_streaming != null && Object.hasOwnProperty.call(message, 'server_streaming'))
            writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.server_streaming);
          return writer;
        };

        /**
         * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MethodDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.MethodDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message.input_type = reader.string();
                break;
              case 3:
                message.output_type = reader.string();
                break;
              case 4:
                message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                break;
              case 5:
                message.client_streaming = reader.bool();
                break;
              case 6:
                message.server_streaming = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MethodDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MethodDescriptorProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
          if (message.input_type != null && message.hasOwnProperty('input_type'))
            if (!$util.isString(message.input_type)) return 'input_type: string expected';
          if (message.output_type != null && message.hasOwnProperty('output_type'))
            if (!$util.isString(message.output_type)) return 'output_type: string expected';
          if (message.options != null && message.hasOwnProperty('options')) {
            var error = $root.google.protobuf.MethodOptions.verify(message.options);
            if (error) return 'options.' + error;
          }
          if (message.client_streaming != null && message.hasOwnProperty('client_streaming'))
            if (typeof message.client_streaming !== 'boolean') return 'client_streaming: boolean expected';
          if (message.server_streaming != null && message.hasOwnProperty('server_streaming'))
            if (typeof message.server_streaming !== 'boolean') return 'server_streaming: boolean expected';
          return null;
        };

        /**
         * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
         */
        MethodDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.MethodDescriptorProto) return object;
          var message = new $root.google.protobuf.MethodDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.input_type != null) message.input_type = String(object.input_type);
          if (object.output_type != null) message.output_type = String(object.output_type);
          if (object.options != null) {
            if (typeof object.options !== 'object') throw TypeError('.google.protobuf.MethodDescriptorProto.options: object expected');
            message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
          }
          if (object.client_streaming != null) message.client_streaming = Boolean(object.client_streaming);
          if (object.server_streaming != null) message.server_streaming = Boolean(object.server_streaming);
          return message;
        };

        /**
         * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MethodDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = '';
            object.input_type = '';
            object.output_type = '';
            object.options = null;
            object.client_streaming = false;
            object.server_streaming = false;
          }
          if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
          if (message.input_type != null && message.hasOwnProperty('input_type')) object.input_type = message.input_type;
          if (message.output_type != null && message.hasOwnProperty('output_type')) object.output_type = message.output_type;
          if (message.options != null && message.hasOwnProperty('options'))
            object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
          if (message.client_streaming != null && message.hasOwnProperty('client_streaming'))
            object.client_streaming = message.client_streaming;
          if (message.server_streaming != null && message.hasOwnProperty('server_streaming'))
            object.server_streaming = message.server_streaming;
          return object;
        };

        /**
         * Converts this MethodDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MethodDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MethodDescriptorProto;
      })();

      protobuf.FileOptions = (function () {
        /**
         * Properties of a FileOptions.
         * @memberof google.protobuf
         * @interface IFileOptions
         * @property {string|null} [java_package] FileOptions java_package
         * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
         * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
         * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
         * @property {boolean|null} [java_string_check_utf8] FileOptions java_string_check_utf8
         * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
         * @property {string|null} [go_package] FileOptions go_package
         * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
         * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
         * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
         * @property {boolean|null} [deprecated] FileOptions deprecated
         * @property {boolean|null} [cc_enable_arenas] FileOptions cc_enable_arenas
         * @property {string|null} [objc_class_prefix] FileOptions objc_class_prefix
         * @property {string|null} [csharp_namespace] FileOptions csharp_namespace
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
         * @property {boolean|null} [".gogoproto.goproto_getters_all"] FileOptions .gogoproto.goproto_getters_all
         * @property {boolean|null} [".gogoproto.goproto_enum_prefix_all"] FileOptions .gogoproto.goproto_enum_prefix_all
         * @property {boolean|null} [".gogoproto.goproto_stringer_all"] FileOptions .gogoproto.goproto_stringer_all
         * @property {boolean|null} [".gogoproto.verbose_equal_all"] FileOptions .gogoproto.verbose_equal_all
         * @property {boolean|null} [".gogoproto.face_all"] FileOptions .gogoproto.face_all
         * @property {boolean|null} [".gogoproto.gostring_all"] FileOptions .gogoproto.gostring_all
         * @property {boolean|null} [".gogoproto.populate_all"] FileOptions .gogoproto.populate_all
         * @property {boolean|null} [".gogoproto.stringer_all"] FileOptions .gogoproto.stringer_all
         * @property {boolean|null} [".gogoproto.onlyone_all"] FileOptions .gogoproto.onlyone_all
         * @property {boolean|null} [".gogoproto.equal_all"] FileOptions .gogoproto.equal_all
         * @property {boolean|null} [".gogoproto.description_all"] FileOptions .gogoproto.description_all
         * @property {boolean|null} [".gogoproto.testgen_all"] FileOptions .gogoproto.testgen_all
         * @property {boolean|null} [".gogoproto.benchgen_all"] FileOptions .gogoproto.benchgen_all
         * @property {boolean|null} [".gogoproto.marshaler_all"] FileOptions .gogoproto.marshaler_all
         * @property {boolean|null} [".gogoproto.unmarshaler_all"] FileOptions .gogoproto.unmarshaler_all
         * @property {boolean|null} [".gogoproto.stable_marshaler_all"] FileOptions .gogoproto.stable_marshaler_all
         * @property {boolean|null} [".gogoproto.sizer_all"] FileOptions .gogoproto.sizer_all
         * @property {boolean|null} [".gogoproto.goproto_enum_stringer_all"] FileOptions .gogoproto.goproto_enum_stringer_all
         * @property {boolean|null} [".gogoproto.enum_stringer_all"] FileOptions .gogoproto.enum_stringer_all
         * @property {boolean|null} [".gogoproto.unsafe_marshaler_all"] FileOptions .gogoproto.unsafe_marshaler_all
         * @property {boolean|null} [".gogoproto.unsafe_unmarshaler_all"] FileOptions .gogoproto.unsafe_unmarshaler_all
         * @property {boolean|null} [".gogoproto.goproto_extensions_map_all"] FileOptions .gogoproto.goproto_extensions_map_all
         * @property {boolean|null} [".gogoproto.goproto_unrecognized_all"] FileOptions .gogoproto.goproto_unrecognized_all
         * @property {boolean|null} [".gogoproto.gogoproto_import"] FileOptions .gogoproto.gogoproto_import
         * @property {boolean|null} [".gogoproto.protosizer_all"] FileOptions .gogoproto.protosizer_all
         * @property {boolean|null} [".gogoproto.compare_all"] FileOptions .gogoproto.compare_all
         * @property {boolean|null} [".gogoproto.typedecl_all"] FileOptions .gogoproto.typedecl_all
         * @property {boolean|null} [".gogoproto.enumdecl_all"] FileOptions .gogoproto.enumdecl_all
         * @property {boolean|null} [".gogoproto.goproto_registration"] FileOptions .gogoproto.goproto_registration
         * @property {boolean|null} [".gogoproto.messagename_all"] FileOptions .gogoproto.messagename_all
         * @property {boolean|null} [".gogoproto.goproto_sizecache_all"] FileOptions .gogoproto.goproto_sizecache_all
         * @property {boolean|null} [".gogoproto.goproto_unkeyed_all"] FileOptions .gogoproto.goproto_unkeyed_all
         */

        /**
         * Constructs a new FileOptions.
         * @memberof google.protobuf
         * @classdesc Represents a FileOptions.
         * @implements IFileOptions
         * @constructor
         * @param {google.protobuf.IFileOptions=} [properties] Properties to set
         */
        function FileOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileOptions java_package.
         * @member {string} java_package
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.java_package = '';

        /**
         * FileOptions java_outer_classname.
         * @member {string} java_outer_classname
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.java_outer_classname = '';

        /**
         * FileOptions java_multiple_files.
         * @member {boolean} java_multiple_files
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.java_multiple_files = false;

        /**
         * FileOptions java_generate_equals_and_hash.
         * @member {boolean} java_generate_equals_and_hash
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.java_generate_equals_and_hash = false;

        /**
         * FileOptions java_string_check_utf8.
         * @member {boolean} java_string_check_utf8
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.java_string_check_utf8 = false;

        /**
         * FileOptions optimize_for.
         * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.optimize_for = 1;

        /**
         * FileOptions go_package.
         * @member {string} go_package
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.go_package = '';

        /**
         * FileOptions cc_generic_services.
         * @member {boolean} cc_generic_services
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.cc_generic_services = false;

        /**
         * FileOptions java_generic_services.
         * @member {boolean} java_generic_services
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.java_generic_services = false;

        /**
         * FileOptions py_generic_services.
         * @member {boolean} py_generic_services
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.py_generic_services = false;

        /**
         * FileOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.deprecated = false;

        /**
         * FileOptions cc_enable_arenas.
         * @member {boolean} cc_enable_arenas
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.cc_enable_arenas = false;

        /**
         * FileOptions objc_class_prefix.
         * @member {string} objc_class_prefix
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.objc_class_prefix = '';

        /**
         * FileOptions csharp_namespace.
         * @member {string} csharp_namespace
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.csharp_namespace = '';

        /**
         * FileOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * FileOptions .gogoproto.goproto_getters_all.
         * @member {boolean} .gogoproto.goproto_getters_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_getters_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_enum_prefix_all.
         * @member {boolean} .gogoproto.goproto_enum_prefix_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_enum_prefix_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_stringer_all.
         * @member {boolean} .gogoproto.goproto_stringer_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_stringer_all'] = false;

        /**
         * FileOptions .gogoproto.verbose_equal_all.
         * @member {boolean} .gogoproto.verbose_equal_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.verbose_equal_all'] = false;

        /**
         * FileOptions .gogoproto.face_all.
         * @member {boolean} .gogoproto.face_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.face_all'] = false;

        /**
         * FileOptions .gogoproto.gostring_all.
         * @member {boolean} .gogoproto.gostring_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.gostring_all'] = false;

        /**
         * FileOptions .gogoproto.populate_all.
         * @member {boolean} .gogoproto.populate_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.populate_all'] = false;

        /**
         * FileOptions .gogoproto.stringer_all.
         * @member {boolean} .gogoproto.stringer_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.stringer_all'] = false;

        /**
         * FileOptions .gogoproto.onlyone_all.
         * @member {boolean} .gogoproto.onlyone_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.onlyone_all'] = false;

        /**
         * FileOptions .gogoproto.equal_all.
         * @member {boolean} .gogoproto.equal_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.equal_all'] = false;

        /**
         * FileOptions .gogoproto.description_all.
         * @member {boolean} .gogoproto.description_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.description_all'] = false;

        /**
         * FileOptions .gogoproto.testgen_all.
         * @member {boolean} .gogoproto.testgen_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.testgen_all'] = false;

        /**
         * FileOptions .gogoproto.benchgen_all.
         * @member {boolean} .gogoproto.benchgen_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.benchgen_all'] = false;

        /**
         * FileOptions .gogoproto.marshaler_all.
         * @member {boolean} .gogoproto.marshaler_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.marshaler_all'] = false;

        /**
         * FileOptions .gogoproto.unmarshaler_all.
         * @member {boolean} .gogoproto.unmarshaler_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.unmarshaler_all'] = false;

        /**
         * FileOptions .gogoproto.stable_marshaler_all.
         * @member {boolean} .gogoproto.stable_marshaler_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.stable_marshaler_all'] = false;

        /**
         * FileOptions .gogoproto.sizer_all.
         * @member {boolean} .gogoproto.sizer_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.sizer_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_enum_stringer_all.
         * @member {boolean} .gogoproto.goproto_enum_stringer_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_enum_stringer_all'] = false;

        /**
         * FileOptions .gogoproto.enum_stringer_all.
         * @member {boolean} .gogoproto.enum_stringer_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.enum_stringer_all'] = false;

        /**
         * FileOptions .gogoproto.unsafe_marshaler_all.
         * @member {boolean} .gogoproto.unsafe_marshaler_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.unsafe_marshaler_all'] = false;

        /**
         * FileOptions .gogoproto.unsafe_unmarshaler_all.
         * @member {boolean} .gogoproto.unsafe_unmarshaler_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.unsafe_unmarshaler_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_extensions_map_all.
         * @member {boolean} .gogoproto.goproto_extensions_map_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_extensions_map_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_unrecognized_all.
         * @member {boolean} .gogoproto.goproto_unrecognized_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_unrecognized_all'] = false;

        /**
         * FileOptions .gogoproto.gogoproto_import.
         * @member {boolean} .gogoproto.gogoproto_import
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.gogoproto_import'] = false;

        /**
         * FileOptions .gogoproto.protosizer_all.
         * @member {boolean} .gogoproto.protosizer_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.protosizer_all'] = false;

        /**
         * FileOptions .gogoproto.compare_all.
         * @member {boolean} .gogoproto.compare_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.compare_all'] = false;

        /**
         * FileOptions .gogoproto.typedecl_all.
         * @member {boolean} .gogoproto.typedecl_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.typedecl_all'] = false;

        /**
         * FileOptions .gogoproto.enumdecl_all.
         * @member {boolean} .gogoproto.enumdecl_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.enumdecl_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_registration.
         * @member {boolean} .gogoproto.goproto_registration
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_registration'] = false;

        /**
         * FileOptions .gogoproto.messagename_all.
         * @member {boolean} .gogoproto.messagename_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.messagename_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_sizecache_all.
         * @member {boolean} .gogoproto.goproto_sizecache_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_sizecache_all'] = false;

        /**
         * FileOptions .gogoproto.goproto_unkeyed_all.
         * @member {boolean} .gogoproto.goproto_unkeyed_all
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype['.gogoproto.goproto_unkeyed_all'] = false;

        /**
         * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.java_package != null && Object.hasOwnProperty.call(message, 'java_package'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.java_package);
          if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, 'java_outer_classname'))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.java_outer_classname);
          if (message.optimize_for != null && Object.hasOwnProperty.call(message, 'optimize_for'))
            writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.optimize_for);
          if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, 'java_multiple_files'))
            writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.java_multiple_files);
          if (message.go_package != null && Object.hasOwnProperty.call(message, 'go_package'))
            writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.go_package);
          if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, 'cc_generic_services'))
            writer.uint32(/* id 16, wireType 0 =*/ 128).bool(message.cc_generic_services);
          if (message.java_generic_services != null && Object.hasOwnProperty.call(message, 'java_generic_services'))
            writer.uint32(/* id 17, wireType 0 =*/ 136).bool(message.java_generic_services);
          if (message.py_generic_services != null && Object.hasOwnProperty.call(message, 'py_generic_services'))
            writer.uint32(/* id 18, wireType 0 =*/ 144).bool(message.py_generic_services);
          if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, 'java_generate_equals_and_hash'))
            writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.java_generate_equals_and_hash);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
            writer.uint32(/* id 23, wireType 0 =*/ 184).bool(message.deprecated);
          if (message.java_string_check_utf8 != null && Object.hasOwnProperty.call(message, 'java_string_check_utf8'))
            writer.uint32(/* id 27, wireType 0 =*/ 216).bool(message.java_string_check_utf8);
          if (message.cc_enable_arenas != null && Object.hasOwnProperty.call(message, 'cc_enable_arenas'))
            writer.uint32(/* id 31, wireType 0 =*/ 248).bool(message.cc_enable_arenas);
          if (message.objc_class_prefix != null && Object.hasOwnProperty.call(message, 'objc_class_prefix'))
            writer.uint32(/* id 36, wireType 2 =*/ 290).string(message.objc_class_prefix);
          if (message.csharp_namespace != null && Object.hasOwnProperty.call(message, 'csharp_namespace'))
            writer.uint32(/* id 37, wireType 2 =*/ 298).string(message.csharp_namespace);
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (message['.gogoproto.goproto_getters_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_getters_all'))
            writer.uint32(/* id 63001, wireType 0 =*/ 504008).bool(message['.gogoproto.goproto_getters_all']);
          if (
            message['.gogoproto.goproto_enum_prefix_all'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_prefix_all')
          )
            writer.uint32(/* id 63002, wireType 0 =*/ 504016).bool(message['.gogoproto.goproto_enum_prefix_all']);
          if (message['.gogoproto.goproto_stringer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_stringer_all'))
            writer.uint32(/* id 63003, wireType 0 =*/ 504024).bool(message['.gogoproto.goproto_stringer_all']);
          if (message['.gogoproto.verbose_equal_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.verbose_equal_all'))
            writer.uint32(/* id 63004, wireType 0 =*/ 504032).bool(message['.gogoproto.verbose_equal_all']);
          if (message['.gogoproto.face_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.face_all'))
            writer.uint32(/* id 63005, wireType 0 =*/ 504040).bool(message['.gogoproto.face_all']);
          if (message['.gogoproto.gostring_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.gostring_all'))
            writer.uint32(/* id 63006, wireType 0 =*/ 504048).bool(message['.gogoproto.gostring_all']);
          if (message['.gogoproto.populate_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.populate_all'))
            writer.uint32(/* id 63007, wireType 0 =*/ 504056).bool(message['.gogoproto.populate_all']);
          if (message['.gogoproto.stringer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stringer_all'))
            writer.uint32(/* id 63008, wireType 0 =*/ 504064).bool(message['.gogoproto.stringer_all']);
          if (message['.gogoproto.onlyone_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.onlyone_all'))
            writer.uint32(/* id 63009, wireType 0 =*/ 504072).bool(message['.gogoproto.onlyone_all']);
          if (message['.gogoproto.equal_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.equal_all'))
            writer.uint32(/* id 63013, wireType 0 =*/ 504104).bool(message['.gogoproto.equal_all']);
          if (message['.gogoproto.description_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.description_all'))
            writer.uint32(/* id 63014, wireType 0 =*/ 504112).bool(message['.gogoproto.description_all']);
          if (message['.gogoproto.testgen_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.testgen_all'))
            writer.uint32(/* id 63015, wireType 0 =*/ 504120).bool(message['.gogoproto.testgen_all']);
          if (message['.gogoproto.benchgen_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.benchgen_all'))
            writer.uint32(/* id 63016, wireType 0 =*/ 504128).bool(message['.gogoproto.benchgen_all']);
          if (message['.gogoproto.marshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.marshaler_all'))
            writer.uint32(/* id 63017, wireType 0 =*/ 504136).bool(message['.gogoproto.marshaler_all']);
          if (message['.gogoproto.unmarshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unmarshaler_all'))
            writer.uint32(/* id 63018, wireType 0 =*/ 504144).bool(message['.gogoproto.unmarshaler_all']);
          if (message['.gogoproto.stable_marshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stable_marshaler_all'))
            writer.uint32(/* id 63019, wireType 0 =*/ 504152).bool(message['.gogoproto.stable_marshaler_all']);
          if (message['.gogoproto.sizer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.sizer_all'))
            writer.uint32(/* id 63020, wireType 0 =*/ 504160).bool(message['.gogoproto.sizer_all']);
          if (
            message['.gogoproto.goproto_enum_stringer_all'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_stringer_all')
          )
            writer.uint32(/* id 63021, wireType 0 =*/ 504168).bool(message['.gogoproto.goproto_enum_stringer_all']);
          if (message['.gogoproto.enum_stringer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enum_stringer_all'))
            writer.uint32(/* id 63022, wireType 0 =*/ 504176).bool(message['.gogoproto.enum_stringer_all']);
          if (message['.gogoproto.unsafe_marshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unsafe_marshaler_all'))
            writer.uint32(/* id 63023, wireType 0 =*/ 504184).bool(message['.gogoproto.unsafe_marshaler_all']);
          if (
            message['.gogoproto.unsafe_unmarshaler_all'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.unsafe_unmarshaler_all')
          )
            writer.uint32(/* id 63024, wireType 0 =*/ 504192).bool(message['.gogoproto.unsafe_unmarshaler_all']);
          if (
            message['.gogoproto.goproto_extensions_map_all'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.goproto_extensions_map_all')
          )
            writer.uint32(/* id 63025, wireType 0 =*/ 504200).bool(message['.gogoproto.goproto_extensions_map_all']);
          if (
            message['.gogoproto.goproto_unrecognized_all'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.goproto_unrecognized_all')
          )
            writer.uint32(/* id 63026, wireType 0 =*/ 504208).bool(message['.gogoproto.goproto_unrecognized_all']);
          if (message['.gogoproto.gogoproto_import'] != null && Object.hasOwnProperty.call(message, '.gogoproto.gogoproto_import'))
            writer.uint32(/* id 63027, wireType 0 =*/ 504216).bool(message['.gogoproto.gogoproto_import']);
          if (message['.gogoproto.protosizer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.protosizer_all'))
            writer.uint32(/* id 63028, wireType 0 =*/ 504224).bool(message['.gogoproto.protosizer_all']);
          if (message['.gogoproto.compare_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.compare_all'))
            writer.uint32(/* id 63029, wireType 0 =*/ 504232).bool(message['.gogoproto.compare_all']);
          if (message['.gogoproto.typedecl_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.typedecl_all'))
            writer.uint32(/* id 63030, wireType 0 =*/ 504240).bool(message['.gogoproto.typedecl_all']);
          if (message['.gogoproto.enumdecl_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enumdecl_all'))
            writer.uint32(/* id 63031, wireType 0 =*/ 504248).bool(message['.gogoproto.enumdecl_all']);
          if (message['.gogoproto.goproto_registration'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_registration'))
            writer.uint32(/* id 63032, wireType 0 =*/ 504256).bool(message['.gogoproto.goproto_registration']);
          if (message['.gogoproto.messagename_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.messagename_all'))
            writer.uint32(/* id 63033, wireType 0 =*/ 504264).bool(message['.gogoproto.messagename_all']);
          if (
            message['.gogoproto.goproto_sizecache_all'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.goproto_sizecache_all')
          )
            writer.uint32(/* id 63034, wireType 0 =*/ 504272).bool(message['.gogoproto.goproto_sizecache_all']);
          if (message['.gogoproto.goproto_unkeyed_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_unkeyed_all'))
            writer.uint32(/* id 63035, wireType 0 =*/ 504280).bool(message['.gogoproto.goproto_unkeyed_all']);
          return writer;
        };

        /**
         * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FileOptions} FileOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FileOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.java_package = reader.string();
                break;
              case 8:
                message.java_outer_classname = reader.string();
                break;
              case 10:
                message.java_multiple_files = reader.bool();
                break;
              case 20:
                message.java_generate_equals_and_hash = reader.bool();
                break;
              case 27:
                message.java_string_check_utf8 = reader.bool();
                break;
              case 9:
                message.optimize_for = reader.int32();
                break;
              case 11:
                message.go_package = reader.string();
                break;
              case 16:
                message.cc_generic_services = reader.bool();
                break;
              case 17:
                message.java_generic_services = reader.bool();
                break;
              case 18:
                message.py_generic_services = reader.bool();
                break;
              case 23:
                message.deprecated = reader.bool();
                break;
              case 31:
                message.cc_enable_arenas = reader.bool();
                break;
              case 36:
                message.objc_class_prefix = reader.string();
                break;
              case 37:
                message.csharp_namespace = reader.string();
                break;
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              case 63001:
                message['.gogoproto.goproto_getters_all'] = reader.bool();
                break;
              case 63002:
                message['.gogoproto.goproto_enum_prefix_all'] = reader.bool();
                break;
              case 63003:
                message['.gogoproto.goproto_stringer_all'] = reader.bool();
                break;
              case 63004:
                message['.gogoproto.verbose_equal_all'] = reader.bool();
                break;
              case 63005:
                message['.gogoproto.face_all'] = reader.bool();
                break;
              case 63006:
                message['.gogoproto.gostring_all'] = reader.bool();
                break;
              case 63007:
                message['.gogoproto.populate_all'] = reader.bool();
                break;
              case 63008:
                message['.gogoproto.stringer_all'] = reader.bool();
                break;
              case 63009:
                message['.gogoproto.onlyone_all'] = reader.bool();
                break;
              case 63013:
                message['.gogoproto.equal_all'] = reader.bool();
                break;
              case 63014:
                message['.gogoproto.description_all'] = reader.bool();
                break;
              case 63015:
                message['.gogoproto.testgen_all'] = reader.bool();
                break;
              case 63016:
                message['.gogoproto.benchgen_all'] = reader.bool();
                break;
              case 63017:
                message['.gogoproto.marshaler_all'] = reader.bool();
                break;
              case 63018:
                message['.gogoproto.unmarshaler_all'] = reader.bool();
                break;
              case 63019:
                message['.gogoproto.stable_marshaler_all'] = reader.bool();
                break;
              case 63020:
                message['.gogoproto.sizer_all'] = reader.bool();
                break;
              case 63021:
                message['.gogoproto.goproto_enum_stringer_all'] = reader.bool();
                break;
              case 63022:
                message['.gogoproto.enum_stringer_all'] = reader.bool();
                break;
              case 63023:
                message['.gogoproto.unsafe_marshaler_all'] = reader.bool();
                break;
              case 63024:
                message['.gogoproto.unsafe_unmarshaler_all'] = reader.bool();
                break;
              case 63025:
                message['.gogoproto.goproto_extensions_map_all'] = reader.bool();
                break;
              case 63026:
                message['.gogoproto.goproto_unrecognized_all'] = reader.bool();
                break;
              case 63027:
                message['.gogoproto.gogoproto_import'] = reader.bool();
                break;
              case 63028:
                message['.gogoproto.protosizer_all'] = reader.bool();
                break;
              case 63029:
                message['.gogoproto.compare_all'] = reader.bool();
                break;
              case 63030:
                message['.gogoproto.typedecl_all'] = reader.bool();
                break;
              case 63031:
                message['.gogoproto.enumdecl_all'] = reader.bool();
                break;
              case 63032:
                message['.gogoproto.goproto_registration'] = reader.bool();
                break;
              case 63033:
                message['.gogoproto.messagename_all'] = reader.bool();
                break;
              case 63034:
                message['.gogoproto.goproto_sizecache_all'] = reader.bool();
                break;
              case 63035:
                message['.gogoproto.goproto_unkeyed_all'] = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FileOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FileOptions} FileOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileOptions message.
         * @function verify
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.java_package != null && message.hasOwnProperty('java_package'))
            if (!$util.isString(message.java_package)) return 'java_package: string expected';
          if (message.java_outer_classname != null && message.hasOwnProperty('java_outer_classname'))
            if (!$util.isString(message.java_outer_classname)) return 'java_outer_classname: string expected';
          if (message.java_multiple_files != null && message.hasOwnProperty('java_multiple_files'))
            if (typeof message.java_multiple_files !== 'boolean') return 'java_multiple_files: boolean expected';
          if (message.java_generate_equals_and_hash != null && message.hasOwnProperty('java_generate_equals_and_hash'))
            if (typeof message.java_generate_equals_and_hash !== 'boolean') return 'java_generate_equals_and_hash: boolean expected';
          if (message.java_string_check_utf8 != null && message.hasOwnProperty('java_string_check_utf8'))
            if (typeof message.java_string_check_utf8 !== 'boolean') return 'java_string_check_utf8: boolean expected';
          if (message.optimize_for != null && message.hasOwnProperty('optimize_for'))
            switch (message.optimize_for) {
              default:
                return 'optimize_for: enum value expected';
              case 1:
              case 2:
              case 3:
                break;
            }
          if (message.go_package != null && message.hasOwnProperty('go_package'))
            if (!$util.isString(message.go_package)) return 'go_package: string expected';
          if (message.cc_generic_services != null && message.hasOwnProperty('cc_generic_services'))
            if (typeof message.cc_generic_services !== 'boolean') return 'cc_generic_services: boolean expected';
          if (message.java_generic_services != null && message.hasOwnProperty('java_generic_services'))
            if (typeof message.java_generic_services !== 'boolean') return 'java_generic_services: boolean expected';
          if (message.py_generic_services != null && message.hasOwnProperty('py_generic_services'))
            if (typeof message.py_generic_services !== 'boolean') return 'py_generic_services: boolean expected';
          if (message.deprecated != null && message.hasOwnProperty('deprecated'))
            if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
          if (message.cc_enable_arenas != null && message.hasOwnProperty('cc_enable_arenas'))
            if (typeof message.cc_enable_arenas !== 'boolean') return 'cc_enable_arenas: boolean expected';
          if (message.objc_class_prefix != null && message.hasOwnProperty('objc_class_prefix'))
            if (!$util.isString(message.objc_class_prefix)) return 'objc_class_prefix: string expected';
          if (message.csharp_namespace != null && message.hasOwnProperty('csharp_namespace'))
            if (!$util.isString(message.csharp_namespace)) return 'csharp_namespace: string expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          if (message['.gogoproto.goproto_getters_all'] != null && message.hasOwnProperty('.gogoproto.goproto_getters_all'))
            if (typeof message['.gogoproto.goproto_getters_all'] !== 'boolean') return '.gogoproto.goproto_getters_all: boolean expected';
          if (message['.gogoproto.goproto_enum_prefix_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix_all'))
            if (typeof message['.gogoproto.goproto_enum_prefix_all'] !== 'boolean')
              return '.gogoproto.goproto_enum_prefix_all: boolean expected';
          if (message['.gogoproto.goproto_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer_all'))
            if (typeof message['.gogoproto.goproto_stringer_all'] !== 'boolean') return '.gogoproto.goproto_stringer_all: boolean expected';
          if (message['.gogoproto.verbose_equal_all'] != null && message.hasOwnProperty('.gogoproto.verbose_equal_all'))
            if (typeof message['.gogoproto.verbose_equal_all'] !== 'boolean') return '.gogoproto.verbose_equal_all: boolean expected';
          if (message['.gogoproto.face_all'] != null && message.hasOwnProperty('.gogoproto.face_all'))
            if (typeof message['.gogoproto.face_all'] !== 'boolean') return '.gogoproto.face_all: boolean expected';
          if (message['.gogoproto.gostring_all'] != null && message.hasOwnProperty('.gogoproto.gostring_all'))
            if (typeof message['.gogoproto.gostring_all'] !== 'boolean') return '.gogoproto.gostring_all: boolean expected';
          if (message['.gogoproto.populate_all'] != null && message.hasOwnProperty('.gogoproto.populate_all'))
            if (typeof message['.gogoproto.populate_all'] !== 'boolean') return '.gogoproto.populate_all: boolean expected';
          if (message['.gogoproto.stringer_all'] != null && message.hasOwnProperty('.gogoproto.stringer_all'))
            if (typeof message['.gogoproto.stringer_all'] !== 'boolean') return '.gogoproto.stringer_all: boolean expected';
          if (message['.gogoproto.onlyone_all'] != null && message.hasOwnProperty('.gogoproto.onlyone_all'))
            if (typeof message['.gogoproto.onlyone_all'] !== 'boolean') return '.gogoproto.onlyone_all: boolean expected';
          if (message['.gogoproto.equal_all'] != null && message.hasOwnProperty('.gogoproto.equal_all'))
            if (typeof message['.gogoproto.equal_all'] !== 'boolean') return '.gogoproto.equal_all: boolean expected';
          if (message['.gogoproto.description_all'] != null && message.hasOwnProperty('.gogoproto.description_all'))
            if (typeof message['.gogoproto.description_all'] !== 'boolean') return '.gogoproto.description_all: boolean expected';
          if (message['.gogoproto.testgen_all'] != null && message.hasOwnProperty('.gogoproto.testgen_all'))
            if (typeof message['.gogoproto.testgen_all'] !== 'boolean') return '.gogoproto.testgen_all: boolean expected';
          if (message['.gogoproto.benchgen_all'] != null && message.hasOwnProperty('.gogoproto.benchgen_all'))
            if (typeof message['.gogoproto.benchgen_all'] !== 'boolean') return '.gogoproto.benchgen_all: boolean expected';
          if (message['.gogoproto.marshaler_all'] != null && message.hasOwnProperty('.gogoproto.marshaler_all'))
            if (typeof message['.gogoproto.marshaler_all'] !== 'boolean') return '.gogoproto.marshaler_all: boolean expected';
          if (message['.gogoproto.unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unmarshaler_all'))
            if (typeof message['.gogoproto.unmarshaler_all'] !== 'boolean') return '.gogoproto.unmarshaler_all: boolean expected';
          if (message['.gogoproto.stable_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler_all'))
            if (typeof message['.gogoproto.stable_marshaler_all'] !== 'boolean') return '.gogoproto.stable_marshaler_all: boolean expected';
          if (message['.gogoproto.sizer_all'] != null && message.hasOwnProperty('.gogoproto.sizer_all'))
            if (typeof message['.gogoproto.sizer_all'] !== 'boolean') return '.gogoproto.sizer_all: boolean expected';
          if (message['.gogoproto.goproto_enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer_all'))
            if (typeof message['.gogoproto.goproto_enum_stringer_all'] !== 'boolean')
              return '.gogoproto.goproto_enum_stringer_all: boolean expected';
          if (message['.gogoproto.enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.enum_stringer_all'))
            if (typeof message['.gogoproto.enum_stringer_all'] !== 'boolean') return '.gogoproto.enum_stringer_all: boolean expected';
          if (message['.gogoproto.unsafe_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler_all'))
            if (typeof message['.gogoproto.unsafe_marshaler_all'] !== 'boolean') return '.gogoproto.unsafe_marshaler_all: boolean expected';
          if (message['.gogoproto.unsafe_unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler_all'))
            if (typeof message['.gogoproto.unsafe_unmarshaler_all'] !== 'boolean')
              return '.gogoproto.unsafe_unmarshaler_all: boolean expected';
          if (message['.gogoproto.goproto_extensions_map_all'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map_all'))
            if (typeof message['.gogoproto.goproto_extensions_map_all'] !== 'boolean')
              return '.gogoproto.goproto_extensions_map_all: boolean expected';
          if (message['.gogoproto.goproto_unrecognized_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized_all'))
            if (typeof message['.gogoproto.goproto_unrecognized_all'] !== 'boolean')
              return '.gogoproto.goproto_unrecognized_all: boolean expected';
          if (message['.gogoproto.gogoproto_import'] != null && message.hasOwnProperty('.gogoproto.gogoproto_import'))
            if (typeof message['.gogoproto.gogoproto_import'] !== 'boolean') return '.gogoproto.gogoproto_import: boolean expected';
          if (message['.gogoproto.protosizer_all'] != null && message.hasOwnProperty('.gogoproto.protosizer_all'))
            if (typeof message['.gogoproto.protosizer_all'] !== 'boolean') return '.gogoproto.protosizer_all: boolean expected';
          if (message['.gogoproto.compare_all'] != null && message.hasOwnProperty('.gogoproto.compare_all'))
            if (typeof message['.gogoproto.compare_all'] !== 'boolean') return '.gogoproto.compare_all: boolean expected';
          if (message['.gogoproto.typedecl_all'] != null && message.hasOwnProperty('.gogoproto.typedecl_all'))
            if (typeof message['.gogoproto.typedecl_all'] !== 'boolean') return '.gogoproto.typedecl_all: boolean expected';
          if (message['.gogoproto.enumdecl_all'] != null && message.hasOwnProperty('.gogoproto.enumdecl_all'))
            if (typeof message['.gogoproto.enumdecl_all'] !== 'boolean') return '.gogoproto.enumdecl_all: boolean expected';
          if (message['.gogoproto.goproto_registration'] != null && message.hasOwnProperty('.gogoproto.goproto_registration'))
            if (typeof message['.gogoproto.goproto_registration'] !== 'boolean') return '.gogoproto.goproto_registration: boolean expected';
          if (message['.gogoproto.messagename_all'] != null && message.hasOwnProperty('.gogoproto.messagename_all'))
            if (typeof message['.gogoproto.messagename_all'] !== 'boolean') return '.gogoproto.messagename_all: boolean expected';
          if (message['.gogoproto.goproto_sizecache_all'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache_all'))
            if (typeof message['.gogoproto.goproto_sizecache_all'] !== 'boolean')
              return '.gogoproto.goproto_sizecache_all: boolean expected';
          if (message['.gogoproto.goproto_unkeyed_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed_all'))
            if (typeof message['.gogoproto.goproto_unkeyed_all'] !== 'boolean') return '.gogoproto.goproto_unkeyed_all: boolean expected';
          return null;
        };

        /**
         * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FileOptions} FileOptions
         */
        FileOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FileOptions) return object;
          var message = new $root.google.protobuf.FileOptions();
          if (object.java_package != null) message.java_package = String(object.java_package);
          if (object.java_outer_classname != null) message.java_outer_classname = String(object.java_outer_classname);
          if (object.java_multiple_files != null) message.java_multiple_files = Boolean(object.java_multiple_files);
          if (object.java_generate_equals_and_hash != null)
            message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
          if (object.java_string_check_utf8 != null) message.java_string_check_utf8 = Boolean(object.java_string_check_utf8);
          switch (object.optimize_for) {
            case 'SPEED':
            case 1:
              message.optimize_for = 1;
              break;
            case 'CODE_SIZE':
            case 2:
              message.optimize_for = 2;
              break;
            case 'LITE_RUNTIME':
            case 3:
              message.optimize_for = 3;
              break;
          }
          if (object.go_package != null) message.go_package = String(object.go_package);
          if (object.cc_generic_services != null) message.cc_generic_services = Boolean(object.cc_generic_services);
          if (object.java_generic_services != null) message.java_generic_services = Boolean(object.java_generic_services);
          if (object.py_generic_services != null) message.py_generic_services = Boolean(object.py_generic_services);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.cc_enable_arenas != null) message.cc_enable_arenas = Boolean(object.cc_enable_arenas);
          if (object.objc_class_prefix != null) message.objc_class_prefix = String(object.objc_class_prefix);
          if (object.csharp_namespace != null) message.csharp_namespace = String(object.csharp_namespace);
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.FileOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.FileOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          if (object['.gogoproto.goproto_getters_all'] != null)
            message['.gogoproto.goproto_getters_all'] = Boolean(object['.gogoproto.goproto_getters_all']);
          if (object['.gogoproto.goproto_enum_prefix_all'] != null)
            message['.gogoproto.goproto_enum_prefix_all'] = Boolean(object['.gogoproto.goproto_enum_prefix_all']);
          if (object['.gogoproto.goproto_stringer_all'] != null)
            message['.gogoproto.goproto_stringer_all'] = Boolean(object['.gogoproto.goproto_stringer_all']);
          if (object['.gogoproto.verbose_equal_all'] != null)
            message['.gogoproto.verbose_equal_all'] = Boolean(object['.gogoproto.verbose_equal_all']);
          if (object['.gogoproto.face_all'] != null) message['.gogoproto.face_all'] = Boolean(object['.gogoproto.face_all']);
          if (object['.gogoproto.gostring_all'] != null) message['.gogoproto.gostring_all'] = Boolean(object['.gogoproto.gostring_all']);
          if (object['.gogoproto.populate_all'] != null) message['.gogoproto.populate_all'] = Boolean(object['.gogoproto.populate_all']);
          if (object['.gogoproto.stringer_all'] != null) message['.gogoproto.stringer_all'] = Boolean(object['.gogoproto.stringer_all']);
          if (object['.gogoproto.onlyone_all'] != null) message['.gogoproto.onlyone_all'] = Boolean(object['.gogoproto.onlyone_all']);
          if (object['.gogoproto.equal_all'] != null) message['.gogoproto.equal_all'] = Boolean(object['.gogoproto.equal_all']);
          if (object['.gogoproto.description_all'] != null)
            message['.gogoproto.description_all'] = Boolean(object['.gogoproto.description_all']);
          if (object['.gogoproto.testgen_all'] != null) message['.gogoproto.testgen_all'] = Boolean(object['.gogoproto.testgen_all']);
          if (object['.gogoproto.benchgen_all'] != null) message['.gogoproto.benchgen_all'] = Boolean(object['.gogoproto.benchgen_all']);
          if (object['.gogoproto.marshaler_all'] != null) message['.gogoproto.marshaler_all'] = Boolean(object['.gogoproto.marshaler_all']);
          if (object['.gogoproto.unmarshaler_all'] != null)
            message['.gogoproto.unmarshaler_all'] = Boolean(object['.gogoproto.unmarshaler_all']);
          if (object['.gogoproto.stable_marshaler_all'] != null)
            message['.gogoproto.stable_marshaler_all'] = Boolean(object['.gogoproto.stable_marshaler_all']);
          if (object['.gogoproto.sizer_all'] != null) message['.gogoproto.sizer_all'] = Boolean(object['.gogoproto.sizer_all']);
          if (object['.gogoproto.goproto_enum_stringer_all'] != null)
            message['.gogoproto.goproto_enum_stringer_all'] = Boolean(object['.gogoproto.goproto_enum_stringer_all']);
          if (object['.gogoproto.enum_stringer_all'] != null)
            message['.gogoproto.enum_stringer_all'] = Boolean(object['.gogoproto.enum_stringer_all']);
          if (object['.gogoproto.unsafe_marshaler_all'] != null)
            message['.gogoproto.unsafe_marshaler_all'] = Boolean(object['.gogoproto.unsafe_marshaler_all']);
          if (object['.gogoproto.unsafe_unmarshaler_all'] != null)
            message['.gogoproto.unsafe_unmarshaler_all'] = Boolean(object['.gogoproto.unsafe_unmarshaler_all']);
          if (object['.gogoproto.goproto_extensions_map_all'] != null)
            message['.gogoproto.goproto_extensions_map_all'] = Boolean(object['.gogoproto.goproto_extensions_map_all']);
          if (object['.gogoproto.goproto_unrecognized_all'] != null)
            message['.gogoproto.goproto_unrecognized_all'] = Boolean(object['.gogoproto.goproto_unrecognized_all']);
          if (object['.gogoproto.gogoproto_import'] != null)
            message['.gogoproto.gogoproto_import'] = Boolean(object['.gogoproto.gogoproto_import']);
          if (object['.gogoproto.protosizer_all'] != null)
            message['.gogoproto.protosizer_all'] = Boolean(object['.gogoproto.protosizer_all']);
          if (object['.gogoproto.compare_all'] != null) message['.gogoproto.compare_all'] = Boolean(object['.gogoproto.compare_all']);
          if (object['.gogoproto.typedecl_all'] != null) message['.gogoproto.typedecl_all'] = Boolean(object['.gogoproto.typedecl_all']);
          if (object['.gogoproto.enumdecl_all'] != null) message['.gogoproto.enumdecl_all'] = Boolean(object['.gogoproto.enumdecl_all']);
          if (object['.gogoproto.goproto_registration'] != null)
            message['.gogoproto.goproto_registration'] = Boolean(object['.gogoproto.goproto_registration']);
          if (object['.gogoproto.messagename_all'] != null)
            message['.gogoproto.messagename_all'] = Boolean(object['.gogoproto.messagename_all']);
          if (object['.gogoproto.goproto_sizecache_all'] != null)
            message['.gogoproto.goproto_sizecache_all'] = Boolean(object['.gogoproto.goproto_sizecache_all']);
          if (object['.gogoproto.goproto_unkeyed_all'] != null)
            message['.gogoproto.goproto_unkeyed_all'] = Boolean(object['.gogoproto.goproto_unkeyed_all']);
          return message;
        };

        /**
         * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {google.protobuf.FileOptions} message FileOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (options.defaults) {
            object.java_package = '';
            object.java_outer_classname = '';
            object.optimize_for = options.enums === String ? 'SPEED' : 1;
            object.java_multiple_files = false;
            object.go_package = '';
            object.cc_generic_services = false;
            object.java_generic_services = false;
            object.py_generic_services = false;
            object.java_generate_equals_and_hash = false;
            object.deprecated = false;
            object.java_string_check_utf8 = false;
            object.cc_enable_arenas = false;
            object.objc_class_prefix = '';
            object.csharp_namespace = '';
            object['.gogoproto.goproto_getters_all'] = false;
            object['.gogoproto.goproto_enum_prefix_all'] = false;
            object['.gogoproto.goproto_stringer_all'] = false;
            object['.gogoproto.verbose_equal_all'] = false;
            object['.gogoproto.face_all'] = false;
            object['.gogoproto.gostring_all'] = false;
            object['.gogoproto.populate_all'] = false;
            object['.gogoproto.stringer_all'] = false;
            object['.gogoproto.onlyone_all'] = false;
            object['.gogoproto.equal_all'] = false;
            object['.gogoproto.description_all'] = false;
            object['.gogoproto.testgen_all'] = false;
            object['.gogoproto.benchgen_all'] = false;
            object['.gogoproto.marshaler_all'] = false;
            object['.gogoproto.unmarshaler_all'] = false;
            object['.gogoproto.stable_marshaler_all'] = false;
            object['.gogoproto.sizer_all'] = false;
            object['.gogoproto.goproto_enum_stringer_all'] = false;
            object['.gogoproto.enum_stringer_all'] = false;
            object['.gogoproto.unsafe_marshaler_all'] = false;
            object['.gogoproto.unsafe_unmarshaler_all'] = false;
            object['.gogoproto.goproto_extensions_map_all'] = false;
            object['.gogoproto.goproto_unrecognized_all'] = false;
            object['.gogoproto.gogoproto_import'] = false;
            object['.gogoproto.protosizer_all'] = false;
            object['.gogoproto.compare_all'] = false;
            object['.gogoproto.typedecl_all'] = false;
            object['.gogoproto.enumdecl_all'] = false;
            object['.gogoproto.goproto_registration'] = false;
            object['.gogoproto.messagename_all'] = false;
            object['.gogoproto.goproto_sizecache_all'] = false;
            object['.gogoproto.goproto_unkeyed_all'] = false;
          }
          if (message.java_package != null && message.hasOwnProperty('java_package')) object.java_package = message.java_package;
          if (message.java_outer_classname != null && message.hasOwnProperty('java_outer_classname'))
            object.java_outer_classname = message.java_outer_classname;
          if (message.optimize_for != null && message.hasOwnProperty('optimize_for'))
            object.optimize_for =
              options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
          if (message.java_multiple_files != null && message.hasOwnProperty('java_multiple_files'))
            object.java_multiple_files = message.java_multiple_files;
          if (message.go_package != null && message.hasOwnProperty('go_package')) object.go_package = message.go_package;
          if (message.cc_generic_services != null && message.hasOwnProperty('cc_generic_services'))
            object.cc_generic_services = message.cc_generic_services;
          if (message.java_generic_services != null && message.hasOwnProperty('java_generic_services'))
            object.java_generic_services = message.java_generic_services;
          if (message.py_generic_services != null && message.hasOwnProperty('py_generic_services'))
            object.py_generic_services = message.py_generic_services;
          if (message.java_generate_equals_and_hash != null && message.hasOwnProperty('java_generate_equals_and_hash'))
            object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
          if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
          if (message.java_string_check_utf8 != null && message.hasOwnProperty('java_string_check_utf8'))
            object.java_string_check_utf8 = message.java_string_check_utf8;
          if (message.cc_enable_arenas != null && message.hasOwnProperty('cc_enable_arenas'))
            object.cc_enable_arenas = message.cc_enable_arenas;
          if (message.objc_class_prefix != null && message.hasOwnProperty('objc_class_prefix'))
            object.objc_class_prefix = message.objc_class_prefix;
          if (message.csharp_namespace != null && message.hasOwnProperty('csharp_namespace'))
            object.csharp_namespace = message.csharp_namespace;
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          if (message['.gogoproto.goproto_getters_all'] != null && message.hasOwnProperty('.gogoproto.goproto_getters_all'))
            object['.gogoproto.goproto_getters_all'] = message['.gogoproto.goproto_getters_all'];
          if (message['.gogoproto.goproto_enum_prefix_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix_all'))
            object['.gogoproto.goproto_enum_prefix_all'] = message['.gogoproto.goproto_enum_prefix_all'];
          if (message['.gogoproto.goproto_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer_all'))
            object['.gogoproto.goproto_stringer_all'] = message['.gogoproto.goproto_stringer_all'];
          if (message['.gogoproto.verbose_equal_all'] != null && message.hasOwnProperty('.gogoproto.verbose_equal_all'))
            object['.gogoproto.verbose_equal_all'] = message['.gogoproto.verbose_equal_all'];
          if (message['.gogoproto.face_all'] != null && message.hasOwnProperty('.gogoproto.face_all'))
            object['.gogoproto.face_all'] = message['.gogoproto.face_all'];
          if (message['.gogoproto.gostring_all'] != null && message.hasOwnProperty('.gogoproto.gostring_all'))
            object['.gogoproto.gostring_all'] = message['.gogoproto.gostring_all'];
          if (message['.gogoproto.populate_all'] != null && message.hasOwnProperty('.gogoproto.populate_all'))
            object['.gogoproto.populate_all'] = message['.gogoproto.populate_all'];
          if (message['.gogoproto.stringer_all'] != null && message.hasOwnProperty('.gogoproto.stringer_all'))
            object['.gogoproto.stringer_all'] = message['.gogoproto.stringer_all'];
          if (message['.gogoproto.onlyone_all'] != null && message.hasOwnProperty('.gogoproto.onlyone_all'))
            object['.gogoproto.onlyone_all'] = message['.gogoproto.onlyone_all'];
          if (message['.gogoproto.equal_all'] != null && message.hasOwnProperty('.gogoproto.equal_all'))
            object['.gogoproto.equal_all'] = message['.gogoproto.equal_all'];
          if (message['.gogoproto.description_all'] != null && message.hasOwnProperty('.gogoproto.description_all'))
            object['.gogoproto.description_all'] = message['.gogoproto.description_all'];
          if (message['.gogoproto.testgen_all'] != null && message.hasOwnProperty('.gogoproto.testgen_all'))
            object['.gogoproto.testgen_all'] = message['.gogoproto.testgen_all'];
          if (message['.gogoproto.benchgen_all'] != null && message.hasOwnProperty('.gogoproto.benchgen_all'))
            object['.gogoproto.benchgen_all'] = message['.gogoproto.benchgen_all'];
          if (message['.gogoproto.marshaler_all'] != null && message.hasOwnProperty('.gogoproto.marshaler_all'))
            object['.gogoproto.marshaler_all'] = message['.gogoproto.marshaler_all'];
          if (message['.gogoproto.unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unmarshaler_all'))
            object['.gogoproto.unmarshaler_all'] = message['.gogoproto.unmarshaler_all'];
          if (message['.gogoproto.stable_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler_all'))
            object['.gogoproto.stable_marshaler_all'] = message['.gogoproto.stable_marshaler_all'];
          if (message['.gogoproto.sizer_all'] != null && message.hasOwnProperty('.gogoproto.sizer_all'))
            object['.gogoproto.sizer_all'] = message['.gogoproto.sizer_all'];
          if (message['.gogoproto.goproto_enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer_all'))
            object['.gogoproto.goproto_enum_stringer_all'] = message['.gogoproto.goproto_enum_stringer_all'];
          if (message['.gogoproto.enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.enum_stringer_all'))
            object['.gogoproto.enum_stringer_all'] = message['.gogoproto.enum_stringer_all'];
          if (message['.gogoproto.unsafe_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler_all'))
            object['.gogoproto.unsafe_marshaler_all'] = message['.gogoproto.unsafe_marshaler_all'];
          if (message['.gogoproto.unsafe_unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler_all'))
            object['.gogoproto.unsafe_unmarshaler_all'] = message['.gogoproto.unsafe_unmarshaler_all'];
          if (message['.gogoproto.goproto_extensions_map_all'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map_all'))
            object['.gogoproto.goproto_extensions_map_all'] = message['.gogoproto.goproto_extensions_map_all'];
          if (message['.gogoproto.goproto_unrecognized_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized_all'))
            object['.gogoproto.goproto_unrecognized_all'] = message['.gogoproto.goproto_unrecognized_all'];
          if (message['.gogoproto.gogoproto_import'] != null && message.hasOwnProperty('.gogoproto.gogoproto_import'))
            object['.gogoproto.gogoproto_import'] = message['.gogoproto.gogoproto_import'];
          if (message['.gogoproto.protosizer_all'] != null && message.hasOwnProperty('.gogoproto.protosizer_all'))
            object['.gogoproto.protosizer_all'] = message['.gogoproto.protosizer_all'];
          if (message['.gogoproto.compare_all'] != null && message.hasOwnProperty('.gogoproto.compare_all'))
            object['.gogoproto.compare_all'] = message['.gogoproto.compare_all'];
          if (message['.gogoproto.typedecl_all'] != null && message.hasOwnProperty('.gogoproto.typedecl_all'))
            object['.gogoproto.typedecl_all'] = message['.gogoproto.typedecl_all'];
          if (message['.gogoproto.enumdecl_all'] != null && message.hasOwnProperty('.gogoproto.enumdecl_all'))
            object['.gogoproto.enumdecl_all'] = message['.gogoproto.enumdecl_all'];
          if (message['.gogoproto.goproto_registration'] != null && message.hasOwnProperty('.gogoproto.goproto_registration'))
            object['.gogoproto.goproto_registration'] = message['.gogoproto.goproto_registration'];
          if (message['.gogoproto.messagename_all'] != null && message.hasOwnProperty('.gogoproto.messagename_all'))
            object['.gogoproto.messagename_all'] = message['.gogoproto.messagename_all'];
          if (message['.gogoproto.goproto_sizecache_all'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache_all'))
            object['.gogoproto.goproto_sizecache_all'] = message['.gogoproto.goproto_sizecache_all'];
          if (message['.gogoproto.goproto_unkeyed_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed_all'))
            object['.gogoproto.goproto_unkeyed_all'] = message['.gogoproto.goproto_unkeyed_all'];
          return object;
        };

        /**
         * Converts this FileOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.FileOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * OptimizeMode enum.
         * @name google.protobuf.FileOptions.OptimizeMode
         * @enum {number}
         * @property {number} SPEED=1 SPEED value
         * @property {number} CODE_SIZE=2 CODE_SIZE value
         * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
         */
        FileOptions.OptimizeMode = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[1] = 'SPEED')] = 1;
          values[(valuesById[2] = 'CODE_SIZE')] = 2;
          values[(valuesById[3] = 'LITE_RUNTIME')] = 3;
          return values;
        })();

        return FileOptions;
      })();

      protobuf.MessageOptions = (function () {
        /**
         * Properties of a MessageOptions.
         * @memberof google.protobuf
         * @interface IMessageOptions
         * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
         * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
         * @property {boolean|null} [deprecated] MessageOptions deprecated
         * @property {boolean|null} [map_entry] MessageOptions map_entry
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
         * @property {string|null} [".cosmos_proto.interface_type"] MessageOptions .cosmos_proto.interface_type
         * @property {string|null} [".cosmos_proto.implements_interface"] MessageOptions .cosmos_proto.implements_interface
         * @property {boolean|null} [".gogoproto.goproto_getters"] MessageOptions .gogoproto.goproto_getters
         * @property {boolean|null} [".gogoproto.goproto_stringer"] MessageOptions .gogoproto.goproto_stringer
         * @property {boolean|null} [".gogoproto.verbose_equal"] MessageOptions .gogoproto.verbose_equal
         * @property {boolean|null} [".gogoproto.face"] MessageOptions .gogoproto.face
         * @property {boolean|null} [".gogoproto.gostring"] MessageOptions .gogoproto.gostring
         * @property {boolean|null} [".gogoproto.populate"] MessageOptions .gogoproto.populate
         * @property {boolean|null} [".gogoproto.stringer"] MessageOptions .gogoproto.stringer
         * @property {boolean|null} [".gogoproto.onlyone"] MessageOptions .gogoproto.onlyone
         * @property {boolean|null} [".gogoproto.equal"] MessageOptions .gogoproto.equal
         * @property {boolean|null} [".gogoproto.description"] MessageOptions .gogoproto.description
         * @property {boolean|null} [".gogoproto.testgen"] MessageOptions .gogoproto.testgen
         * @property {boolean|null} [".gogoproto.benchgen"] MessageOptions .gogoproto.benchgen
         * @property {boolean|null} [".gogoproto.marshaler"] MessageOptions .gogoproto.marshaler
         * @property {boolean|null} [".gogoproto.unmarshaler"] MessageOptions .gogoproto.unmarshaler
         * @property {boolean|null} [".gogoproto.stable_marshaler"] MessageOptions .gogoproto.stable_marshaler
         * @property {boolean|null} [".gogoproto.sizer"] MessageOptions .gogoproto.sizer
         * @property {boolean|null} [".gogoproto.unsafe_marshaler"] MessageOptions .gogoproto.unsafe_marshaler
         * @property {boolean|null} [".gogoproto.unsafe_unmarshaler"] MessageOptions .gogoproto.unsafe_unmarshaler
         * @property {boolean|null} [".gogoproto.goproto_extensions_map"] MessageOptions .gogoproto.goproto_extensions_map
         * @property {boolean|null} [".gogoproto.goproto_unrecognized"] MessageOptions .gogoproto.goproto_unrecognized
         * @property {boolean|null} [".gogoproto.protosizer"] MessageOptions .gogoproto.protosizer
         * @property {boolean|null} [".gogoproto.compare"] MessageOptions .gogoproto.compare
         * @property {boolean|null} [".gogoproto.typedecl"] MessageOptions .gogoproto.typedecl
         * @property {boolean|null} [".gogoproto.messagename"] MessageOptions .gogoproto.messagename
         * @property {boolean|null} [".gogoproto.goproto_sizecache"] MessageOptions .gogoproto.goproto_sizecache
         * @property {boolean|null} [".gogoproto.goproto_unkeyed"] MessageOptions .gogoproto.goproto_unkeyed
         */

        /**
         * Constructs a new MessageOptions.
         * @memberof google.protobuf
         * @classdesc Represents a MessageOptions.
         * @implements IMessageOptions
         * @constructor
         * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
         */
        function MessageOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageOptions message_set_wire_format.
         * @member {boolean} message_set_wire_format
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.message_set_wire_format = false;

        /**
         * MessageOptions no_standard_descriptor_accessor.
         * @member {boolean} no_standard_descriptor_accessor
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.no_standard_descriptor_accessor = false;

        /**
         * MessageOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.deprecated = false;

        /**
         * MessageOptions map_entry.
         * @member {boolean} map_entry
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.map_entry = false;

        /**
         * MessageOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * MessageOptions .cosmos_proto.interface_type.
         * @member {string} .cosmos_proto.interface_type
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.cosmos_proto.interface_type'] = '';

        /**
         * MessageOptions .cosmos_proto.implements_interface.
         * @member {string} .cosmos_proto.implements_interface
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.cosmos_proto.implements_interface'] = '';

        /**
         * MessageOptions .gogoproto.goproto_getters.
         * @member {boolean} .gogoproto.goproto_getters
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.goproto_getters'] = false;

        /**
         * MessageOptions .gogoproto.goproto_stringer.
         * @member {boolean} .gogoproto.goproto_stringer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.goproto_stringer'] = false;

        /**
         * MessageOptions .gogoproto.verbose_equal.
         * @member {boolean} .gogoproto.verbose_equal
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.verbose_equal'] = false;

        /**
         * MessageOptions .gogoproto.face.
         * @member {boolean} .gogoproto.face
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.face'] = false;

        /**
         * MessageOptions .gogoproto.gostring.
         * @member {boolean} .gogoproto.gostring
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.gostring'] = false;

        /**
         * MessageOptions .gogoproto.populate.
         * @member {boolean} .gogoproto.populate
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.populate'] = false;

        /**
         * MessageOptions .gogoproto.stringer.
         * @member {boolean} .gogoproto.stringer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.stringer'] = false;

        /**
         * MessageOptions .gogoproto.onlyone.
         * @member {boolean} .gogoproto.onlyone
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.onlyone'] = false;

        /**
         * MessageOptions .gogoproto.equal.
         * @member {boolean} .gogoproto.equal
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.equal'] = false;

        /**
         * MessageOptions .gogoproto.description.
         * @member {boolean} .gogoproto.description
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.description'] = false;

        /**
         * MessageOptions .gogoproto.testgen.
         * @member {boolean} .gogoproto.testgen
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.testgen'] = false;

        /**
         * MessageOptions .gogoproto.benchgen.
         * @member {boolean} .gogoproto.benchgen
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.benchgen'] = false;

        /**
         * MessageOptions .gogoproto.marshaler.
         * @member {boolean} .gogoproto.marshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.marshaler'] = false;

        /**
         * MessageOptions .gogoproto.unmarshaler.
         * @member {boolean} .gogoproto.unmarshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.unmarshaler'] = false;

        /**
         * MessageOptions .gogoproto.stable_marshaler.
         * @member {boolean} .gogoproto.stable_marshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.stable_marshaler'] = false;

        /**
         * MessageOptions .gogoproto.sizer.
         * @member {boolean} .gogoproto.sizer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.sizer'] = false;

        /**
         * MessageOptions .gogoproto.unsafe_marshaler.
         * @member {boolean} .gogoproto.unsafe_marshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.unsafe_marshaler'] = false;

        /**
         * MessageOptions .gogoproto.unsafe_unmarshaler.
         * @member {boolean} .gogoproto.unsafe_unmarshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.unsafe_unmarshaler'] = false;

        /**
         * MessageOptions .gogoproto.goproto_extensions_map.
         * @member {boolean} .gogoproto.goproto_extensions_map
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.goproto_extensions_map'] = false;

        /**
         * MessageOptions .gogoproto.goproto_unrecognized.
         * @member {boolean} .gogoproto.goproto_unrecognized
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.goproto_unrecognized'] = false;

        /**
         * MessageOptions .gogoproto.protosizer.
         * @member {boolean} .gogoproto.protosizer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.protosizer'] = false;

        /**
         * MessageOptions .gogoproto.compare.
         * @member {boolean} .gogoproto.compare
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.compare'] = false;

        /**
         * MessageOptions .gogoproto.typedecl.
         * @member {boolean} .gogoproto.typedecl
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.typedecl'] = false;

        /**
         * MessageOptions .gogoproto.messagename.
         * @member {boolean} .gogoproto.messagename
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.messagename'] = false;

        /**
         * MessageOptions .gogoproto.goproto_sizecache.
         * @member {boolean} .gogoproto.goproto_sizecache
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.goproto_sizecache'] = false;

        /**
         * MessageOptions .gogoproto.goproto_unkeyed.
         * @member {boolean} .gogoproto.goproto_unkeyed
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype['.gogoproto.goproto_unkeyed'] = false;

        /**
         * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, 'message_set_wire_format'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.message_set_wire_format);
          if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, 'no_standard_descriptor_accessor'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.no_standard_descriptor_accessor);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
          if (message.map_entry != null && Object.hasOwnProperty.call(message, 'map_entry'))
            writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.map_entry);
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (message['.gogoproto.goproto_getters'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_getters'))
            writer.uint32(/* id 64001, wireType 0 =*/ 512008).bool(message['.gogoproto.goproto_getters']);
          if (message['.gogoproto.goproto_stringer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_stringer'))
            writer.uint32(/* id 64003, wireType 0 =*/ 512024).bool(message['.gogoproto.goproto_stringer']);
          if (message['.gogoproto.verbose_equal'] != null && Object.hasOwnProperty.call(message, '.gogoproto.verbose_equal'))
            writer.uint32(/* id 64004, wireType 0 =*/ 512032).bool(message['.gogoproto.verbose_equal']);
          if (message['.gogoproto.face'] != null && Object.hasOwnProperty.call(message, '.gogoproto.face'))
            writer.uint32(/* id 64005, wireType 0 =*/ 512040).bool(message['.gogoproto.face']);
          if (message['.gogoproto.gostring'] != null && Object.hasOwnProperty.call(message, '.gogoproto.gostring'))
            writer.uint32(/* id 64006, wireType 0 =*/ 512048).bool(message['.gogoproto.gostring']);
          if (message['.gogoproto.populate'] != null && Object.hasOwnProperty.call(message, '.gogoproto.populate'))
            writer.uint32(/* id 64007, wireType 0 =*/ 512056).bool(message['.gogoproto.populate']);
          if (message['.gogoproto.onlyone'] != null && Object.hasOwnProperty.call(message, '.gogoproto.onlyone'))
            writer.uint32(/* id 64009, wireType 0 =*/ 512072).bool(message['.gogoproto.onlyone']);
          if (message['.gogoproto.equal'] != null && Object.hasOwnProperty.call(message, '.gogoproto.equal'))
            writer.uint32(/* id 64013, wireType 0 =*/ 512104).bool(message['.gogoproto.equal']);
          if (message['.gogoproto.description'] != null && Object.hasOwnProperty.call(message, '.gogoproto.description'))
            writer.uint32(/* id 64014, wireType 0 =*/ 512112).bool(message['.gogoproto.description']);
          if (message['.gogoproto.testgen'] != null && Object.hasOwnProperty.call(message, '.gogoproto.testgen'))
            writer.uint32(/* id 64015, wireType 0 =*/ 512120).bool(message['.gogoproto.testgen']);
          if (message['.gogoproto.benchgen'] != null && Object.hasOwnProperty.call(message, '.gogoproto.benchgen'))
            writer.uint32(/* id 64016, wireType 0 =*/ 512128).bool(message['.gogoproto.benchgen']);
          if (message['.gogoproto.marshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.marshaler'))
            writer.uint32(/* id 64017, wireType 0 =*/ 512136).bool(message['.gogoproto.marshaler']);
          if (message['.gogoproto.unmarshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unmarshaler'))
            writer.uint32(/* id 64018, wireType 0 =*/ 512144).bool(message['.gogoproto.unmarshaler']);
          if (message['.gogoproto.stable_marshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stable_marshaler'))
            writer.uint32(/* id 64019, wireType 0 =*/ 512152).bool(message['.gogoproto.stable_marshaler']);
          if (message['.gogoproto.sizer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.sizer'))
            writer.uint32(/* id 64020, wireType 0 =*/ 512160).bool(message['.gogoproto.sizer']);
          if (message['.gogoproto.unsafe_marshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unsafe_marshaler'))
            writer.uint32(/* id 64023, wireType 0 =*/ 512184).bool(message['.gogoproto.unsafe_marshaler']);
          if (message['.gogoproto.unsafe_unmarshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unsafe_unmarshaler'))
            writer.uint32(/* id 64024, wireType 0 =*/ 512192).bool(message['.gogoproto.unsafe_unmarshaler']);
          if (
            message['.gogoproto.goproto_extensions_map'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.goproto_extensions_map')
          )
            writer.uint32(/* id 64025, wireType 0 =*/ 512200).bool(message['.gogoproto.goproto_extensions_map']);
          if (message['.gogoproto.goproto_unrecognized'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_unrecognized'))
            writer.uint32(/* id 64026, wireType 0 =*/ 512208).bool(message['.gogoproto.goproto_unrecognized']);
          if (message['.gogoproto.protosizer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.protosizer'))
            writer.uint32(/* id 64028, wireType 0 =*/ 512224).bool(message['.gogoproto.protosizer']);
          if (message['.gogoproto.compare'] != null && Object.hasOwnProperty.call(message, '.gogoproto.compare'))
            writer.uint32(/* id 64029, wireType 0 =*/ 512232).bool(message['.gogoproto.compare']);
          if (message['.gogoproto.typedecl'] != null && Object.hasOwnProperty.call(message, '.gogoproto.typedecl'))
            writer.uint32(/* id 64030, wireType 0 =*/ 512240).bool(message['.gogoproto.typedecl']);
          if (message['.gogoproto.messagename'] != null && Object.hasOwnProperty.call(message, '.gogoproto.messagename'))
            writer.uint32(/* id 64033, wireType 0 =*/ 512264).bool(message['.gogoproto.messagename']);
          if (message['.gogoproto.goproto_sizecache'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_sizecache'))
            writer.uint32(/* id 64034, wireType 0 =*/ 512272).bool(message['.gogoproto.goproto_sizecache']);
          if (message['.gogoproto.goproto_unkeyed'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_unkeyed'))
            writer.uint32(/* id 64035, wireType 0 =*/ 512280).bool(message['.gogoproto.goproto_unkeyed']);
          if (message['.gogoproto.stringer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stringer'))
            writer.uint32(/* id 67008, wireType 0 =*/ 536064).bool(message['.gogoproto.stringer']);
          if (message['.cosmos_proto.interface_type'] != null && Object.hasOwnProperty.call(message, '.cosmos_proto.interface_type'))
            writer.uint32(/* id 93001, wireType 2 =*/ 744010).string(message['.cosmos_proto.interface_type']);
          if (
            message['.cosmos_proto.implements_interface'] != null &&
            Object.hasOwnProperty.call(message, '.cosmos_proto.implements_interface')
          )
            writer.uint32(/* id 93002, wireType 2 =*/ 744018).string(message['.cosmos_proto.implements_interface']);
          return writer;
        };

        /**
         * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.MessageOptions} MessageOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.MessageOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message_set_wire_format = reader.bool();
                break;
              case 2:
                message.no_standard_descriptor_accessor = reader.bool();
                break;
              case 3:
                message.deprecated = reader.bool();
                break;
              case 7:
                message.map_entry = reader.bool();
                break;
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              case 93001:
                message['.cosmos_proto.interface_type'] = reader.string();
                break;
              case 93002:
                message['.cosmos_proto.implements_interface'] = reader.string();
                break;
              case 64001:
                message['.gogoproto.goproto_getters'] = reader.bool();
                break;
              case 64003:
                message['.gogoproto.goproto_stringer'] = reader.bool();
                break;
              case 64004:
                message['.gogoproto.verbose_equal'] = reader.bool();
                break;
              case 64005:
                message['.gogoproto.face'] = reader.bool();
                break;
              case 64006:
                message['.gogoproto.gostring'] = reader.bool();
                break;
              case 64007:
                message['.gogoproto.populate'] = reader.bool();
                break;
              case 67008:
                message['.gogoproto.stringer'] = reader.bool();
                break;
              case 64009:
                message['.gogoproto.onlyone'] = reader.bool();
                break;
              case 64013:
                message['.gogoproto.equal'] = reader.bool();
                break;
              case 64014:
                message['.gogoproto.description'] = reader.bool();
                break;
              case 64015:
                message['.gogoproto.testgen'] = reader.bool();
                break;
              case 64016:
                message['.gogoproto.benchgen'] = reader.bool();
                break;
              case 64017:
                message['.gogoproto.marshaler'] = reader.bool();
                break;
              case 64018:
                message['.gogoproto.unmarshaler'] = reader.bool();
                break;
              case 64019:
                message['.gogoproto.stable_marshaler'] = reader.bool();
                break;
              case 64020:
                message['.gogoproto.sizer'] = reader.bool();
                break;
              case 64023:
                message['.gogoproto.unsafe_marshaler'] = reader.bool();
                break;
              case 64024:
                message['.gogoproto.unsafe_unmarshaler'] = reader.bool();
                break;
              case 64025:
                message['.gogoproto.goproto_extensions_map'] = reader.bool();
                break;
              case 64026:
                message['.gogoproto.goproto_unrecognized'] = reader.bool();
                break;
              case 64028:
                message['.gogoproto.protosizer'] = reader.bool();
                break;
              case 64029:
                message['.gogoproto.compare'] = reader.bool();
                break;
              case 64030:
                message['.gogoproto.typedecl'] = reader.bool();
                break;
              case 64033:
                message['.gogoproto.messagename'] = reader.bool();
                break;
              case 64034:
                message['.gogoproto.goproto_sizecache'] = reader.bool();
                break;
              case 64035:
                message['.gogoproto.goproto_unkeyed'] = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.MessageOptions} MessageOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageOptions message.
         * @function verify
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.message_set_wire_format != null && message.hasOwnProperty('message_set_wire_format'))
            if (typeof message.message_set_wire_format !== 'boolean') return 'message_set_wire_format: boolean expected';
          if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty('no_standard_descriptor_accessor'))
            if (typeof message.no_standard_descriptor_accessor !== 'boolean') return 'no_standard_descriptor_accessor: boolean expected';
          if (message.deprecated != null && message.hasOwnProperty('deprecated'))
            if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
          if (message.map_entry != null && message.hasOwnProperty('map_entry'))
            if (typeof message.map_entry !== 'boolean') return 'map_entry: boolean expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          if (message['.cosmos_proto.interface_type'] != null && message.hasOwnProperty('.cosmos_proto.interface_type'))
            if (!$util.isString(message['.cosmos_proto.interface_type'])) return '.cosmos_proto.interface_type: string expected';
          if (message['.cosmos_proto.implements_interface'] != null && message.hasOwnProperty('.cosmos_proto.implements_interface'))
            if (!$util.isString(message['.cosmos_proto.implements_interface']))
              return '.cosmos_proto.implements_interface: string expected';
          if (message['.gogoproto.goproto_getters'] != null && message.hasOwnProperty('.gogoproto.goproto_getters'))
            if (typeof message['.gogoproto.goproto_getters'] !== 'boolean') return '.gogoproto.goproto_getters: boolean expected';
          if (message['.gogoproto.goproto_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer'))
            if (typeof message['.gogoproto.goproto_stringer'] !== 'boolean') return '.gogoproto.goproto_stringer: boolean expected';
          if (message['.gogoproto.verbose_equal'] != null && message.hasOwnProperty('.gogoproto.verbose_equal'))
            if (typeof message['.gogoproto.verbose_equal'] !== 'boolean') return '.gogoproto.verbose_equal: boolean expected';
          if (message['.gogoproto.face'] != null && message.hasOwnProperty('.gogoproto.face'))
            if (typeof message['.gogoproto.face'] !== 'boolean') return '.gogoproto.face: boolean expected';
          if (message['.gogoproto.gostring'] != null && message.hasOwnProperty('.gogoproto.gostring'))
            if (typeof message['.gogoproto.gostring'] !== 'boolean') return '.gogoproto.gostring: boolean expected';
          if (message['.gogoproto.populate'] != null && message.hasOwnProperty('.gogoproto.populate'))
            if (typeof message['.gogoproto.populate'] !== 'boolean') return '.gogoproto.populate: boolean expected';
          if (message['.gogoproto.stringer'] != null && message.hasOwnProperty('.gogoproto.stringer'))
            if (typeof message['.gogoproto.stringer'] !== 'boolean') return '.gogoproto.stringer: boolean expected';
          if (message['.gogoproto.onlyone'] != null && message.hasOwnProperty('.gogoproto.onlyone'))
            if (typeof message['.gogoproto.onlyone'] !== 'boolean') return '.gogoproto.onlyone: boolean expected';
          if (message['.gogoproto.equal'] != null && message.hasOwnProperty('.gogoproto.equal'))
            if (typeof message['.gogoproto.equal'] !== 'boolean') return '.gogoproto.equal: boolean expected';
          if (message['.gogoproto.description'] != null && message.hasOwnProperty('.gogoproto.description'))
            if (typeof message['.gogoproto.description'] !== 'boolean') return '.gogoproto.description: boolean expected';
          if (message['.gogoproto.testgen'] != null && message.hasOwnProperty('.gogoproto.testgen'))
            if (typeof message['.gogoproto.testgen'] !== 'boolean') return '.gogoproto.testgen: boolean expected';
          if (message['.gogoproto.benchgen'] != null && message.hasOwnProperty('.gogoproto.benchgen'))
            if (typeof message['.gogoproto.benchgen'] !== 'boolean') return '.gogoproto.benchgen: boolean expected';
          if (message['.gogoproto.marshaler'] != null && message.hasOwnProperty('.gogoproto.marshaler'))
            if (typeof message['.gogoproto.marshaler'] !== 'boolean') return '.gogoproto.marshaler: boolean expected';
          if (message['.gogoproto.unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unmarshaler'))
            if (typeof message['.gogoproto.unmarshaler'] !== 'boolean') return '.gogoproto.unmarshaler: boolean expected';
          if (message['.gogoproto.stable_marshaler'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler'))
            if (typeof message['.gogoproto.stable_marshaler'] !== 'boolean') return '.gogoproto.stable_marshaler: boolean expected';
          if (message['.gogoproto.sizer'] != null && message.hasOwnProperty('.gogoproto.sizer'))
            if (typeof message['.gogoproto.sizer'] !== 'boolean') return '.gogoproto.sizer: boolean expected';
          if (message['.gogoproto.unsafe_marshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler'))
            if (typeof message['.gogoproto.unsafe_marshaler'] !== 'boolean') return '.gogoproto.unsafe_marshaler: boolean expected';
          if (message['.gogoproto.unsafe_unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler'))
            if (typeof message['.gogoproto.unsafe_unmarshaler'] !== 'boolean') return '.gogoproto.unsafe_unmarshaler: boolean expected';
          if (message['.gogoproto.goproto_extensions_map'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map'))
            if (typeof message['.gogoproto.goproto_extensions_map'] !== 'boolean')
              return '.gogoproto.goproto_extensions_map: boolean expected';
          if (message['.gogoproto.goproto_unrecognized'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized'))
            if (typeof message['.gogoproto.goproto_unrecognized'] !== 'boolean') return '.gogoproto.goproto_unrecognized: boolean expected';
          if (message['.gogoproto.protosizer'] != null && message.hasOwnProperty('.gogoproto.protosizer'))
            if (typeof message['.gogoproto.protosizer'] !== 'boolean') return '.gogoproto.protosizer: boolean expected';
          if (message['.gogoproto.compare'] != null && message.hasOwnProperty('.gogoproto.compare'))
            if (typeof message['.gogoproto.compare'] !== 'boolean') return '.gogoproto.compare: boolean expected';
          if (message['.gogoproto.typedecl'] != null && message.hasOwnProperty('.gogoproto.typedecl'))
            if (typeof message['.gogoproto.typedecl'] !== 'boolean') return '.gogoproto.typedecl: boolean expected';
          if (message['.gogoproto.messagename'] != null && message.hasOwnProperty('.gogoproto.messagename'))
            if (typeof message['.gogoproto.messagename'] !== 'boolean') return '.gogoproto.messagename: boolean expected';
          if (message['.gogoproto.goproto_sizecache'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache'))
            if (typeof message['.gogoproto.goproto_sizecache'] !== 'boolean') return '.gogoproto.goproto_sizecache: boolean expected';
          if (message['.gogoproto.goproto_unkeyed'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed'))
            if (typeof message['.gogoproto.goproto_unkeyed'] !== 'boolean') return '.gogoproto.goproto_unkeyed: boolean expected';
          return null;
        };

        /**
         * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.MessageOptions} MessageOptions
         */
        MessageOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.MessageOptions) return object;
          var message = new $root.google.protobuf.MessageOptions();
          if (object.message_set_wire_format != null) message.message_set_wire_format = Boolean(object.message_set_wire_format);
          if (object.no_standard_descriptor_accessor != null)
            message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.map_entry != null) message.map_entry = Boolean(object.map_entry);
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.MessageOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.MessageOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          if (object['.cosmos_proto.interface_type'] != null)
            message['.cosmos_proto.interface_type'] = String(object['.cosmos_proto.interface_type']);
          if (object['.cosmos_proto.implements_interface'] != null)
            message['.cosmos_proto.implements_interface'] = String(object['.cosmos_proto.implements_interface']);
          if (object['.gogoproto.goproto_getters'] != null)
            message['.gogoproto.goproto_getters'] = Boolean(object['.gogoproto.goproto_getters']);
          if (object['.gogoproto.goproto_stringer'] != null)
            message['.gogoproto.goproto_stringer'] = Boolean(object['.gogoproto.goproto_stringer']);
          if (object['.gogoproto.verbose_equal'] != null) message['.gogoproto.verbose_equal'] = Boolean(object['.gogoproto.verbose_equal']);
          if (object['.gogoproto.face'] != null) message['.gogoproto.face'] = Boolean(object['.gogoproto.face']);
          if (object['.gogoproto.gostring'] != null) message['.gogoproto.gostring'] = Boolean(object['.gogoproto.gostring']);
          if (object['.gogoproto.populate'] != null) message['.gogoproto.populate'] = Boolean(object['.gogoproto.populate']);
          if (object['.gogoproto.stringer'] != null) message['.gogoproto.stringer'] = Boolean(object['.gogoproto.stringer']);
          if (object['.gogoproto.onlyone'] != null) message['.gogoproto.onlyone'] = Boolean(object['.gogoproto.onlyone']);
          if (object['.gogoproto.equal'] != null) message['.gogoproto.equal'] = Boolean(object['.gogoproto.equal']);
          if (object['.gogoproto.description'] != null) message['.gogoproto.description'] = Boolean(object['.gogoproto.description']);
          if (object['.gogoproto.testgen'] != null) message['.gogoproto.testgen'] = Boolean(object['.gogoproto.testgen']);
          if (object['.gogoproto.benchgen'] != null) message['.gogoproto.benchgen'] = Boolean(object['.gogoproto.benchgen']);
          if (object['.gogoproto.marshaler'] != null) message['.gogoproto.marshaler'] = Boolean(object['.gogoproto.marshaler']);
          if (object['.gogoproto.unmarshaler'] != null) message['.gogoproto.unmarshaler'] = Boolean(object['.gogoproto.unmarshaler']);
          if (object['.gogoproto.stable_marshaler'] != null)
            message['.gogoproto.stable_marshaler'] = Boolean(object['.gogoproto.stable_marshaler']);
          if (object['.gogoproto.sizer'] != null) message['.gogoproto.sizer'] = Boolean(object['.gogoproto.sizer']);
          if (object['.gogoproto.unsafe_marshaler'] != null)
            message['.gogoproto.unsafe_marshaler'] = Boolean(object['.gogoproto.unsafe_marshaler']);
          if (object['.gogoproto.unsafe_unmarshaler'] != null)
            message['.gogoproto.unsafe_unmarshaler'] = Boolean(object['.gogoproto.unsafe_unmarshaler']);
          if (object['.gogoproto.goproto_extensions_map'] != null)
            message['.gogoproto.goproto_extensions_map'] = Boolean(object['.gogoproto.goproto_extensions_map']);
          if (object['.gogoproto.goproto_unrecognized'] != null)
            message['.gogoproto.goproto_unrecognized'] = Boolean(object['.gogoproto.goproto_unrecognized']);
          if (object['.gogoproto.protosizer'] != null) message['.gogoproto.protosizer'] = Boolean(object['.gogoproto.protosizer']);
          if (object['.gogoproto.compare'] != null) message['.gogoproto.compare'] = Boolean(object['.gogoproto.compare']);
          if (object['.gogoproto.typedecl'] != null) message['.gogoproto.typedecl'] = Boolean(object['.gogoproto.typedecl']);
          if (object['.gogoproto.messagename'] != null) message['.gogoproto.messagename'] = Boolean(object['.gogoproto.messagename']);
          if (object['.gogoproto.goproto_sizecache'] != null)
            message['.gogoproto.goproto_sizecache'] = Boolean(object['.gogoproto.goproto_sizecache']);
          if (object['.gogoproto.goproto_unkeyed'] != null)
            message['.gogoproto.goproto_unkeyed'] = Boolean(object['.gogoproto.goproto_unkeyed']);
          return message;
        };

        /**
         * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {google.protobuf.MessageOptions} message MessageOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (options.defaults) {
            object.message_set_wire_format = false;
            object.no_standard_descriptor_accessor = false;
            object.deprecated = false;
            object.map_entry = false;
            object['.gogoproto.goproto_getters'] = false;
            object['.gogoproto.goproto_stringer'] = false;
            object['.gogoproto.verbose_equal'] = false;
            object['.gogoproto.face'] = false;
            object['.gogoproto.gostring'] = false;
            object['.gogoproto.populate'] = false;
            object['.gogoproto.onlyone'] = false;
            object['.gogoproto.equal'] = false;
            object['.gogoproto.description'] = false;
            object['.gogoproto.testgen'] = false;
            object['.gogoproto.benchgen'] = false;
            object['.gogoproto.marshaler'] = false;
            object['.gogoproto.unmarshaler'] = false;
            object['.gogoproto.stable_marshaler'] = false;
            object['.gogoproto.sizer'] = false;
            object['.gogoproto.unsafe_marshaler'] = false;
            object['.gogoproto.unsafe_unmarshaler'] = false;
            object['.gogoproto.goproto_extensions_map'] = false;
            object['.gogoproto.goproto_unrecognized'] = false;
            object['.gogoproto.protosizer'] = false;
            object['.gogoproto.compare'] = false;
            object['.gogoproto.typedecl'] = false;
            object['.gogoproto.messagename'] = false;
            object['.gogoproto.goproto_sizecache'] = false;
            object['.gogoproto.goproto_unkeyed'] = false;
            object['.gogoproto.stringer'] = false;
            object['.cosmos_proto.interface_type'] = '';
            object['.cosmos_proto.implements_interface'] = '';
          }
          if (message.message_set_wire_format != null && message.hasOwnProperty('message_set_wire_format'))
            object.message_set_wire_format = message.message_set_wire_format;
          if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty('no_standard_descriptor_accessor'))
            object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
          if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
          if (message.map_entry != null && message.hasOwnProperty('map_entry')) object.map_entry = message.map_entry;
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          if (message['.gogoproto.goproto_getters'] != null && message.hasOwnProperty('.gogoproto.goproto_getters'))
            object['.gogoproto.goproto_getters'] = message['.gogoproto.goproto_getters'];
          if (message['.gogoproto.goproto_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer'))
            object['.gogoproto.goproto_stringer'] = message['.gogoproto.goproto_stringer'];
          if (message['.gogoproto.verbose_equal'] != null && message.hasOwnProperty('.gogoproto.verbose_equal'))
            object['.gogoproto.verbose_equal'] = message['.gogoproto.verbose_equal'];
          if (message['.gogoproto.face'] != null && message.hasOwnProperty('.gogoproto.face'))
            object['.gogoproto.face'] = message['.gogoproto.face'];
          if (message['.gogoproto.gostring'] != null && message.hasOwnProperty('.gogoproto.gostring'))
            object['.gogoproto.gostring'] = message['.gogoproto.gostring'];
          if (message['.gogoproto.populate'] != null && message.hasOwnProperty('.gogoproto.populate'))
            object['.gogoproto.populate'] = message['.gogoproto.populate'];
          if (message['.gogoproto.onlyone'] != null && message.hasOwnProperty('.gogoproto.onlyone'))
            object['.gogoproto.onlyone'] = message['.gogoproto.onlyone'];
          if (message['.gogoproto.equal'] != null && message.hasOwnProperty('.gogoproto.equal'))
            object['.gogoproto.equal'] = message['.gogoproto.equal'];
          if (message['.gogoproto.description'] != null && message.hasOwnProperty('.gogoproto.description'))
            object['.gogoproto.description'] = message['.gogoproto.description'];
          if (message['.gogoproto.testgen'] != null && message.hasOwnProperty('.gogoproto.testgen'))
            object['.gogoproto.testgen'] = message['.gogoproto.testgen'];
          if (message['.gogoproto.benchgen'] != null && message.hasOwnProperty('.gogoproto.benchgen'))
            object['.gogoproto.benchgen'] = message['.gogoproto.benchgen'];
          if (message['.gogoproto.marshaler'] != null && message.hasOwnProperty('.gogoproto.marshaler'))
            object['.gogoproto.marshaler'] = message['.gogoproto.marshaler'];
          if (message['.gogoproto.unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unmarshaler'))
            object['.gogoproto.unmarshaler'] = message['.gogoproto.unmarshaler'];
          if (message['.gogoproto.stable_marshaler'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler'))
            object['.gogoproto.stable_marshaler'] = message['.gogoproto.stable_marshaler'];
          if (message['.gogoproto.sizer'] != null && message.hasOwnProperty('.gogoproto.sizer'))
            object['.gogoproto.sizer'] = message['.gogoproto.sizer'];
          if (message['.gogoproto.unsafe_marshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler'))
            object['.gogoproto.unsafe_marshaler'] = message['.gogoproto.unsafe_marshaler'];
          if (message['.gogoproto.unsafe_unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler'))
            object['.gogoproto.unsafe_unmarshaler'] = message['.gogoproto.unsafe_unmarshaler'];
          if (message['.gogoproto.goproto_extensions_map'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map'))
            object['.gogoproto.goproto_extensions_map'] = message['.gogoproto.goproto_extensions_map'];
          if (message['.gogoproto.goproto_unrecognized'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized'))
            object['.gogoproto.goproto_unrecognized'] = message['.gogoproto.goproto_unrecognized'];
          if (message['.gogoproto.protosizer'] != null && message.hasOwnProperty('.gogoproto.protosizer'))
            object['.gogoproto.protosizer'] = message['.gogoproto.protosizer'];
          if (message['.gogoproto.compare'] != null && message.hasOwnProperty('.gogoproto.compare'))
            object['.gogoproto.compare'] = message['.gogoproto.compare'];
          if (message['.gogoproto.typedecl'] != null && message.hasOwnProperty('.gogoproto.typedecl'))
            object['.gogoproto.typedecl'] = message['.gogoproto.typedecl'];
          if (message['.gogoproto.messagename'] != null && message.hasOwnProperty('.gogoproto.messagename'))
            object['.gogoproto.messagename'] = message['.gogoproto.messagename'];
          if (message['.gogoproto.goproto_sizecache'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache'))
            object['.gogoproto.goproto_sizecache'] = message['.gogoproto.goproto_sizecache'];
          if (message['.gogoproto.goproto_unkeyed'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed'))
            object['.gogoproto.goproto_unkeyed'] = message['.gogoproto.goproto_unkeyed'];
          if (message['.gogoproto.stringer'] != null && message.hasOwnProperty('.gogoproto.stringer'))
            object['.gogoproto.stringer'] = message['.gogoproto.stringer'];
          if (message['.cosmos_proto.interface_type'] != null && message.hasOwnProperty('.cosmos_proto.interface_type'))
            object['.cosmos_proto.interface_type'] = message['.cosmos_proto.interface_type'];
          if (message['.cosmos_proto.implements_interface'] != null && message.hasOwnProperty('.cosmos_proto.implements_interface'))
            object['.cosmos_proto.implements_interface'] = message['.cosmos_proto.implements_interface'];
          return object;
        };

        /**
         * Converts this MessageOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.MessageOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageOptions;
      })();

      protobuf.FieldOptions = (function () {
        /**
         * Properties of a FieldOptions.
         * @memberof google.protobuf
         * @interface IFieldOptions
         * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
         * @property {boolean|null} [packed] FieldOptions packed
         * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
         * @property {boolean|null} [lazy] FieldOptions lazy
         * @property {boolean|null} [deprecated] FieldOptions deprecated
         * @property {boolean|null} [weak] FieldOptions weak
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
         * @property {string|null} [".cosmos_proto.accepts_interface"] FieldOptions .cosmos_proto.accepts_interface
         * @property {string|null} [".cosmos_proto.scalar"] FieldOptions .cosmos_proto.scalar
         * @property {boolean|null} [".gogoproto.nullable"] FieldOptions .gogoproto.nullable
         * @property {boolean|null} [".gogoproto.embed"] FieldOptions .gogoproto.embed
         * @property {string|null} [".gogoproto.customtype"] FieldOptions .gogoproto.customtype
         * @property {string|null} [".gogoproto.customname"] FieldOptions .gogoproto.customname
         * @property {string|null} [".gogoproto.jsontag"] FieldOptions .gogoproto.jsontag
         * @property {string|null} [".gogoproto.moretags"] FieldOptions .gogoproto.moretags
         * @property {string|null} [".gogoproto.casttype"] FieldOptions .gogoproto.casttype
         * @property {string|null} [".gogoproto.castkey"] FieldOptions .gogoproto.castkey
         * @property {string|null} [".gogoproto.castvalue"] FieldOptions .gogoproto.castvalue
         * @property {boolean|null} [".gogoproto.stdtime"] FieldOptions .gogoproto.stdtime
         * @property {boolean|null} [".gogoproto.stdduration"] FieldOptions .gogoproto.stdduration
         * @property {boolean|null} [".gogoproto.wktpointer"] FieldOptions .gogoproto.wktpointer
         * @property {string|null} [".gogoproto.castrepeated"] FieldOptions .gogoproto.castrepeated
         */

        /**
         * Constructs a new FieldOptions.
         * @memberof google.protobuf
         * @classdesc Represents a FieldOptions.
         * @implements IFieldOptions
         * @constructor
         * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
         */
        function FieldOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FieldOptions ctype.
         * @member {google.protobuf.FieldOptions.CType} ctype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.ctype = 0;

        /**
         * FieldOptions packed.
         * @member {boolean} packed
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.packed = false;

        /**
         * FieldOptions jstype.
         * @member {google.protobuf.FieldOptions.JSType} jstype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.jstype = 0;

        /**
         * FieldOptions lazy.
         * @member {boolean} lazy
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.lazy = false;

        /**
         * FieldOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.deprecated = false;

        /**
         * FieldOptions weak.
         * @member {boolean} weak
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.weak = false;

        /**
         * FieldOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * FieldOptions .cosmos_proto.accepts_interface.
         * @member {string} .cosmos_proto.accepts_interface
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.cosmos_proto.accepts_interface'] = '';

        /**
         * FieldOptions .cosmos_proto.scalar.
         * @member {string} .cosmos_proto.scalar
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.cosmos_proto.scalar'] = '';

        /**
         * FieldOptions .gogoproto.nullable.
         * @member {boolean} .gogoproto.nullable
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.nullable'] = false;

        /**
         * FieldOptions .gogoproto.embed.
         * @member {boolean} .gogoproto.embed
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.embed'] = false;

        /**
         * FieldOptions .gogoproto.customtype.
         * @member {string} .gogoproto.customtype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.customtype'] = '';

        /**
         * FieldOptions .gogoproto.customname.
         * @member {string} .gogoproto.customname
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.customname'] = '';

        /**
         * FieldOptions .gogoproto.jsontag.
         * @member {string} .gogoproto.jsontag
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.jsontag'] = '';

        /**
         * FieldOptions .gogoproto.moretags.
         * @member {string} .gogoproto.moretags
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.moretags'] = '';

        /**
         * FieldOptions .gogoproto.casttype.
         * @member {string} .gogoproto.casttype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.casttype'] = '';

        /**
         * FieldOptions .gogoproto.castkey.
         * @member {string} .gogoproto.castkey
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.castkey'] = '';

        /**
         * FieldOptions .gogoproto.castvalue.
         * @member {string} .gogoproto.castvalue
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.castvalue'] = '';

        /**
         * FieldOptions .gogoproto.stdtime.
         * @member {boolean} .gogoproto.stdtime
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.stdtime'] = false;

        /**
         * FieldOptions .gogoproto.stdduration.
         * @member {boolean} .gogoproto.stdduration
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.stdduration'] = false;

        /**
         * FieldOptions .gogoproto.wktpointer.
         * @member {boolean} .gogoproto.wktpointer
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.wktpointer'] = false;

        /**
         * FieldOptions .gogoproto.castrepeated.
         * @member {string} .gogoproto.castrepeated
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype['.gogoproto.castrepeated'] = '';

        /**
         * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.ctype != null && Object.hasOwnProperty.call(message, 'ctype'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.ctype);
          if (message.packed != null && Object.hasOwnProperty.call(message, 'packed'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.packed);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
          if (message.lazy != null && Object.hasOwnProperty.call(message, 'lazy'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.lazy);
          if (message.jstype != null && Object.hasOwnProperty.call(message, 'jstype'))
            writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.jstype);
          if (message.weak != null && Object.hasOwnProperty.call(message, 'weak'))
            writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.weak);
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (message['.gogoproto.nullable'] != null && Object.hasOwnProperty.call(message, '.gogoproto.nullable'))
            writer.uint32(/* id 65001, wireType 0 =*/ 520008).bool(message['.gogoproto.nullable']);
          if (message['.gogoproto.embed'] != null && Object.hasOwnProperty.call(message, '.gogoproto.embed'))
            writer.uint32(/* id 65002, wireType 0 =*/ 520016).bool(message['.gogoproto.embed']);
          if (message['.gogoproto.customtype'] != null && Object.hasOwnProperty.call(message, '.gogoproto.customtype'))
            writer.uint32(/* id 65003, wireType 2 =*/ 520026).string(message['.gogoproto.customtype']);
          if (message['.gogoproto.customname'] != null && Object.hasOwnProperty.call(message, '.gogoproto.customname'))
            writer.uint32(/* id 65004, wireType 2 =*/ 520034).string(message['.gogoproto.customname']);
          if (message['.gogoproto.jsontag'] != null && Object.hasOwnProperty.call(message, '.gogoproto.jsontag'))
            writer.uint32(/* id 65005, wireType 2 =*/ 520042).string(message['.gogoproto.jsontag']);
          if (message['.gogoproto.moretags'] != null && Object.hasOwnProperty.call(message, '.gogoproto.moretags'))
            writer.uint32(/* id 65006, wireType 2 =*/ 520050).string(message['.gogoproto.moretags']);
          if (message['.gogoproto.casttype'] != null && Object.hasOwnProperty.call(message, '.gogoproto.casttype'))
            writer.uint32(/* id 65007, wireType 2 =*/ 520058).string(message['.gogoproto.casttype']);
          if (message['.gogoproto.castkey'] != null && Object.hasOwnProperty.call(message, '.gogoproto.castkey'))
            writer.uint32(/* id 65008, wireType 2 =*/ 520066).string(message['.gogoproto.castkey']);
          if (message['.gogoproto.castvalue'] != null && Object.hasOwnProperty.call(message, '.gogoproto.castvalue'))
            writer.uint32(/* id 65009, wireType 2 =*/ 520074).string(message['.gogoproto.castvalue']);
          if (message['.gogoproto.stdtime'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stdtime'))
            writer.uint32(/* id 65010, wireType 0 =*/ 520080).bool(message['.gogoproto.stdtime']);
          if (message['.gogoproto.stdduration'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stdduration'))
            writer.uint32(/* id 65011, wireType 0 =*/ 520088).bool(message['.gogoproto.stdduration']);
          if (message['.gogoproto.wktpointer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.wktpointer'))
            writer.uint32(/* id 65012, wireType 0 =*/ 520096).bool(message['.gogoproto.wktpointer']);
          if (message['.gogoproto.castrepeated'] != null && Object.hasOwnProperty.call(message, '.gogoproto.castrepeated'))
            writer.uint32(/* id 65013, wireType 2 =*/ 520106).string(message['.gogoproto.castrepeated']);
          if (message['.cosmos_proto.accepts_interface'] != null && Object.hasOwnProperty.call(message, '.cosmos_proto.accepts_interface'))
            writer.uint32(/* id 93001, wireType 2 =*/ 744010).string(message['.cosmos_proto.accepts_interface']);
          if (message['.cosmos_proto.scalar'] != null && Object.hasOwnProperty.call(message, '.cosmos_proto.scalar'))
            writer.uint32(/* id 93002, wireType 2 =*/ 744018).string(message['.cosmos_proto.scalar']);
          return writer;
        };

        /**
         * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FieldOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FieldOptions} FieldOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FieldOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.ctype = reader.int32();
                break;
              case 2:
                message.packed = reader.bool();
                break;
              case 6:
                message.jstype = reader.int32();
                break;
              case 5:
                message.lazy = reader.bool();
                break;
              case 3:
                message.deprecated = reader.bool();
                break;
              case 10:
                message.weak = reader.bool();
                break;
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              case 93001:
                message['.cosmos_proto.accepts_interface'] = reader.string();
                break;
              case 93002:
                message['.cosmos_proto.scalar'] = reader.string();
                break;
              case 65001:
                message['.gogoproto.nullable'] = reader.bool();
                break;
              case 65002:
                message['.gogoproto.embed'] = reader.bool();
                break;
              case 65003:
                message['.gogoproto.customtype'] = reader.string();
                break;
              case 65004:
                message['.gogoproto.customname'] = reader.string();
                break;
              case 65005:
                message['.gogoproto.jsontag'] = reader.string();
                break;
              case 65006:
                message['.gogoproto.moretags'] = reader.string();
                break;
              case 65007:
                message['.gogoproto.casttype'] = reader.string();
                break;
              case 65008:
                message['.gogoproto.castkey'] = reader.string();
                break;
              case 65009:
                message['.gogoproto.castvalue'] = reader.string();
                break;
              case 65010:
                message['.gogoproto.stdtime'] = reader.bool();
                break;
              case 65011:
                message['.gogoproto.stdduration'] = reader.bool();
                break;
              case 65012:
                message['.gogoproto.wktpointer'] = reader.bool();
                break;
              case 65013:
                message['.gogoproto.castrepeated'] = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FieldOptions} FieldOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FieldOptions message.
         * @function verify
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.ctype != null && message.hasOwnProperty('ctype'))
            switch (message.ctype) {
              default:
                return 'ctype: enum value expected';
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.packed != null && message.hasOwnProperty('packed'))
            if (typeof message.packed !== 'boolean') return 'packed: boolean expected';
          if (message.jstype != null && message.hasOwnProperty('jstype'))
            switch (message.jstype) {
              default:
                return 'jstype: enum value expected';
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.lazy != null && message.hasOwnProperty('lazy'))
            if (typeof message.lazy !== 'boolean') return 'lazy: boolean expected';
          if (message.deprecated != null && message.hasOwnProperty('deprecated'))
            if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
          if (message.weak != null && message.hasOwnProperty('weak'))
            if (typeof message.weak !== 'boolean') return 'weak: boolean expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          if (message['.cosmos_proto.accepts_interface'] != null && message.hasOwnProperty('.cosmos_proto.accepts_interface'))
            if (!$util.isString(message['.cosmos_proto.accepts_interface'])) return '.cosmos_proto.accepts_interface: string expected';
          if (message['.cosmos_proto.scalar'] != null && message.hasOwnProperty('.cosmos_proto.scalar'))
            if (!$util.isString(message['.cosmos_proto.scalar'])) return '.cosmos_proto.scalar: string expected';
          if (message['.gogoproto.nullable'] != null && message.hasOwnProperty('.gogoproto.nullable'))
            if (typeof message['.gogoproto.nullable'] !== 'boolean') return '.gogoproto.nullable: boolean expected';
          if (message['.gogoproto.embed'] != null && message.hasOwnProperty('.gogoproto.embed'))
            if (typeof message['.gogoproto.embed'] !== 'boolean') return '.gogoproto.embed: boolean expected';
          if (message['.gogoproto.customtype'] != null && message.hasOwnProperty('.gogoproto.customtype'))
            if (!$util.isString(message['.gogoproto.customtype'])) return '.gogoproto.customtype: string expected';
          if (message['.gogoproto.customname'] != null && message.hasOwnProperty('.gogoproto.customname'))
            if (!$util.isString(message['.gogoproto.customname'])) return '.gogoproto.customname: string expected';
          if (message['.gogoproto.jsontag'] != null && message.hasOwnProperty('.gogoproto.jsontag'))
            if (!$util.isString(message['.gogoproto.jsontag'])) return '.gogoproto.jsontag: string expected';
          if (message['.gogoproto.moretags'] != null && message.hasOwnProperty('.gogoproto.moretags'))
            if (!$util.isString(message['.gogoproto.moretags'])) return '.gogoproto.moretags: string expected';
          if (message['.gogoproto.casttype'] != null && message.hasOwnProperty('.gogoproto.casttype'))
            if (!$util.isString(message['.gogoproto.casttype'])) return '.gogoproto.casttype: string expected';
          if (message['.gogoproto.castkey'] != null && message.hasOwnProperty('.gogoproto.castkey'))
            if (!$util.isString(message['.gogoproto.castkey'])) return '.gogoproto.castkey: string expected';
          if (message['.gogoproto.castvalue'] != null && message.hasOwnProperty('.gogoproto.castvalue'))
            if (!$util.isString(message['.gogoproto.castvalue'])) return '.gogoproto.castvalue: string expected';
          if (message['.gogoproto.stdtime'] != null && message.hasOwnProperty('.gogoproto.stdtime'))
            if (typeof message['.gogoproto.stdtime'] !== 'boolean') return '.gogoproto.stdtime: boolean expected';
          if (message['.gogoproto.stdduration'] != null && message.hasOwnProperty('.gogoproto.stdduration'))
            if (typeof message['.gogoproto.stdduration'] !== 'boolean') return '.gogoproto.stdduration: boolean expected';
          if (message['.gogoproto.wktpointer'] != null && message.hasOwnProperty('.gogoproto.wktpointer'))
            if (typeof message['.gogoproto.wktpointer'] !== 'boolean') return '.gogoproto.wktpointer: boolean expected';
          if (message['.gogoproto.castrepeated'] != null && message.hasOwnProperty('.gogoproto.castrepeated'))
            if (!$util.isString(message['.gogoproto.castrepeated'])) return '.gogoproto.castrepeated: string expected';
          return null;
        };

        /**
         * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FieldOptions} FieldOptions
         */
        FieldOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FieldOptions) return object;
          var message = new $root.google.protobuf.FieldOptions();
          switch (object.ctype) {
            case 'STRING':
            case 0:
              message.ctype = 0;
              break;
            case 'CORD':
            case 1:
              message.ctype = 1;
              break;
            case 'STRING_PIECE':
            case 2:
              message.ctype = 2;
              break;
          }
          if (object.packed != null) message.packed = Boolean(object.packed);
          switch (object.jstype) {
            case 'JS_NORMAL':
            case 0:
              message.jstype = 0;
              break;
            case 'JS_STRING':
            case 1:
              message.jstype = 1;
              break;
            case 'JS_NUMBER':
            case 2:
              message.jstype = 2;
              break;
          }
          if (object.lazy != null) message.lazy = Boolean(object.lazy);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.weak != null) message.weak = Boolean(object.weak);
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.FieldOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.FieldOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          if (object['.cosmos_proto.accepts_interface'] != null)
            message['.cosmos_proto.accepts_interface'] = String(object['.cosmos_proto.accepts_interface']);
          if (object['.cosmos_proto.scalar'] != null) message['.cosmos_proto.scalar'] = String(object['.cosmos_proto.scalar']);
          if (object['.gogoproto.nullable'] != null) message['.gogoproto.nullable'] = Boolean(object['.gogoproto.nullable']);
          if (object['.gogoproto.embed'] != null) message['.gogoproto.embed'] = Boolean(object['.gogoproto.embed']);
          if (object['.gogoproto.customtype'] != null) message['.gogoproto.customtype'] = String(object['.gogoproto.customtype']);
          if (object['.gogoproto.customname'] != null) message['.gogoproto.customname'] = String(object['.gogoproto.customname']);
          if (object['.gogoproto.jsontag'] != null) message['.gogoproto.jsontag'] = String(object['.gogoproto.jsontag']);
          if (object['.gogoproto.moretags'] != null) message['.gogoproto.moretags'] = String(object['.gogoproto.moretags']);
          if (object['.gogoproto.casttype'] != null) message['.gogoproto.casttype'] = String(object['.gogoproto.casttype']);
          if (object['.gogoproto.castkey'] != null) message['.gogoproto.castkey'] = String(object['.gogoproto.castkey']);
          if (object['.gogoproto.castvalue'] != null) message['.gogoproto.castvalue'] = String(object['.gogoproto.castvalue']);
          if (object['.gogoproto.stdtime'] != null) message['.gogoproto.stdtime'] = Boolean(object['.gogoproto.stdtime']);
          if (object['.gogoproto.stdduration'] != null) message['.gogoproto.stdduration'] = Boolean(object['.gogoproto.stdduration']);
          if (object['.gogoproto.wktpointer'] != null) message['.gogoproto.wktpointer'] = Boolean(object['.gogoproto.wktpointer']);
          if (object['.gogoproto.castrepeated'] != null) message['.gogoproto.castrepeated'] = String(object['.gogoproto.castrepeated']);
          return message;
        };

        /**
         * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {google.protobuf.FieldOptions} message FieldOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (options.defaults) {
            object.ctype = options.enums === String ? 'STRING' : 0;
            object.packed = false;
            object.deprecated = false;
            object.lazy = false;
            object.jstype = options.enums === String ? 'JS_NORMAL' : 0;
            object.weak = false;
            object['.gogoproto.nullable'] = false;
            object['.gogoproto.embed'] = false;
            object['.gogoproto.customtype'] = '';
            object['.gogoproto.customname'] = '';
            object['.gogoproto.jsontag'] = '';
            object['.gogoproto.moretags'] = '';
            object['.gogoproto.casttype'] = '';
            object['.gogoproto.castkey'] = '';
            object['.gogoproto.castvalue'] = '';
            object['.gogoproto.stdtime'] = false;
            object['.gogoproto.stdduration'] = false;
            object['.gogoproto.wktpointer'] = false;
            object['.gogoproto.castrepeated'] = '';
            object['.cosmos_proto.accepts_interface'] = '';
            object['.cosmos_proto.scalar'] = '';
          }
          if (message.ctype != null && message.hasOwnProperty('ctype'))
            object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
          if (message.packed != null && message.hasOwnProperty('packed')) object.packed = message.packed;
          if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
          if (message.lazy != null && message.hasOwnProperty('lazy')) object.lazy = message.lazy;
          if (message.jstype != null && message.hasOwnProperty('jstype'))
            object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
          if (message.weak != null && message.hasOwnProperty('weak')) object.weak = message.weak;
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          if (message['.gogoproto.nullable'] != null && message.hasOwnProperty('.gogoproto.nullable'))
            object['.gogoproto.nullable'] = message['.gogoproto.nullable'];
          if (message['.gogoproto.embed'] != null && message.hasOwnProperty('.gogoproto.embed'))
            object['.gogoproto.embed'] = message['.gogoproto.embed'];
          if (message['.gogoproto.customtype'] != null && message.hasOwnProperty('.gogoproto.customtype'))
            object['.gogoproto.customtype'] = message['.gogoproto.customtype'];
          if (message['.gogoproto.customname'] != null && message.hasOwnProperty('.gogoproto.customname'))
            object['.gogoproto.customname'] = message['.gogoproto.customname'];
          if (message['.gogoproto.jsontag'] != null && message.hasOwnProperty('.gogoproto.jsontag'))
            object['.gogoproto.jsontag'] = message['.gogoproto.jsontag'];
          if (message['.gogoproto.moretags'] != null && message.hasOwnProperty('.gogoproto.moretags'))
            object['.gogoproto.moretags'] = message['.gogoproto.moretags'];
          if (message['.gogoproto.casttype'] != null && message.hasOwnProperty('.gogoproto.casttype'))
            object['.gogoproto.casttype'] = message['.gogoproto.casttype'];
          if (message['.gogoproto.castkey'] != null && message.hasOwnProperty('.gogoproto.castkey'))
            object['.gogoproto.castkey'] = message['.gogoproto.castkey'];
          if (message['.gogoproto.castvalue'] != null && message.hasOwnProperty('.gogoproto.castvalue'))
            object['.gogoproto.castvalue'] = message['.gogoproto.castvalue'];
          if (message['.gogoproto.stdtime'] != null && message.hasOwnProperty('.gogoproto.stdtime'))
            object['.gogoproto.stdtime'] = message['.gogoproto.stdtime'];
          if (message['.gogoproto.stdduration'] != null && message.hasOwnProperty('.gogoproto.stdduration'))
            object['.gogoproto.stdduration'] = message['.gogoproto.stdduration'];
          if (message['.gogoproto.wktpointer'] != null && message.hasOwnProperty('.gogoproto.wktpointer'))
            object['.gogoproto.wktpointer'] = message['.gogoproto.wktpointer'];
          if (message['.gogoproto.castrepeated'] != null && message.hasOwnProperty('.gogoproto.castrepeated'))
            object['.gogoproto.castrepeated'] = message['.gogoproto.castrepeated'];
          if (message['.cosmos_proto.accepts_interface'] != null && message.hasOwnProperty('.cosmos_proto.accepts_interface'))
            object['.cosmos_proto.accepts_interface'] = message['.cosmos_proto.accepts_interface'];
          if (message['.cosmos_proto.scalar'] != null && message.hasOwnProperty('.cosmos_proto.scalar'))
            object['.cosmos_proto.scalar'] = message['.cosmos_proto.scalar'];
          return object;
        };

        /**
         * Converts this FieldOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.FieldOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CType enum.
         * @name google.protobuf.FieldOptions.CType
         * @enum {number}
         * @property {number} STRING=0 STRING value
         * @property {number} CORD=1 CORD value
         * @property {number} STRING_PIECE=2 STRING_PIECE value
         */
        FieldOptions.CType = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = 'STRING')] = 0;
          values[(valuesById[1] = 'CORD')] = 1;
          values[(valuesById[2] = 'STRING_PIECE')] = 2;
          return values;
        })();

        /**
         * JSType enum.
         * @name google.protobuf.FieldOptions.JSType
         * @enum {number}
         * @property {number} JS_NORMAL=0 JS_NORMAL value
         * @property {number} JS_STRING=1 JS_STRING value
         * @property {number} JS_NUMBER=2 JS_NUMBER value
         */
        FieldOptions.JSType = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = 'JS_NORMAL')] = 0;
          values[(valuesById[1] = 'JS_STRING')] = 1;
          values[(valuesById[2] = 'JS_NUMBER')] = 2;
          return values;
        })();

        return FieldOptions;
      })();

      protobuf.OneofOptions = (function () {
        /**
         * Properties of an OneofOptions.
         * @memberof google.protobuf
         * @interface IOneofOptions
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] OneofOptions uninterpreted_option
         */

        /**
         * Constructs a new OneofOptions.
         * @memberof google.protobuf
         * @classdesc Represents an OneofOptions.
         * @implements IOneofOptions
         * @constructor
         * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
         */
        function OneofOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * OneofOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.OneofOptions
         * @instance
         */
        OneofOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OneofOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.OneofOptions} OneofOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.OneofOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.OneofOptions} OneofOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OneofOptions message.
         * @function verify
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OneofOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          return null;
        };

        /**
         * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.OneofOptions} OneofOptions
         */
        OneofOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.OneofOptions) return object;
          var message = new $root.google.protobuf.OneofOptions();
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.OneofOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.OneofOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {google.protobuf.OneofOptions} message OneofOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OneofOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          return object;
        };

        /**
         * Converts this OneofOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.OneofOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OneofOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OneofOptions;
      })();

      protobuf.EnumOptions = (function () {
        /**
         * Properties of an EnumOptions.
         * @memberof google.protobuf
         * @interface IEnumOptions
         * @property {boolean|null} [allow_alias] EnumOptions allow_alias
         * @property {boolean|null} [deprecated] EnumOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
         * @property {boolean|null} [".gogoproto.goproto_enum_prefix"] EnumOptions .gogoproto.goproto_enum_prefix
         * @property {boolean|null} [".gogoproto.goproto_enum_stringer"] EnumOptions .gogoproto.goproto_enum_stringer
         * @property {boolean|null} [".gogoproto.enum_stringer"] EnumOptions .gogoproto.enum_stringer
         * @property {string|null} [".gogoproto.enum_customname"] EnumOptions .gogoproto.enum_customname
         * @property {boolean|null} [".gogoproto.enumdecl"] EnumOptions .gogoproto.enumdecl
         */

        /**
         * Constructs a new EnumOptions.
         * @memberof google.protobuf
         * @classdesc Represents an EnumOptions.
         * @implements IEnumOptions
         * @constructor
         * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
         */
        function EnumOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumOptions allow_alias.
         * @member {boolean} allow_alias
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype.allow_alias = false;

        /**
         * EnumOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype.deprecated = false;

        /**
         * EnumOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * EnumOptions .gogoproto.goproto_enum_prefix.
         * @member {boolean} .gogoproto.goproto_enum_prefix
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype['.gogoproto.goproto_enum_prefix'] = false;

        /**
         * EnumOptions .gogoproto.goproto_enum_stringer.
         * @member {boolean} .gogoproto.goproto_enum_stringer
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype['.gogoproto.goproto_enum_stringer'] = false;

        /**
         * EnumOptions .gogoproto.enum_stringer.
         * @member {boolean} .gogoproto.enum_stringer
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype['.gogoproto.enum_stringer'] = false;

        /**
         * EnumOptions .gogoproto.enum_customname.
         * @member {string} .gogoproto.enum_customname
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype['.gogoproto.enum_customname'] = '';

        /**
         * EnumOptions .gogoproto.enumdecl.
         * @member {boolean} .gogoproto.enumdecl
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype['.gogoproto.enumdecl'] = false;

        /**
         * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.allow_alias != null && Object.hasOwnProperty.call(message, 'allow_alias'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.allow_alias);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (message['.gogoproto.goproto_enum_prefix'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_prefix'))
            writer.uint32(/* id 62001, wireType 0 =*/ 496008).bool(message['.gogoproto.goproto_enum_prefix']);
          if (
            message['.gogoproto.goproto_enum_stringer'] != null &&
            Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_stringer')
          )
            writer.uint32(/* id 62021, wireType 0 =*/ 496168).bool(message['.gogoproto.goproto_enum_stringer']);
          if (message['.gogoproto.enum_stringer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enum_stringer'))
            writer.uint32(/* id 62022, wireType 0 =*/ 496176).bool(message['.gogoproto.enum_stringer']);
          if (message['.gogoproto.enum_customname'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enum_customname'))
            writer.uint32(/* id 62023, wireType 2 =*/ 496186).string(message['.gogoproto.enum_customname']);
          if (message['.gogoproto.enumdecl'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enumdecl'))
            writer.uint32(/* id 62024, wireType 0 =*/ 496192).bool(message['.gogoproto.enumdecl']);
          return writer;
        };

        /**
         * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumOptions} EnumOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 2:
                message.allow_alias = reader.bool();
                break;
              case 3:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              case 62001:
                message['.gogoproto.goproto_enum_prefix'] = reader.bool();
                break;
              case 62021:
                message['.gogoproto.goproto_enum_stringer'] = reader.bool();
                break;
              case 62022:
                message['.gogoproto.enum_stringer'] = reader.bool();
                break;
              case 62023:
                message['.gogoproto.enum_customname'] = reader.string();
                break;
              case 62024:
                message['.gogoproto.enumdecl'] = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumOptions} EnumOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumOptions message.
         * @function verify
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.allow_alias != null && message.hasOwnProperty('allow_alias'))
            if (typeof message.allow_alias !== 'boolean') return 'allow_alias: boolean expected';
          if (message.deprecated != null && message.hasOwnProperty('deprecated'))
            if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          if (message['.gogoproto.goproto_enum_prefix'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix'))
            if (typeof message['.gogoproto.goproto_enum_prefix'] !== 'boolean') return '.gogoproto.goproto_enum_prefix: boolean expected';
          if (message['.gogoproto.goproto_enum_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer'))
            if (typeof message['.gogoproto.goproto_enum_stringer'] !== 'boolean')
              return '.gogoproto.goproto_enum_stringer: boolean expected';
          if (message['.gogoproto.enum_stringer'] != null && message.hasOwnProperty('.gogoproto.enum_stringer'))
            if (typeof message['.gogoproto.enum_stringer'] !== 'boolean') return '.gogoproto.enum_stringer: boolean expected';
          if (message['.gogoproto.enum_customname'] != null && message.hasOwnProperty('.gogoproto.enum_customname'))
            if (!$util.isString(message['.gogoproto.enum_customname'])) return '.gogoproto.enum_customname: string expected';
          if (message['.gogoproto.enumdecl'] != null && message.hasOwnProperty('.gogoproto.enumdecl'))
            if (typeof message['.gogoproto.enumdecl'] !== 'boolean') return '.gogoproto.enumdecl: boolean expected';
          return null;
        };

        /**
         * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumOptions} EnumOptions
         */
        EnumOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumOptions) return object;
          var message = new $root.google.protobuf.EnumOptions();
          if (object.allow_alias != null) message.allow_alias = Boolean(object.allow_alias);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.EnumOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.EnumOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          if (object['.gogoproto.goproto_enum_prefix'] != null)
            message['.gogoproto.goproto_enum_prefix'] = Boolean(object['.gogoproto.goproto_enum_prefix']);
          if (object['.gogoproto.goproto_enum_stringer'] != null)
            message['.gogoproto.goproto_enum_stringer'] = Boolean(object['.gogoproto.goproto_enum_stringer']);
          if (object['.gogoproto.enum_stringer'] != null) message['.gogoproto.enum_stringer'] = Boolean(object['.gogoproto.enum_stringer']);
          if (object['.gogoproto.enum_customname'] != null)
            message['.gogoproto.enum_customname'] = String(object['.gogoproto.enum_customname']);
          if (object['.gogoproto.enumdecl'] != null) message['.gogoproto.enumdecl'] = Boolean(object['.gogoproto.enumdecl']);
          return message;
        };

        /**
         * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {google.protobuf.EnumOptions} message EnumOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (options.defaults) {
            object.allow_alias = false;
            object.deprecated = false;
            object['.gogoproto.goproto_enum_prefix'] = false;
            object['.gogoproto.goproto_enum_stringer'] = false;
            object['.gogoproto.enum_stringer'] = false;
            object['.gogoproto.enum_customname'] = '';
            object['.gogoproto.enumdecl'] = false;
          }
          if (message.allow_alias != null && message.hasOwnProperty('allow_alias')) object.allow_alias = message.allow_alias;
          if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          if (message['.gogoproto.goproto_enum_prefix'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix'))
            object['.gogoproto.goproto_enum_prefix'] = message['.gogoproto.goproto_enum_prefix'];
          if (message['.gogoproto.goproto_enum_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer'))
            object['.gogoproto.goproto_enum_stringer'] = message['.gogoproto.goproto_enum_stringer'];
          if (message['.gogoproto.enum_stringer'] != null && message.hasOwnProperty('.gogoproto.enum_stringer'))
            object['.gogoproto.enum_stringer'] = message['.gogoproto.enum_stringer'];
          if (message['.gogoproto.enum_customname'] != null && message.hasOwnProperty('.gogoproto.enum_customname'))
            object['.gogoproto.enum_customname'] = message['.gogoproto.enum_customname'];
          if (message['.gogoproto.enumdecl'] != null && message.hasOwnProperty('.gogoproto.enumdecl'))
            object['.gogoproto.enumdecl'] = message['.gogoproto.enumdecl'];
          return object;
        };

        /**
         * Converts this EnumOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumOptions;
      })();

      protobuf.EnumValueOptions = (function () {
        /**
         * Properties of an EnumValueOptions.
         * @memberof google.protobuf
         * @interface IEnumValueOptions
         * @property {boolean|null} [deprecated] EnumValueOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
         * @property {string|null} [".gogoproto.enumvalue_customname"] EnumValueOptions .gogoproto.enumvalue_customname
         */

        /**
         * Constructs a new EnumValueOptions.
         * @memberof google.protobuf
         * @classdesc Represents an EnumValueOptions.
         * @implements IEnumValueOptions
         * @constructor
         * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
         */
        function EnumValueOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumValueOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         */
        EnumValueOptions.prototype.deprecated = false;

        /**
         * EnumValueOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         */
        EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * EnumValueOptions .gogoproto.enumvalue_customname.
         * @member {string} .gogoproto.enumvalue_customname
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         */
        EnumValueOptions.prototype['.gogoproto.enumvalue_customname'] = '';

        /**
         * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.deprecated);
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (message['.gogoproto.enumvalue_customname'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enumvalue_customname'))
            writer.uint32(/* id 66001, wireType 2 =*/ 528010).string(message['.gogoproto.enumvalue_customname']);
          return writer;
        };

        /**
         * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumValueOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumValueOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              case 66001:
                message['.gogoproto.enumvalue_customname'] = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumValueOptions message.
         * @function verify
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumValueOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.deprecated != null && message.hasOwnProperty('deprecated'))
            if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          if (message['.gogoproto.enumvalue_customname'] != null && message.hasOwnProperty('.gogoproto.enumvalue_customname'))
            if (!$util.isString(message['.gogoproto.enumvalue_customname'])) return '.gogoproto.enumvalue_customname: string expected';
          return null;
        };

        /**
         * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
         */
        EnumValueOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumValueOptions) return object;
          var message = new $root.google.protobuf.EnumValueOptions();
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.EnumValueOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.EnumValueOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          if (object['.gogoproto.enumvalue_customname'] != null)
            message['.gogoproto.enumvalue_customname'] = String(object['.gogoproto.enumvalue_customname']);
          return message;
        };

        /**
         * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumValueOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (options.defaults) {
            object.deprecated = false;
            object['.gogoproto.enumvalue_customname'] = '';
          }
          if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          if (message['.gogoproto.enumvalue_customname'] != null && message.hasOwnProperty('.gogoproto.enumvalue_customname'))
            object['.gogoproto.enumvalue_customname'] = message['.gogoproto.enumvalue_customname'];
          return object;
        };

        /**
         * Converts this EnumValueOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumValueOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumValueOptions;
      })();

      protobuf.ServiceOptions = (function () {
        /**
         * Properties of a ServiceOptions.
         * @memberof google.protobuf
         * @interface IServiceOptions
         * @property {boolean|null} [deprecated] ServiceOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
         */

        /**
         * Constructs a new ServiceOptions.
         * @memberof google.protobuf
         * @classdesc Represents a ServiceOptions.
         * @implements IServiceOptions
         * @constructor
         * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
         */
        function ServiceOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.ServiceOptions
         * @instance
         */
        ServiceOptions.prototype.deprecated = false;

        /**
         * ServiceOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.ServiceOptions
         * @instance
         */
        ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
            writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.ServiceOptions} ServiceOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.ServiceOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 33:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.ServiceOptions} ServiceOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceOptions message.
         * @function verify
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.deprecated != null && message.hasOwnProperty('deprecated'))
            if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.ServiceOptions} ServiceOptions
         */
        ServiceOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.ServiceOptions) return object;
          var message = new $root.google.protobuf.ServiceOptions();
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.ServiceOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.ServiceOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {google.protobuf.ServiceOptions} message ServiceOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (options.defaults) object.deprecated = false;
          if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          return object;
        };

        /**
         * Converts this ServiceOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.ServiceOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceOptions;
      })();

      protobuf.MethodOptions = (function () {
        /**
         * Properties of a MethodOptions.
         * @memberof google.protobuf
         * @interface IMethodOptions
         * @property {boolean|null} [deprecated] MethodOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
         * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
         */

        /**
         * Constructs a new MethodOptions.
         * @memberof google.protobuf
         * @classdesc Represents a MethodOptions.
         * @implements IMethodOptions
         * @constructor
         * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
         */
        function MethodOptions(properties) {
          this.uninterpreted_option = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MethodOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.MethodOptions
         * @instance
         */
        MethodOptions.prototype.deprecated = false;

        /**
         * MethodOptions uninterpreted_option.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
         * @memberof google.protobuf.MethodOptions
         * @instance
         */
        MethodOptions.prototype.uninterpreted_option = $util.emptyArray;

        /**
         * MethodOptions .google.api.http.
         * @member {google.api.IHttpRule|null|undefined} .google.api.http
         * @memberof google.protobuf.MethodOptions
         * @instance
         */
        MethodOptions.prototype['.google.api.http'] = null;

        /**
         * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
            writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
          if (message.uninterpreted_option != null && message.uninterpreted_option.length)
            for (var i = 0; i < message.uninterpreted_option.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpreted_option[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (message['.google.api.http'] != null && Object.hasOwnProperty.call(message, '.google.api.http'))
            $root.google.api.HttpRule.encode(
              message['.google.api.http'],
              writer.uint32(/* id 72295728, wireType 2 =*/ 578365826).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MethodOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.MethodOptions} MethodOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.MethodOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 33:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
                message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                break;
              case 72295728:
                message['.google.api.http'] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.MethodOptions} MethodOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MethodOptions message.
         * @function verify
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MethodOptions.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.deprecated != null && message.hasOwnProperty('deprecated'))
            if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
          if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
            if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
            for (var i = 0; i < message.uninterpreted_option.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
              if (error) return 'uninterpreted_option.' + error;
            }
          }
          if (message['.google.api.http'] != null && message.hasOwnProperty('.google.api.http')) {
            var error = $root.google.api.HttpRule.verify(message['.google.api.http']);
            if (error) return '.google.api.http.' + error;
          }
          return null;
        };

        /**
         * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.MethodOptions} MethodOptions
         */
        MethodOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.MethodOptions) return object;
          var message = new $root.google.protobuf.MethodOptions();
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpreted_option) {
            if (!Array.isArray(object.uninterpreted_option))
              throw TypeError('.google.protobuf.MethodOptions.uninterpreted_option: array expected');
            message.uninterpreted_option = [];
            for (var i = 0; i < object.uninterpreted_option.length; ++i) {
              if (typeof object.uninterpreted_option[i] !== 'object')
                throw TypeError('.google.protobuf.MethodOptions.uninterpreted_option: object expected');
              message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
            }
          }
          if (object['.google.api.http'] != null) {
            if (typeof object['.google.api.http'] !== 'object')
              throw TypeError('.google.protobuf.MethodOptions..google.api.http: object expected');
            message['.google.api.http'] = $root.google.api.HttpRule.fromObject(object['.google.api.http']);
          }
          return message;
        };

        /**
         * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {google.protobuf.MethodOptions} message MethodOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MethodOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpreted_option = [];
          if (options.defaults) {
            object.deprecated = false;
            object['.google.api.http'] = null;
          }
          if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
          if (message.uninterpreted_option && message.uninterpreted_option.length) {
            object.uninterpreted_option = [];
            for (var j = 0; j < message.uninterpreted_option.length; ++j)
              object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
          }
          if (message['.google.api.http'] != null && message.hasOwnProperty('.google.api.http'))
            object['.google.api.http'] = $root.google.api.HttpRule.toObject(message['.google.api.http'], options);
          return object;
        };

        /**
         * Converts this MethodOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.MethodOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MethodOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MethodOptions;
      })();

      protobuf.UninterpretedOption = (function () {
        /**
         * Properties of an UninterpretedOption.
         * @memberof google.protobuf
         * @interface IUninterpretedOption
         * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
         * @property {string|null} [identifier_value] UninterpretedOption identifier_value
         * @property {Long|null} [positive_int_value] UninterpretedOption positive_int_value
         * @property {Long|null} [negative_int_value] UninterpretedOption negative_int_value
         * @property {number|null} [double_value] UninterpretedOption double_value
         * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
         * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
         */

        /**
         * Constructs a new UninterpretedOption.
         * @memberof google.protobuf
         * @classdesc Represents an UninterpretedOption.
         * @implements IUninterpretedOption
         * @constructor
         * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
         */
        function UninterpretedOption(properties) {
          this.name = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * UninterpretedOption name.
         * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.name = $util.emptyArray;

        /**
         * UninterpretedOption identifier_value.
         * @member {string} identifier_value
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.identifier_value = '';

        /**
         * UninterpretedOption positive_int_value.
         * @member {Long} positive_int_value
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * UninterpretedOption negative_int_value.
         * @member {Long} negative_int_value
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * UninterpretedOption double_value.
         * @member {number} double_value
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.double_value = 0;

        /**
         * UninterpretedOption string_value.
         * @member {Uint8Array} string_value
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.string_value = $util.newBuffer([]);

        /**
         * UninterpretedOption aggregate_value.
         * @member {string} aggregate_value
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.aggregate_value = '';

        /**
         * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UninterpretedOption.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && message.name.length)
            for (var i = 0; i < message.name.length; ++i)
              $root.google.protobuf.UninterpretedOption.NamePart.encode(
                message.name[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.identifier_value != null && Object.hasOwnProperty.call(message, 'identifier_value'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.identifier_value);
          if (message.positive_int_value != null && Object.hasOwnProperty.call(message, 'positive_int_value'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.positive_int_value);
          if (message.negative_int_value != null && Object.hasOwnProperty.call(message, 'negative_int_value'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.negative_int_value);
          if (message.double_value != null && Object.hasOwnProperty.call(message, 'double_value'))
            writer.uint32(/* id 6, wireType 1 =*/ 49).double(message.double_value);
          if (message.string_value != null && Object.hasOwnProperty.call(message, 'string_value'))
            writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.string_value);
          if (message.aggregate_value != null && Object.hasOwnProperty.call(message, 'aggregate_value'))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.aggregate_value);
          return writer;
        };

        /**
         * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UninterpretedOption message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UninterpretedOption.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.UninterpretedOption();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 2:
                if (!(message.name && message.name.length)) message.name = [];
                message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                break;
              case 3:
                message.identifier_value = reader.string();
                break;
              case 4:
                message.positive_int_value = reader.uint64();
                break;
              case 5:
                message.negative_int_value = reader.int64();
                break;
              case 6:
                message.double_value = reader.double();
                break;
              case 7:
                message.string_value = reader.bytes();
                break;
              case 8:
                message.aggregate_value = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UninterpretedOption message.
         * @function verify
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UninterpretedOption.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.name != null && message.hasOwnProperty('name')) {
            if (!Array.isArray(message.name)) return 'name: array expected';
            for (var i = 0; i < message.name.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
              if (error) return 'name.' + error;
            }
          }
          if (message.identifier_value != null && message.hasOwnProperty('identifier_value'))
            if (!$util.isString(message.identifier_value)) return 'identifier_value: string expected';
          if (message.positive_int_value != null && message.hasOwnProperty('positive_int_value'))
            if (
              !$util.isInteger(message.positive_int_value) &&
              !(
                message.positive_int_value &&
                $util.isInteger(message.positive_int_value.low) &&
                $util.isInteger(message.positive_int_value.high)
              )
            )
              return 'positive_int_value: integer|Long expected';
          if (message.negative_int_value != null && message.hasOwnProperty('negative_int_value'))
            if (
              !$util.isInteger(message.negative_int_value) &&
              !(
                message.negative_int_value &&
                $util.isInteger(message.negative_int_value.low) &&
                $util.isInteger(message.negative_int_value.high)
              )
            )
              return 'negative_int_value: integer|Long expected';
          if (message.double_value != null && message.hasOwnProperty('double_value'))
            if (typeof message.double_value !== 'number') return 'double_value: number expected';
          if (message.string_value != null && message.hasOwnProperty('string_value'))
            if (!((message.string_value && typeof message.string_value.length === 'number') || $util.isString(message.string_value)))
              return 'string_value: buffer expected';
          if (message.aggregate_value != null && message.hasOwnProperty('aggregate_value'))
            if (!$util.isString(message.aggregate_value)) return 'aggregate_value: string expected';
          return null;
        };

        /**
         * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
         */
        UninterpretedOption.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.UninterpretedOption) return object;
          var message = new $root.google.protobuf.UninterpretedOption();
          if (object.name) {
            if (!Array.isArray(object.name)) throw TypeError('.google.protobuf.UninterpretedOption.name: array expected');
            message.name = [];
            for (var i = 0; i < object.name.length; ++i) {
              if (typeof object.name[i] !== 'object') throw TypeError('.google.protobuf.UninterpretedOption.name: object expected');
              message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
            }
          }
          if (object.identifier_value != null) message.identifier_value = String(object.identifier_value);
          if (object.positive_int_value != null)
            if ($util.Long) (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
            else if (typeof object.positive_int_value === 'string') message.positive_int_value = parseInt(object.positive_int_value, 10);
            else if (typeof object.positive_int_value === 'number') message.positive_int_value = object.positive_int_value;
            else if (typeof object.positive_int_value === 'object')
              message.positive_int_value = new $util.LongBits(
                object.positive_int_value.low >>> 0,
                object.positive_int_value.high >>> 0,
              ).toNumber(true);
          if (object.negative_int_value != null)
            if ($util.Long) (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
            else if (typeof object.negative_int_value === 'string') message.negative_int_value = parseInt(object.negative_int_value, 10);
            else if (typeof object.negative_int_value === 'number') message.negative_int_value = object.negative_int_value;
            else if (typeof object.negative_int_value === 'object')
              message.negative_int_value = new $util.LongBits(
                object.negative_int_value.low >>> 0,
                object.negative_int_value.high >>> 0,
              ).toNumber();
          if (object.double_value != null) message.double_value = Number(object.double_value);
          if (object.string_value != null)
            if (typeof object.string_value === 'string')
              $util.base64.decode(
                object.string_value,
                (message.string_value = $util.newBuffer($util.base64.length(object.string_value))),
                0,
              );
            else if (object.string_value.length) message.string_value = object.string_value;
          if (object.aggregate_value != null) message.aggregate_value = String(object.aggregate_value);
          return message;
        };

        /**
         * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UninterpretedOption.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.name = [];
          if (options.defaults) {
            object.identifier_value = '';
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.positive_int_value = options.longs === String ? '0' : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.negative_int_value = options.longs === String ? '0' : 0;
            object.double_value = 0;
            if (options.bytes === String) object.string_value = '';
            else {
              object.string_value = [];
              if (options.bytes !== Array) object.string_value = $util.newBuffer(object.string_value);
            }
            object.aggregate_value = '';
          }
          if (message.name && message.name.length) {
            object.name = [];
            for (var j = 0; j < message.name.length; ++j)
              object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
          }
          if (message.identifier_value != null && message.hasOwnProperty('identifier_value'))
            object.identifier_value = message.identifier_value;
          if (message.positive_int_value != null && message.hasOwnProperty('positive_int_value'))
            if (typeof message.positive_int_value === 'number')
              object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
            else
              object.positive_int_value =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.positive_int_value)
                  : options.longs === Number
                  ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true)
                  : message.positive_int_value;
          if (message.negative_int_value != null && message.hasOwnProperty('negative_int_value'))
            if (typeof message.negative_int_value === 'number')
              object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
            else
              object.negative_int_value =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.negative_int_value)
                  : options.longs === Number
                  ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber()
                  : message.negative_int_value;
          if (message.double_value != null && message.hasOwnProperty('double_value'))
            object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
          if (message.string_value != null && message.hasOwnProperty('string_value'))
            object.string_value =
              options.bytes === String
                ? $util.base64.encode(message.string_value, 0, message.string_value.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.string_value)
                : message.string_value;
          if (message.aggregate_value != null && message.hasOwnProperty('aggregate_value'))
            object.aggregate_value = message.aggregate_value;
          return object;
        };

        /**
         * Converts this UninterpretedOption to JSON.
         * @function toJSON
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UninterpretedOption.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        UninterpretedOption.NamePart = (function () {
          /**
           * Properties of a NamePart.
           * @memberof google.protobuf.UninterpretedOption
           * @interface INamePart
           * @property {string} name_part NamePart name_part
           * @property {boolean} is_extension NamePart is_extension
           */

          /**
           * Constructs a new NamePart.
           * @memberof google.protobuf.UninterpretedOption
           * @classdesc Represents a NamePart.
           * @implements INamePart
           * @constructor
           * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
           */
          function NamePart(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * NamePart name_part.
           * @member {string} name_part
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @instance
           */
          NamePart.prototype.name_part = '';

          /**
           * NamePart is_extension.
           * @member {boolean} is_extension
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @instance
           */
          NamePart.prototype.is_extension = false;

          /**
           * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          NamePart.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name_part);
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.is_extension);
            return writer;
          };

          /**
           * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          NamePart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a NamePart message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          NamePart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.UninterpretedOption.NamePart();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.name_part = reader.string();
                  break;
                case 2:
                  message.is_extension = reader.bool();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            if (!message.hasOwnProperty('name_part')) throw $util.ProtocolError("missing required 'name_part'", { instance: message });
            if (!message.hasOwnProperty('is_extension'))
              throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
            return message;
          };

          /**
           * Decodes a NamePart message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          NamePart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a NamePart message.
           * @function verify
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          NamePart.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (!$util.isString(message.name_part)) return 'name_part: string expected';
            if (typeof message.is_extension !== 'boolean') return 'is_extension: boolean expected';
            return null;
          };

          /**
           * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
           */
          NamePart.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart) return object;
            var message = new $root.google.protobuf.UninterpretedOption.NamePart();
            if (object.name_part != null) message.name_part = String(object.name_part);
            if (object.is_extension != null) message.is_extension = Boolean(object.is_extension);
            return message;
          };

          /**
           * Creates a plain object from a NamePart message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          NamePart.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.name_part = '';
              object.is_extension = false;
            }
            if (message.name_part != null && message.hasOwnProperty('name_part')) object.name_part = message.name_part;
            if (message.is_extension != null && message.hasOwnProperty('is_extension')) object.is_extension = message.is_extension;
            return object;
          };

          /**
           * Converts this NamePart to JSON.
           * @function toJSON
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          NamePart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return NamePart;
        })();

        return UninterpretedOption;
      })();

      protobuf.SourceCodeInfo = (function () {
        /**
         * Properties of a SourceCodeInfo.
         * @memberof google.protobuf
         * @interface ISourceCodeInfo
         * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
         */

        /**
         * Constructs a new SourceCodeInfo.
         * @memberof google.protobuf
         * @classdesc Represents a SourceCodeInfo.
         * @implements ISourceCodeInfo
         * @constructor
         * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
         */
        function SourceCodeInfo(properties) {
          this.location = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SourceCodeInfo location.
         * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
         * @memberof google.protobuf.SourceCodeInfo
         * @instance
         */
        SourceCodeInfo.prototype.location = $util.emptyArray;

        /**
         * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SourceCodeInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.google.protobuf.SourceCodeInfo.Location.encode(
                message.location[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SourceCodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SourceCodeInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.SourceCodeInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.location && message.location.length)) message.location = [];
                message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SourceCodeInfo message.
         * @function verify
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SourceCodeInfo.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.location != null && message.hasOwnProperty('location')) {
            if (!Array.isArray(message.location)) return 'location: array expected';
            for (var i = 0; i < message.location.length; ++i) {
              var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
              if (error) return 'location.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
         */
        SourceCodeInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.SourceCodeInfo) return object;
          var message = new $root.google.protobuf.SourceCodeInfo();
          if (object.location) {
            if (!Array.isArray(object.location)) throw TypeError('.google.protobuf.SourceCodeInfo.location: array expected');
            message.location = [];
            for (var i = 0; i < object.location.length; ++i) {
              if (typeof object.location[i] !== 'object') throw TypeError('.google.protobuf.SourceCodeInfo.location: object expected');
              message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SourceCodeInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.location = [];
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
          }
          return object;
        };

        /**
         * Converts this SourceCodeInfo to JSON.
         * @function toJSON
         * @memberof google.protobuf.SourceCodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SourceCodeInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SourceCodeInfo.Location = (function () {
          /**
           * Properties of a Location.
           * @memberof google.protobuf.SourceCodeInfo
           * @interface ILocation
           * @property {Array.<number>|null} [path] Location path
           * @property {Array.<number>|null} [span] Location span
           * @property {string|null} [leading_comments] Location leading_comments
           * @property {string|null} [trailing_comments] Location trailing_comments
           * @property {Array.<string>|null} [leading_detached_comments] Location leading_detached_comments
           */

          /**
           * Constructs a new Location.
           * @memberof google.protobuf.SourceCodeInfo
           * @classdesc Represents a Location.
           * @implements ILocation
           * @constructor
           * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
           */
          function Location(properties) {
            this.path = [];
            this.span = [];
            this.leading_detached_comments = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Location path.
           * @member {Array.<number>} path
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.path = $util.emptyArray;

          /**
           * Location span.
           * @member {Array.<number>} span
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.span = $util.emptyArray;

          /**
           * Location leading_comments.
           * @member {string} leading_comments
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.leading_comments = '';

          /**
           * Location trailing_comments.
           * @member {string} trailing_comments
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.trailing_comments = '';

          /**
           * Location leading_detached_comments.
           * @member {Array.<string>} leading_detached_comments
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.leading_detached_comments = $util.emptyArray;

          /**
           * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Location.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.path != null && message.path.length) {
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
              for (var i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
              writer.ldelim();
            }
            if (message.span != null && message.span.length) {
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
              for (var i = 0; i < message.span.length; ++i) writer.int32(message.span[i]);
              writer.ldelim();
            }
            if (message.leading_comments != null && Object.hasOwnProperty.call(message, 'leading_comments'))
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.leading_comments);
            if (message.trailing_comments != null && Object.hasOwnProperty.call(message, 'trailing_comments'))
              writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.trailing_comments);
            if (message.leading_detached_comments != null && message.leading_detached_comments.length)
              for (var i = 0; i < message.leading_detached_comments.length; ++i)
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.leading_detached_comments[i]);
            return writer;
          };

          /**
           * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Location.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Location message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.SourceCodeInfo.Location} Location
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Location.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.SourceCodeInfo.Location();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.path && message.path.length)) message.path = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2) message.path.push(reader.int32());
                  } else message.path.push(reader.int32());
                  break;
                case 2:
                  if (!(message.span && message.span.length)) message.span = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2) message.span.push(reader.int32());
                  } else message.span.push(reader.int32());
                  break;
                case 3:
                  message.leading_comments = reader.string();
                  break;
                case 4:
                  message.trailing_comments = reader.string();
                  break;
                case 6:
                  if (!(message.leading_detached_comments && message.leading_detached_comments.length))
                    message.leading_detached_comments = [];
                  message.leading_detached_comments.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Location message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.SourceCodeInfo.Location} Location
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Location.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Location message.
           * @function verify
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Location.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.path != null && message.hasOwnProperty('path')) {
              if (!Array.isArray(message.path)) return 'path: array expected';
              for (var i = 0; i < message.path.length; ++i) if (!$util.isInteger(message.path[i])) return 'path: integer[] expected';
            }
            if (message.span != null && message.hasOwnProperty('span')) {
              if (!Array.isArray(message.span)) return 'span: array expected';
              for (var i = 0; i < message.span.length; ++i) if (!$util.isInteger(message.span[i])) return 'span: integer[] expected';
            }
            if (message.leading_comments != null && message.hasOwnProperty('leading_comments'))
              if (!$util.isString(message.leading_comments)) return 'leading_comments: string expected';
            if (message.trailing_comments != null && message.hasOwnProperty('trailing_comments'))
              if (!$util.isString(message.trailing_comments)) return 'trailing_comments: string expected';
            if (message.leading_detached_comments != null && message.hasOwnProperty('leading_detached_comments')) {
              if (!Array.isArray(message.leading_detached_comments)) return 'leading_detached_comments: array expected';
              for (var i = 0; i < message.leading_detached_comments.length; ++i)
                if (!$util.isString(message.leading_detached_comments[i])) return 'leading_detached_comments: string[] expected';
            }
            return null;
          };

          /**
           * Creates a Location message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.SourceCodeInfo.Location} Location
           */
          Location.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.SourceCodeInfo.Location) return object;
            var message = new $root.google.protobuf.SourceCodeInfo.Location();
            if (object.path) {
              if (!Array.isArray(object.path)) throw TypeError('.google.protobuf.SourceCodeInfo.Location.path: array expected');
              message.path = [];
              for (var i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
            }
            if (object.span) {
              if (!Array.isArray(object.span)) throw TypeError('.google.protobuf.SourceCodeInfo.Location.span: array expected');
              message.span = [];
              for (var i = 0; i < object.span.length; ++i) message.span[i] = object.span[i] | 0;
            }
            if (object.leading_comments != null) message.leading_comments = String(object.leading_comments);
            if (object.trailing_comments != null) message.trailing_comments = String(object.trailing_comments);
            if (object.leading_detached_comments) {
              if (!Array.isArray(object.leading_detached_comments))
                throw TypeError('.google.protobuf.SourceCodeInfo.Location.leading_detached_comments: array expected');
              message.leading_detached_comments = [];
              for (var i = 0; i < object.leading_detached_comments.length; ++i)
                message.leading_detached_comments[i] = String(object.leading_detached_comments[i]);
            }
            return message;
          };

          /**
           * Creates a plain object from a Location message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {google.protobuf.SourceCodeInfo.Location} message Location
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Location.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.path = [];
              object.span = [];
              object.leading_detached_comments = [];
            }
            if (options.defaults) {
              object.leading_comments = '';
              object.trailing_comments = '';
            }
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
            }
            if (message.span && message.span.length) {
              object.span = [];
              for (var j = 0; j < message.span.length; ++j) object.span[j] = message.span[j];
            }
            if (message.leading_comments != null && message.hasOwnProperty('leading_comments'))
              object.leading_comments = message.leading_comments;
            if (message.trailing_comments != null && message.hasOwnProperty('trailing_comments'))
              object.trailing_comments = message.trailing_comments;
            if (message.leading_detached_comments && message.leading_detached_comments.length) {
              object.leading_detached_comments = [];
              for (var j = 0; j < message.leading_detached_comments.length; ++j)
                object.leading_detached_comments[j] = message.leading_detached_comments[j];
            }
            return object;
          };

          /**
           * Converts this Location to JSON.
           * @function toJSON
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Location.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Location;
        })();

        return SourceCodeInfo;
      })();

      protobuf.GeneratedCodeInfo = (function () {
        /**
         * Properties of a GeneratedCodeInfo.
         * @memberof google.protobuf
         * @interface IGeneratedCodeInfo
         * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
         */

        /**
         * Constructs a new GeneratedCodeInfo.
         * @memberof google.protobuf
         * @classdesc Represents a GeneratedCodeInfo.
         * @implements IGeneratedCodeInfo
         * @constructor
         * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
         */
        function GeneratedCodeInfo(properties) {
          this.annotation = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GeneratedCodeInfo annotation.
         * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
         * @memberof google.protobuf.GeneratedCodeInfo
         * @instance
         */
        GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

        /**
         * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeneratedCodeInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.annotation != null && message.annotation.length)
            for (var i = 0; i < message.annotation.length; ++i)
              $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(
                message.annotation[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeneratedCodeInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.GeneratedCodeInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.annotation && message.annotation.length)) message.annotation = [];
                message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GeneratedCodeInfo message.
         * @function verify
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GeneratedCodeInfo.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.annotation != null && message.hasOwnProperty('annotation')) {
            if (!Array.isArray(message.annotation)) return 'annotation: array expected';
            for (var i = 0; i < message.annotation.length; ++i) {
              var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
              if (error) return 'annotation.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
         */
        GeneratedCodeInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.GeneratedCodeInfo) return object;
          var message = new $root.google.protobuf.GeneratedCodeInfo();
          if (object.annotation) {
            if (!Array.isArray(object.annotation)) throw TypeError('.google.protobuf.GeneratedCodeInfo.annotation: array expected');
            message.annotation = [];
            for (var i = 0; i < object.annotation.length; ++i) {
              if (typeof object.annotation[i] !== 'object')
                throw TypeError('.google.protobuf.GeneratedCodeInfo.annotation: object expected');
              message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GeneratedCodeInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.annotation = [];
          if (message.annotation && message.annotation.length) {
            object.annotation = [];
            for (var j = 0; j < message.annotation.length; ++j)
              object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
          }
          return object;
        };

        /**
         * Converts this GeneratedCodeInfo to JSON.
         * @function toJSON
         * @memberof google.protobuf.GeneratedCodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GeneratedCodeInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GeneratedCodeInfo.Annotation = (function () {
          /**
           * Properties of an Annotation.
           * @memberof google.protobuf.GeneratedCodeInfo
           * @interface IAnnotation
           * @property {Array.<number>|null} [path] Annotation path
           * @property {string|null} [source_file] Annotation source_file
           * @property {number|null} [begin] Annotation begin
           * @property {number|null} [end] Annotation end
           */

          /**
           * Constructs a new Annotation.
           * @memberof google.protobuf.GeneratedCodeInfo
           * @classdesc Represents an Annotation.
           * @implements IAnnotation
           * @constructor
           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
           */
          function Annotation(properties) {
            this.path = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Annotation path.
           * @member {Array.<number>} path
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.path = $util.emptyArray;

          /**
           * Annotation source_file.
           * @member {string} source_file
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.source_file = '';

          /**
           * Annotation begin.
           * @member {number} begin
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.begin = 0;

          /**
           * Annotation end.
           * @member {number} end
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.end = 0;

          /**
           * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Annotation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.path != null && message.path.length) {
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
              for (var i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
              writer.ldelim();
            }
            if (message.source_file != null && Object.hasOwnProperty.call(message, 'source_file'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.source_file);
            if (message.begin != null && Object.hasOwnProperty.call(message, 'begin'))
              writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.begin);
            if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
              writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.end);
            return writer;
          };

          /**
           * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Annotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an Annotation message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Annotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.path && message.path.length)) message.path = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2) message.path.push(reader.int32());
                  } else message.path.push(reader.int32());
                  break;
                case 2:
                  message.source_file = reader.string();
                  break;
                case 3:
                  message.begin = reader.int32();
                  break;
                case 4:
                  message.end = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an Annotation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Annotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an Annotation message.
           * @function verify
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Annotation.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.path != null && message.hasOwnProperty('path')) {
              if (!Array.isArray(message.path)) return 'path: array expected';
              for (var i = 0; i < message.path.length; ++i) if (!$util.isInteger(message.path[i])) return 'path: integer[] expected';
            }
            if (message.source_file != null && message.hasOwnProperty('source_file'))
              if (!$util.isString(message.source_file)) return 'source_file: string expected';
            if (message.begin != null && message.hasOwnProperty('begin'))
              if (!$util.isInteger(message.begin)) return 'begin: integer expected';
            if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
            return null;
          };

          /**
           * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
           */
          Annotation.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation) return object;
            var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
            if (object.path) {
              if (!Array.isArray(object.path)) throw TypeError('.google.protobuf.GeneratedCodeInfo.Annotation.path: array expected');
              message.path = [];
              for (var i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
            }
            if (object.source_file != null) message.source_file = String(object.source_file);
            if (object.begin != null) message.begin = object.begin | 0;
            if (object.end != null) message.end = object.end | 0;
            return message;
          };

          /**
           * Creates a plain object from an Annotation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Annotation.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) object.path = [];
            if (options.defaults) {
              object.source_file = '';
              object.begin = 0;
              object.end = 0;
            }
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
            }
            if (message.source_file != null && message.hasOwnProperty('source_file')) object.source_file = message.source_file;
            if (message.begin != null && message.hasOwnProperty('begin')) object.begin = message.begin;
            if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
            return object;
          };

          /**
           * Converts this Annotation to JSON.
           * @function toJSON
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Annotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Annotation;
        })();

        return GeneratedCodeInfo;
      })();

      protobuf.Any = (function () {
        /**
         * Properties of an Any.
         * @memberof google.protobuf
         * @interface IAny
         * @property {string|null} [type_url] Any type_url
         * @property {Uint8Array|null} [value] Any value
         */

        /**
         * Constructs a new Any.
         * @memberof google.protobuf
         * @classdesc Represents an Any.
         * @implements IAny
         * @constructor
         * @param {google.protobuf.IAny=} [properties] Properties to set
         */
        function Any(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Any type_url.
         * @member {string} type_url
         * @memberof google.protobuf.Any
         * @instance
         */
        Any.prototype.type_url = '';

        /**
         * Any value.
         * @member {Uint8Array} value
         * @memberof google.protobuf.Any
         * @instance
         */
        Any.prototype.value = $util.newBuffer([]);

        /**
         * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.Any
         * @static
         * @param {google.protobuf.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.type_url != null && Object.hasOwnProperty.call(message, 'type_url'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type_url);
          if (message.value != null && Object.hasOwnProperty.call(message, 'value'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
          return writer;
        };

        /**
         * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.Any
         * @static
         * @param {google.protobuf.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Any message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.Any();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.type_url = reader.string();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Any message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Any message.
         * @function verify
         * @memberof google.protobuf.Any
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Any.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.type_url != null && message.hasOwnProperty('type_url'))
            if (!$util.isString(message.type_url)) return 'type_url: string expected';
          if (message.value != null && message.hasOwnProperty('value'))
            if (!((message.value && typeof message.value.length === 'number') || $util.isString(message.value)))
              return 'value: buffer expected';
          return null;
        };

        /**
         * Creates an Any message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.Any
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.Any} Any
         */
        Any.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.Any) return object;
          var message = new $root.google.protobuf.Any();
          if (object.type_url != null) message.type_url = String(object.type_url);
          if (object.value != null)
            if (typeof object.value === 'string')
              $util.base64.decode(object.value, (message.value = $util.newBuffer($util.base64.length(object.value))), 0);
            else if (object.value.length) message.value = object.value;
          return message;
        };

        /**
         * Creates a plain object from an Any message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.Any
         * @static
         * @param {google.protobuf.Any} message Any
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Any.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.type_url = '';
            if (options.bytes === String) object.value = '';
            else {
              object.value = [];
              if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
            }
          }
          if (message.type_url != null && message.hasOwnProperty('type_url')) object.type_url = message.type_url;
          if (message.value != null && message.hasOwnProperty('value'))
            object.value =
              options.bytes === String
                ? $util.base64.encode(message.value, 0, message.value.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.value)
                : message.value;
          return object;
        };

        /**
         * Converts this Any to JSON.
         * @function toJSON
         * @memberof google.protobuf.Any
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Any.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Any;
      })();

      protobuf.Timestamp = (function () {
        /**
         * Properties of a Timestamp.
         * @memberof google.protobuf
         * @interface ITimestamp
         * @property {Long|null} [seconds] Timestamp seconds
         * @property {number|null} [nanos] Timestamp nanos
         */

        /**
         * Constructs a new Timestamp.
         * @memberof google.protobuf
         * @classdesc Represents a Timestamp.
         * @implements ITimestamp
         * @constructor
         * @param {google.protobuf.ITimestamp=} [properties] Properties to set
         */
        function Timestamp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timestamp seconds.
         * @member {Long} seconds
         * @memberof google.protobuf.Timestamp
         * @instance
         */
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Timestamp nanos.
         * @member {number} nanos
         * @memberof google.protobuf.Timestamp
         * @instance
         */
        Timestamp.prototype.nanos = 0;

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.seconds != null && Object.hasOwnProperty.call(message, 'seconds'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
          if (message.nanos != null && Object.hasOwnProperty.call(message, 'nanos'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
          return writer;
        };

        /**
         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.Timestamp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.seconds = reader.int64();
                break;
              case 2:
                message.nanos = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timestamp message.
         * @function verify
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timestamp.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.seconds != null && message.hasOwnProperty('seconds'))
            if (
              !$util.isInteger(message.seconds) &&
              !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))
            )
              return 'seconds: integer|Long expected';
          if (message.nanos != null && message.hasOwnProperty('nanos'))
            if (!$util.isInteger(message.nanos)) return 'nanos: integer expected';
          return null;
        };

        /**
         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.Timestamp} Timestamp
         */
        Timestamp.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.Timestamp) return object;
          var message = new $root.google.protobuf.Timestamp();
          if (object.seconds != null)
            if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
            else if (typeof object.seconds === 'string') message.seconds = parseInt(object.seconds, 10);
            else if (typeof object.seconds === 'number') message.seconds = object.seconds;
            else if (typeof object.seconds === 'object')
              message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
          if (object.nanos != null) message.nanos = object.nanos | 0;
          return message;
        };

        /**
         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {google.protobuf.Timestamp} message Timestamp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timestamp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.seconds = options.longs === String ? '0' : 0;
            object.nanos = 0;
          }
          if (message.seconds != null && message.hasOwnProperty('seconds'))
            if (typeof message.seconds === 'number') object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
            else
              object.seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.seconds)
                  : options.longs === Number
                  ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                  : message.seconds;
          if (message.nanos != null && message.hasOwnProperty('nanos')) object.nanos = message.nanos;
          return object;
        };

        /**
         * Converts this Timestamp to JSON.
         * @function toJSON
         * @memberof google.protobuf.Timestamp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timestamp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Timestamp;
      })();

      protobuf.Duration = (function () {
        /**
         * Properties of a Duration.
         * @memberof google.protobuf
         * @interface IDuration
         * @property {Long|null} [seconds] Duration seconds
         * @property {number|null} [nanos] Duration nanos
         */

        /**
         * Constructs a new Duration.
         * @memberof google.protobuf
         * @classdesc Represents a Duration.
         * @implements IDuration
         * @constructor
         * @param {google.protobuf.IDuration=} [properties] Properties to set
         */
        function Duration(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Duration seconds.
         * @member {Long} seconds
         * @memberof google.protobuf.Duration
         * @instance
         */
        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Duration nanos.
         * @member {number} nanos
         * @memberof google.protobuf.Duration
         * @instance
         */
        Duration.prototype.nanos = 0;

        /**
         * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.Duration
         * @static
         * @param {google.protobuf.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.seconds != null && Object.hasOwnProperty.call(message, 'seconds'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
          if (message.nanos != null && Object.hasOwnProperty.call(message, 'nanos'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
          return writer;
        };

        /**
         * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.Duration
         * @static
         * @param {google.protobuf.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.Duration();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.seconds = reader.int64();
                break;
              case 2:
                message.nanos = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Duration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Duration message.
         * @function verify
         * @memberof google.protobuf.Duration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Duration.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.seconds != null && message.hasOwnProperty('seconds'))
            if (
              !$util.isInteger(message.seconds) &&
              !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))
            )
              return 'seconds: integer|Long expected';
          if (message.nanos != null && message.hasOwnProperty('nanos'))
            if (!$util.isInteger(message.nanos)) return 'nanos: integer expected';
          return null;
        };

        /**
         * Creates a Duration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.Duration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.Duration} Duration
         */
        Duration.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.Duration) return object;
          var message = new $root.google.protobuf.Duration();
          if (object.seconds != null)
            if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
            else if (typeof object.seconds === 'string') message.seconds = parseInt(object.seconds, 10);
            else if (typeof object.seconds === 'number') message.seconds = object.seconds;
            else if (typeof object.seconds === 'object')
              message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
          if (object.nanos != null) message.nanos = object.nanos | 0;
          return message;
        };

        /**
         * Creates a plain object from a Duration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.Duration
         * @static
         * @param {google.protobuf.Duration} message Duration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Duration.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.seconds = options.longs === String ? '0' : 0;
            object.nanos = 0;
          }
          if (message.seconds != null && message.hasOwnProperty('seconds'))
            if (typeof message.seconds === 'number') object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
            else
              object.seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.seconds)
                  : options.longs === Number
                  ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                  : message.seconds;
          if (message.nanos != null && message.hasOwnProperty('nanos')) object.nanos = message.nanos;
          return object;
        };

        /**
         * Converts this Duration to JSON.
         * @function toJSON
         * @memberof google.protobuf.Duration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Duration.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Duration;
      })();

      return protobuf;
    })();

    return google;
  })();

  return $root;
});
