/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["ununifi-client"] || ($protobuf.roots["ununifi-client"] = {});
    
    $root.ununifi = (function() {
    
        /**
         * Namespace ununifi.
         * @exports ununifi
         * @namespace
         */
        var ununifi = {};
    
        ununifi.derivatives = (function() {
    
            /**
             * Namespace derivatives.
             * @memberof ununifi
             * @namespace
             */
            var derivatives = {};
    
            derivatives.Msg = (function() {
    
                /**
                 * Constructs a new Msg service.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a Msg
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Msg(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#depositToPool}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef DepositToPoolCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgDepositToPoolResponse} [response] MsgDepositToPoolResponse
                 */
    
                /**
                 * Calls DepositToPool.
                 * @function depositToPool
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgDepositToPool} request MsgDepositToPool message or plain object
                 * @param {ununifi.derivatives.Msg.DepositToPoolCallback} callback Node-style callback called with the error, if any, and MsgDepositToPoolResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.depositToPool = function depositToPool(request, callback) {
                    return this.rpcCall(depositToPool, $root.ununifi.derivatives.MsgDepositToPool, $root.ununifi.derivatives.MsgDepositToPoolResponse, request, callback);
                }, "name", { value: "DepositToPool" });
    
                /**
                 * Calls DepositToPool.
                 * @function depositToPool
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgDepositToPool} request MsgDepositToPool message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgDepositToPoolResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#withdrawFromPool}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef WithdrawFromPoolCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgWithdrawFromPoolResponse} [response] MsgWithdrawFromPoolResponse
                 */
    
                /**
                 * Calls WithdrawFromPool.
                 * @function withdrawFromPool
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgWithdrawFromPool} request MsgWithdrawFromPool message or plain object
                 * @param {ununifi.derivatives.Msg.WithdrawFromPoolCallback} callback Node-style callback called with the error, if any, and MsgWithdrawFromPoolResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.withdrawFromPool = function withdrawFromPool(request, callback) {
                    return this.rpcCall(withdrawFromPool, $root.ununifi.derivatives.MsgWithdrawFromPool, $root.ununifi.derivatives.MsgWithdrawFromPoolResponse, request, callback);
                }, "name", { value: "WithdrawFromPool" });
    
                /**
                 * Calls WithdrawFromPool.
                 * @function withdrawFromPool
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgWithdrawFromPool} request MsgWithdrawFromPool message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgWithdrawFromPoolResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#openPosition}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef OpenPositionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgOpenPositionResponse} [response] MsgOpenPositionResponse
                 */
    
                /**
                 * Calls OpenPosition.
                 * @function openPosition
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgOpenPosition} request MsgOpenPosition message or plain object
                 * @param {ununifi.derivatives.Msg.OpenPositionCallback} callback Node-style callback called with the error, if any, and MsgOpenPositionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.openPosition = function openPosition(request, callback) {
                    return this.rpcCall(openPosition, $root.ununifi.derivatives.MsgOpenPosition, $root.ununifi.derivatives.MsgOpenPositionResponse, request, callback);
                }, "name", { value: "OpenPosition" });
    
                /**
                 * Calls OpenPosition.
                 * @function openPosition
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgOpenPosition} request MsgOpenPosition message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgOpenPositionResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#closePosition}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef ClosePositionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgClosePositionResponse} [response] MsgClosePositionResponse
                 */
    
                /**
                 * Calls ClosePosition.
                 * @function closePosition
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgClosePosition} request MsgClosePosition message or plain object
                 * @param {ununifi.derivatives.Msg.ClosePositionCallback} callback Node-style callback called with the error, if any, and MsgClosePositionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.closePosition = function closePosition(request, callback) {
                    return this.rpcCall(closePosition, $root.ununifi.derivatives.MsgClosePosition, $root.ununifi.derivatives.MsgClosePositionResponse, request, callback);
                }, "name", { value: "ClosePosition" });
    
                /**
                 * Calls ClosePosition.
                 * @function closePosition
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgClosePosition} request MsgClosePosition message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgClosePositionResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#reportLiquidation}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef ReportLiquidationCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgReportLiquidationResponse} [response] MsgReportLiquidationResponse
                 */
    
                /**
                 * Calls ReportLiquidation.
                 * @function reportLiquidation
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgReportLiquidation} request MsgReportLiquidation message or plain object
                 * @param {ununifi.derivatives.Msg.ReportLiquidationCallback} callback Node-style callback called with the error, if any, and MsgReportLiquidationResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.reportLiquidation = function reportLiquidation(request, callback) {
                    return this.rpcCall(reportLiquidation, $root.ununifi.derivatives.MsgReportLiquidation, $root.ununifi.derivatives.MsgReportLiquidationResponse, request, callback);
                }, "name", { value: "ReportLiquidation" });
    
                /**
                 * Calls ReportLiquidation.
                 * @function reportLiquidation
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgReportLiquidation} request MsgReportLiquidation message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgReportLiquidationResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#reportLevyPeriod}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef ReportLevyPeriodCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgReportLevyPeriodResponse} [response] MsgReportLevyPeriodResponse
                 */
    
                /**
                 * Calls ReportLevyPeriod.
                 * @function reportLevyPeriod
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgReportLevyPeriod} request MsgReportLevyPeriod message or plain object
                 * @param {ununifi.derivatives.Msg.ReportLevyPeriodCallback} callback Node-style callback called with the error, if any, and MsgReportLevyPeriodResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.reportLevyPeriod = function reportLevyPeriod(request, callback) {
                    return this.rpcCall(reportLevyPeriod, $root.ununifi.derivatives.MsgReportLevyPeriod, $root.ununifi.derivatives.MsgReportLevyPeriodResponse, request, callback);
                }, "name", { value: "ReportLevyPeriod" });
    
                /**
                 * Calls ReportLevyPeriod.
                 * @function reportLevyPeriod
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgReportLevyPeriod} request MsgReportLevyPeriod message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgReportLevyPeriodResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#addMargin}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef AddMarginCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgAddMarginResponse} [response] MsgAddMarginResponse
                 */
    
                /**
                 * Calls AddMargin.
                 * @function addMargin
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgAddMargin} request MsgAddMargin message or plain object
                 * @param {ununifi.derivatives.Msg.AddMarginCallback} callback Node-style callback called with the error, if any, and MsgAddMarginResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.addMargin = function addMargin(request, callback) {
                    return this.rpcCall(addMargin, $root.ununifi.derivatives.MsgAddMargin, $root.ununifi.derivatives.MsgAddMarginResponse, request, callback);
                }, "name", { value: "AddMargin" });
    
                /**
                 * Calls AddMargin.
                 * @function addMargin
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgAddMargin} request MsgAddMargin message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgAddMarginResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Msg#removeMargin}.
                 * @memberof ununifi.derivatives.Msg
                 * @typedef RemoveMarginCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.MsgRemoveMarginResponse} [response] MsgRemoveMarginResponse
                 */
    
                /**
                 * Calls RemoveMargin.
                 * @function removeMargin
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgRemoveMargin} request MsgRemoveMargin message or plain object
                 * @param {ununifi.derivatives.Msg.RemoveMarginCallback} callback Node-style callback called with the error, if any, and MsgRemoveMarginResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.removeMargin = function removeMargin(request, callback) {
                    return this.rpcCall(removeMargin, $root.ununifi.derivatives.MsgRemoveMargin, $root.ununifi.derivatives.MsgRemoveMarginResponse, request, callback);
                }, "name", { value: "RemoveMargin" });
    
                /**
                 * Calls RemoveMargin.
                 * @function removeMargin
                 * @memberof ununifi.derivatives.Msg
                 * @instance
                 * @param {ununifi.derivatives.IMsgRemoveMargin} request MsgRemoveMargin message or plain object
                 * @returns {Promise<ununifi.derivatives.MsgRemoveMarginResponse>} Promise
                 * @variation 2
                 */
    
                return Msg;
            })();
    
            derivatives.MsgDepositToPool = (function() {
    
                /**
                 * Properties of a MsgDepositToPool.
                 * @memberof ununifi.derivatives
                 * @interface IMsgDepositToPool
                 * @property {string|null} [sender] MsgDepositToPool sender
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgDepositToPool amount
                 */
    
                /**
                 * Constructs a new MsgDepositToPool.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgDepositToPool.
                 * @implements IMsgDepositToPool
                 * @constructor
                 * @param {ununifi.derivatives.IMsgDepositToPool=} [properties] Properties to set
                 */
                function MsgDepositToPool(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgDepositToPool sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @instance
                 */
                MsgDepositToPool.prototype.sender = "";
    
                /**
                 * MsgDepositToPool amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @instance
                 */
                MsgDepositToPool.prototype.amount = null;
    
                /**
                 * Encodes the specified MsgDepositToPool message. Does not implicitly {@link ununifi.derivatives.MsgDepositToPool.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @static
                 * @param {ununifi.derivatives.IMsgDepositToPool} message MsgDepositToPool message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToPool.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgDepositToPool message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgDepositToPool.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @static
                 * @param {ununifi.derivatives.IMsgDepositToPool} message MsgDepositToPool message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToPool.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgDepositToPool message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgDepositToPool} MsgDepositToPool
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToPool.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgDepositToPool();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgDepositToPool message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgDepositToPool} MsgDepositToPool
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToPool.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgDepositToPool message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgDepositToPool.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgDepositToPool message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgDepositToPool} MsgDepositToPool
                 */
                MsgDepositToPool.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgDepositToPool)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgDepositToPool();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.derivatives.MsgDepositToPool.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgDepositToPool message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @static
                 * @param {ununifi.derivatives.MsgDepositToPool} message MsgDepositToPool
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgDepositToPool.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.amount = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    return object;
                };
    
                /**
                 * Converts this MsgDepositToPool to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgDepositToPool
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgDepositToPool.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgDepositToPool;
            })();
    
            derivatives.MsgDepositToPoolResponse = (function() {
    
                /**
                 * Properties of a MsgDepositToPoolResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgDepositToPoolResponse
                 */
    
                /**
                 * Constructs a new MsgDepositToPoolResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgDepositToPoolResponse.
                 * @implements IMsgDepositToPoolResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgDepositToPoolResponse=} [properties] Properties to set
                 */
                function MsgDepositToPoolResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgDepositToPoolResponse message. Does not implicitly {@link ununifi.derivatives.MsgDepositToPoolResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgDepositToPoolResponse} message MsgDepositToPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToPoolResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgDepositToPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgDepositToPoolResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgDepositToPoolResponse} message MsgDepositToPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgDepositToPoolResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgDepositToPoolResponse} MsgDepositToPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToPoolResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgDepositToPoolResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgDepositToPoolResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgDepositToPoolResponse} MsgDepositToPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToPoolResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgDepositToPoolResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgDepositToPoolResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgDepositToPoolResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgDepositToPoolResponse} MsgDepositToPoolResponse
                 */
                MsgDepositToPoolResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgDepositToPoolResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgDepositToPoolResponse();
                };
    
                /**
                 * Creates a plain object from a MsgDepositToPoolResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @static
                 * @param {ununifi.derivatives.MsgDepositToPoolResponse} message MsgDepositToPoolResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgDepositToPoolResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgDepositToPoolResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgDepositToPoolResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgDepositToPoolResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgDepositToPoolResponse;
            })();
    
            derivatives.MsgWithdrawFromPool = (function() {
    
                /**
                 * Properties of a MsgWithdrawFromPool.
                 * @memberof ununifi.derivatives
                 * @interface IMsgWithdrawFromPool
                 * @property {string|null} [sender] MsgWithdrawFromPool sender
                 * @property {string|null} [lpt_amount] MsgWithdrawFromPool lpt_amount
                 * @property {string|null} [redeem_denom] MsgWithdrawFromPool redeem_denom
                 */
    
                /**
                 * Constructs a new MsgWithdrawFromPool.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgWithdrawFromPool.
                 * @implements IMsgWithdrawFromPool
                 * @constructor
                 * @param {ununifi.derivatives.IMsgWithdrawFromPool=} [properties] Properties to set
                 */
                function MsgWithdrawFromPool(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgWithdrawFromPool sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @instance
                 */
                MsgWithdrawFromPool.prototype.sender = "";
    
                /**
                 * MsgWithdrawFromPool lpt_amount.
                 * @member {string} lpt_amount
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @instance
                 */
                MsgWithdrawFromPool.prototype.lpt_amount = "";
    
                /**
                 * MsgWithdrawFromPool redeem_denom.
                 * @member {string} redeem_denom
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @instance
                 */
                MsgWithdrawFromPool.prototype.redeem_denom = "";
    
                /**
                 * Encodes the specified MsgWithdrawFromPool message. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPool.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @static
                 * @param {ununifi.derivatives.IMsgWithdrawFromPool} message MsgWithdrawFromPool message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromPool.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.lpt_amount != null && Object.hasOwnProperty.call(message, "lpt_amount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.lpt_amount);
                    if (message.redeem_denom != null && Object.hasOwnProperty.call(message, "redeem_denom"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.redeem_denom);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawFromPool message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPool.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @static
                 * @param {ununifi.derivatives.IMsgWithdrawFromPool} message MsgWithdrawFromPool message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromPool.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawFromPool message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgWithdrawFromPool} MsgWithdrawFromPool
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromPool.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgWithdrawFromPool();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.lpt_amount = reader.string();
                            break;
                        case 3:
                            message.redeem_denom = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawFromPool message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgWithdrawFromPool} MsgWithdrawFromPool
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromPool.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawFromPool message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawFromPool.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.lpt_amount != null && message.hasOwnProperty("lpt_amount"))
                        if (!$util.isString(message.lpt_amount))
                            return "lpt_amount: string expected";
                    if (message.redeem_denom != null && message.hasOwnProperty("redeem_denom"))
                        if (!$util.isString(message.redeem_denom))
                            return "redeem_denom: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawFromPool message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgWithdrawFromPool} MsgWithdrawFromPool
                 */
                MsgWithdrawFromPool.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgWithdrawFromPool)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgWithdrawFromPool();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.lpt_amount != null)
                        message.lpt_amount = String(object.lpt_amount);
                    if (object.redeem_denom != null)
                        message.redeem_denom = String(object.redeem_denom);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawFromPool message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @static
                 * @param {ununifi.derivatives.MsgWithdrawFromPool} message MsgWithdrawFromPool
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawFromPool.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.lpt_amount = "";
                        object.redeem_denom = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.lpt_amount != null && message.hasOwnProperty("lpt_amount"))
                        object.lpt_amount = message.lpt_amount;
                    if (message.redeem_denom != null && message.hasOwnProperty("redeem_denom"))
                        object.redeem_denom = message.redeem_denom;
                    return object;
                };
    
                /**
                 * Converts this MsgWithdrawFromPool to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgWithdrawFromPool
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawFromPool.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawFromPool;
            })();
    
            derivatives.MsgWithdrawFromPoolResponse = (function() {
    
                /**
                 * Properties of a MsgWithdrawFromPoolResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgWithdrawFromPoolResponse
                 */
    
                /**
                 * Constructs a new MsgWithdrawFromPoolResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgWithdrawFromPoolResponse.
                 * @implements IMsgWithdrawFromPoolResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgWithdrawFromPoolResponse=} [properties] Properties to set
                 */
                function MsgWithdrawFromPoolResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgWithdrawFromPoolResponse message. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPoolResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgWithdrawFromPoolResponse} message MsgWithdrawFromPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromPoolResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawFromPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPoolResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgWithdrawFromPoolResponse} message MsgWithdrawFromPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawFromPoolResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgWithdrawFromPoolResponse} MsgWithdrawFromPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromPoolResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgWithdrawFromPoolResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawFromPoolResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgWithdrawFromPoolResponse} MsgWithdrawFromPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromPoolResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawFromPoolResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawFromPoolResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawFromPoolResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgWithdrawFromPoolResponse} MsgWithdrawFromPoolResponse
                 */
                MsgWithdrawFromPoolResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgWithdrawFromPoolResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgWithdrawFromPoolResponse();
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawFromPoolResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @static
                 * @param {ununifi.derivatives.MsgWithdrawFromPoolResponse} message MsgWithdrawFromPoolResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawFromPoolResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgWithdrawFromPoolResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawFromPoolResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawFromPoolResponse;
            })();
    
            derivatives.MsgOpenPosition = (function() {
    
                /**
                 * Properties of a MsgOpenPosition.
                 * @memberof ununifi.derivatives
                 * @interface IMsgOpenPosition
                 * @property {string|null} [sender] MsgOpenPosition sender
                 * @property {cosmos.base.v1beta1.ICoin|null} [margin] MsgOpenPosition margin
                 * @property {ununifi.derivatives.IMarket|null} [market] MsgOpenPosition market
                 * @property {google.protobuf.IAny|null} [position_instance] MsgOpenPosition position_instance
                 */
    
                /**
                 * Constructs a new MsgOpenPosition.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgOpenPosition.
                 * @implements IMsgOpenPosition
                 * @constructor
                 * @param {ununifi.derivatives.IMsgOpenPosition=} [properties] Properties to set
                 */
                function MsgOpenPosition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgOpenPosition sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @instance
                 */
                MsgOpenPosition.prototype.sender = "";
    
                /**
                 * MsgOpenPosition margin.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} margin
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @instance
                 */
                MsgOpenPosition.prototype.margin = null;
    
                /**
                 * MsgOpenPosition market.
                 * @member {ununifi.derivatives.IMarket|null|undefined} market
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @instance
                 */
                MsgOpenPosition.prototype.market = null;
    
                /**
                 * MsgOpenPosition position_instance.
                 * @member {google.protobuf.IAny|null|undefined} position_instance
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @instance
                 */
                MsgOpenPosition.prototype.position_instance = null;
    
                /**
                 * Encodes the specified MsgOpenPosition message. Does not implicitly {@link ununifi.derivatives.MsgOpenPosition.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @static
                 * @param {ununifi.derivatives.IMsgOpenPosition} message MsgOpenPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgOpenPosition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.margin != null && Object.hasOwnProperty.call(message, "margin"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.margin, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.market != null && Object.hasOwnProperty.call(message, "market"))
                        $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.position_instance != null && Object.hasOwnProperty.call(message, "position_instance"))
                        $root.google.protobuf.Any.encode(message.position_instance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgOpenPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgOpenPosition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @static
                 * @param {ununifi.derivatives.IMsgOpenPosition} message MsgOpenPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgOpenPosition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgOpenPosition message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgOpenPosition} MsgOpenPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgOpenPosition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgOpenPosition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.position_instance = $root.google.protobuf.Any.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgOpenPosition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgOpenPosition} MsgOpenPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgOpenPosition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgOpenPosition message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgOpenPosition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.margin != null && message.hasOwnProperty("margin")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.margin);
                        if (error)
                            return "margin." + error;
                    }
                    if (message.market != null && message.hasOwnProperty("market")) {
                        var error = $root.ununifi.derivatives.Market.verify(message.market);
                        if (error)
                            return "market." + error;
                    }
                    if (message.position_instance != null && message.hasOwnProperty("position_instance")) {
                        var error = $root.google.protobuf.Any.verify(message.position_instance);
                        if (error)
                            return "position_instance." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgOpenPosition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgOpenPosition} MsgOpenPosition
                 */
                MsgOpenPosition.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgOpenPosition)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgOpenPosition();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.margin != null) {
                        if (typeof object.margin !== "object")
                            throw TypeError(".ununifi.derivatives.MsgOpenPosition.margin: object expected");
                        message.margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.margin);
                    }
                    if (object.market != null) {
                        if (typeof object.market !== "object")
                            throw TypeError(".ununifi.derivatives.MsgOpenPosition.market: object expected");
                        message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
                    }
                    if (object.position_instance != null) {
                        if (typeof object.position_instance !== "object")
                            throw TypeError(".ununifi.derivatives.MsgOpenPosition.position_instance: object expected");
                        message.position_instance = $root.google.protobuf.Any.fromObject(object.position_instance);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgOpenPosition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @static
                 * @param {ununifi.derivatives.MsgOpenPosition} message MsgOpenPosition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgOpenPosition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.margin = null;
                        object.market = null;
                        object.position_instance = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.margin != null && message.hasOwnProperty("margin"))
                        object.margin = $root.cosmos.base.v1beta1.Coin.toObject(message.margin, options);
                    if (message.market != null && message.hasOwnProperty("market"))
                        object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
                    if (message.position_instance != null && message.hasOwnProperty("position_instance"))
                        object.position_instance = $root.google.protobuf.Any.toObject(message.position_instance, options);
                    return object;
                };
    
                /**
                 * Converts this MsgOpenPosition to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgOpenPosition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgOpenPosition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgOpenPosition;
            })();
    
            derivatives.MsgOpenPositionResponse = (function() {
    
                /**
                 * Properties of a MsgOpenPositionResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgOpenPositionResponse
                 */
    
                /**
                 * Constructs a new MsgOpenPositionResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgOpenPositionResponse.
                 * @implements IMsgOpenPositionResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgOpenPositionResponse=} [properties] Properties to set
                 */
                function MsgOpenPositionResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgOpenPositionResponse message. Does not implicitly {@link ununifi.derivatives.MsgOpenPositionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgOpenPositionResponse} message MsgOpenPositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgOpenPositionResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgOpenPositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgOpenPositionResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgOpenPositionResponse} message MsgOpenPositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgOpenPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgOpenPositionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgOpenPositionResponse} MsgOpenPositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgOpenPositionResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgOpenPositionResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgOpenPositionResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgOpenPositionResponse} MsgOpenPositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgOpenPositionResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgOpenPositionResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgOpenPositionResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgOpenPositionResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgOpenPositionResponse} MsgOpenPositionResponse
                 */
                MsgOpenPositionResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgOpenPositionResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgOpenPositionResponse();
                };
    
                /**
                 * Creates a plain object from a MsgOpenPositionResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @static
                 * @param {ununifi.derivatives.MsgOpenPositionResponse} message MsgOpenPositionResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgOpenPositionResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgOpenPositionResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgOpenPositionResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgOpenPositionResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgOpenPositionResponse;
            })();
    
            derivatives.MsgClosePosition = (function() {
    
                /**
                 * Properties of a MsgClosePosition.
                 * @memberof ununifi.derivatives
                 * @interface IMsgClosePosition
                 * @property {string|null} [sender] MsgClosePosition sender
                 * @property {string|null} [position_id] MsgClosePosition position_id
                 */
    
                /**
                 * Constructs a new MsgClosePosition.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgClosePosition.
                 * @implements IMsgClosePosition
                 * @constructor
                 * @param {ununifi.derivatives.IMsgClosePosition=} [properties] Properties to set
                 */
                function MsgClosePosition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgClosePosition sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @instance
                 */
                MsgClosePosition.prototype.sender = "";
    
                /**
                 * MsgClosePosition position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @instance
                 */
                MsgClosePosition.prototype.position_id = "";
    
                /**
                 * Encodes the specified MsgClosePosition message. Does not implicitly {@link ununifi.derivatives.MsgClosePosition.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @static
                 * @param {ununifi.derivatives.IMsgClosePosition} message MsgClosePosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgClosePosition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgClosePosition message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgClosePosition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @static
                 * @param {ununifi.derivatives.IMsgClosePosition} message MsgClosePosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgClosePosition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgClosePosition message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgClosePosition} MsgClosePosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgClosePosition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgClosePosition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgClosePosition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgClosePosition} MsgClosePosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgClosePosition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgClosePosition message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgClosePosition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgClosePosition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgClosePosition} MsgClosePosition
                 */
                MsgClosePosition.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgClosePosition)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgClosePosition();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgClosePosition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @static
                 * @param {ununifi.derivatives.MsgClosePosition} message MsgClosePosition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgClosePosition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.position_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this MsgClosePosition to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgClosePosition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgClosePosition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgClosePosition;
            })();
    
            derivatives.MsgClosePositionResponse = (function() {
    
                /**
                 * Properties of a MsgClosePositionResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgClosePositionResponse
                 */
    
                /**
                 * Constructs a new MsgClosePositionResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgClosePositionResponse.
                 * @implements IMsgClosePositionResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgClosePositionResponse=} [properties] Properties to set
                 */
                function MsgClosePositionResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgClosePositionResponse message. Does not implicitly {@link ununifi.derivatives.MsgClosePositionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgClosePositionResponse} message MsgClosePositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgClosePositionResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgClosePositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgClosePositionResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgClosePositionResponse} message MsgClosePositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgClosePositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgClosePositionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgClosePositionResponse} MsgClosePositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgClosePositionResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgClosePositionResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgClosePositionResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgClosePositionResponse} MsgClosePositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgClosePositionResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgClosePositionResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgClosePositionResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgClosePositionResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgClosePositionResponse} MsgClosePositionResponse
                 */
                MsgClosePositionResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgClosePositionResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgClosePositionResponse();
                };
    
                /**
                 * Creates a plain object from a MsgClosePositionResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @static
                 * @param {ununifi.derivatives.MsgClosePositionResponse} message MsgClosePositionResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgClosePositionResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgClosePositionResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgClosePositionResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgClosePositionResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgClosePositionResponse;
            })();
    
            derivatives.MsgReportLiquidation = (function() {
    
                /**
                 * Properties of a MsgReportLiquidation.
                 * @memberof ununifi.derivatives
                 * @interface IMsgReportLiquidation
                 * @property {string|null} [sender] MsgReportLiquidation sender
                 * @property {string|null} [position_id] MsgReportLiquidation position_id
                 * @property {string|null} [reward_recipient] MsgReportLiquidation reward_recipient
                 */
    
                /**
                 * Constructs a new MsgReportLiquidation.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgReportLiquidation.
                 * @implements IMsgReportLiquidation
                 * @constructor
                 * @param {ununifi.derivatives.IMsgReportLiquidation=} [properties] Properties to set
                 */
                function MsgReportLiquidation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgReportLiquidation sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @instance
                 */
                MsgReportLiquidation.prototype.sender = "";
    
                /**
                 * MsgReportLiquidation position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @instance
                 */
                MsgReportLiquidation.prototype.position_id = "";
    
                /**
                 * MsgReportLiquidation reward_recipient.
                 * @member {string} reward_recipient
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @instance
                 */
                MsgReportLiquidation.prototype.reward_recipient = "";
    
                /**
                 * Encodes the specified MsgReportLiquidation message. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidation.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLiquidation} message MsgReportLiquidation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLiquidation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    if (message.reward_recipient != null && Object.hasOwnProperty.call(message, "reward_recipient"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.reward_recipient);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgReportLiquidation message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLiquidation} message MsgReportLiquidation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLiquidation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgReportLiquidation message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgReportLiquidation} MsgReportLiquidation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLiquidation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgReportLiquidation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        case 3:
                            message.reward_recipient = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgReportLiquidation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgReportLiquidation} MsgReportLiquidation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLiquidation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgReportLiquidation message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgReportLiquidation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        if (!$util.isString(message.reward_recipient))
                            return "reward_recipient: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgReportLiquidation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgReportLiquidation} MsgReportLiquidation
                 */
                MsgReportLiquidation.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgReportLiquidation)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgReportLiquidation();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    if (object.reward_recipient != null)
                        message.reward_recipient = String(object.reward_recipient);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgReportLiquidation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @static
                 * @param {ununifi.derivatives.MsgReportLiquidation} message MsgReportLiquidation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgReportLiquidation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.position_id = "";
                        object.reward_recipient = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        object.reward_recipient = message.reward_recipient;
                    return object;
                };
    
                /**
                 * Converts this MsgReportLiquidation to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgReportLiquidation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgReportLiquidation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgReportLiquidation;
            })();
    
            derivatives.MsgReportLiquidationResponse = (function() {
    
                /**
                 * Properties of a MsgReportLiquidationResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgReportLiquidationResponse
                 */
    
                /**
                 * Constructs a new MsgReportLiquidationResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgReportLiquidationResponse.
                 * @implements IMsgReportLiquidationResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgReportLiquidationResponse=} [properties] Properties to set
                 */
                function MsgReportLiquidationResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgReportLiquidationResponse message. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidationResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLiquidationResponse} message MsgReportLiquidationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLiquidationResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgReportLiquidationResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidationResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLiquidationResponse} message MsgReportLiquidationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLiquidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgReportLiquidationResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgReportLiquidationResponse} MsgReportLiquidationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLiquidationResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgReportLiquidationResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgReportLiquidationResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgReportLiquidationResponse} MsgReportLiquidationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLiquidationResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgReportLiquidationResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgReportLiquidationResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgReportLiquidationResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgReportLiquidationResponse} MsgReportLiquidationResponse
                 */
                MsgReportLiquidationResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgReportLiquidationResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgReportLiquidationResponse();
                };
    
                /**
                 * Creates a plain object from a MsgReportLiquidationResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @static
                 * @param {ununifi.derivatives.MsgReportLiquidationResponse} message MsgReportLiquidationResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgReportLiquidationResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgReportLiquidationResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgReportLiquidationResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgReportLiquidationResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgReportLiquidationResponse;
            })();
    
            derivatives.MsgReportLevyPeriod = (function() {
    
                /**
                 * Properties of a MsgReportLevyPeriod.
                 * @memberof ununifi.derivatives
                 * @interface IMsgReportLevyPeriod
                 * @property {string|null} [sender] MsgReportLevyPeriod sender
                 * @property {string|null} [position_id] MsgReportLevyPeriod position_id
                 * @property {string|null} [reward_recipient] MsgReportLevyPeriod reward_recipient
                 */
    
                /**
                 * Constructs a new MsgReportLevyPeriod.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgReportLevyPeriod.
                 * @implements IMsgReportLevyPeriod
                 * @constructor
                 * @param {ununifi.derivatives.IMsgReportLevyPeriod=} [properties] Properties to set
                 */
                function MsgReportLevyPeriod(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgReportLevyPeriod sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @instance
                 */
                MsgReportLevyPeriod.prototype.sender = "";
    
                /**
                 * MsgReportLevyPeriod position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @instance
                 */
                MsgReportLevyPeriod.prototype.position_id = "";
    
                /**
                 * MsgReportLevyPeriod reward_recipient.
                 * @member {string} reward_recipient
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @instance
                 */
                MsgReportLevyPeriod.prototype.reward_recipient = "";
    
                /**
                 * Encodes the specified MsgReportLevyPeriod message. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriod.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLevyPeriod} message MsgReportLevyPeriod message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLevyPeriod.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    if (message.reward_recipient != null && Object.hasOwnProperty.call(message, "reward_recipient"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.reward_recipient);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgReportLevyPeriod message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriod.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLevyPeriod} message MsgReportLevyPeriod message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLevyPeriod.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgReportLevyPeriod message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgReportLevyPeriod} MsgReportLevyPeriod
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLevyPeriod.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgReportLevyPeriod();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        case 3:
                            message.reward_recipient = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgReportLevyPeriod message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgReportLevyPeriod} MsgReportLevyPeriod
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLevyPeriod.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgReportLevyPeriod message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgReportLevyPeriod.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        if (!$util.isString(message.reward_recipient))
                            return "reward_recipient: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgReportLevyPeriod message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgReportLevyPeriod} MsgReportLevyPeriod
                 */
                MsgReportLevyPeriod.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgReportLevyPeriod)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgReportLevyPeriod();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    if (object.reward_recipient != null)
                        message.reward_recipient = String(object.reward_recipient);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgReportLevyPeriod message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @static
                 * @param {ununifi.derivatives.MsgReportLevyPeriod} message MsgReportLevyPeriod
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgReportLevyPeriod.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.position_id = "";
                        object.reward_recipient = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        object.reward_recipient = message.reward_recipient;
                    return object;
                };
    
                /**
                 * Converts this MsgReportLevyPeriod to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgReportLevyPeriod
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgReportLevyPeriod.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgReportLevyPeriod;
            })();
    
            derivatives.MsgReportLevyPeriodResponse = (function() {
    
                /**
                 * Properties of a MsgReportLevyPeriodResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgReportLevyPeriodResponse
                 */
    
                /**
                 * Constructs a new MsgReportLevyPeriodResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgReportLevyPeriodResponse.
                 * @implements IMsgReportLevyPeriodResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgReportLevyPeriodResponse=} [properties] Properties to set
                 */
                function MsgReportLevyPeriodResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgReportLevyPeriodResponse message. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriodResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLevyPeriodResponse} message MsgReportLevyPeriodResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLevyPeriodResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgReportLevyPeriodResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriodResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgReportLevyPeriodResponse} message MsgReportLevyPeriodResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgReportLevyPeriodResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgReportLevyPeriodResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgReportLevyPeriodResponse} MsgReportLevyPeriodResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLevyPeriodResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgReportLevyPeriodResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgReportLevyPeriodResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgReportLevyPeriodResponse} MsgReportLevyPeriodResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgReportLevyPeriodResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgReportLevyPeriodResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgReportLevyPeriodResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgReportLevyPeriodResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgReportLevyPeriodResponse} MsgReportLevyPeriodResponse
                 */
                MsgReportLevyPeriodResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgReportLevyPeriodResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgReportLevyPeriodResponse();
                };
    
                /**
                 * Creates a plain object from a MsgReportLevyPeriodResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @static
                 * @param {ununifi.derivatives.MsgReportLevyPeriodResponse} message MsgReportLevyPeriodResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgReportLevyPeriodResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgReportLevyPeriodResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgReportLevyPeriodResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgReportLevyPeriodResponse;
            })();
    
            derivatives.MsgAddMargin = (function() {
    
                /**
                 * Properties of a MsgAddMargin.
                 * @memberof ununifi.derivatives
                 * @interface IMsgAddMargin
                 * @property {string|null} [sender] MsgAddMargin sender
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgAddMargin amount
                 * @property {string|null} [position_id] MsgAddMargin position_id
                 */
    
                /**
                 * Constructs a new MsgAddMargin.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgAddMargin.
                 * @implements IMsgAddMargin
                 * @constructor
                 * @param {ununifi.derivatives.IMsgAddMargin=} [properties] Properties to set
                 */
                function MsgAddMargin(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgAddMargin sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @instance
                 */
                MsgAddMargin.prototype.sender = "";
    
                /**
                 * MsgAddMargin amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @instance
                 */
                MsgAddMargin.prototype.amount = null;
    
                /**
                 * MsgAddMargin position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @instance
                 */
                MsgAddMargin.prototype.position_id = "";
    
                /**
                 * Encodes the specified MsgAddMargin message. Does not implicitly {@link ununifi.derivatives.MsgAddMargin.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @static
                 * @param {ununifi.derivatives.IMsgAddMargin} message MsgAddMargin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgAddMargin.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgAddMargin message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgAddMargin.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @static
                 * @param {ununifi.derivatives.IMsgAddMargin} message MsgAddMargin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgAddMargin.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgAddMargin message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgAddMargin} MsgAddMargin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgAddMargin.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgAddMargin();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgAddMargin message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgAddMargin} MsgAddMargin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgAddMargin.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgAddMargin message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgAddMargin.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgAddMargin message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgAddMargin} MsgAddMargin
                 */
                MsgAddMargin.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgAddMargin)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgAddMargin();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.derivatives.MsgAddMargin.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgAddMargin message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @static
                 * @param {ununifi.derivatives.MsgAddMargin} message MsgAddMargin
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgAddMargin.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.amount = null;
                        object.position_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this MsgAddMargin to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgAddMargin
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgAddMargin.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgAddMargin;
            })();
    
            derivatives.MsgAddMarginResponse = (function() {
    
                /**
                 * Properties of a MsgAddMarginResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgAddMarginResponse
                 */
    
                /**
                 * Constructs a new MsgAddMarginResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgAddMarginResponse.
                 * @implements IMsgAddMarginResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgAddMarginResponse=} [properties] Properties to set
                 */
                function MsgAddMarginResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgAddMarginResponse message. Does not implicitly {@link ununifi.derivatives.MsgAddMarginResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgAddMarginResponse} message MsgAddMarginResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgAddMarginResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgAddMarginResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgAddMarginResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgAddMarginResponse} message MsgAddMarginResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgAddMarginResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgAddMarginResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgAddMarginResponse} MsgAddMarginResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgAddMarginResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgAddMarginResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgAddMarginResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgAddMarginResponse} MsgAddMarginResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgAddMarginResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgAddMarginResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgAddMarginResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgAddMarginResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgAddMarginResponse} MsgAddMarginResponse
                 */
                MsgAddMarginResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgAddMarginResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgAddMarginResponse();
                };
    
                /**
                 * Creates a plain object from a MsgAddMarginResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @static
                 * @param {ununifi.derivatives.MsgAddMarginResponse} message MsgAddMarginResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgAddMarginResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgAddMarginResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgAddMarginResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgAddMarginResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgAddMarginResponse;
            })();
    
            derivatives.MsgRemoveMargin = (function() {
    
                /**
                 * Properties of a MsgRemoveMargin.
                 * @memberof ununifi.derivatives
                 * @interface IMsgRemoveMargin
                 * @property {string|null} [sender] MsgRemoveMargin sender
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgRemoveMargin amount
                 * @property {string|null} [position_id] MsgRemoveMargin position_id
                 */
    
                /**
                 * Constructs a new MsgRemoveMargin.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgRemoveMargin.
                 * @implements IMsgRemoveMargin
                 * @constructor
                 * @param {ununifi.derivatives.IMsgRemoveMargin=} [properties] Properties to set
                 */
                function MsgRemoveMargin(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgRemoveMargin sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @instance
                 */
                MsgRemoveMargin.prototype.sender = "";
    
                /**
                 * MsgRemoveMargin amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @instance
                 */
                MsgRemoveMargin.prototype.amount = null;
    
                /**
                 * MsgRemoveMargin position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @instance
                 */
                MsgRemoveMargin.prototype.position_id = "";
    
                /**
                 * Encodes the specified MsgRemoveMargin message. Does not implicitly {@link ununifi.derivatives.MsgRemoveMargin.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @static
                 * @param {ununifi.derivatives.IMsgRemoveMargin} message MsgRemoveMargin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRemoveMargin.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRemoveMargin message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgRemoveMargin.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @static
                 * @param {ununifi.derivatives.IMsgRemoveMargin} message MsgRemoveMargin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRemoveMargin.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRemoveMargin message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgRemoveMargin} MsgRemoveMargin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRemoveMargin.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgRemoveMargin();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRemoveMargin message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgRemoveMargin} MsgRemoveMargin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRemoveMargin.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRemoveMargin message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRemoveMargin.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgRemoveMargin message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgRemoveMargin} MsgRemoveMargin
                 */
                MsgRemoveMargin.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgRemoveMargin)
                        return object;
                    var message = new $root.ununifi.derivatives.MsgRemoveMargin();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.derivatives.MsgRemoveMargin.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgRemoveMargin message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @static
                 * @param {ununifi.derivatives.MsgRemoveMargin} message MsgRemoveMargin
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRemoveMargin.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.amount = null;
                        object.position_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this MsgRemoveMargin to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgRemoveMargin
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRemoveMargin.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRemoveMargin;
            })();
    
            derivatives.MsgRemoveMarginResponse = (function() {
    
                /**
                 * Properties of a MsgRemoveMarginResponse.
                 * @memberof ununifi.derivatives
                 * @interface IMsgRemoveMarginResponse
                 */
    
                /**
                 * Constructs a new MsgRemoveMarginResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a MsgRemoveMarginResponse.
                 * @implements IMsgRemoveMarginResponse
                 * @constructor
                 * @param {ununifi.derivatives.IMsgRemoveMarginResponse=} [properties] Properties to set
                 */
                function MsgRemoveMarginResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgRemoveMarginResponse message. Does not implicitly {@link ununifi.derivatives.MsgRemoveMarginResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgRemoveMarginResponse} message MsgRemoveMarginResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRemoveMarginResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRemoveMarginResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgRemoveMarginResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @static
                 * @param {ununifi.derivatives.IMsgRemoveMarginResponse} message MsgRemoveMarginResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRemoveMarginResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRemoveMarginResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.MsgRemoveMarginResponse} MsgRemoveMarginResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRemoveMarginResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.MsgRemoveMarginResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRemoveMarginResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.MsgRemoveMarginResponse} MsgRemoveMarginResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRemoveMarginResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRemoveMarginResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRemoveMarginResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgRemoveMarginResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.MsgRemoveMarginResponse} MsgRemoveMarginResponse
                 */
                MsgRemoveMarginResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.MsgRemoveMarginResponse)
                        return object;
                    return new $root.ununifi.derivatives.MsgRemoveMarginResponse();
                };
    
                /**
                 * Creates a plain object from a MsgRemoveMarginResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @static
                 * @param {ununifi.derivatives.MsgRemoveMarginResponse} message MsgRemoveMarginResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRemoveMarginResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgRemoveMarginResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.MsgRemoveMarginResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRemoveMarginResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRemoveMarginResponse;
            })();
    
            derivatives.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof ununifi.derivatives
                 * @interface IGenesisState
                 * @property {ununifi.derivatives.IParams|null} [params] GenesisState params
                 * @property {Array.<ununifi.derivatives.IPosition>|null} [positions] GenesisState positions
                 * @property {ununifi.derivatives.IPoolMarketCap|null} [pool_market_cap] GenesisState pool_market_cap
                 * @property {Array.<ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket>|null} [perpetual_futures_gross_position_of_market] GenesisState perpetual_futures_gross_position_of_market
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {ununifi.derivatives.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.positions = [];
                    this.perpetual_futures_gross_position_of_market = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState params.
                 * @member {ununifi.derivatives.IParams|null|undefined} params
                 * @memberof ununifi.derivatives.GenesisState
                 * @instance
                 */
                GenesisState.prototype.params = null;
    
                /**
                 * GenesisState positions.
                 * @member {Array.<ununifi.derivatives.IPosition>} positions
                 * @memberof ununifi.derivatives.GenesisState
                 * @instance
                 */
                GenesisState.prototype.positions = $util.emptyArray;
    
                /**
                 * GenesisState pool_market_cap.
                 * @member {ununifi.derivatives.IPoolMarketCap|null|undefined} pool_market_cap
                 * @memberof ununifi.derivatives.GenesisState
                 * @instance
                 */
                GenesisState.prototype.pool_market_cap = null;
    
                /**
                 * GenesisState perpetual_futures_gross_position_of_market.
                 * @member {Array.<ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket>} perpetual_futures_gross_position_of_market
                 * @memberof ununifi.derivatives.GenesisState
                 * @instance
                 */
                GenesisState.prototype.perpetual_futures_gross_position_of_market = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.derivatives.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.GenesisState
                 * @static
                 * @param {ununifi.derivatives.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.derivatives.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.positions != null && message.positions.length)
                        for (var i = 0; i < message.positions.length; ++i)
                            $root.ununifi.derivatives.Position.encode(message.positions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.pool_market_cap != null && Object.hasOwnProperty.call(message, "pool_market_cap"))
                        $root.ununifi.derivatives.PoolMarketCap.encode(message.pool_market_cap, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.perpetual_futures_gross_position_of_market != null && message.perpetual_futures_gross_position_of_market.length)
                        for (var i = 0; i < message.perpetual_futures_gross_position_of_market.length; ++i)
                            $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.encode(message.perpetual_futures_gross_position_of_market[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.derivatives.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.GenesisState
                 * @static
                 * @param {ununifi.derivatives.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.derivatives.Params.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.positions && message.positions.length))
                                message.positions = [];
                            message.positions.push($root.ununifi.derivatives.Position.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.perpetual_futures_gross_position_of_market && message.perpetual_futures_gross_position_of_market.length))
                                message.perpetual_futures_gross_position_of_market = [];
                            message.perpetual_futures_gross_position_of_market.push($root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof ununifi.derivatives.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.derivatives.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.positions != null && message.hasOwnProperty("positions")) {
                        if (!Array.isArray(message.positions))
                            return "positions: array expected";
                        for (var i = 0; i < message.positions.length; ++i) {
                            var error = $root.ununifi.derivatives.Position.verify(message.positions[i]);
                            if (error)
                                return "positions." + error;
                        }
                    }
                    if (message.pool_market_cap != null && message.hasOwnProperty("pool_market_cap")) {
                        var error = $root.ununifi.derivatives.PoolMarketCap.verify(message.pool_market_cap);
                        if (error)
                            return "pool_market_cap." + error;
                    }
                    if (message.perpetual_futures_gross_position_of_market != null && message.hasOwnProperty("perpetual_futures_gross_position_of_market")) {
                        if (!Array.isArray(message.perpetual_futures_gross_position_of_market))
                            return "perpetual_futures_gross_position_of_market: array expected";
                        for (var i = 0; i < message.perpetual_futures_gross_position_of_market.length; ++i) {
                            var error = $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.verify(message.perpetual_futures_gross_position_of_market[i]);
                            if (error)
                                return "perpetual_futures_gross_position_of_market." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.GenesisState)
                        return object;
                    var message = new $root.ununifi.derivatives.GenesisState();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.derivatives.GenesisState.params: object expected");
                        message.params = $root.ununifi.derivatives.Params.fromObject(object.params);
                    }
                    if (object.positions) {
                        if (!Array.isArray(object.positions))
                            throw TypeError(".ununifi.derivatives.GenesisState.positions: array expected");
                        message.positions = [];
                        for (var i = 0; i < object.positions.length; ++i) {
                            if (typeof object.positions[i] !== "object")
                                throw TypeError(".ununifi.derivatives.GenesisState.positions: object expected");
                            message.positions[i] = $root.ununifi.derivatives.Position.fromObject(object.positions[i]);
                        }
                    }
                    if (object.pool_market_cap != null) {
                        if (typeof object.pool_market_cap !== "object")
                            throw TypeError(".ununifi.derivatives.GenesisState.pool_market_cap: object expected");
                        message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.fromObject(object.pool_market_cap);
                    }
                    if (object.perpetual_futures_gross_position_of_market) {
                        if (!Array.isArray(object.perpetual_futures_gross_position_of_market))
                            throw TypeError(".ununifi.derivatives.GenesisState.perpetual_futures_gross_position_of_market: array expected");
                        message.perpetual_futures_gross_position_of_market = [];
                        for (var i = 0; i < object.perpetual_futures_gross_position_of_market.length; ++i) {
                            if (typeof object.perpetual_futures_gross_position_of_market[i] !== "object")
                                throw TypeError(".ununifi.derivatives.GenesisState.perpetual_futures_gross_position_of_market: object expected");
                            message.perpetual_futures_gross_position_of_market[i] = $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.fromObject(object.perpetual_futures_gross_position_of_market[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.GenesisState
                 * @static
                 * @param {ununifi.derivatives.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.positions = [];
                        object.perpetual_futures_gross_position_of_market = [];
                    }
                    if (options.defaults) {
                        object.params = null;
                        object.pool_market_cap = null;
                    }
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.derivatives.Params.toObject(message.params, options);
                    if (message.positions && message.positions.length) {
                        object.positions = [];
                        for (var j = 0; j < message.positions.length; ++j)
                            object.positions[j] = $root.ununifi.derivatives.Position.toObject(message.positions[j], options);
                    }
                    if (message.pool_market_cap != null && message.hasOwnProperty("pool_market_cap"))
                        object.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.toObject(message.pool_market_cap, options);
                    if (message.perpetual_futures_gross_position_of_market && message.perpetual_futures_gross_position_of_market.length) {
                        object.perpetual_futures_gross_position_of_market = [];
                        for (var j = 0; j < message.perpetual_futures_gross_position_of_market.length; ++j)
                            object.perpetual_futures_gross_position_of_market[j] = $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.toObject(message.perpetual_futures_gross_position_of_market[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            /**
             * PositionType enum.
             * @name ununifi.derivatives.PositionType
             * @enum {number}
             * @property {number} POSITION_UNKNOWN=0 POSITION_UNKNOWN value
             * @property {number} LONG=1 LONG value
             * @property {number} SHORT=2 SHORT value
             */
            derivatives.PositionType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "POSITION_UNKNOWN"] = 0;
                values[valuesById[1] = "LONG"] = 1;
                values[valuesById[2] = "SHORT"] = 2;
                return values;
            })();
    
            derivatives.Position = (function() {
    
                /**
                 * Properties of a Position.
                 * @memberof ununifi.derivatives
                 * @interface IPosition
                 * @property {string|null} [id] Position id
                 * @property {ununifi.derivatives.IMarket|null} [market] Position market
                 * @property {string|null} [opener_address] Position opener_address
                 * @property {google.protobuf.ITimestamp|null} [opened_at] Position opened_at
                 * @property {Long|null} [opened_height] Position opened_height
                 * @property {string|null} [opened_base_rate] Position opened_base_rate
                 * @property {string|null} [opened_quote_rate] Position opened_quote_rate
                 * @property {cosmos.base.v1beta1.ICoin|null} [remaining_margin] Position remaining_margin
                 * @property {cosmos.base.v1beta1.ICoin|null} [levied_amount] Position levied_amount
                 * @property {boolean|null} [levied_amount_negative] Position levied_amount_negative
                 * @property {google.protobuf.ITimestamp|null} [last_levied_at] Position last_levied_at
                 * @property {google.protobuf.IAny|null} [position_instance] Position position_instance
                 */
    
                /**
                 * Constructs a new Position.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a Position.
                 * @implements IPosition
                 * @constructor
                 * @param {ununifi.derivatives.IPosition=} [properties] Properties to set
                 */
                function Position(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Position id.
                 * @member {string} id
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.id = "";
    
                /**
                 * Position market.
                 * @member {ununifi.derivatives.IMarket|null|undefined} market
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.market = null;
    
                /**
                 * Position opener_address.
                 * @member {string} opener_address
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.opener_address = "";
    
                /**
                 * Position opened_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} opened_at
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.opened_at = null;
    
                /**
                 * Position opened_height.
                 * @member {Long} opened_height
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.opened_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Position opened_base_rate.
                 * @member {string} opened_base_rate
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.opened_base_rate = "";
    
                /**
                 * Position opened_quote_rate.
                 * @member {string} opened_quote_rate
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.opened_quote_rate = "";
    
                /**
                 * Position remaining_margin.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} remaining_margin
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.remaining_margin = null;
    
                /**
                 * Position levied_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} levied_amount
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.levied_amount = null;
    
                /**
                 * Position levied_amount_negative.
                 * @member {boolean} levied_amount_negative
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.levied_amount_negative = false;
    
                /**
                 * Position last_levied_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} last_levied_at
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.last_levied_at = null;
    
                /**
                 * Position position_instance.
                 * @member {google.protobuf.IAny|null|undefined} position_instance
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 */
                Position.prototype.position_instance = null;
    
                /**
                 * Encodes the specified Position message. Does not implicitly {@link ununifi.derivatives.Position.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.Position
                 * @static
                 * @param {ununifi.derivatives.IPosition} message Position message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Position.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.market != null && Object.hasOwnProperty.call(message, "market"))
                        $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.opener_address != null && Object.hasOwnProperty.call(message, "opener_address"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.opener_address);
                    if (message.opened_at != null && Object.hasOwnProperty.call(message, "opened_at"))
                        $root.google.protobuf.Timestamp.encode(message.opened_at, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.opened_height != null && Object.hasOwnProperty.call(message, "opened_height"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.opened_height);
                    if (message.opened_base_rate != null && Object.hasOwnProperty.call(message, "opened_base_rate"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.opened_base_rate);
                    if (message.opened_quote_rate != null && Object.hasOwnProperty.call(message, "opened_quote_rate"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.opened_quote_rate);
                    if (message.remaining_margin != null && Object.hasOwnProperty.call(message, "remaining_margin"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.remaining_margin, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.levied_amount != null && Object.hasOwnProperty.call(message, "levied_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.levied_amount, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.levied_amount_negative != null && Object.hasOwnProperty.call(message, "levied_amount_negative"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.levied_amount_negative);
                    if (message.last_levied_at != null && Object.hasOwnProperty.call(message, "last_levied_at"))
                        $root.google.protobuf.Timestamp.encode(message.last_levied_at, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.position_instance != null && Object.hasOwnProperty.call(message, "position_instance"))
                        $root.google.protobuf.Any.encode(message.position_instance, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Position message, length delimited. Does not implicitly {@link ununifi.derivatives.Position.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.Position
                 * @static
                 * @param {ununifi.derivatives.IPosition} message Position message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Position.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Position message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.Position
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.Position} Position
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Position.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.Position();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.opener_address = reader.string();
                            break;
                        case 4:
                            message.opened_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.opened_height = reader.uint64();
                            break;
                        case 6:
                            message.opened_base_rate = reader.string();
                            break;
                        case 7:
                            message.opened_quote_rate = reader.string();
                            break;
                        case 8:
                            message.remaining_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.levied_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.levied_amount_negative = reader.bool();
                            break;
                        case 11:
                            message.last_levied_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.position_instance = $root.google.protobuf.Any.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Position message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.Position
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.Position} Position
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Position.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Position message.
                 * @function verify
                 * @memberof ununifi.derivatives.Position
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Position.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.market != null && message.hasOwnProperty("market")) {
                        var error = $root.ununifi.derivatives.Market.verify(message.market);
                        if (error)
                            return "market." + error;
                    }
                    if (message.opener_address != null && message.hasOwnProperty("opener_address"))
                        if (!$util.isString(message.opener_address))
                            return "opener_address: string expected";
                    if (message.opened_at != null && message.hasOwnProperty("opened_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.opened_at);
                        if (error)
                            return "opened_at." + error;
                    }
                    if (message.opened_height != null && message.hasOwnProperty("opened_height"))
                        if (!$util.isInteger(message.opened_height) && !(message.opened_height && $util.isInteger(message.opened_height.low) && $util.isInteger(message.opened_height.high)))
                            return "opened_height: integer|Long expected";
                    if (message.opened_base_rate != null && message.hasOwnProperty("opened_base_rate"))
                        if (!$util.isString(message.opened_base_rate))
                            return "opened_base_rate: string expected";
                    if (message.opened_quote_rate != null && message.hasOwnProperty("opened_quote_rate"))
                        if (!$util.isString(message.opened_quote_rate))
                            return "opened_quote_rate: string expected";
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.remaining_margin);
                        if (error)
                            return "remaining_margin." + error;
                    }
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.levied_amount);
                        if (error)
                            return "levied_amount." + error;
                    }
                    if (message.levied_amount_negative != null && message.hasOwnProperty("levied_amount_negative"))
                        if (typeof message.levied_amount_negative !== "boolean")
                            return "levied_amount_negative: boolean expected";
                    if (message.last_levied_at != null && message.hasOwnProperty("last_levied_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.last_levied_at);
                        if (error)
                            return "last_levied_at." + error;
                    }
                    if (message.position_instance != null && message.hasOwnProperty("position_instance")) {
                        var error = $root.google.protobuf.Any.verify(message.position_instance);
                        if (error)
                            return "position_instance." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Position message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.Position
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.Position} Position
                 */
                Position.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.Position)
                        return object;
                    var message = new $root.ununifi.derivatives.Position();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.market != null) {
                        if (typeof object.market !== "object")
                            throw TypeError(".ununifi.derivatives.Position.market: object expected");
                        message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
                    }
                    if (object.opener_address != null)
                        message.opener_address = String(object.opener_address);
                    if (object.opened_at != null) {
                        if (typeof object.opened_at !== "object")
                            throw TypeError(".ununifi.derivatives.Position.opened_at: object expected");
                        message.opened_at = $root.google.protobuf.Timestamp.fromObject(object.opened_at);
                    }
                    if (object.opened_height != null)
                        if ($util.Long)
                            (message.opened_height = $util.Long.fromValue(object.opened_height)).unsigned = true;
                        else if (typeof object.opened_height === "string")
                            message.opened_height = parseInt(object.opened_height, 10);
                        else if (typeof object.opened_height === "number")
                            message.opened_height = object.opened_height;
                        else if (typeof object.opened_height === "object")
                            message.opened_height = new $util.LongBits(object.opened_height.low >>> 0, object.opened_height.high >>> 0).toNumber(true);
                    if (object.opened_base_rate != null)
                        message.opened_base_rate = String(object.opened_base_rate);
                    if (object.opened_quote_rate != null)
                        message.opened_quote_rate = String(object.opened_quote_rate);
                    if (object.remaining_margin != null) {
                        if (typeof object.remaining_margin !== "object")
                            throw TypeError(".ununifi.derivatives.Position.remaining_margin: object expected");
                        message.remaining_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.remaining_margin);
                    }
                    if (object.levied_amount != null) {
                        if (typeof object.levied_amount !== "object")
                            throw TypeError(".ununifi.derivatives.Position.levied_amount: object expected");
                        message.levied_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.levied_amount);
                    }
                    if (object.levied_amount_negative != null)
                        message.levied_amount_negative = Boolean(object.levied_amount_negative);
                    if (object.last_levied_at != null) {
                        if (typeof object.last_levied_at !== "object")
                            throw TypeError(".ununifi.derivatives.Position.last_levied_at: object expected");
                        message.last_levied_at = $root.google.protobuf.Timestamp.fromObject(object.last_levied_at);
                    }
                    if (object.position_instance != null) {
                        if (typeof object.position_instance !== "object")
                            throw TypeError(".ununifi.derivatives.Position.position_instance: object expected");
                        message.position_instance = $root.google.protobuf.Any.fromObject(object.position_instance);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Position message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.Position
                 * @static
                 * @param {ununifi.derivatives.Position} message Position
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Position.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.market = null;
                        object.opener_address = "";
                        object.opened_at = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.opened_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.opened_height = options.longs === String ? "0" : 0;
                        object.opened_base_rate = "";
                        object.opened_quote_rate = "";
                        object.remaining_margin = null;
                        object.levied_amount = null;
                        object.levied_amount_negative = false;
                        object.last_levied_at = null;
                        object.position_instance = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.market != null && message.hasOwnProperty("market"))
                        object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
                    if (message.opener_address != null && message.hasOwnProperty("opener_address"))
                        object.opener_address = message.opener_address;
                    if (message.opened_at != null && message.hasOwnProperty("opened_at"))
                        object.opened_at = $root.google.protobuf.Timestamp.toObject(message.opened_at, options);
                    if (message.opened_height != null && message.hasOwnProperty("opened_height"))
                        if (typeof message.opened_height === "number")
                            object.opened_height = options.longs === String ? String(message.opened_height) : message.opened_height;
                        else
                            object.opened_height = options.longs === String ? $util.Long.prototype.toString.call(message.opened_height) : options.longs === Number ? new $util.LongBits(message.opened_height.low >>> 0, message.opened_height.high >>> 0).toNumber(true) : message.opened_height;
                    if (message.opened_base_rate != null && message.hasOwnProperty("opened_base_rate"))
                        object.opened_base_rate = message.opened_base_rate;
                    if (message.opened_quote_rate != null && message.hasOwnProperty("opened_quote_rate"))
                        object.opened_quote_rate = message.opened_quote_rate;
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin"))
                        object.remaining_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.remaining_margin, options);
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount"))
                        object.levied_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.levied_amount, options);
                    if (message.levied_amount_negative != null && message.hasOwnProperty("levied_amount_negative"))
                        object.levied_amount_negative = message.levied_amount_negative;
                    if (message.last_levied_at != null && message.hasOwnProperty("last_levied_at"))
                        object.last_levied_at = $root.google.protobuf.Timestamp.toObject(message.last_levied_at, options);
                    if (message.position_instance != null && message.hasOwnProperty("position_instance"))
                        object.position_instance = $root.google.protobuf.Any.toObject(message.position_instance, options);
                    return object;
                };
    
                /**
                 * Converts this Position to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.Position
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Position.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Position;
            })();
    
            derivatives.PendingPaymentPosition = (function() {
    
                /**
                 * Properties of a PendingPaymentPosition.
                 * @memberof ununifi.derivatives
                 * @interface IPendingPaymentPosition
                 * @property {string|null} [id] PendingPaymentPosition id
                 * @property {cosmos.base.v1beta1.ICoin|null} [refundable_amount] PendingPaymentPosition refundable_amount
                 * @property {google.protobuf.ITimestamp|null} [created_at] PendingPaymentPosition created_at
                 * @property {Long|null} [created_height] PendingPaymentPosition created_height
                 */
    
                /**
                 * Constructs a new PendingPaymentPosition.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PendingPaymentPosition.
                 * @implements IPendingPaymentPosition
                 * @constructor
                 * @param {ununifi.derivatives.IPendingPaymentPosition=} [properties] Properties to set
                 */
                function PendingPaymentPosition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PendingPaymentPosition id.
                 * @member {string} id
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @instance
                 */
                PendingPaymentPosition.prototype.id = "";
    
                /**
                 * PendingPaymentPosition refundable_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} refundable_amount
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @instance
                 */
                PendingPaymentPosition.prototype.refundable_amount = null;
    
                /**
                 * PendingPaymentPosition created_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} created_at
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @instance
                 */
                PendingPaymentPosition.prototype.created_at = null;
    
                /**
                 * PendingPaymentPosition created_height.
                 * @member {Long} created_height
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @instance
                 */
                PendingPaymentPosition.prototype.created_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified PendingPaymentPosition message. Does not implicitly {@link ununifi.derivatives.PendingPaymentPosition.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @static
                 * @param {ununifi.derivatives.IPendingPaymentPosition} message PendingPaymentPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PendingPaymentPosition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.refundable_amount != null && Object.hasOwnProperty.call(message, "refundable_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.refundable_amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.created_at != null && Object.hasOwnProperty.call(message, "created_at"))
                        $root.google.protobuf.Timestamp.encode(message.created_at, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.created_height != null && Object.hasOwnProperty.call(message, "created_height"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.created_height);
                    return writer;
                };
    
                /**
                 * Encodes the specified PendingPaymentPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.PendingPaymentPosition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @static
                 * @param {ununifi.derivatives.IPendingPaymentPosition} message PendingPaymentPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PendingPaymentPosition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PendingPaymentPosition message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PendingPaymentPosition} PendingPaymentPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PendingPaymentPosition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PendingPaymentPosition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.refundable_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.created_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.created_height = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PendingPaymentPosition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PendingPaymentPosition} PendingPaymentPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PendingPaymentPosition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PendingPaymentPosition message.
                 * @function verify
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PendingPaymentPosition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.refundable_amount != null && message.hasOwnProperty("refundable_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.refundable_amount);
                        if (error)
                            return "refundable_amount." + error;
                    }
                    if (message.created_at != null && message.hasOwnProperty("created_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.created_at);
                        if (error)
                            return "created_at." + error;
                    }
                    if (message.created_height != null && message.hasOwnProperty("created_height"))
                        if (!$util.isInteger(message.created_height) && !(message.created_height && $util.isInteger(message.created_height.low) && $util.isInteger(message.created_height.high)))
                            return "created_height: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a PendingPaymentPosition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PendingPaymentPosition} PendingPaymentPosition
                 */
                PendingPaymentPosition.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PendingPaymentPosition)
                        return object;
                    var message = new $root.ununifi.derivatives.PendingPaymentPosition();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.refundable_amount != null) {
                        if (typeof object.refundable_amount !== "object")
                            throw TypeError(".ununifi.derivatives.PendingPaymentPosition.refundable_amount: object expected");
                        message.refundable_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.refundable_amount);
                    }
                    if (object.created_at != null) {
                        if (typeof object.created_at !== "object")
                            throw TypeError(".ununifi.derivatives.PendingPaymentPosition.created_at: object expected");
                        message.created_at = $root.google.protobuf.Timestamp.fromObject(object.created_at);
                    }
                    if (object.created_height != null)
                        if ($util.Long)
                            (message.created_height = $util.Long.fromValue(object.created_height)).unsigned = true;
                        else if (typeof object.created_height === "string")
                            message.created_height = parseInt(object.created_height, 10);
                        else if (typeof object.created_height === "number")
                            message.created_height = object.created_height;
                        else if (typeof object.created_height === "object")
                            message.created_height = new $util.LongBits(object.created_height.low >>> 0, object.created_height.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PendingPaymentPosition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @static
                 * @param {ununifi.derivatives.PendingPaymentPosition} message PendingPaymentPosition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PendingPaymentPosition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.refundable_amount = null;
                        object.created_at = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.created_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.created_height = options.longs === String ? "0" : 0;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.refundable_amount != null && message.hasOwnProperty("refundable_amount"))
                        object.refundable_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.refundable_amount, options);
                    if (message.created_at != null && message.hasOwnProperty("created_at"))
                        object.created_at = $root.google.protobuf.Timestamp.toObject(message.created_at, options);
                    if (message.created_height != null && message.hasOwnProperty("created_height"))
                        if (typeof message.created_height === "number")
                            object.created_height = options.longs === String ? String(message.created_height) : message.created_height;
                        else
                            object.created_height = options.longs === String ? $util.Long.prototype.toString.call(message.created_height) : options.longs === Number ? new $util.LongBits(message.created_height.low >>> 0, message.created_height.high >>> 0).toNumber(true) : message.created_height;
                    return object;
                };
    
                /**
                 * Converts this PendingPaymentPosition to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PendingPaymentPosition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PendingPaymentPosition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PendingPaymentPosition;
            })();
    
            derivatives.QueriedPosition = (function() {
    
                /**
                 * Properties of a QueriedPosition.
                 * @memberof ununifi.derivatives
                 * @interface IQueriedPosition
                 * @property {ununifi.derivatives.IPosition|null} [position] QueriedPosition position
                 * @property {cosmos.base.v1beta1.ICoin|null} [valuation_profit] QueriedPosition valuation_profit
                 * @property {string|null} [remaining_margin_value] QueriedPosition remaining_margin_value
                 * @property {cosmos.base.v1beta1.ICoin|null} [effective_margin] QueriedPosition effective_margin
                 * @property {string|null} [margin_maintenance_rate] QueriedPosition margin_maintenance_rate
                 */
    
                /**
                 * Constructs a new QueriedPosition.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueriedPosition.
                 * @implements IQueriedPosition
                 * @constructor
                 * @param {ununifi.derivatives.IQueriedPosition=} [properties] Properties to set
                 */
                function QueriedPosition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueriedPosition position.
                 * @member {ununifi.derivatives.IPosition|null|undefined} position
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @instance
                 */
                QueriedPosition.prototype.position = null;
    
                /**
                 * QueriedPosition valuation_profit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} valuation_profit
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @instance
                 */
                QueriedPosition.prototype.valuation_profit = null;
    
                /**
                 * QueriedPosition remaining_margin_value.
                 * @member {string} remaining_margin_value
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @instance
                 */
                QueriedPosition.prototype.remaining_margin_value = "";
    
                /**
                 * QueriedPosition effective_margin.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} effective_margin
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @instance
                 */
                QueriedPosition.prototype.effective_margin = null;
    
                /**
                 * QueriedPosition margin_maintenance_rate.
                 * @member {string} margin_maintenance_rate
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @instance
                 */
                QueriedPosition.prototype.margin_maintenance_rate = "";
    
                /**
                 * Encodes the specified QueriedPosition message. Does not implicitly {@link ununifi.derivatives.QueriedPosition.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @static
                 * @param {ununifi.derivatives.IQueriedPosition} message QueriedPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueriedPosition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.ununifi.derivatives.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.valuation_profit != null && Object.hasOwnProperty.call(message, "valuation_profit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.valuation_profit, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.remaining_margin_value != null && Object.hasOwnProperty.call(message, "remaining_margin_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.remaining_margin_value);
                    if (message.effective_margin != null && Object.hasOwnProperty.call(message, "effective_margin"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.effective_margin, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, "margin_maintenance_rate"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.margin_maintenance_rate);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueriedPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.QueriedPosition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @static
                 * @param {ununifi.derivatives.IQueriedPosition} message QueriedPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueriedPosition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueriedPosition message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueriedPosition} QueriedPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueriedPosition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueriedPosition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position = $root.ununifi.derivatives.Position.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.valuation_profit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.remaining_margin_value = reader.string();
                            break;
                        case 4:
                            message.effective_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.margin_maintenance_rate = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueriedPosition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueriedPosition} QueriedPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueriedPosition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueriedPosition message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueriedPosition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.ununifi.derivatives.Position.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.valuation_profit != null && message.hasOwnProperty("valuation_profit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.valuation_profit);
                        if (error)
                            return "valuation_profit." + error;
                    }
                    if (message.remaining_margin_value != null && message.hasOwnProperty("remaining_margin_value"))
                        if (!$util.isString(message.remaining_margin_value))
                            return "remaining_margin_value: string expected";
                    if (message.effective_margin != null && message.hasOwnProperty("effective_margin")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.effective_margin);
                        if (error)
                            return "effective_margin." + error;
                    }
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        if (!$util.isString(message.margin_maintenance_rate))
                            return "margin_maintenance_rate: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueriedPosition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueriedPosition} QueriedPosition
                 */
                QueriedPosition.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueriedPosition)
                        return object;
                    var message = new $root.ununifi.derivatives.QueriedPosition();
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".ununifi.derivatives.QueriedPosition.position: object expected");
                        message.position = $root.ununifi.derivatives.Position.fromObject(object.position);
                    }
                    if (object.valuation_profit != null) {
                        if (typeof object.valuation_profit !== "object")
                            throw TypeError(".ununifi.derivatives.QueriedPosition.valuation_profit: object expected");
                        message.valuation_profit = $root.cosmos.base.v1beta1.Coin.fromObject(object.valuation_profit);
                    }
                    if (object.remaining_margin_value != null)
                        message.remaining_margin_value = String(object.remaining_margin_value);
                    if (object.effective_margin != null) {
                        if (typeof object.effective_margin !== "object")
                            throw TypeError(".ununifi.derivatives.QueriedPosition.effective_margin: object expected");
                        message.effective_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.effective_margin);
                    }
                    if (object.margin_maintenance_rate != null)
                        message.margin_maintenance_rate = String(object.margin_maintenance_rate);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueriedPosition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @static
                 * @param {ununifi.derivatives.QueriedPosition} message QueriedPosition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueriedPosition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.position = null;
                        object.valuation_profit = null;
                        object.remaining_margin_value = "";
                        object.effective_margin = null;
                        object.margin_maintenance_rate = "";
                    }
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.ununifi.derivatives.Position.toObject(message.position, options);
                    if (message.valuation_profit != null && message.hasOwnProperty("valuation_profit"))
                        object.valuation_profit = $root.cosmos.base.v1beta1.Coin.toObject(message.valuation_profit, options);
                    if (message.remaining_margin_value != null && message.hasOwnProperty("remaining_margin_value"))
                        object.remaining_margin_value = message.remaining_margin_value;
                    if (message.effective_margin != null && message.hasOwnProperty("effective_margin"))
                        object.effective_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.effective_margin, options);
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        object.margin_maintenance_rate = message.margin_maintenance_rate;
                    return object;
                };
    
                /**
                 * Converts this QueriedPosition to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueriedPosition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueriedPosition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueriedPosition;
            })();
    
            derivatives.PoolAssetConf = (function() {
    
                /**
                 * Properties of a PoolAssetConf.
                 * @memberof ununifi.derivatives
                 * @interface IPoolAssetConf
                 * @property {string|null} [denom] PoolAssetConf denom
                 * @property {string|null} [target_weight] PoolAssetConf target_weight
                 */
    
                /**
                 * Constructs a new PoolAssetConf.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PoolAssetConf.
                 * @implements IPoolAssetConf
                 * @constructor
                 * @param {ununifi.derivatives.IPoolAssetConf=} [properties] Properties to set
                 */
                function PoolAssetConf(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PoolAssetConf denom.
                 * @member {string} denom
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @instance
                 */
                PoolAssetConf.prototype.denom = "";
    
                /**
                 * PoolAssetConf target_weight.
                 * @member {string} target_weight
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @instance
                 */
                PoolAssetConf.prototype.target_weight = "";
    
                /**
                 * Encodes the specified PoolAssetConf message. Does not implicitly {@link ununifi.derivatives.PoolAssetConf.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @static
                 * @param {ununifi.derivatives.IPoolAssetConf} message PoolAssetConf message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolAssetConf.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                    if (message.target_weight != null && Object.hasOwnProperty.call(message, "target_weight"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_weight);
                    return writer;
                };
    
                /**
                 * Encodes the specified PoolAssetConf message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolAssetConf.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @static
                 * @param {ununifi.derivatives.IPoolAssetConf} message PoolAssetConf message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolAssetConf.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PoolAssetConf message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PoolAssetConf} PoolAssetConf
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolAssetConf.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PoolAssetConf();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.denom = reader.string();
                            break;
                        case 2:
                            message.target_weight = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PoolAssetConf message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PoolAssetConf} PoolAssetConf
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolAssetConf.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PoolAssetConf message.
                 * @function verify
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PoolAssetConf.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.target_weight != null && message.hasOwnProperty("target_weight"))
                        if (!$util.isString(message.target_weight))
                            return "target_weight: string expected";
                    return null;
                };
    
                /**
                 * Creates a PoolAssetConf message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PoolAssetConf} PoolAssetConf
                 */
                PoolAssetConf.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PoolAssetConf)
                        return object;
                    var message = new $root.ununifi.derivatives.PoolAssetConf();
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.target_weight != null)
                        message.target_weight = String(object.target_weight);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PoolAssetConf message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @static
                 * @param {ununifi.derivatives.PoolAssetConf} message PoolAssetConf
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PoolAssetConf.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.denom = "";
                        object.target_weight = "";
                    }
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.target_weight != null && message.hasOwnProperty("target_weight"))
                        object.target_weight = message.target_weight;
                    return object;
                };
    
                /**
                 * Converts this PoolAssetConf to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PoolAssetConf
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PoolAssetConf.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PoolAssetConf;
            })();
    
            derivatives.PoolParams = (function() {
    
                /**
                 * Properties of a PoolParams.
                 * @memberof ununifi.derivatives
                 * @interface IPoolParams
                 * @property {string|null} [quote_ticker] PoolParams quote_ticker
                 * @property {string|null} [base_lpt_mint_fee] PoolParams base_lpt_mint_fee
                 * @property {string|null} [base_lpt_redeem_fee] PoolParams base_lpt_redeem_fee
                 * @property {string|null} [borrowing_fee_rate_per_hour] PoolParams borrowing_fee_rate_per_hour
                 * @property {string|null} [report_liquidation_reward_rate] PoolParams report_liquidation_reward_rate
                 * @property {string|null} [report_levy_period_reward_rate] PoolParams report_levy_period_reward_rate
                 * @property {Array.<ununifi.derivatives.IPoolAssetConf>|null} [accepted_assets_conf] PoolParams accepted_assets_conf
                 * @property {Long|null} [levy_period_required_seconds] PoolParams levy_period_required_seconds
                 */
    
                /**
                 * Constructs a new PoolParams.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PoolParams.
                 * @implements IPoolParams
                 * @constructor
                 * @param {ununifi.derivatives.IPoolParams=} [properties] Properties to set
                 */
                function PoolParams(properties) {
                    this.accepted_assets_conf = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PoolParams quote_ticker.
                 * @member {string} quote_ticker
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.quote_ticker = "";
    
                /**
                 * PoolParams base_lpt_mint_fee.
                 * @member {string} base_lpt_mint_fee
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.base_lpt_mint_fee = "";
    
                /**
                 * PoolParams base_lpt_redeem_fee.
                 * @member {string} base_lpt_redeem_fee
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.base_lpt_redeem_fee = "";
    
                /**
                 * PoolParams borrowing_fee_rate_per_hour.
                 * @member {string} borrowing_fee_rate_per_hour
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.borrowing_fee_rate_per_hour = "";
    
                /**
                 * PoolParams report_liquidation_reward_rate.
                 * @member {string} report_liquidation_reward_rate
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.report_liquidation_reward_rate = "";
    
                /**
                 * PoolParams report_levy_period_reward_rate.
                 * @member {string} report_levy_period_reward_rate
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.report_levy_period_reward_rate = "";
    
                /**
                 * PoolParams accepted_assets_conf.
                 * @member {Array.<ununifi.derivatives.IPoolAssetConf>} accepted_assets_conf
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.accepted_assets_conf = $util.emptyArray;
    
                /**
                 * PoolParams levy_period_required_seconds.
                 * @member {Long} levy_period_required_seconds
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 */
                PoolParams.prototype.levy_period_required_seconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified PoolParams message. Does not implicitly {@link ununifi.derivatives.PoolParams.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PoolParams
                 * @static
                 * @param {ununifi.derivatives.IPoolParams} message PoolParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.quote_ticker != null && Object.hasOwnProperty.call(message, "quote_ticker"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.quote_ticker);
                    if (message.base_lpt_mint_fee != null && Object.hasOwnProperty.call(message, "base_lpt_mint_fee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.base_lpt_mint_fee);
                    if (message.base_lpt_redeem_fee != null && Object.hasOwnProperty.call(message, "base_lpt_redeem_fee"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.base_lpt_redeem_fee);
                    if (message.borrowing_fee_rate_per_hour != null && Object.hasOwnProperty.call(message, "borrowing_fee_rate_per_hour"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.borrowing_fee_rate_per_hour);
                    if (message.report_liquidation_reward_rate != null && Object.hasOwnProperty.call(message, "report_liquidation_reward_rate"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.report_liquidation_reward_rate);
                    if (message.report_levy_period_reward_rate != null && Object.hasOwnProperty.call(message, "report_levy_period_reward_rate"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.report_levy_period_reward_rate);
                    if (message.accepted_assets_conf != null && message.accepted_assets_conf.length)
                        for (var i = 0; i < message.accepted_assets_conf.length; ++i)
                            $root.ununifi.derivatives.PoolAssetConf.encode(message.accepted_assets_conf[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.levy_period_required_seconds != null && Object.hasOwnProperty.call(message, "levy_period_required_seconds"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.levy_period_required_seconds);
                    return writer;
                };
    
                /**
                 * Encodes the specified PoolParams message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PoolParams
                 * @static
                 * @param {ununifi.derivatives.IPoolParams} message PoolParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PoolParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PoolParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PoolParams} PoolParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PoolParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.quote_ticker = reader.string();
                            break;
                        case 2:
                            message.base_lpt_mint_fee = reader.string();
                            break;
                        case 3:
                            message.base_lpt_redeem_fee = reader.string();
                            break;
                        case 4:
                            message.borrowing_fee_rate_per_hour = reader.string();
                            break;
                        case 5:
                            message.report_liquidation_reward_rate = reader.string();
                            break;
                        case 6:
                            message.report_levy_period_reward_rate = reader.string();
                            break;
                        case 7:
                            if (!(message.accepted_assets_conf && message.accepted_assets_conf.length))
                                message.accepted_assets_conf = [];
                            message.accepted_assets_conf.push($root.ununifi.derivatives.PoolAssetConf.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.levy_period_required_seconds = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PoolParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PoolParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PoolParams} PoolParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PoolParams message.
                 * @function verify
                 * @memberof ununifi.derivatives.PoolParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PoolParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.quote_ticker != null && message.hasOwnProperty("quote_ticker"))
                        if (!$util.isString(message.quote_ticker))
                            return "quote_ticker: string expected";
                    if (message.base_lpt_mint_fee != null && message.hasOwnProperty("base_lpt_mint_fee"))
                        if (!$util.isString(message.base_lpt_mint_fee))
                            return "base_lpt_mint_fee: string expected";
                    if (message.base_lpt_redeem_fee != null && message.hasOwnProperty("base_lpt_redeem_fee"))
                        if (!$util.isString(message.base_lpt_redeem_fee))
                            return "base_lpt_redeem_fee: string expected";
                    if (message.borrowing_fee_rate_per_hour != null && message.hasOwnProperty("borrowing_fee_rate_per_hour"))
                        if (!$util.isString(message.borrowing_fee_rate_per_hour))
                            return "borrowing_fee_rate_per_hour: string expected";
                    if (message.report_liquidation_reward_rate != null && message.hasOwnProperty("report_liquidation_reward_rate"))
                        if (!$util.isString(message.report_liquidation_reward_rate))
                            return "report_liquidation_reward_rate: string expected";
                    if (message.report_levy_period_reward_rate != null && message.hasOwnProperty("report_levy_period_reward_rate"))
                        if (!$util.isString(message.report_levy_period_reward_rate))
                            return "report_levy_period_reward_rate: string expected";
                    if (message.accepted_assets_conf != null && message.hasOwnProperty("accepted_assets_conf")) {
                        if (!Array.isArray(message.accepted_assets_conf))
                            return "accepted_assets_conf: array expected";
                        for (var i = 0; i < message.accepted_assets_conf.length; ++i) {
                            var error = $root.ununifi.derivatives.PoolAssetConf.verify(message.accepted_assets_conf[i]);
                            if (error)
                                return "accepted_assets_conf." + error;
                        }
                    }
                    if (message.levy_period_required_seconds != null && message.hasOwnProperty("levy_period_required_seconds"))
                        if (!$util.isInteger(message.levy_period_required_seconds) && !(message.levy_period_required_seconds && $util.isInteger(message.levy_period_required_seconds.low) && $util.isInteger(message.levy_period_required_seconds.high)))
                            return "levy_period_required_seconds: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a PoolParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PoolParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PoolParams} PoolParams
                 */
                PoolParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PoolParams)
                        return object;
                    var message = new $root.ununifi.derivatives.PoolParams();
                    if (object.quote_ticker != null)
                        message.quote_ticker = String(object.quote_ticker);
                    if (object.base_lpt_mint_fee != null)
                        message.base_lpt_mint_fee = String(object.base_lpt_mint_fee);
                    if (object.base_lpt_redeem_fee != null)
                        message.base_lpt_redeem_fee = String(object.base_lpt_redeem_fee);
                    if (object.borrowing_fee_rate_per_hour != null)
                        message.borrowing_fee_rate_per_hour = String(object.borrowing_fee_rate_per_hour);
                    if (object.report_liquidation_reward_rate != null)
                        message.report_liquidation_reward_rate = String(object.report_liquidation_reward_rate);
                    if (object.report_levy_period_reward_rate != null)
                        message.report_levy_period_reward_rate = String(object.report_levy_period_reward_rate);
                    if (object.accepted_assets_conf) {
                        if (!Array.isArray(object.accepted_assets_conf))
                            throw TypeError(".ununifi.derivatives.PoolParams.accepted_assets_conf: array expected");
                        message.accepted_assets_conf = [];
                        for (var i = 0; i < object.accepted_assets_conf.length; ++i) {
                            if (typeof object.accepted_assets_conf[i] !== "object")
                                throw TypeError(".ununifi.derivatives.PoolParams.accepted_assets_conf: object expected");
                            message.accepted_assets_conf[i] = $root.ununifi.derivatives.PoolAssetConf.fromObject(object.accepted_assets_conf[i]);
                        }
                    }
                    if (object.levy_period_required_seconds != null)
                        if ($util.Long)
                            (message.levy_period_required_seconds = $util.Long.fromValue(object.levy_period_required_seconds)).unsigned = true;
                        else if (typeof object.levy_period_required_seconds === "string")
                            message.levy_period_required_seconds = parseInt(object.levy_period_required_seconds, 10);
                        else if (typeof object.levy_period_required_seconds === "number")
                            message.levy_period_required_seconds = object.levy_period_required_seconds;
                        else if (typeof object.levy_period_required_seconds === "object")
                            message.levy_period_required_seconds = new $util.LongBits(object.levy_period_required_seconds.low >>> 0, object.levy_period_required_seconds.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PoolParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PoolParams
                 * @static
                 * @param {ununifi.derivatives.PoolParams} message PoolParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PoolParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.accepted_assets_conf = [];
                    if (options.defaults) {
                        object.quote_ticker = "";
                        object.base_lpt_mint_fee = "";
                        object.base_lpt_redeem_fee = "";
                        object.borrowing_fee_rate_per_hour = "";
                        object.report_liquidation_reward_rate = "";
                        object.report_levy_period_reward_rate = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.levy_period_required_seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.levy_period_required_seconds = options.longs === String ? "0" : 0;
                    }
                    if (message.quote_ticker != null && message.hasOwnProperty("quote_ticker"))
                        object.quote_ticker = message.quote_ticker;
                    if (message.base_lpt_mint_fee != null && message.hasOwnProperty("base_lpt_mint_fee"))
                        object.base_lpt_mint_fee = message.base_lpt_mint_fee;
                    if (message.base_lpt_redeem_fee != null && message.hasOwnProperty("base_lpt_redeem_fee"))
                        object.base_lpt_redeem_fee = message.base_lpt_redeem_fee;
                    if (message.borrowing_fee_rate_per_hour != null && message.hasOwnProperty("borrowing_fee_rate_per_hour"))
                        object.borrowing_fee_rate_per_hour = message.borrowing_fee_rate_per_hour;
                    if (message.report_liquidation_reward_rate != null && message.hasOwnProperty("report_liquidation_reward_rate"))
                        object.report_liquidation_reward_rate = message.report_liquidation_reward_rate;
                    if (message.report_levy_period_reward_rate != null && message.hasOwnProperty("report_levy_period_reward_rate"))
                        object.report_levy_period_reward_rate = message.report_levy_period_reward_rate;
                    if (message.accepted_assets_conf && message.accepted_assets_conf.length) {
                        object.accepted_assets_conf = [];
                        for (var j = 0; j < message.accepted_assets_conf.length; ++j)
                            object.accepted_assets_conf[j] = $root.ununifi.derivatives.PoolAssetConf.toObject(message.accepted_assets_conf[j], options);
                    }
                    if (message.levy_period_required_seconds != null && message.hasOwnProperty("levy_period_required_seconds"))
                        if (typeof message.levy_period_required_seconds === "number")
                            object.levy_period_required_seconds = options.longs === String ? String(message.levy_period_required_seconds) : message.levy_period_required_seconds;
                        else
                            object.levy_period_required_seconds = options.longs === String ? $util.Long.prototype.toString.call(message.levy_period_required_seconds) : options.longs === Number ? new $util.LongBits(message.levy_period_required_seconds.low >>> 0, message.levy_period_required_seconds.high >>> 0).toNumber(true) : message.levy_period_required_seconds;
                    return object;
                };
    
                /**
                 * Converts this PoolParams to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PoolParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PoolParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PoolParams;
            })();
    
            derivatives.PoolMarketCap = (function() {
    
                /**
                 * Properties of a PoolMarketCap.
                 * @memberof ununifi.derivatives
                 * @interface IPoolMarketCap
                 * @property {string|null} [quote_ticker] PoolMarketCap quote_ticker
                 * @property {string|null} [total] PoolMarketCap total
                 * @property {Array.<ununifi.derivatives.PoolMarketCap.IAssetInfo>|null} [asset_info] PoolMarketCap asset_info
                 */
    
                /**
                 * Constructs a new PoolMarketCap.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PoolMarketCap.
                 * @implements IPoolMarketCap
                 * @constructor
                 * @param {ununifi.derivatives.IPoolMarketCap=} [properties] Properties to set
                 */
                function PoolMarketCap(properties) {
                    this.asset_info = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PoolMarketCap quote_ticker.
                 * @member {string} quote_ticker
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @instance
                 */
                PoolMarketCap.prototype.quote_ticker = "";
    
                /**
                 * PoolMarketCap total.
                 * @member {string} total
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @instance
                 */
                PoolMarketCap.prototype.total = "";
    
                /**
                 * PoolMarketCap asset_info.
                 * @member {Array.<ununifi.derivatives.PoolMarketCap.IAssetInfo>} asset_info
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @instance
                 */
                PoolMarketCap.prototype.asset_info = $util.emptyArray;
    
                /**
                 * Encodes the specified PoolMarketCap message. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @static
                 * @param {ununifi.derivatives.IPoolMarketCap} message PoolMarketCap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolMarketCap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.quote_ticker != null && Object.hasOwnProperty.call(message, "quote_ticker"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.quote_ticker);
                    if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.total);
                    if (message.asset_info != null && message.asset_info.length)
                        for (var i = 0; i < message.asset_info.length; ++i)
                            $root.ununifi.derivatives.PoolMarketCap.AssetInfo.encode(message.asset_info[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PoolMarketCap message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @static
                 * @param {ununifi.derivatives.IPoolMarketCap} message PoolMarketCap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolMarketCap.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PoolMarketCap message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PoolMarketCap} PoolMarketCap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolMarketCap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PoolMarketCap();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.quote_ticker = reader.string();
                            break;
                        case 2:
                            message.total = reader.string();
                            break;
                        case 3:
                            if (!(message.asset_info && message.asset_info.length))
                                message.asset_info = [];
                            message.asset_info.push($root.ununifi.derivatives.PoolMarketCap.AssetInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PoolMarketCap message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PoolMarketCap} PoolMarketCap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolMarketCap.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PoolMarketCap message.
                 * @function verify
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PoolMarketCap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.quote_ticker != null && message.hasOwnProperty("quote_ticker"))
                        if (!$util.isString(message.quote_ticker))
                            return "quote_ticker: string expected";
                    if (message.total != null && message.hasOwnProperty("total"))
                        if (!$util.isString(message.total))
                            return "total: string expected";
                    if (message.asset_info != null && message.hasOwnProperty("asset_info")) {
                        if (!Array.isArray(message.asset_info))
                            return "asset_info: array expected";
                        for (var i = 0; i < message.asset_info.length; ++i) {
                            var error = $root.ununifi.derivatives.PoolMarketCap.AssetInfo.verify(message.asset_info[i]);
                            if (error)
                                return "asset_info." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a PoolMarketCap message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PoolMarketCap} PoolMarketCap
                 */
                PoolMarketCap.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PoolMarketCap)
                        return object;
                    var message = new $root.ununifi.derivatives.PoolMarketCap();
                    if (object.quote_ticker != null)
                        message.quote_ticker = String(object.quote_ticker);
                    if (object.total != null)
                        message.total = String(object.total);
                    if (object.asset_info) {
                        if (!Array.isArray(object.asset_info))
                            throw TypeError(".ununifi.derivatives.PoolMarketCap.asset_info: array expected");
                        message.asset_info = [];
                        for (var i = 0; i < object.asset_info.length; ++i) {
                            if (typeof object.asset_info[i] !== "object")
                                throw TypeError(".ununifi.derivatives.PoolMarketCap.asset_info: object expected");
                            message.asset_info[i] = $root.ununifi.derivatives.PoolMarketCap.AssetInfo.fromObject(object.asset_info[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PoolMarketCap message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @static
                 * @param {ununifi.derivatives.PoolMarketCap} message PoolMarketCap
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PoolMarketCap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.asset_info = [];
                    if (options.defaults) {
                        object.quote_ticker = "";
                        object.total = "";
                    }
                    if (message.quote_ticker != null && message.hasOwnProperty("quote_ticker"))
                        object.quote_ticker = message.quote_ticker;
                    if (message.total != null && message.hasOwnProperty("total"))
                        object.total = message.total;
                    if (message.asset_info && message.asset_info.length) {
                        object.asset_info = [];
                        for (var j = 0; j < message.asset_info.length; ++j)
                            object.asset_info[j] = $root.ununifi.derivatives.PoolMarketCap.AssetInfo.toObject(message.asset_info[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this PoolMarketCap to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PoolMarketCap
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PoolMarketCap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                PoolMarketCap.AssetInfo = (function() {
    
                    /**
                     * Properties of an AssetInfo.
                     * @memberof ununifi.derivatives.PoolMarketCap
                     * @interface IAssetInfo
                     * @property {string|null} [denom] AssetInfo denom
                     * @property {string|null} [amount] AssetInfo amount
                     * @property {string|null} [price] AssetInfo price
                     * @property {string|null} [reserved] AssetInfo reserved
                     */
    
                    /**
                     * Constructs a new AssetInfo.
                     * @memberof ununifi.derivatives.PoolMarketCap
                     * @classdesc Represents an AssetInfo.
                     * @implements IAssetInfo
                     * @constructor
                     * @param {ununifi.derivatives.PoolMarketCap.IAssetInfo=} [properties] Properties to set
                     */
                    function AssetInfo(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AssetInfo denom.
                     * @member {string} denom
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @instance
                     */
                    AssetInfo.prototype.denom = "";
    
                    /**
                     * AssetInfo amount.
                     * @member {string} amount
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @instance
                     */
                    AssetInfo.prototype.amount = "";
    
                    /**
                     * AssetInfo price.
                     * @member {string} price
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @instance
                     */
                    AssetInfo.prototype.price = "";
    
                    /**
                     * AssetInfo reserved.
                     * @member {string} reserved
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @instance
                     */
                    AssetInfo.prototype.reserved = "";
    
                    /**
                     * Encodes the specified AssetInfo message. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.AssetInfo.verify|verify} messages.
                     * @function encode
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @static
                     * @param {ununifi.derivatives.PoolMarketCap.IAssetInfo} message AssetInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AssetInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                        if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.price);
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.reserved);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified AssetInfo message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.AssetInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @static
                     * @param {ununifi.derivatives.PoolMarketCap.IAssetInfo} message AssetInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AssetInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an AssetInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ununifi.derivatives.PoolMarketCap.AssetInfo} AssetInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AssetInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PoolMarketCap.AssetInfo();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.denom = reader.string();
                                break;
                            case 2:
                                message.amount = reader.string();
                                break;
                            case 3:
                                message.price = reader.string();
                                break;
                            case 4:
                                message.reserved = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an AssetInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ununifi.derivatives.PoolMarketCap.AssetInfo} AssetInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AssetInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an AssetInfo message.
                     * @function verify
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AssetInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            if (!$util.isString(message.denom))
                                return "denom: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        if (message.price != null && message.hasOwnProperty("price"))
                            if (!$util.isString(message.price))
                                return "price: string expected";
                        if (message.reserved != null && message.hasOwnProperty("reserved"))
                            if (!$util.isString(message.reserved))
                                return "reserved: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an AssetInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ununifi.derivatives.PoolMarketCap.AssetInfo} AssetInfo
                     */
                    AssetInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.ununifi.derivatives.PoolMarketCap.AssetInfo)
                            return object;
                        var message = new $root.ununifi.derivatives.PoolMarketCap.AssetInfo();
                        if (object.denom != null)
                            message.denom = String(object.denom);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        if (object.price != null)
                            message.price = String(object.price);
                        if (object.reserved != null)
                            message.reserved = String(object.reserved);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an AssetInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @static
                     * @param {ununifi.derivatives.PoolMarketCap.AssetInfo} message AssetInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AssetInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.denom = "";
                            object.amount = "";
                            object.price = "";
                            object.reserved = "";
                        }
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            object.denom = message.denom;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        if (message.price != null && message.hasOwnProperty("price"))
                            object.price = message.price;
                        if (message.reserved != null && message.hasOwnProperty("reserved"))
                            object.reserved = message.reserved;
                        return object;
                    };
    
                    /**
                     * Converts this AssetInfo to JSON.
                     * @function toJSON
                     * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AssetInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return AssetInfo;
                })();
    
                return PoolMarketCap;
            })();
    
            derivatives.Market = (function() {
    
                /**
                 * Properties of a Market.
                 * @memberof ununifi.derivatives
                 * @interface IMarket
                 * @property {string|null} [base_denom] Market base_denom
                 * @property {string|null} [quote_denom] Market quote_denom
                 */
    
                /**
                 * Constructs a new Market.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a Market.
                 * @implements IMarket
                 * @constructor
                 * @param {ununifi.derivatives.IMarket=} [properties] Properties to set
                 */
                function Market(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Market base_denom.
                 * @member {string} base_denom
                 * @memberof ununifi.derivatives.Market
                 * @instance
                 */
                Market.prototype.base_denom = "";
    
                /**
                 * Market quote_denom.
                 * @member {string} quote_denom
                 * @memberof ununifi.derivatives.Market
                 * @instance
                 */
                Market.prototype.quote_denom = "";
    
                /**
                 * Encodes the specified Market message. Does not implicitly {@link ununifi.derivatives.Market.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.Market
                 * @static
                 * @param {ununifi.derivatives.IMarket} message Market message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Market.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.base_denom != null && Object.hasOwnProperty.call(message, "base_denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.base_denom);
                    if (message.quote_denom != null && Object.hasOwnProperty.call(message, "quote_denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.quote_denom);
                    return writer;
                };
    
                /**
                 * Encodes the specified Market message, length delimited. Does not implicitly {@link ununifi.derivatives.Market.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.Market
                 * @static
                 * @param {ununifi.derivatives.IMarket} message Market message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Market.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Market message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.Market
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.Market} Market
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Market.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.Market();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.base_denom = reader.string();
                            break;
                        case 2:
                            message.quote_denom = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Market message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.Market
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.Market} Market
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Market.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Market message.
                 * @function verify
                 * @memberof ununifi.derivatives.Market
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Market.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.base_denom != null && message.hasOwnProperty("base_denom"))
                        if (!$util.isString(message.base_denom))
                            return "base_denom: string expected";
                    if (message.quote_denom != null && message.hasOwnProperty("quote_denom"))
                        if (!$util.isString(message.quote_denom))
                            return "quote_denom: string expected";
                    return null;
                };
    
                /**
                 * Creates a Market message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.Market
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.Market} Market
                 */
                Market.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.Market)
                        return object;
                    var message = new $root.ununifi.derivatives.Market();
                    if (object.base_denom != null)
                        message.base_denom = String(object.base_denom);
                    if (object.quote_denom != null)
                        message.quote_denom = String(object.quote_denom);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Market message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.Market
                 * @static
                 * @param {ununifi.derivatives.Market} message Market
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Market.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.base_denom = "";
                        object.quote_denom = "";
                    }
                    if (message.base_denom != null && message.hasOwnProperty("base_denom"))
                        object.base_denom = message.base_denom;
                    if (message.quote_denom != null && message.hasOwnProperty("quote_denom"))
                        object.quote_denom = message.quote_denom;
                    return object;
                };
    
                /**
                 * Converts this Market to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.Market
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Market.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Market;
            })();
    
            /**
             * MarketType enum.
             * @name ununifi.derivatives.MarketType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} FUTURES=1 FUTURES value
             * @property {number} OPTIONS=2 OPTIONS value
             */
            derivatives.MarketType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "FUTURES"] = 1;
                values[valuesById[2] = "OPTIONS"] = 2;
                return values;
            })();
    
            derivatives.Reserve = (function() {
    
                /**
                 * Properties of a Reserve.
                 * @memberof ununifi.derivatives
                 * @interface IReserve
                 * @property {ununifi.derivatives.MarketType|null} [market_type] Reserve market_type
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] Reserve amount
                 */
    
                /**
                 * Constructs a new Reserve.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a Reserve.
                 * @implements IReserve
                 * @constructor
                 * @param {ununifi.derivatives.IReserve=} [properties] Properties to set
                 */
                function Reserve(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Reserve market_type.
                 * @member {ununifi.derivatives.MarketType} market_type
                 * @memberof ununifi.derivatives.Reserve
                 * @instance
                 */
                Reserve.prototype.market_type = 0;
    
                /**
                 * Reserve amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.derivatives.Reserve
                 * @instance
                 */
                Reserve.prototype.amount = null;
    
                /**
                 * Encodes the specified Reserve message. Does not implicitly {@link ununifi.derivatives.Reserve.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.Reserve
                 * @static
                 * @param {ununifi.derivatives.IReserve} message Reserve message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reserve.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market_type != null && Object.hasOwnProperty.call(message, "market_type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market_type);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Reserve message, length delimited. Does not implicitly {@link ununifi.derivatives.Reserve.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.Reserve
                 * @static
                 * @param {ununifi.derivatives.IReserve} message Reserve message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reserve.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Reserve message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.Reserve
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.Reserve} Reserve
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reserve.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.Reserve();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market_type = reader.int32();
                            break;
                        case 2:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Reserve message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.Reserve
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.Reserve} Reserve
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reserve.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Reserve message.
                 * @function verify
                 * @memberof ununifi.derivatives.Reserve
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reserve.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market_type != null && message.hasOwnProperty("market_type"))
                        switch (message.market_type) {
                        default:
                            return "market_type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Reserve message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.Reserve
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.Reserve} Reserve
                 */
                Reserve.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.Reserve)
                        return object;
                    var message = new $root.ununifi.derivatives.Reserve();
                    switch (object.market_type) {
                    case "UNKNOWN":
                    case 0:
                        message.market_type = 0;
                        break;
                    case "FUTURES":
                    case 1:
                        message.market_type = 1;
                        break;
                    case "OPTIONS":
                    case 2:
                        message.market_type = 2;
                        break;
                    }
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.derivatives.Reserve.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Reserve message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.Reserve
                 * @static
                 * @param {ununifi.derivatives.Reserve} message Reserve
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Reserve.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.market_type = options.enums === String ? "UNKNOWN" : 0;
                        object.amount = null;
                    }
                    if (message.market_type != null && message.hasOwnProperty("market_type"))
                        object.market_type = options.enums === String ? $root.ununifi.derivatives.MarketType[message.market_type] : message.market_type;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    return object;
                };
    
                /**
                 * Converts this Reserve to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.Reserve
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Reserve.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Reserve;
            })();
    
            derivatives.EventPriceIsNotFed = (function() {
    
                /**
                 * Properties of an EventPriceIsNotFed.
                 * @memberof ununifi.derivatives
                 * @interface IEventPriceIsNotFed
                 * @property {string|null} [asset] EventPriceIsNotFed asset
                 */
    
                /**
                 * Constructs a new EventPriceIsNotFed.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPriceIsNotFed.
                 * @implements IEventPriceIsNotFed
                 * @constructor
                 * @param {ununifi.derivatives.IEventPriceIsNotFed=} [properties] Properties to set
                 */
                function EventPriceIsNotFed(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPriceIsNotFed asset.
                 * @member {string} asset
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @instance
                 */
                EventPriceIsNotFed.prototype.asset = "";
    
                /**
                 * Encodes the specified EventPriceIsNotFed message. Does not implicitly {@link ununifi.derivatives.EventPriceIsNotFed.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @static
                 * @param {ununifi.derivatives.IEventPriceIsNotFed} message EventPriceIsNotFed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPriceIsNotFed.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.asset);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPriceIsNotFed message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPriceIsNotFed.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @static
                 * @param {ununifi.derivatives.IEventPriceIsNotFed} message EventPriceIsNotFed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPriceIsNotFed.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPriceIsNotFed message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPriceIsNotFed} EventPriceIsNotFed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPriceIsNotFed.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPriceIsNotFed();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.asset = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPriceIsNotFed message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPriceIsNotFed} EventPriceIsNotFed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPriceIsNotFed.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPriceIsNotFed message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPriceIsNotFed.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.asset != null && message.hasOwnProperty("asset"))
                        if (!$util.isString(message.asset))
                            return "asset: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPriceIsNotFed message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPriceIsNotFed} EventPriceIsNotFed
                 */
                EventPriceIsNotFed.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPriceIsNotFed)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPriceIsNotFed();
                    if (object.asset != null)
                        message.asset = String(object.asset);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPriceIsNotFed message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @static
                 * @param {ununifi.derivatives.EventPriceIsNotFed} message EventPriceIsNotFed
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPriceIsNotFed.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.asset = "";
                    if (message.asset != null && message.hasOwnProperty("asset"))
                        object.asset = message.asset;
                    return object;
                };
    
                /**
                 * Converts this EventPriceIsNotFed to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPriceIsNotFed
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPriceIsNotFed.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPriceIsNotFed;
            })();
    
            derivatives.EventPerpetualFuturesLevyFee = (function() {
    
                /**
                 * Properties of an EventPerpetualFuturesLevyFee.
                 * @memberof ununifi.derivatives
                 * @interface IEventPerpetualFuturesLevyFee
                 * @property {cosmos.base.v1beta1.ICoin|null} [fee] EventPerpetualFuturesLevyFee fee
                 * @property {string|null} [position_id] EventPerpetualFuturesLevyFee position_id
                 */
    
                /**
                 * Constructs a new EventPerpetualFuturesLevyFee.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPerpetualFuturesLevyFee.
                 * @implements IEventPerpetualFuturesLevyFee
                 * @constructor
                 * @param {ununifi.derivatives.IEventPerpetualFuturesLevyFee=} [properties] Properties to set
                 */
                function EventPerpetualFuturesLevyFee(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPerpetualFuturesLevyFee fee.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @instance
                 */
                EventPerpetualFuturesLevyFee.prototype.fee = null;
    
                /**
                 * EventPerpetualFuturesLevyFee position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @instance
                 */
                EventPerpetualFuturesLevyFee.prototype.position_id = "";
    
                /**
                 * Encodes the specified EventPerpetualFuturesLevyFee message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLevyFee.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesLevyFee} message EventPerpetualFuturesLevyFee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesLevyFee.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPerpetualFuturesLevyFee message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLevyFee.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesLevyFee} message EventPerpetualFuturesLevyFee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesLevyFee.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPerpetualFuturesLevyFee message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPerpetualFuturesLevyFee} EventPerpetualFuturesLevyFee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesLevyFee.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPerpetualFuturesLevyFee();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPerpetualFuturesLevyFee message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPerpetualFuturesLevyFee} EventPerpetualFuturesLevyFee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesLevyFee.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPerpetualFuturesLevyFee message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPerpetualFuturesLevyFee.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fee != null && message.hasOwnProperty("fee")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
                        if (error)
                            return "fee." + error;
                    }
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPerpetualFuturesLevyFee message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPerpetualFuturesLevyFee} EventPerpetualFuturesLevyFee
                 */
                EventPerpetualFuturesLevyFee.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesLevyFee)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPerpetualFuturesLevyFee();
                    if (object.fee != null) {
                        if (typeof object.fee !== "object")
                            throw TypeError(".ununifi.derivatives.EventPerpetualFuturesLevyFee.fee: object expected");
                        message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
                    }
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPerpetualFuturesLevyFee message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @static
                 * @param {ununifi.derivatives.EventPerpetualFuturesLevyFee} message EventPerpetualFuturesLevyFee
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPerpetualFuturesLevyFee.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.fee = null;
                        object.position_id = "";
                    }
                    if (message.fee != null && message.hasOwnProperty("fee"))
                        object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this EventPerpetualFuturesLevyFee to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPerpetualFuturesLevyFee.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPerpetualFuturesLevyFee;
            })();
    
            derivatives.EventPerpetualFuturesImaginaryFundingFee = (function() {
    
                /**
                 * Properties of an EventPerpetualFuturesImaginaryFundingFee.
                 * @memberof ununifi.derivatives
                 * @interface IEventPerpetualFuturesImaginaryFundingFee
                 * @property {cosmos.base.v1beta1.ICoin|null} [fee] EventPerpetualFuturesImaginaryFundingFee fee
                 * @property {boolean|null} [fee_negative] EventPerpetualFuturesImaginaryFundingFee fee_negative
                 * @property {string|null} [position_id] EventPerpetualFuturesImaginaryFundingFee position_id
                 */
    
                /**
                 * Constructs a new EventPerpetualFuturesImaginaryFundingFee.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPerpetualFuturesImaginaryFundingFee.
                 * @implements IEventPerpetualFuturesImaginaryFundingFee
                 * @constructor
                 * @param {ununifi.derivatives.IEventPerpetualFuturesImaginaryFundingFee=} [properties] Properties to set
                 */
                function EventPerpetualFuturesImaginaryFundingFee(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPerpetualFuturesImaginaryFundingFee fee.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @instance
                 */
                EventPerpetualFuturesImaginaryFundingFee.prototype.fee = null;
    
                /**
                 * EventPerpetualFuturesImaginaryFundingFee fee_negative.
                 * @member {boolean} fee_negative
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @instance
                 */
                EventPerpetualFuturesImaginaryFundingFee.prototype.fee_negative = false;
    
                /**
                 * EventPerpetualFuturesImaginaryFundingFee position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @instance
                 */
                EventPerpetualFuturesImaginaryFundingFee.prototype.position_id = "";
    
                /**
                 * Encodes the specified EventPerpetualFuturesImaginaryFundingFee message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesImaginaryFundingFee} message EventPerpetualFuturesImaginaryFundingFee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesImaginaryFundingFee.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    if (message.fee_negative != null && Object.hasOwnProperty.call(message, "fee_negative"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.fee_negative);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPerpetualFuturesImaginaryFundingFee message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesImaginaryFundingFee} message EventPerpetualFuturesImaginaryFundingFee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesImaginaryFundingFee.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPerpetualFuturesImaginaryFundingFee message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} EventPerpetualFuturesImaginaryFundingFee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesImaginaryFundingFee.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.fee_negative = reader.bool();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPerpetualFuturesImaginaryFundingFee message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} EventPerpetualFuturesImaginaryFundingFee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesImaginaryFundingFee.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPerpetualFuturesImaginaryFundingFee message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPerpetualFuturesImaginaryFundingFee.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fee != null && message.hasOwnProperty("fee")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
                        if (error)
                            return "fee." + error;
                    }
                    if (message.fee_negative != null && message.hasOwnProperty("fee_negative"))
                        if (typeof message.fee_negative !== "boolean")
                            return "fee_negative: boolean expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPerpetualFuturesImaginaryFundingFee message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} EventPerpetualFuturesImaginaryFundingFee
                 */
                EventPerpetualFuturesImaginaryFundingFee.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee();
                    if (object.fee != null) {
                        if (typeof object.fee !== "object")
                            throw TypeError(".ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee.fee: object expected");
                        message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
                    }
                    if (object.fee_negative != null)
                        message.fee_negative = Boolean(object.fee_negative);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPerpetualFuturesImaginaryFundingFee message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @static
                 * @param {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} message EventPerpetualFuturesImaginaryFundingFee
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPerpetualFuturesImaginaryFundingFee.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.fee = null;
                        object.position_id = "";
                        object.fee_negative = false;
                    }
                    if (message.fee != null && message.hasOwnProperty("fee"))
                        object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    if (message.fee_negative != null && message.hasOwnProperty("fee_negative"))
                        object.fee_negative = message.fee_negative;
                    return object;
                };
    
                /**
                 * Converts this EventPerpetualFuturesImaginaryFundingFee to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPerpetualFuturesImaginaryFundingFee.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPerpetualFuturesImaginaryFundingFee;
            })();
    
            derivatives.EventPerpetualFuturesLiquidationFee = (function() {
    
                /**
                 * Properties of an EventPerpetualFuturesLiquidationFee.
                 * @memberof ununifi.derivatives
                 * @interface IEventPerpetualFuturesLiquidationFee
                 * @property {cosmos.base.v1beta1.ICoin|null} [fee] EventPerpetualFuturesLiquidationFee fee
                 * @property {string|null} [position_id] EventPerpetualFuturesLiquidationFee position_id
                 */
    
                /**
                 * Constructs a new EventPerpetualFuturesLiquidationFee.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPerpetualFuturesLiquidationFee.
                 * @implements IEventPerpetualFuturesLiquidationFee
                 * @constructor
                 * @param {ununifi.derivatives.IEventPerpetualFuturesLiquidationFee=} [properties] Properties to set
                 */
                function EventPerpetualFuturesLiquidationFee(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPerpetualFuturesLiquidationFee fee.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @instance
                 */
                EventPerpetualFuturesLiquidationFee.prototype.fee = null;
    
                /**
                 * EventPerpetualFuturesLiquidationFee position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @instance
                 */
                EventPerpetualFuturesLiquidationFee.prototype.position_id = "";
    
                /**
                 * Encodes the specified EventPerpetualFuturesLiquidationFee message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLiquidationFee.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesLiquidationFee} message EventPerpetualFuturesLiquidationFee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesLiquidationFee.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPerpetualFuturesLiquidationFee message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLiquidationFee.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesLiquidationFee} message EventPerpetualFuturesLiquidationFee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesLiquidationFee.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPerpetualFuturesLiquidationFee message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} EventPerpetualFuturesLiquidationFee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesLiquidationFee.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPerpetualFuturesLiquidationFee();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPerpetualFuturesLiquidationFee message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} EventPerpetualFuturesLiquidationFee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesLiquidationFee.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPerpetualFuturesLiquidationFee message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPerpetualFuturesLiquidationFee.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fee != null && message.hasOwnProperty("fee")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
                        if (error)
                            return "fee." + error;
                    }
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPerpetualFuturesLiquidationFee message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} EventPerpetualFuturesLiquidationFee
                 */
                EventPerpetualFuturesLiquidationFee.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesLiquidationFee)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPerpetualFuturesLiquidationFee();
                    if (object.fee != null) {
                        if (typeof object.fee !== "object")
                            throw TypeError(".ununifi.derivatives.EventPerpetualFuturesLiquidationFee.fee: object expected");
                        message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
                    }
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPerpetualFuturesLiquidationFee message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @static
                 * @param {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} message EventPerpetualFuturesLiquidationFee
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPerpetualFuturesLiquidationFee.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.fee = null;
                        object.position_id = "";
                    }
                    if (message.fee != null && message.hasOwnProperty("fee"))
                        object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this EventPerpetualFuturesLiquidationFee to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPerpetualFuturesLiquidationFee.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPerpetualFuturesLiquidationFee;
            })();
    
            derivatives.EventLiquidationNeeded = (function() {
    
                /**
                 * Properties of an EventLiquidationNeeded.
                 * @memberof ununifi.derivatives
                 * @interface IEventLiquidationNeeded
                 * @property {string|null} [position_id] EventLiquidationNeeded position_id
                 */
    
                /**
                 * Constructs a new EventLiquidationNeeded.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventLiquidationNeeded.
                 * @implements IEventLiquidationNeeded
                 * @constructor
                 * @param {ununifi.derivatives.IEventLiquidationNeeded=} [properties] Properties to set
                 */
                function EventLiquidationNeeded(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventLiquidationNeeded position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @instance
                 */
                EventLiquidationNeeded.prototype.position_id = "";
    
                /**
                 * Encodes the specified EventLiquidationNeeded message. Does not implicitly {@link ununifi.derivatives.EventLiquidationNeeded.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @static
                 * @param {ununifi.derivatives.IEventLiquidationNeeded} message EventLiquidationNeeded message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventLiquidationNeeded.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventLiquidationNeeded message, length delimited. Does not implicitly {@link ununifi.derivatives.EventLiquidationNeeded.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @static
                 * @param {ununifi.derivatives.IEventLiquidationNeeded} message EventLiquidationNeeded message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventLiquidationNeeded.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventLiquidationNeeded message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventLiquidationNeeded} EventLiquidationNeeded
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventLiquidationNeeded.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventLiquidationNeeded();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventLiquidationNeeded message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventLiquidationNeeded} EventLiquidationNeeded
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventLiquidationNeeded.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventLiquidationNeeded message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventLiquidationNeeded.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventLiquidationNeeded message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventLiquidationNeeded} EventLiquidationNeeded
                 */
                EventLiquidationNeeded.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventLiquidationNeeded)
                        return object;
                    var message = new $root.ununifi.derivatives.EventLiquidationNeeded();
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventLiquidationNeeded message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @static
                 * @param {ununifi.derivatives.EventLiquidationNeeded} message EventLiquidationNeeded
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventLiquidationNeeded.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.position_id = "";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this EventLiquidationNeeded to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventLiquidationNeeded
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventLiquidationNeeded.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventLiquidationNeeded;
            })();
    
            derivatives.PerpetualFuturesParams = (function() {
    
                /**
                 * Properties of a PerpetualFuturesParams.
                 * @memberof ununifi.derivatives
                 * @interface IPerpetualFuturesParams
                 * @property {string|null} [commission_rate] PerpetualFuturesParams commission_rate
                 * @property {string|null} [margin_maintenance_rate] PerpetualFuturesParams margin_maintenance_rate
                 * @property {string|null} [imaginary_funding_rate_proportional_coefficient] PerpetualFuturesParams imaginary_funding_rate_proportional_coefficient
                 * @property {Array.<ununifi.derivatives.IMarket>|null} [markets] PerpetualFuturesParams markets
                 * @property {number|null} [max_leverage] PerpetualFuturesParams max_leverage
                 */
    
                /**
                 * Constructs a new PerpetualFuturesParams.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PerpetualFuturesParams.
                 * @implements IPerpetualFuturesParams
                 * @constructor
                 * @param {ununifi.derivatives.IPerpetualFuturesParams=} [properties] Properties to set
                 */
                function PerpetualFuturesParams(properties) {
                    this.markets = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PerpetualFuturesParams commission_rate.
                 * @member {string} commission_rate
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @instance
                 */
                PerpetualFuturesParams.prototype.commission_rate = "";
    
                /**
                 * PerpetualFuturesParams margin_maintenance_rate.
                 * @member {string} margin_maintenance_rate
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @instance
                 */
                PerpetualFuturesParams.prototype.margin_maintenance_rate = "";
    
                /**
                 * PerpetualFuturesParams imaginary_funding_rate_proportional_coefficient.
                 * @member {string} imaginary_funding_rate_proportional_coefficient
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @instance
                 */
                PerpetualFuturesParams.prototype.imaginary_funding_rate_proportional_coefficient = "";
    
                /**
                 * PerpetualFuturesParams markets.
                 * @member {Array.<ununifi.derivatives.IMarket>} markets
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @instance
                 */
                PerpetualFuturesParams.prototype.markets = $util.emptyArray;
    
                /**
                 * PerpetualFuturesParams max_leverage.
                 * @member {number} max_leverage
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @instance
                 */
                PerpetualFuturesParams.prototype.max_leverage = 0;
    
                /**
                 * Encodes the specified PerpetualFuturesParams message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesParams.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesParams} message PerpetualFuturesParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.commission_rate != null && Object.hasOwnProperty.call(message, "commission_rate"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commission_rate);
                    if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, "margin_maintenance_rate"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.margin_maintenance_rate);
                    if (message.imaginary_funding_rate_proportional_coefficient != null && Object.hasOwnProperty.call(message, "imaginary_funding_rate_proportional_coefficient"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.imaginary_funding_rate_proportional_coefficient);
                    if (message.markets != null && message.markets.length)
                        for (var i = 0; i < message.markets.length; ++i)
                            $root.ununifi.derivatives.Market.encode(message.markets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.max_leverage != null && Object.hasOwnProperty.call(message, "max_leverage"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.max_leverage);
                    return writer;
                };
    
                /**
                 * Encodes the specified PerpetualFuturesParams message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesParams} message PerpetualFuturesParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PerpetualFuturesParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PerpetualFuturesParams} PerpetualFuturesParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PerpetualFuturesParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.commission_rate = reader.string();
                            break;
                        case 2:
                            message.margin_maintenance_rate = reader.string();
                            break;
                        case 3:
                            message.imaginary_funding_rate_proportional_coefficient = reader.string();
                            break;
                        case 4:
                            if (!(message.markets && message.markets.length))
                                message.markets = [];
                            message.markets.push($root.ununifi.derivatives.Market.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.max_leverage = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PerpetualFuturesParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PerpetualFuturesParams} PerpetualFuturesParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PerpetualFuturesParams message.
                 * @function verify
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PerpetualFuturesParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.commission_rate != null && message.hasOwnProperty("commission_rate"))
                        if (!$util.isString(message.commission_rate))
                            return "commission_rate: string expected";
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        if (!$util.isString(message.margin_maintenance_rate))
                            return "margin_maintenance_rate: string expected";
                    if (message.imaginary_funding_rate_proportional_coefficient != null && message.hasOwnProperty("imaginary_funding_rate_proportional_coefficient"))
                        if (!$util.isString(message.imaginary_funding_rate_proportional_coefficient))
                            return "imaginary_funding_rate_proportional_coefficient: string expected";
                    if (message.markets != null && message.hasOwnProperty("markets")) {
                        if (!Array.isArray(message.markets))
                            return "markets: array expected";
                        for (var i = 0; i < message.markets.length; ++i) {
                            var error = $root.ununifi.derivatives.Market.verify(message.markets[i]);
                            if (error)
                                return "markets." + error;
                        }
                    }
                    if (message.max_leverage != null && message.hasOwnProperty("max_leverage"))
                        if (!$util.isInteger(message.max_leverage))
                            return "max_leverage: integer expected";
                    return null;
                };
    
                /**
                 * Creates a PerpetualFuturesParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PerpetualFuturesParams} PerpetualFuturesParams
                 */
                PerpetualFuturesParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PerpetualFuturesParams)
                        return object;
                    var message = new $root.ununifi.derivatives.PerpetualFuturesParams();
                    if (object.commission_rate != null)
                        message.commission_rate = String(object.commission_rate);
                    if (object.margin_maintenance_rate != null)
                        message.margin_maintenance_rate = String(object.margin_maintenance_rate);
                    if (object.imaginary_funding_rate_proportional_coefficient != null)
                        message.imaginary_funding_rate_proportional_coefficient = String(object.imaginary_funding_rate_proportional_coefficient);
                    if (object.markets) {
                        if (!Array.isArray(object.markets))
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesParams.markets: array expected");
                        message.markets = [];
                        for (var i = 0; i < object.markets.length; ++i) {
                            if (typeof object.markets[i] !== "object")
                                throw TypeError(".ununifi.derivatives.PerpetualFuturesParams.markets: object expected");
                            message.markets[i] = $root.ununifi.derivatives.Market.fromObject(object.markets[i]);
                        }
                    }
                    if (object.max_leverage != null)
                        message.max_leverage = object.max_leverage >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a PerpetualFuturesParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @static
                 * @param {ununifi.derivatives.PerpetualFuturesParams} message PerpetualFuturesParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PerpetualFuturesParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.markets = [];
                    if (options.defaults) {
                        object.commission_rate = "";
                        object.margin_maintenance_rate = "";
                        object.imaginary_funding_rate_proportional_coefficient = "";
                        object.max_leverage = 0;
                    }
                    if (message.commission_rate != null && message.hasOwnProperty("commission_rate"))
                        object.commission_rate = message.commission_rate;
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        object.margin_maintenance_rate = message.margin_maintenance_rate;
                    if (message.imaginary_funding_rate_proportional_coefficient != null && message.hasOwnProperty("imaginary_funding_rate_proportional_coefficient"))
                        object.imaginary_funding_rate_proportional_coefficient = message.imaginary_funding_rate_proportional_coefficient;
                    if (message.markets && message.markets.length) {
                        object.markets = [];
                        for (var j = 0; j < message.markets.length; ++j)
                            object.markets[j] = $root.ununifi.derivatives.Market.toObject(message.markets[j], options);
                    }
                    if (message.max_leverage != null && message.hasOwnProperty("max_leverage"))
                        object.max_leverage = message.max_leverage;
                    return object;
                };
    
                /**
                 * Converts this PerpetualFuturesParams to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PerpetualFuturesParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PerpetualFuturesParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PerpetualFuturesParams;
            })();
    
            derivatives.PerpetualFuturesPosition = (function() {
    
                /**
                 * Properties of a PerpetualFuturesPosition.
                 * @memberof ununifi.derivatives
                 * @interface IPerpetualFuturesPosition
                 * @property {string|null} [id] PerpetualFuturesPosition id
                 * @property {ununifi.derivatives.IMarket|null} [market] PerpetualFuturesPosition market
                 * @property {string|null} [opener_address] PerpetualFuturesPosition opener_address
                 * @property {google.protobuf.ITimestamp|null} [opened_at] PerpetualFuturesPosition opened_at
                 * @property {Long|null} [opened_height] PerpetualFuturesPosition opened_height
                 * @property {string|null} [opened_base_rate] PerpetualFuturesPosition opened_base_rate
                 * @property {string|null} [opened_quote_rate] PerpetualFuturesPosition opened_quote_rate
                 * @property {cosmos.base.v1beta1.ICoin|null} [remaining_margin] PerpetualFuturesPosition remaining_margin
                 * @property {cosmos.base.v1beta1.ICoin|null} [levied_amount] PerpetualFuturesPosition levied_amount
                 * @property {boolean|null} [levied_amount_negative] PerpetualFuturesPosition levied_amount_negative
                 * @property {google.protobuf.ITimestamp|null} [last_levied_at] PerpetualFuturesPosition last_levied_at
                 * @property {ununifi.derivatives.IPerpetualFuturesPositionInstance|null} [position_instance] PerpetualFuturesPosition position_instance
                 */
    
                /**
                 * Constructs a new PerpetualFuturesPosition.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PerpetualFuturesPosition.
                 * @implements IPerpetualFuturesPosition
                 * @constructor
                 * @param {ununifi.derivatives.IPerpetualFuturesPosition=} [properties] Properties to set
                 */
                function PerpetualFuturesPosition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PerpetualFuturesPosition id.
                 * @member {string} id
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.id = "";
    
                /**
                 * PerpetualFuturesPosition market.
                 * @member {ununifi.derivatives.IMarket|null|undefined} market
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.market = null;
    
                /**
                 * PerpetualFuturesPosition opener_address.
                 * @member {string} opener_address
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.opener_address = "";
    
                /**
                 * PerpetualFuturesPosition opened_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} opened_at
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.opened_at = null;
    
                /**
                 * PerpetualFuturesPosition opened_height.
                 * @member {Long} opened_height
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.opened_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * PerpetualFuturesPosition opened_base_rate.
                 * @member {string} opened_base_rate
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.opened_base_rate = "";
    
                /**
                 * PerpetualFuturesPosition opened_quote_rate.
                 * @member {string} opened_quote_rate
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.opened_quote_rate = "";
    
                /**
                 * PerpetualFuturesPosition remaining_margin.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} remaining_margin
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.remaining_margin = null;
    
                /**
                 * PerpetualFuturesPosition levied_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} levied_amount
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.levied_amount = null;
    
                /**
                 * PerpetualFuturesPosition levied_amount_negative.
                 * @member {boolean} levied_amount_negative
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.levied_amount_negative = false;
    
                /**
                 * PerpetualFuturesPosition last_levied_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} last_levied_at
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.last_levied_at = null;
    
                /**
                 * PerpetualFuturesPosition position_instance.
                 * @member {ununifi.derivatives.IPerpetualFuturesPositionInstance|null|undefined} position_instance
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 */
                PerpetualFuturesPosition.prototype.position_instance = null;
    
                /**
                 * Encodes the specified PerpetualFuturesPosition message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPosition.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesPosition} message PerpetualFuturesPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesPosition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.market != null && Object.hasOwnProperty.call(message, "market"))
                        $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.opener_address != null && Object.hasOwnProperty.call(message, "opener_address"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.opener_address);
                    if (message.opened_at != null && Object.hasOwnProperty.call(message, "opened_at"))
                        $root.google.protobuf.Timestamp.encode(message.opened_at, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.opened_height != null && Object.hasOwnProperty.call(message, "opened_height"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.opened_height);
                    if (message.opened_base_rate != null && Object.hasOwnProperty.call(message, "opened_base_rate"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.opened_base_rate);
                    if (message.opened_quote_rate != null && Object.hasOwnProperty.call(message, "opened_quote_rate"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.opened_quote_rate);
                    if (message.remaining_margin != null && Object.hasOwnProperty.call(message, "remaining_margin"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.remaining_margin, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.levied_amount != null && Object.hasOwnProperty.call(message, "levied_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.levied_amount, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.levied_amount_negative != null && Object.hasOwnProperty.call(message, "levied_amount_negative"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.levied_amount_negative);
                    if (message.last_levied_at != null && Object.hasOwnProperty.call(message, "last_levied_at"))
                        $root.google.protobuf.Timestamp.encode(message.last_levied_at, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.position_instance != null && Object.hasOwnProperty.call(message, "position_instance"))
                        $root.ununifi.derivatives.PerpetualFuturesPositionInstance.encode(message.position_instance, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PerpetualFuturesPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPosition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesPosition} message PerpetualFuturesPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesPosition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PerpetualFuturesPosition message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PerpetualFuturesPosition} PerpetualFuturesPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesPosition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PerpetualFuturesPosition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.opener_address = reader.string();
                            break;
                        case 4:
                            message.opened_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.opened_height = reader.uint64();
                            break;
                        case 6:
                            message.opened_base_rate = reader.string();
                            break;
                        case 7:
                            message.opened_quote_rate = reader.string();
                            break;
                        case 8:
                            message.remaining_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.levied_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.levied_amount_negative = reader.bool();
                            break;
                        case 11:
                            message.last_levied_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.position_instance = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PerpetualFuturesPosition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PerpetualFuturesPosition} PerpetualFuturesPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesPosition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PerpetualFuturesPosition message.
                 * @function verify
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PerpetualFuturesPosition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.market != null && message.hasOwnProperty("market")) {
                        var error = $root.ununifi.derivatives.Market.verify(message.market);
                        if (error)
                            return "market." + error;
                    }
                    if (message.opener_address != null && message.hasOwnProperty("opener_address"))
                        if (!$util.isString(message.opener_address))
                            return "opener_address: string expected";
                    if (message.opened_at != null && message.hasOwnProperty("opened_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.opened_at);
                        if (error)
                            return "opened_at." + error;
                    }
                    if (message.opened_height != null && message.hasOwnProperty("opened_height"))
                        if (!$util.isInteger(message.opened_height) && !(message.opened_height && $util.isInteger(message.opened_height.low) && $util.isInteger(message.opened_height.high)))
                            return "opened_height: integer|Long expected";
                    if (message.opened_base_rate != null && message.hasOwnProperty("opened_base_rate"))
                        if (!$util.isString(message.opened_base_rate))
                            return "opened_base_rate: string expected";
                    if (message.opened_quote_rate != null && message.hasOwnProperty("opened_quote_rate"))
                        if (!$util.isString(message.opened_quote_rate))
                            return "opened_quote_rate: string expected";
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.remaining_margin);
                        if (error)
                            return "remaining_margin." + error;
                    }
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.levied_amount);
                        if (error)
                            return "levied_amount." + error;
                    }
                    if (message.levied_amount_negative != null && message.hasOwnProperty("levied_amount_negative"))
                        if (typeof message.levied_amount_negative !== "boolean")
                            return "levied_amount_negative: boolean expected";
                    if (message.last_levied_at != null && message.hasOwnProperty("last_levied_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.last_levied_at);
                        if (error)
                            return "last_levied_at." + error;
                    }
                    if (message.position_instance != null && message.hasOwnProperty("position_instance")) {
                        var error = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.verify(message.position_instance);
                        if (error)
                            return "position_instance." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a PerpetualFuturesPosition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PerpetualFuturesPosition} PerpetualFuturesPosition
                 */
                PerpetualFuturesPosition.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PerpetualFuturesPosition)
                        return object;
                    var message = new $root.ununifi.derivatives.PerpetualFuturesPosition();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.market != null) {
                        if (typeof object.market !== "object")
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesPosition.market: object expected");
                        message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
                    }
                    if (object.opener_address != null)
                        message.opener_address = String(object.opener_address);
                    if (object.opened_at != null) {
                        if (typeof object.opened_at !== "object")
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesPosition.opened_at: object expected");
                        message.opened_at = $root.google.protobuf.Timestamp.fromObject(object.opened_at);
                    }
                    if (object.opened_height != null)
                        if ($util.Long)
                            (message.opened_height = $util.Long.fromValue(object.opened_height)).unsigned = true;
                        else if (typeof object.opened_height === "string")
                            message.opened_height = parseInt(object.opened_height, 10);
                        else if (typeof object.opened_height === "number")
                            message.opened_height = object.opened_height;
                        else if (typeof object.opened_height === "object")
                            message.opened_height = new $util.LongBits(object.opened_height.low >>> 0, object.opened_height.high >>> 0).toNumber(true);
                    if (object.opened_base_rate != null)
                        message.opened_base_rate = String(object.opened_base_rate);
                    if (object.opened_quote_rate != null)
                        message.opened_quote_rate = String(object.opened_quote_rate);
                    if (object.remaining_margin != null) {
                        if (typeof object.remaining_margin !== "object")
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesPosition.remaining_margin: object expected");
                        message.remaining_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.remaining_margin);
                    }
                    if (object.levied_amount != null) {
                        if (typeof object.levied_amount !== "object")
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesPosition.levied_amount: object expected");
                        message.levied_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.levied_amount);
                    }
                    if (object.levied_amount_negative != null)
                        message.levied_amount_negative = Boolean(object.levied_amount_negative);
                    if (object.last_levied_at != null) {
                        if (typeof object.last_levied_at !== "object")
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesPosition.last_levied_at: object expected");
                        message.last_levied_at = $root.google.protobuf.Timestamp.fromObject(object.last_levied_at);
                    }
                    if (object.position_instance != null) {
                        if (typeof object.position_instance !== "object")
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesPosition.position_instance: object expected");
                        message.position_instance = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.fromObject(object.position_instance);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PerpetualFuturesPosition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @static
                 * @param {ununifi.derivatives.PerpetualFuturesPosition} message PerpetualFuturesPosition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PerpetualFuturesPosition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.market = null;
                        object.opener_address = "";
                        object.opened_at = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.opened_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.opened_height = options.longs === String ? "0" : 0;
                        object.opened_base_rate = "";
                        object.opened_quote_rate = "";
                        object.remaining_margin = null;
                        object.levied_amount = null;
                        object.levied_amount_negative = false;
                        object.last_levied_at = null;
                        object.position_instance = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.market != null && message.hasOwnProperty("market"))
                        object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
                    if (message.opener_address != null && message.hasOwnProperty("opener_address"))
                        object.opener_address = message.opener_address;
                    if (message.opened_at != null && message.hasOwnProperty("opened_at"))
                        object.opened_at = $root.google.protobuf.Timestamp.toObject(message.opened_at, options);
                    if (message.opened_height != null && message.hasOwnProperty("opened_height"))
                        if (typeof message.opened_height === "number")
                            object.opened_height = options.longs === String ? String(message.opened_height) : message.opened_height;
                        else
                            object.opened_height = options.longs === String ? $util.Long.prototype.toString.call(message.opened_height) : options.longs === Number ? new $util.LongBits(message.opened_height.low >>> 0, message.opened_height.high >>> 0).toNumber(true) : message.opened_height;
                    if (message.opened_base_rate != null && message.hasOwnProperty("opened_base_rate"))
                        object.opened_base_rate = message.opened_base_rate;
                    if (message.opened_quote_rate != null && message.hasOwnProperty("opened_quote_rate"))
                        object.opened_quote_rate = message.opened_quote_rate;
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin"))
                        object.remaining_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.remaining_margin, options);
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount"))
                        object.levied_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.levied_amount, options);
                    if (message.levied_amount_negative != null && message.hasOwnProperty("levied_amount_negative"))
                        object.levied_amount_negative = message.levied_amount_negative;
                    if (message.last_levied_at != null && message.hasOwnProperty("last_levied_at"))
                        object.last_levied_at = $root.google.protobuf.Timestamp.toObject(message.last_levied_at, options);
                    if (message.position_instance != null && message.hasOwnProperty("position_instance"))
                        object.position_instance = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.toObject(message.position_instance, options);
                    return object;
                };
    
                /**
                 * Converts this PerpetualFuturesPosition to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PerpetualFuturesPosition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PerpetualFuturesPosition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PerpetualFuturesPosition;
            })();
    
            derivatives.PerpetualFuturesPositionInstance = (function() {
    
                /**
                 * Properties of a PerpetualFuturesPositionInstance.
                 * @memberof ununifi.derivatives
                 * @interface IPerpetualFuturesPositionInstance
                 * @property {ununifi.derivatives.PositionType|null} [position_type] PerpetualFuturesPositionInstance position_type
                 * @property {string|null} [size] PerpetualFuturesPositionInstance size
                 * @property {number|null} [leverage] PerpetualFuturesPositionInstance leverage
                 */
    
                /**
                 * Constructs a new PerpetualFuturesPositionInstance.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PerpetualFuturesPositionInstance.
                 * @implements IPerpetualFuturesPositionInstance
                 * @constructor
                 * @param {ununifi.derivatives.IPerpetualFuturesPositionInstance=} [properties] Properties to set
                 */
                function PerpetualFuturesPositionInstance(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PerpetualFuturesPositionInstance position_type.
                 * @member {ununifi.derivatives.PositionType} position_type
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @instance
                 */
                PerpetualFuturesPositionInstance.prototype.position_type = 0;
    
                /**
                 * PerpetualFuturesPositionInstance size.
                 * @member {string} size
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @instance
                 */
                PerpetualFuturesPositionInstance.prototype.size = "";
    
                /**
                 * PerpetualFuturesPositionInstance leverage.
                 * @member {number} leverage
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @instance
                 */
                PerpetualFuturesPositionInstance.prototype.leverage = 0;
    
                /**
                 * Encodes the specified PerpetualFuturesPositionInstance message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPositionInstance.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesPositionInstance} message PerpetualFuturesPositionInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesPositionInstance.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position_type != null && Object.hasOwnProperty.call(message, "position_type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.position_type);
                    if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.size);
                    if (message.leverage != null && Object.hasOwnProperty.call(message, "leverage"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.leverage);
                    return writer;
                };
    
                /**
                 * Encodes the specified PerpetualFuturesPositionInstance message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPositionInstance.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesPositionInstance} message PerpetualFuturesPositionInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesPositionInstance.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PerpetualFuturesPositionInstance message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PerpetualFuturesPositionInstance} PerpetualFuturesPositionInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesPositionInstance.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PerpetualFuturesPositionInstance();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position_type = reader.int32();
                            break;
                        case 2:
                            message.size = reader.string();
                            break;
                        case 3:
                            message.leverage = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PerpetualFuturesPositionInstance message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PerpetualFuturesPositionInstance} PerpetualFuturesPositionInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesPositionInstance.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PerpetualFuturesPositionInstance message.
                 * @function verify
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PerpetualFuturesPositionInstance.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        switch (message.position_type) {
                        default:
                            return "position_type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.size != null && message.hasOwnProperty("size"))
                        if (!$util.isString(message.size))
                            return "size: string expected";
                    if (message.leverage != null && message.hasOwnProperty("leverage"))
                        if (!$util.isInteger(message.leverage))
                            return "leverage: integer expected";
                    return null;
                };
    
                /**
                 * Creates a PerpetualFuturesPositionInstance message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PerpetualFuturesPositionInstance} PerpetualFuturesPositionInstance
                 */
                PerpetualFuturesPositionInstance.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PerpetualFuturesPositionInstance)
                        return object;
                    var message = new $root.ununifi.derivatives.PerpetualFuturesPositionInstance();
                    switch (object.position_type) {
                    case "POSITION_UNKNOWN":
                    case 0:
                        message.position_type = 0;
                        break;
                    case "LONG":
                    case 1:
                        message.position_type = 1;
                        break;
                    case "SHORT":
                    case 2:
                        message.position_type = 2;
                        break;
                    }
                    if (object.size != null)
                        message.size = String(object.size);
                    if (object.leverage != null)
                        message.leverage = object.leverage >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a PerpetualFuturesPositionInstance message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @static
                 * @param {ununifi.derivatives.PerpetualFuturesPositionInstance} message PerpetualFuturesPositionInstance
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PerpetualFuturesPositionInstance.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.position_type = options.enums === String ? "POSITION_UNKNOWN" : 0;
                        object.size = "";
                        object.leverage = 0;
                    }
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        object.position_type = options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
                    if (message.size != null && message.hasOwnProperty("size"))
                        object.size = message.size;
                    if (message.leverage != null && message.hasOwnProperty("leverage"))
                        object.leverage = message.leverage;
                    return object;
                };
    
                /**
                 * Converts this PerpetualFuturesPositionInstance to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PerpetualFuturesPositionInstance.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PerpetualFuturesPositionInstance;
            })();
    
            derivatives.PerpetualFuturesGrossPositionOfMarket = (function() {
    
                /**
                 * Properties of a PerpetualFuturesGrossPositionOfMarket.
                 * @memberof ununifi.derivatives
                 * @interface IPerpetualFuturesGrossPositionOfMarket
                 * @property {ununifi.derivatives.IMarket|null} [market] PerpetualFuturesGrossPositionOfMarket market
                 * @property {ununifi.derivatives.PositionType|null} [position_type] PerpetualFuturesGrossPositionOfMarket position_type
                 * @property {string|null} [position_size_in_denom_exponent] PerpetualFuturesGrossPositionOfMarket position_size_in_denom_exponent
                 */
    
                /**
                 * Constructs a new PerpetualFuturesGrossPositionOfMarket.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PerpetualFuturesGrossPositionOfMarket.
                 * @implements IPerpetualFuturesGrossPositionOfMarket
                 * @constructor
                 * @param {ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket=} [properties] Properties to set
                 */
                function PerpetualFuturesGrossPositionOfMarket(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PerpetualFuturesGrossPositionOfMarket market.
                 * @member {ununifi.derivatives.IMarket|null|undefined} market
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @instance
                 */
                PerpetualFuturesGrossPositionOfMarket.prototype.market = null;
    
                /**
                 * PerpetualFuturesGrossPositionOfMarket position_type.
                 * @member {ununifi.derivatives.PositionType} position_type
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @instance
                 */
                PerpetualFuturesGrossPositionOfMarket.prototype.position_type = 0;
    
                /**
                 * PerpetualFuturesGrossPositionOfMarket position_size_in_denom_exponent.
                 * @member {string} position_size_in_denom_exponent
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @instance
                 */
                PerpetualFuturesGrossPositionOfMarket.prototype.position_size_in_denom_exponent = "";
    
                /**
                 * Encodes the specified PerpetualFuturesGrossPositionOfMarket message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket} message PerpetualFuturesGrossPositionOfMarket message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesGrossPositionOfMarket.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market != null && Object.hasOwnProperty.call(message, "market"))
                        $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.position_type != null && Object.hasOwnProperty.call(message, "position_type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.position_type);
                    if (message.position_size_in_denom_exponent != null && Object.hasOwnProperty.call(message, "position_size_in_denom_exponent"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.position_size_in_denom_exponent);
                    return writer;
                };
    
                /**
                 * Encodes the specified PerpetualFuturesGrossPositionOfMarket message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @static
                 * @param {ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket} message PerpetualFuturesGrossPositionOfMarket message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualFuturesGrossPositionOfMarket.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PerpetualFuturesGrossPositionOfMarket message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} PerpetualFuturesGrossPositionOfMarket
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesGrossPositionOfMarket.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.position_type = reader.int32();
                            break;
                        case 3:
                            message.position_size_in_denom_exponent = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PerpetualFuturesGrossPositionOfMarket message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} PerpetualFuturesGrossPositionOfMarket
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualFuturesGrossPositionOfMarket.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PerpetualFuturesGrossPositionOfMarket message.
                 * @function verify
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PerpetualFuturesGrossPositionOfMarket.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market != null && message.hasOwnProperty("market")) {
                        var error = $root.ununifi.derivatives.Market.verify(message.market);
                        if (error)
                            return "market." + error;
                    }
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        switch (message.position_type) {
                        default:
                            return "position_type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.position_size_in_denom_exponent != null && message.hasOwnProperty("position_size_in_denom_exponent"))
                        if (!$util.isString(message.position_size_in_denom_exponent))
                            return "position_size_in_denom_exponent: string expected";
                    return null;
                };
    
                /**
                 * Creates a PerpetualFuturesGrossPositionOfMarket message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} PerpetualFuturesGrossPositionOfMarket
                 */
                PerpetualFuturesGrossPositionOfMarket.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket)
                        return object;
                    var message = new $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket();
                    if (object.market != null) {
                        if (typeof object.market !== "object")
                            throw TypeError(".ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.market: object expected");
                        message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
                    }
                    switch (object.position_type) {
                    case "POSITION_UNKNOWN":
                    case 0:
                        message.position_type = 0;
                        break;
                    case "LONG":
                    case 1:
                        message.position_type = 1;
                        break;
                    case "SHORT":
                    case 2:
                        message.position_type = 2;
                        break;
                    }
                    if (object.position_size_in_denom_exponent != null)
                        message.position_size_in_denom_exponent = String(object.position_size_in_denom_exponent);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PerpetualFuturesGrossPositionOfMarket message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @static
                 * @param {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} message PerpetualFuturesGrossPositionOfMarket
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PerpetualFuturesGrossPositionOfMarket.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.market = null;
                        object.position_type = options.enums === String ? "POSITION_UNKNOWN" : 0;
                        object.position_size_in_denom_exponent = "";
                    }
                    if (message.market != null && message.hasOwnProperty("market"))
                        object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        object.position_type = options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
                    if (message.position_size_in_denom_exponent != null && message.hasOwnProperty("position_size_in_denom_exponent"))
                        object.position_size_in_denom_exponent = message.position_size_in_denom_exponent;
                    return object;
                };
    
                /**
                 * Converts this PerpetualFuturesGrossPositionOfMarket to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PerpetualFuturesGrossPositionOfMarket.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PerpetualFuturesGrossPositionOfMarket;
            })();
    
            derivatives.EventPerpetualFuturesPositionOpened = (function() {
    
                /**
                 * Properties of an EventPerpetualFuturesPositionOpened.
                 * @memberof ununifi.derivatives
                 * @interface IEventPerpetualFuturesPositionOpened
                 * @property {string|null} [sender] EventPerpetualFuturesPositionOpened sender
                 * @property {string|null} [position_id] EventPerpetualFuturesPositionOpened position_id
                 */
    
                /**
                 * Constructs a new EventPerpetualFuturesPositionOpened.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPerpetualFuturesPositionOpened.
                 * @implements IEventPerpetualFuturesPositionOpened
                 * @constructor
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionOpened=} [properties] Properties to set
                 */
                function EventPerpetualFuturesPositionOpened(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPerpetualFuturesPositionOpened sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @instance
                 */
                EventPerpetualFuturesPositionOpened.prototype.sender = "";
    
                /**
                 * EventPerpetualFuturesPositionOpened position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @instance
                 */
                EventPerpetualFuturesPositionOpened.prototype.position_id = "";
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionOpened message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionOpened.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionOpened} message EventPerpetualFuturesPositionOpened message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionOpened.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionOpened message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionOpened.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionOpened} message EventPerpetualFuturesPositionOpened message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionOpened.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionOpened message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionOpened} EventPerpetualFuturesPositionOpened
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionOpened.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionOpened();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionOpened message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionOpened} EventPerpetualFuturesPositionOpened
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionOpened.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPerpetualFuturesPositionOpened message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPerpetualFuturesPositionOpened.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPerpetualFuturesPositionOpened message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionOpened} EventPerpetualFuturesPositionOpened
                 */
                EventPerpetualFuturesPositionOpened.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionOpened)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionOpened();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPerpetualFuturesPositionOpened message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @static
                 * @param {ununifi.derivatives.EventPerpetualFuturesPositionOpened} message EventPerpetualFuturesPositionOpened
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPerpetualFuturesPositionOpened.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.position_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this EventPerpetualFuturesPositionOpened to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPerpetualFuturesPositionOpened.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPerpetualFuturesPositionOpened;
            })();
    
            derivatives.EventPerpetualFuturesPositionClosed = (function() {
    
                /**
                 * Properties of an EventPerpetualFuturesPositionClosed.
                 * @memberof ununifi.derivatives
                 * @interface IEventPerpetualFuturesPositionClosed
                 * @property {string|null} [sender] EventPerpetualFuturesPositionClosed sender
                 * @property {string|null} [position_id] EventPerpetualFuturesPositionClosed position_id
                 * @property {string|null} [position_size] EventPerpetualFuturesPositionClosed position_size
                 * @property {string|null} [pnl_amount] EventPerpetualFuturesPositionClosed pnl_amount
                 * @property {string|null} [returning_amount] EventPerpetualFuturesPositionClosed returning_amount
                 */
    
                /**
                 * Constructs a new EventPerpetualFuturesPositionClosed.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPerpetualFuturesPositionClosed.
                 * @implements IEventPerpetualFuturesPositionClosed
                 * @constructor
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionClosed=} [properties] Properties to set
                 */
                function EventPerpetualFuturesPositionClosed(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPerpetualFuturesPositionClosed sender.
                 * @member {string} sender
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @instance
                 */
                EventPerpetualFuturesPositionClosed.prototype.sender = "";
    
                /**
                 * EventPerpetualFuturesPositionClosed position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @instance
                 */
                EventPerpetualFuturesPositionClosed.prototype.position_id = "";
    
                /**
                 * EventPerpetualFuturesPositionClosed position_size.
                 * @member {string} position_size
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @instance
                 */
                EventPerpetualFuturesPositionClosed.prototype.position_size = "";
    
                /**
                 * EventPerpetualFuturesPositionClosed pnl_amount.
                 * @member {string} pnl_amount
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @instance
                 */
                EventPerpetualFuturesPositionClosed.prototype.pnl_amount = "";
    
                /**
                 * EventPerpetualFuturesPositionClosed returning_amount.
                 * @member {string} returning_amount
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @instance
                 */
                EventPerpetualFuturesPositionClosed.prototype.returning_amount = "";
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionClosed message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionClosed.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionClosed} message EventPerpetualFuturesPositionClosed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionClosed.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    if (message.position_size != null && Object.hasOwnProperty.call(message, "position_size"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.position_size);
                    if (message.pnl_amount != null && Object.hasOwnProperty.call(message, "pnl_amount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.pnl_amount);
                    if (message.returning_amount != null && Object.hasOwnProperty.call(message, "returning_amount"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.returning_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionClosed message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionClosed.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionClosed} message EventPerpetualFuturesPositionClosed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionClosed.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionClosed message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionClosed} EventPerpetualFuturesPositionClosed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionClosed.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionClosed();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        case 3:
                            message.position_size = reader.string();
                            break;
                        case 4:
                            message.pnl_amount = reader.string();
                            break;
                        case 5:
                            message.returning_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionClosed message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionClosed} EventPerpetualFuturesPositionClosed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionClosed.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPerpetualFuturesPositionClosed message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPerpetualFuturesPositionClosed.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    if (message.position_size != null && message.hasOwnProperty("position_size"))
                        if (!$util.isString(message.position_size))
                            return "position_size: string expected";
                    if (message.pnl_amount != null && message.hasOwnProperty("pnl_amount"))
                        if (!$util.isString(message.pnl_amount))
                            return "pnl_amount: string expected";
                    if (message.returning_amount != null && message.hasOwnProperty("returning_amount"))
                        if (!$util.isString(message.returning_amount))
                            return "returning_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPerpetualFuturesPositionClosed message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionClosed} EventPerpetualFuturesPositionClosed
                 */
                EventPerpetualFuturesPositionClosed.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionClosed)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionClosed();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    if (object.position_size != null)
                        message.position_size = String(object.position_size);
                    if (object.pnl_amount != null)
                        message.pnl_amount = String(object.pnl_amount);
                    if (object.returning_amount != null)
                        message.returning_amount = String(object.returning_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPerpetualFuturesPositionClosed message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @static
                 * @param {ununifi.derivatives.EventPerpetualFuturesPositionClosed} message EventPerpetualFuturesPositionClosed
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPerpetualFuturesPositionClosed.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.position_id = "";
                        object.position_size = "";
                        object.pnl_amount = "";
                        object.returning_amount = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    if (message.position_size != null && message.hasOwnProperty("position_size"))
                        object.position_size = message.position_size;
                    if (message.pnl_amount != null && message.hasOwnProperty("pnl_amount"))
                        object.pnl_amount = message.pnl_amount;
                    if (message.returning_amount != null && message.hasOwnProperty("returning_amount"))
                        object.returning_amount = message.returning_amount;
                    return object;
                };
    
                /**
                 * Converts this EventPerpetualFuturesPositionClosed to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPerpetualFuturesPositionClosed.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPerpetualFuturesPositionClosed;
            })();
    
            derivatives.EventPerpetualFuturesPositionLiquidated = (function() {
    
                /**
                 * Properties of an EventPerpetualFuturesPositionLiquidated.
                 * @memberof ununifi.derivatives
                 * @interface IEventPerpetualFuturesPositionLiquidated
                 * @property {string|null} [reward_recipient] EventPerpetualFuturesPositionLiquidated reward_recipient
                 * @property {string|null} [position_id] EventPerpetualFuturesPositionLiquidated position_id
                 * @property {string|null} [remaining_margin] EventPerpetualFuturesPositionLiquidated remaining_margin
                 * @property {string|null} [reward_amount] EventPerpetualFuturesPositionLiquidated reward_amount
                 * @property {string|null} [levied_amount] EventPerpetualFuturesPositionLiquidated levied_amount
                 */
    
                /**
                 * Constructs a new EventPerpetualFuturesPositionLiquidated.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPerpetualFuturesPositionLiquidated.
                 * @implements IEventPerpetualFuturesPositionLiquidated
                 * @constructor
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLiquidated=} [properties] Properties to set
                 */
                function EventPerpetualFuturesPositionLiquidated(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPerpetualFuturesPositionLiquidated reward_recipient.
                 * @member {string} reward_recipient
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @instance
                 */
                EventPerpetualFuturesPositionLiquidated.prototype.reward_recipient = "";
    
                /**
                 * EventPerpetualFuturesPositionLiquidated position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @instance
                 */
                EventPerpetualFuturesPositionLiquidated.prototype.position_id = "";
    
                /**
                 * EventPerpetualFuturesPositionLiquidated remaining_margin.
                 * @member {string} remaining_margin
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @instance
                 */
                EventPerpetualFuturesPositionLiquidated.prototype.remaining_margin = "";
    
                /**
                 * EventPerpetualFuturesPositionLiquidated reward_amount.
                 * @member {string} reward_amount
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @instance
                 */
                EventPerpetualFuturesPositionLiquidated.prototype.reward_amount = "";
    
                /**
                 * EventPerpetualFuturesPositionLiquidated levied_amount.
                 * @member {string} levied_amount
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @instance
                 */
                EventPerpetualFuturesPositionLiquidated.prototype.levied_amount = "";
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionLiquidated message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLiquidated.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLiquidated} message EventPerpetualFuturesPositionLiquidated message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionLiquidated.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reward_recipient != null && Object.hasOwnProperty.call(message, "reward_recipient"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.reward_recipient);
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    if (message.remaining_margin != null && Object.hasOwnProperty.call(message, "remaining_margin"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.remaining_margin);
                    if (message.reward_amount != null && Object.hasOwnProperty.call(message, "reward_amount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.reward_amount);
                    if (message.levied_amount != null && Object.hasOwnProperty.call(message, "levied_amount"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.levied_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionLiquidated message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLiquidated.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLiquidated} message EventPerpetualFuturesPositionLiquidated message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionLiquidated.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionLiquidated message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} EventPerpetualFuturesPositionLiquidated
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionLiquidated.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLiquidated();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reward_recipient = reader.string();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        case 3:
                            message.remaining_margin = reader.string();
                            break;
                        case 4:
                            message.reward_amount = reader.string();
                            break;
                        case 5:
                            message.levied_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionLiquidated message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} EventPerpetualFuturesPositionLiquidated
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionLiquidated.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPerpetualFuturesPositionLiquidated message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPerpetualFuturesPositionLiquidated.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        if (!$util.isString(message.reward_recipient))
                            return "reward_recipient: string expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin"))
                        if (!$util.isString(message.remaining_margin))
                            return "remaining_margin: string expected";
                    if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                        if (!$util.isString(message.reward_amount))
                            return "reward_amount: string expected";
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount"))
                        if (!$util.isString(message.levied_amount))
                            return "levied_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPerpetualFuturesPositionLiquidated message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} EventPerpetualFuturesPositionLiquidated
                 */
                EventPerpetualFuturesPositionLiquidated.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionLiquidated)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLiquidated();
                    if (object.reward_recipient != null)
                        message.reward_recipient = String(object.reward_recipient);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    if (object.remaining_margin != null)
                        message.remaining_margin = String(object.remaining_margin);
                    if (object.reward_amount != null)
                        message.reward_amount = String(object.reward_amount);
                    if (object.levied_amount != null)
                        message.levied_amount = String(object.levied_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPerpetualFuturesPositionLiquidated message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @static
                 * @param {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} message EventPerpetualFuturesPositionLiquidated
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPerpetualFuturesPositionLiquidated.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.reward_recipient = "";
                        object.position_id = "";
                        object.remaining_margin = "";
                        object.reward_amount = "";
                        object.levied_amount = "";
                    }
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        object.reward_recipient = message.reward_recipient;
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin"))
                        object.remaining_margin = message.remaining_margin;
                    if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                        object.reward_amount = message.reward_amount;
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount"))
                        object.levied_amount = message.levied_amount;
                    return object;
                };
    
                /**
                 * Converts this EventPerpetualFuturesPositionLiquidated to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPerpetualFuturesPositionLiquidated.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPerpetualFuturesPositionLiquidated;
            })();
    
            derivatives.EventPerpetualFuturesPositionLevied = (function() {
    
                /**
                 * Properties of an EventPerpetualFuturesPositionLevied.
                 * @memberof ununifi.derivatives
                 * @interface IEventPerpetualFuturesPositionLevied
                 * @property {string|null} [reward_recipient] EventPerpetualFuturesPositionLevied reward_recipient
                 * @property {string|null} [position_id] EventPerpetualFuturesPositionLevied position_id
                 * @property {string|null} [remaining_margin] EventPerpetualFuturesPositionLevied remaining_margin
                 * @property {string|null} [reward_amount] EventPerpetualFuturesPositionLevied reward_amount
                 * @property {string|null} [levied_amount] EventPerpetualFuturesPositionLevied levied_amount
                 */
    
                /**
                 * Constructs a new EventPerpetualFuturesPositionLevied.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventPerpetualFuturesPositionLevied.
                 * @implements IEventPerpetualFuturesPositionLevied
                 * @constructor
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLevied=} [properties] Properties to set
                 */
                function EventPerpetualFuturesPositionLevied(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPerpetualFuturesPositionLevied reward_recipient.
                 * @member {string} reward_recipient
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @instance
                 */
                EventPerpetualFuturesPositionLevied.prototype.reward_recipient = "";
    
                /**
                 * EventPerpetualFuturesPositionLevied position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @instance
                 */
                EventPerpetualFuturesPositionLevied.prototype.position_id = "";
    
                /**
                 * EventPerpetualFuturesPositionLevied remaining_margin.
                 * @member {string} remaining_margin
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @instance
                 */
                EventPerpetualFuturesPositionLevied.prototype.remaining_margin = "";
    
                /**
                 * EventPerpetualFuturesPositionLevied reward_amount.
                 * @member {string} reward_amount
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @instance
                 */
                EventPerpetualFuturesPositionLevied.prototype.reward_amount = "";
    
                /**
                 * EventPerpetualFuturesPositionLevied levied_amount.
                 * @member {string} levied_amount
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @instance
                 */
                EventPerpetualFuturesPositionLevied.prototype.levied_amount = "";
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionLevied message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLevied.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLevied} message EventPerpetualFuturesPositionLevied message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionLevied.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reward_recipient != null && Object.hasOwnProperty.call(message, "reward_recipient"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.reward_recipient);
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.position_id);
                    if (message.remaining_margin != null && Object.hasOwnProperty.call(message, "remaining_margin"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.remaining_margin);
                    if (message.reward_amount != null && Object.hasOwnProperty.call(message, "reward_amount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.reward_amount);
                    if (message.levied_amount != null && Object.hasOwnProperty.call(message, "levied_amount"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.levied_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPerpetualFuturesPositionLevied message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLevied.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @static
                 * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLevied} message EventPerpetualFuturesPositionLevied message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPerpetualFuturesPositionLevied.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionLevied message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLevied} EventPerpetualFuturesPositionLevied
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionLevied.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLevied();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reward_recipient = reader.string();
                            break;
                        case 2:
                            message.position_id = reader.string();
                            break;
                        case 3:
                            message.remaining_margin = reader.string();
                            break;
                        case 4:
                            message.reward_amount = reader.string();
                            break;
                        case 5:
                            message.levied_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPerpetualFuturesPositionLevied message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLevied} EventPerpetualFuturesPositionLevied
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPerpetualFuturesPositionLevied.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPerpetualFuturesPositionLevied message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPerpetualFuturesPositionLevied.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        if (!$util.isString(message.reward_recipient))
                            return "reward_recipient: string expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin"))
                        if (!$util.isString(message.remaining_margin))
                            return "remaining_margin: string expected";
                    if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                        if (!$util.isString(message.reward_amount))
                            return "reward_amount: string expected";
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount"))
                        if (!$util.isString(message.levied_amount))
                            return "levied_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPerpetualFuturesPositionLevied message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLevied} EventPerpetualFuturesPositionLevied
                 */
                EventPerpetualFuturesPositionLevied.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionLevied)
                        return object;
                    var message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLevied();
                    if (object.reward_recipient != null)
                        message.reward_recipient = String(object.reward_recipient);
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    if (object.remaining_margin != null)
                        message.remaining_margin = String(object.remaining_margin);
                    if (object.reward_amount != null)
                        message.reward_amount = String(object.reward_amount);
                    if (object.levied_amount != null)
                        message.levied_amount = String(object.levied_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPerpetualFuturesPositionLevied message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @static
                 * @param {ununifi.derivatives.EventPerpetualFuturesPositionLevied} message EventPerpetualFuturesPositionLevied
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPerpetualFuturesPositionLevied.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.reward_recipient = "";
                        object.position_id = "";
                        object.remaining_margin = "";
                        object.reward_amount = "";
                        object.levied_amount = "";
                    }
                    if (message.reward_recipient != null && message.hasOwnProperty("reward_recipient"))
                        object.reward_recipient = message.reward_recipient;
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    if (message.remaining_margin != null && message.hasOwnProperty("remaining_margin"))
                        object.remaining_margin = message.remaining_margin;
                    if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                        object.reward_amount = message.reward_amount;
                    if (message.levied_amount != null && message.hasOwnProperty("levied_amount"))
                        object.levied_amount = message.levied_amount;
                    return object;
                };
    
                /**
                 * Converts this EventPerpetualFuturesPositionLevied to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPerpetualFuturesPositionLevied.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPerpetualFuturesPositionLevied;
            })();
    
            derivatives.EventLossToLP = (function() {
    
                /**
                 * Properties of an EventLossToLP.
                 * @memberof ununifi.derivatives
                 * @interface IEventLossToLP
                 * @property {string|null} [position_id] EventLossToLP position_id
                 * @property {string|null} [loss_amount] EventLossToLP loss_amount
                 */
    
                /**
                 * Constructs a new EventLossToLP.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents an EventLossToLP.
                 * @implements IEventLossToLP
                 * @constructor
                 * @param {ununifi.derivatives.IEventLossToLP=} [properties] Properties to set
                 */
                function EventLossToLP(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventLossToLP position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @instance
                 */
                EventLossToLP.prototype.position_id = "";
    
                /**
                 * EventLossToLP loss_amount.
                 * @member {string} loss_amount
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @instance
                 */
                EventLossToLP.prototype.loss_amount = "";
    
                /**
                 * Encodes the specified EventLossToLP message. Does not implicitly {@link ununifi.derivatives.EventLossToLP.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @static
                 * @param {ununifi.derivatives.IEventLossToLP} message EventLossToLP message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventLossToLP.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.position_id);
                    if (message.loss_amount != null && Object.hasOwnProperty.call(message, "loss_amount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.loss_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventLossToLP message, length delimited. Does not implicitly {@link ununifi.derivatives.EventLossToLP.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @static
                 * @param {ununifi.derivatives.IEventLossToLP} message EventLossToLP message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventLossToLP.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventLossToLP message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.EventLossToLP} EventLossToLP
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventLossToLP.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.EventLossToLP();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position_id = reader.string();
                            break;
                        case 2:
                            message.loss_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventLossToLP message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.EventLossToLP} EventLossToLP
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventLossToLP.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventLossToLP message.
                 * @function verify
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventLossToLP.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    if (message.loss_amount != null && message.hasOwnProperty("loss_amount"))
                        if (!$util.isString(message.loss_amount))
                            return "loss_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventLossToLP message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.EventLossToLP} EventLossToLP
                 */
                EventLossToLP.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.EventLossToLP)
                        return object;
                    var message = new $root.ununifi.derivatives.EventLossToLP();
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    if (object.loss_amount != null)
                        message.loss_amount = String(object.loss_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventLossToLP message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @static
                 * @param {ununifi.derivatives.EventLossToLP} message EventLossToLP
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventLossToLP.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.position_id = "";
                        object.loss_amount = "";
                    }
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    if (message.loss_amount != null && message.hasOwnProperty("loss_amount"))
                        object.loss_amount = message.loss_amount;
                    return object;
                };
    
                /**
                 * Converts this EventLossToLP to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.EventLossToLP
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventLossToLP.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventLossToLP;
            })();
    
            derivatives.Params = (function() {
    
                /**
                 * Properties of a Params.
                 * @memberof ununifi.derivatives
                 * @interface IParams
                 * @property {ununifi.derivatives.IPoolParams|null} [pool_params] Params pool_params
                 * @property {ununifi.derivatives.IPerpetualFuturesParams|null} [perpetual_futures] Params perpetual_futures
                 * @property {ununifi.derivatives.IPerpetualOptionsParams|null} [perpetual_options] Params perpetual_options
                 */
    
                /**
                 * Constructs a new Params.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a Params.
                 * @implements IParams
                 * @constructor
                 * @param {ununifi.derivatives.IParams=} [properties] Properties to set
                 */
                function Params(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Params pool_params.
                 * @member {ununifi.derivatives.IPoolParams|null|undefined} pool_params
                 * @memberof ununifi.derivatives.Params
                 * @instance
                 */
                Params.prototype.pool_params = null;
    
                /**
                 * Params perpetual_futures.
                 * @member {ununifi.derivatives.IPerpetualFuturesParams|null|undefined} perpetual_futures
                 * @memberof ununifi.derivatives.Params
                 * @instance
                 */
                Params.prototype.perpetual_futures = null;
    
                /**
                 * Params perpetual_options.
                 * @member {ununifi.derivatives.IPerpetualOptionsParams|null|undefined} perpetual_options
                 * @memberof ununifi.derivatives.Params
                 * @instance
                 */
                Params.prototype.perpetual_options = null;
    
                /**
                 * Encodes the specified Params message. Does not implicitly {@link ununifi.derivatives.Params.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.Params
                 * @static
                 * @param {ununifi.derivatives.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pool_params != null && Object.hasOwnProperty.call(message, "pool_params"))
                        $root.ununifi.derivatives.PoolParams.encode(message.pool_params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.perpetual_futures != null && Object.hasOwnProperty.call(message, "perpetual_futures"))
                        $root.ununifi.derivatives.PerpetualFuturesParams.encode(message.perpetual_futures, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.perpetual_options != null && Object.hasOwnProperty.call(message, "perpetual_options"))
                        $root.ununifi.derivatives.PerpetualOptionsParams.encode(message.perpetual_options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.derivatives.Params.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.Params
                 * @static
                 * @param {ununifi.derivatives.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.Params();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pool_params = $root.ununifi.derivatives.PoolParams.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.perpetual_futures = $root.ununifi.derivatives.PerpetualFuturesParams.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.perpetual_options = $root.ununifi.derivatives.PerpetualOptionsParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Params message.
                 * @function verify
                 * @memberof ununifi.derivatives.Params
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Params.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pool_params != null && message.hasOwnProperty("pool_params")) {
                        var error = $root.ununifi.derivatives.PoolParams.verify(message.pool_params);
                        if (error)
                            return "pool_params." + error;
                    }
                    if (message.perpetual_futures != null && message.hasOwnProperty("perpetual_futures")) {
                        var error = $root.ununifi.derivatives.PerpetualFuturesParams.verify(message.perpetual_futures);
                        if (error)
                            return "perpetual_futures." + error;
                    }
                    if (message.perpetual_options != null && message.hasOwnProperty("perpetual_options")) {
                        var error = $root.ununifi.derivatives.PerpetualOptionsParams.verify(message.perpetual_options);
                        if (error)
                            return "perpetual_options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Params message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.Params
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.Params} Params
                 */
                Params.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.Params)
                        return object;
                    var message = new $root.ununifi.derivatives.Params();
                    if (object.pool_params != null) {
                        if (typeof object.pool_params !== "object")
                            throw TypeError(".ununifi.derivatives.Params.pool_params: object expected");
                        message.pool_params = $root.ununifi.derivatives.PoolParams.fromObject(object.pool_params);
                    }
                    if (object.perpetual_futures != null) {
                        if (typeof object.perpetual_futures !== "object")
                            throw TypeError(".ununifi.derivatives.Params.perpetual_futures: object expected");
                        message.perpetual_futures = $root.ununifi.derivatives.PerpetualFuturesParams.fromObject(object.perpetual_futures);
                    }
                    if (object.perpetual_options != null) {
                        if (typeof object.perpetual_options !== "object")
                            throw TypeError(".ununifi.derivatives.Params.perpetual_options: object expected");
                        message.perpetual_options = $root.ununifi.derivatives.PerpetualOptionsParams.fromObject(object.perpetual_options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Params message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.Params
                 * @static
                 * @param {ununifi.derivatives.Params} message Params
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Params.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.pool_params = null;
                        object.perpetual_futures = null;
                        object.perpetual_options = null;
                    }
                    if (message.pool_params != null && message.hasOwnProperty("pool_params"))
                        object.pool_params = $root.ununifi.derivatives.PoolParams.toObject(message.pool_params, options);
                    if (message.perpetual_futures != null && message.hasOwnProperty("perpetual_futures"))
                        object.perpetual_futures = $root.ununifi.derivatives.PerpetualFuturesParams.toObject(message.perpetual_futures, options);
                    if (message.perpetual_options != null && message.hasOwnProperty("perpetual_options"))
                        object.perpetual_options = $root.ununifi.derivatives.PerpetualOptionsParams.toObject(message.perpetual_options, options);
                    return object;
                };
    
                /**
                 * Converts this Params to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.Params
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Params.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Params;
            })();
    
            derivatives.PerpetualOptionsParams = (function() {
    
                /**
                 * Properties of a PerpetualOptionsParams.
                 * @memberof ununifi.derivatives
                 * @interface IPerpetualOptionsParams
                 * @property {string|null} [premium_commission_rate] PerpetualOptionsParams premium_commission_rate
                 * @property {string|null} [strike_commission_rate] PerpetualOptionsParams strike_commission_rate
                 * @property {string|null} [margin_maintenance_rate] PerpetualOptionsParams margin_maintenance_rate
                 * @property {string|null} [imaginary_funding_rate_proportional_coefficient] PerpetualOptionsParams imaginary_funding_rate_proportional_coefficient
                 * @property {Array.<ununifi.derivatives.IMarket>|null} [markets] PerpetualOptionsParams markets
                 */
    
                /**
                 * Constructs a new PerpetualOptionsParams.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PerpetualOptionsParams.
                 * @implements IPerpetualOptionsParams
                 * @constructor
                 * @param {ununifi.derivatives.IPerpetualOptionsParams=} [properties] Properties to set
                 */
                function PerpetualOptionsParams(properties) {
                    this.markets = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PerpetualOptionsParams premium_commission_rate.
                 * @member {string} premium_commission_rate
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @instance
                 */
                PerpetualOptionsParams.prototype.premium_commission_rate = "";
    
                /**
                 * PerpetualOptionsParams strike_commission_rate.
                 * @member {string} strike_commission_rate
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @instance
                 */
                PerpetualOptionsParams.prototype.strike_commission_rate = "";
    
                /**
                 * PerpetualOptionsParams margin_maintenance_rate.
                 * @member {string} margin_maintenance_rate
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @instance
                 */
                PerpetualOptionsParams.prototype.margin_maintenance_rate = "";
    
                /**
                 * PerpetualOptionsParams imaginary_funding_rate_proportional_coefficient.
                 * @member {string} imaginary_funding_rate_proportional_coefficient
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @instance
                 */
                PerpetualOptionsParams.prototype.imaginary_funding_rate_proportional_coefficient = "";
    
                /**
                 * PerpetualOptionsParams markets.
                 * @member {Array.<ununifi.derivatives.IMarket>} markets
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @instance
                 */
                PerpetualOptionsParams.prototype.markets = $util.emptyArray;
    
                /**
                 * Encodes the specified PerpetualOptionsParams message. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsParams.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @static
                 * @param {ununifi.derivatives.IPerpetualOptionsParams} message PerpetualOptionsParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualOptionsParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.premium_commission_rate != null && Object.hasOwnProperty.call(message, "premium_commission_rate"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.premium_commission_rate);
                    if (message.strike_commission_rate != null && Object.hasOwnProperty.call(message, "strike_commission_rate"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.strike_commission_rate);
                    if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, "margin_maintenance_rate"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.margin_maintenance_rate);
                    if (message.imaginary_funding_rate_proportional_coefficient != null && Object.hasOwnProperty.call(message, "imaginary_funding_rate_proportional_coefficient"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.imaginary_funding_rate_proportional_coefficient);
                    if (message.markets != null && message.markets.length)
                        for (var i = 0; i < message.markets.length; ++i)
                            $root.ununifi.derivatives.Market.encode(message.markets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PerpetualOptionsParams message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @static
                 * @param {ununifi.derivatives.IPerpetualOptionsParams} message PerpetualOptionsParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualOptionsParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PerpetualOptionsParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PerpetualOptionsParams} PerpetualOptionsParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualOptionsParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PerpetualOptionsParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.premium_commission_rate = reader.string();
                            break;
                        case 2:
                            message.strike_commission_rate = reader.string();
                            break;
                        case 3:
                            message.margin_maintenance_rate = reader.string();
                            break;
                        case 4:
                            message.imaginary_funding_rate_proportional_coefficient = reader.string();
                            break;
                        case 5:
                            if (!(message.markets && message.markets.length))
                                message.markets = [];
                            message.markets.push($root.ununifi.derivatives.Market.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PerpetualOptionsParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PerpetualOptionsParams} PerpetualOptionsParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualOptionsParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PerpetualOptionsParams message.
                 * @function verify
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PerpetualOptionsParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.premium_commission_rate != null && message.hasOwnProperty("premium_commission_rate"))
                        if (!$util.isString(message.premium_commission_rate))
                            return "premium_commission_rate: string expected";
                    if (message.strike_commission_rate != null && message.hasOwnProperty("strike_commission_rate"))
                        if (!$util.isString(message.strike_commission_rate))
                            return "strike_commission_rate: string expected";
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        if (!$util.isString(message.margin_maintenance_rate))
                            return "margin_maintenance_rate: string expected";
                    if (message.imaginary_funding_rate_proportional_coefficient != null && message.hasOwnProperty("imaginary_funding_rate_proportional_coefficient"))
                        if (!$util.isString(message.imaginary_funding_rate_proportional_coefficient))
                            return "imaginary_funding_rate_proportional_coefficient: string expected";
                    if (message.markets != null && message.hasOwnProperty("markets")) {
                        if (!Array.isArray(message.markets))
                            return "markets: array expected";
                        for (var i = 0; i < message.markets.length; ++i) {
                            var error = $root.ununifi.derivatives.Market.verify(message.markets[i]);
                            if (error)
                                return "markets." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a PerpetualOptionsParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PerpetualOptionsParams} PerpetualOptionsParams
                 */
                PerpetualOptionsParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PerpetualOptionsParams)
                        return object;
                    var message = new $root.ununifi.derivatives.PerpetualOptionsParams();
                    if (object.premium_commission_rate != null)
                        message.premium_commission_rate = String(object.premium_commission_rate);
                    if (object.strike_commission_rate != null)
                        message.strike_commission_rate = String(object.strike_commission_rate);
                    if (object.margin_maintenance_rate != null)
                        message.margin_maintenance_rate = String(object.margin_maintenance_rate);
                    if (object.imaginary_funding_rate_proportional_coefficient != null)
                        message.imaginary_funding_rate_proportional_coefficient = String(object.imaginary_funding_rate_proportional_coefficient);
                    if (object.markets) {
                        if (!Array.isArray(object.markets))
                            throw TypeError(".ununifi.derivatives.PerpetualOptionsParams.markets: array expected");
                        message.markets = [];
                        for (var i = 0; i < object.markets.length; ++i) {
                            if (typeof object.markets[i] !== "object")
                                throw TypeError(".ununifi.derivatives.PerpetualOptionsParams.markets: object expected");
                            message.markets[i] = $root.ununifi.derivatives.Market.fromObject(object.markets[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PerpetualOptionsParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @static
                 * @param {ununifi.derivatives.PerpetualOptionsParams} message PerpetualOptionsParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PerpetualOptionsParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.markets = [];
                    if (options.defaults) {
                        object.premium_commission_rate = "";
                        object.strike_commission_rate = "";
                        object.margin_maintenance_rate = "";
                        object.imaginary_funding_rate_proportional_coefficient = "";
                    }
                    if (message.premium_commission_rate != null && message.hasOwnProperty("premium_commission_rate"))
                        object.premium_commission_rate = message.premium_commission_rate;
                    if (message.strike_commission_rate != null && message.hasOwnProperty("strike_commission_rate"))
                        object.strike_commission_rate = message.strike_commission_rate;
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        object.margin_maintenance_rate = message.margin_maintenance_rate;
                    if (message.imaginary_funding_rate_proportional_coefficient != null && message.hasOwnProperty("imaginary_funding_rate_proportional_coefficient"))
                        object.imaginary_funding_rate_proportional_coefficient = message.imaginary_funding_rate_proportional_coefficient;
                    if (message.markets && message.markets.length) {
                        object.markets = [];
                        for (var j = 0; j < message.markets.length; ++j)
                            object.markets[j] = $root.ununifi.derivatives.Market.toObject(message.markets[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this PerpetualOptionsParams to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PerpetualOptionsParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PerpetualOptionsParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PerpetualOptionsParams;
            })();
    
            /**
             * OptionType enum.
             * @name ununifi.derivatives.OptionType
             * @enum {number}
             * @property {number} OPTION_UNKNOWN=0 OPTION_UNKNOWN value
             * @property {number} CALL=1 CALL value
             * @property {number} PUT=2 PUT value
             */
            derivatives.OptionType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OPTION_UNKNOWN"] = 0;
                values[valuesById[1] = "CALL"] = 1;
                values[valuesById[2] = "PUT"] = 2;
                return values;
            })();
    
            derivatives.PerpetualOptionsPositionInstance = (function() {
    
                /**
                 * Properties of a PerpetualOptionsPositionInstance.
                 * @memberof ununifi.derivatives
                 * @interface IPerpetualOptionsPositionInstance
                 * @property {ununifi.derivatives.OptionType|null} [option_type] PerpetualOptionsPositionInstance option_type
                 * @property {ununifi.derivatives.PositionType|null} [position_type] PerpetualOptionsPositionInstance position_type
                 * @property {string|null} [strike_price] PerpetualOptionsPositionInstance strike_price
                 * @property {string|null} [premium] PerpetualOptionsPositionInstance premium
                 */
    
                /**
                 * Constructs a new PerpetualOptionsPositionInstance.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a PerpetualOptionsPositionInstance.
                 * @implements IPerpetualOptionsPositionInstance
                 * @constructor
                 * @param {ununifi.derivatives.IPerpetualOptionsPositionInstance=} [properties] Properties to set
                 */
                function PerpetualOptionsPositionInstance(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PerpetualOptionsPositionInstance option_type.
                 * @member {ununifi.derivatives.OptionType} option_type
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @instance
                 */
                PerpetualOptionsPositionInstance.prototype.option_type = 0;
    
                /**
                 * PerpetualOptionsPositionInstance position_type.
                 * @member {ununifi.derivatives.PositionType} position_type
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @instance
                 */
                PerpetualOptionsPositionInstance.prototype.position_type = 0;
    
                /**
                 * PerpetualOptionsPositionInstance strike_price.
                 * @member {string} strike_price
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @instance
                 */
                PerpetualOptionsPositionInstance.prototype.strike_price = "";
    
                /**
                 * PerpetualOptionsPositionInstance premium.
                 * @member {string} premium
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @instance
                 */
                PerpetualOptionsPositionInstance.prototype.premium = "";
    
                /**
                 * Encodes the specified PerpetualOptionsPositionInstance message. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsPositionInstance.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @static
                 * @param {ununifi.derivatives.IPerpetualOptionsPositionInstance} message PerpetualOptionsPositionInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualOptionsPositionInstance.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.option_type != null && Object.hasOwnProperty.call(message, "option_type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.option_type);
                    if (message.position_type != null && Object.hasOwnProperty.call(message, "position_type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.position_type);
                    if (message.strike_price != null && Object.hasOwnProperty.call(message, "strike_price"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.strike_price);
                    if (message.premium != null && Object.hasOwnProperty.call(message, "premium"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.premium);
                    return writer;
                };
    
                /**
                 * Encodes the specified PerpetualOptionsPositionInstance message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsPositionInstance.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @static
                 * @param {ununifi.derivatives.IPerpetualOptionsPositionInstance} message PerpetualOptionsPositionInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PerpetualOptionsPositionInstance.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PerpetualOptionsPositionInstance message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.PerpetualOptionsPositionInstance} PerpetualOptionsPositionInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualOptionsPositionInstance.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.PerpetualOptionsPositionInstance();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.option_type = reader.int32();
                            break;
                        case 2:
                            message.position_type = reader.int32();
                            break;
                        case 3:
                            message.strike_price = reader.string();
                            break;
                        case 4:
                            message.premium = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PerpetualOptionsPositionInstance message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.PerpetualOptionsPositionInstance} PerpetualOptionsPositionInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PerpetualOptionsPositionInstance.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PerpetualOptionsPositionInstance message.
                 * @function verify
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PerpetualOptionsPositionInstance.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.option_type != null && message.hasOwnProperty("option_type"))
                        switch (message.option_type) {
                        default:
                            return "option_type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        switch (message.position_type) {
                        default:
                            return "position_type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.strike_price != null && message.hasOwnProperty("strike_price"))
                        if (!$util.isString(message.strike_price))
                            return "strike_price: string expected";
                    if (message.premium != null && message.hasOwnProperty("premium"))
                        if (!$util.isString(message.premium))
                            return "premium: string expected";
                    return null;
                };
    
                /**
                 * Creates a PerpetualOptionsPositionInstance message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.PerpetualOptionsPositionInstance} PerpetualOptionsPositionInstance
                 */
                PerpetualOptionsPositionInstance.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.PerpetualOptionsPositionInstance)
                        return object;
                    var message = new $root.ununifi.derivatives.PerpetualOptionsPositionInstance();
                    switch (object.option_type) {
                    case "OPTION_UNKNOWN":
                    case 0:
                        message.option_type = 0;
                        break;
                    case "CALL":
                    case 1:
                        message.option_type = 1;
                        break;
                    case "PUT":
                    case 2:
                        message.option_type = 2;
                        break;
                    }
                    switch (object.position_type) {
                    case "POSITION_UNKNOWN":
                    case 0:
                        message.position_type = 0;
                        break;
                    case "LONG":
                    case 1:
                        message.position_type = 1;
                        break;
                    case "SHORT":
                    case 2:
                        message.position_type = 2;
                        break;
                    }
                    if (object.strike_price != null)
                        message.strike_price = String(object.strike_price);
                    if (object.premium != null)
                        message.premium = String(object.premium);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PerpetualOptionsPositionInstance message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @static
                 * @param {ununifi.derivatives.PerpetualOptionsPositionInstance} message PerpetualOptionsPositionInstance
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PerpetualOptionsPositionInstance.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.option_type = options.enums === String ? "OPTION_UNKNOWN" : 0;
                        object.position_type = options.enums === String ? "POSITION_UNKNOWN" : 0;
                        object.strike_price = "";
                        object.premium = "";
                    }
                    if (message.option_type != null && message.hasOwnProperty("option_type"))
                        object.option_type = options.enums === String ? $root.ununifi.derivatives.OptionType[message.option_type] : message.option_type;
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        object.position_type = options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
                    if (message.strike_price != null && message.hasOwnProperty("strike_price"))
                        object.strike_price = message.strike_price;
                    if (message.premium != null && message.hasOwnProperty("premium"))
                        object.premium = message.premium;
                    return object;
                };
    
                /**
                 * Converts this PerpetualOptionsPositionInstance to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PerpetualOptionsPositionInstance.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PerpetualOptionsPositionInstance;
            })();
    
            derivatives.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#params}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef ParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryParamsResponse} [response] QueryParamsResponse
                 */
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @param {ununifi.derivatives.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.params = function params(request, callback) {
                    return this.rpcCall(params, $root.ununifi.derivatives.QueryParamsRequest, $root.ununifi.derivatives.QueryParamsResponse, request, callback);
                }, "name", { value: "Params" });
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#pool}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PoolCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPoolResponse} [response] QueryPoolResponse
                 */
    
                /**
                 * Calls Pool.
                 * @function pool
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPoolRequest} request QueryPoolRequest message or plain object
                 * @param {ununifi.derivatives.Query.PoolCallback} callback Node-style callback called with the error, if any, and QueryPoolResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.pool = function pool(request, callback) {
                    return this.rpcCall(pool, $root.ununifi.derivatives.QueryPoolRequest, $root.ununifi.derivatives.QueryPoolResponse, request, callback);
                }, "name", { value: "Pool" });
    
                /**
                 * Calls Pool.
                 * @function pool
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPoolRequest} request QueryPoolRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPoolResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#liquidityProviderTokenRealAPY}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef LiquidityProviderTokenRealAPYCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} [response] QueryLiquidityProviderTokenRealAPYResponse
                 */
    
                /**
                 * Calls LiquidityProviderTokenRealAPY.
                 * @function liquidityProviderTokenRealAPY
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} request QueryLiquidityProviderTokenRealAPYRequest message or plain object
                 * @param {ununifi.derivatives.Query.LiquidityProviderTokenRealAPYCallback} callback Node-style callback called with the error, if any, and QueryLiquidityProviderTokenRealAPYResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.liquidityProviderTokenRealAPY = function liquidityProviderTokenRealAPY(request, callback) {
                    return this.rpcCall(liquidityProviderTokenRealAPY, $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest, $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse, request, callback);
                }, "name", { value: "LiquidityProviderTokenRealAPY" });
    
                /**
                 * Calls LiquidityProviderTokenRealAPY.
                 * @function liquidityProviderTokenRealAPY
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} request QueryLiquidityProviderTokenRealAPYRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#liquidityProviderTokenNominalAPY}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef LiquidityProviderTokenNominalAPYCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} [response] QueryLiquidityProviderTokenNominalAPYResponse
                 */
    
                /**
                 * Calls LiquidityProviderTokenNominalAPY.
                 * @function liquidityProviderTokenNominalAPY
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} request QueryLiquidityProviderTokenNominalAPYRequest message or plain object
                 * @param {ununifi.derivatives.Query.LiquidityProviderTokenNominalAPYCallback} callback Node-style callback called with the error, if any, and QueryLiquidityProviderTokenNominalAPYResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.liquidityProviderTokenNominalAPY = function liquidityProviderTokenNominalAPY(request, callback) {
                    return this.rpcCall(liquidityProviderTokenNominalAPY, $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest, $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse, request, callback);
                }, "name", { value: "LiquidityProviderTokenNominalAPY" });
    
                /**
                 * Calls LiquidityProviderTokenNominalAPY.
                 * @function liquidityProviderTokenNominalAPY
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} request QueryLiquidityProviderTokenNominalAPYRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#perpetualFutures}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PerpetualFuturesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPerpetualFuturesResponse} [response] QueryPerpetualFuturesResponse
                 */
    
                /**
                 * Calls PerpetualFutures.
                 * @function perpetualFutures
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} request QueryPerpetualFuturesRequest message or plain object
                 * @param {ununifi.derivatives.Query.PerpetualFuturesCallback} callback Node-style callback called with the error, if any, and QueryPerpetualFuturesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.perpetualFutures = function perpetualFutures(request, callback) {
                    return this.rpcCall(perpetualFutures, $root.ununifi.derivatives.QueryPerpetualFuturesRequest, $root.ununifi.derivatives.QueryPerpetualFuturesResponse, request, callback);
                }, "name", { value: "PerpetualFutures" });
    
                /**
                 * Calls PerpetualFutures.
                 * @function perpetualFutures
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} request QueryPerpetualFuturesRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPerpetualFuturesResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#perpetualFuturesMarket}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PerpetualFuturesMarketCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} [response] QueryPerpetualFuturesMarketResponse
                 */
    
                /**
                 * Calls PerpetualFuturesMarket.
                 * @function perpetualFuturesMarket
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} request QueryPerpetualFuturesMarketRequest message or plain object
                 * @param {ununifi.derivatives.Query.PerpetualFuturesMarketCallback} callback Node-style callback called with the error, if any, and QueryPerpetualFuturesMarketResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.perpetualFuturesMarket = function perpetualFuturesMarket(request, callback) {
                    return this.rpcCall(perpetualFuturesMarket, $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest, $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse, request, callback);
                }, "name", { value: "PerpetualFuturesMarket" });
    
                /**
                 * Calls PerpetualFuturesMarket.
                 * @function perpetualFuturesMarket
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} request QueryPerpetualFuturesMarketRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPerpetualFuturesMarketResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#perpetualOptions}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PerpetualOptionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPerpetualOptionsResponse} [response] QueryPerpetualOptionsResponse
                 */
    
                /**
                 * Calls PerpetualOptions.
                 * @function perpetualOptions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} request QueryPerpetualOptionsRequest message or plain object
                 * @param {ununifi.derivatives.Query.PerpetualOptionsCallback} callback Node-style callback called with the error, if any, and QueryPerpetualOptionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.perpetualOptions = function perpetualOptions(request, callback) {
                    return this.rpcCall(perpetualOptions, $root.ununifi.derivatives.QueryPerpetualOptionsRequest, $root.ununifi.derivatives.QueryPerpetualOptionsResponse, request, callback);
                }, "name", { value: "PerpetualOptions" });
    
                /**
                 * Calls PerpetualOptions.
                 * @function perpetualOptions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} request QueryPerpetualOptionsRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPerpetualOptionsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#perpetualOptionsMarket}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PerpetualOptionsMarketCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} [response] QueryPerpetualOptionsMarketResponse
                 */
    
                /**
                 * Calls PerpetualOptionsMarket.
                 * @function perpetualOptionsMarket
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} request QueryPerpetualOptionsMarketRequest message or plain object
                 * @param {ununifi.derivatives.Query.PerpetualOptionsMarketCallback} callback Node-style callback called with the error, if any, and QueryPerpetualOptionsMarketResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.perpetualOptionsMarket = function perpetualOptionsMarket(request, callback) {
                    return this.rpcCall(perpetualOptionsMarket, $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest, $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse, request, callback);
                }, "name", { value: "PerpetualOptionsMarket" });
    
                /**
                 * Calls PerpetualOptionsMarket.
                 * @function perpetualOptionsMarket
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} request QueryPerpetualOptionsMarketRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPerpetualOptionsMarketResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#allPositions}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef AllPositionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryAllPositionsResponse} [response] QueryAllPositionsResponse
                 */
    
                /**
                 * Calls AllPositions.
                 * @function allPositions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAllPositionsRequest} request QueryAllPositionsRequest message or plain object
                 * @param {ununifi.derivatives.Query.AllPositionsCallback} callback Node-style callback called with the error, if any, and QueryAllPositionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.allPositions = function allPositions(request, callback) {
                    return this.rpcCall(allPositions, $root.ununifi.derivatives.QueryAllPositionsRequest, $root.ununifi.derivatives.QueryAllPositionsResponse, request, callback);
                }, "name", { value: "AllPositions" });
    
                /**
                 * Calls AllPositions.
                 * @function allPositions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAllPositionsRequest} request QueryAllPositionsRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryAllPositionsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#position}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PositionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPositionResponse} [response] QueryPositionResponse
                 */
    
                /**
                 * Calls Position.
                 * @function position
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPositionRequest} request QueryPositionRequest message or plain object
                 * @param {ununifi.derivatives.Query.PositionCallback} callback Node-style callback called with the error, if any, and QueryPositionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.position = function position(request, callback) {
                    return this.rpcCall(position, $root.ununifi.derivatives.QueryPositionRequest, $root.ununifi.derivatives.QueryPositionResponse, request, callback);
                }, "name", { value: "Position" });
    
                /**
                 * Calls Position.
                 * @function position
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPositionRequest} request QueryPositionRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPositionResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#perpetualFuturesPositionSize}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PerpetualFuturesPositionSizeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} [response] QueryPerpetualFuturesPositionSizeResponse
                 */
    
                /**
                 * Calls PerpetualFuturesPositionSize.
                 * @function perpetualFuturesPositionSize
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} request QueryPerpetualFuturesPositionSizeRequest message or plain object
                 * @param {ununifi.derivatives.Query.PerpetualFuturesPositionSizeCallback} callback Node-style callback called with the error, if any, and QueryPerpetualFuturesPositionSizeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.perpetualFuturesPositionSize = function perpetualFuturesPositionSize(request, callback) {
                    return this.rpcCall(perpetualFuturesPositionSize, $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest, $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse, request, callback);
                }, "name", { value: "PerpetualFuturesPositionSize" });
    
                /**
                 * Calls PerpetualFuturesPositionSize.
                 * @function perpetualFuturesPositionSize
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} request QueryPerpetualFuturesPositionSizeRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#addressPositions}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef AddressPositionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryAddressPositionsResponse} [response] QueryAddressPositionsResponse
                 */
    
                /**
                 * Calls AddressPositions.
                 * @function addressPositions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAddressPositionsRequest} request QueryAddressPositionsRequest message or plain object
                 * @param {ununifi.derivatives.Query.AddressPositionsCallback} callback Node-style callback called with the error, if any, and QueryAddressPositionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.addressPositions = function addressPositions(request, callback) {
                    return this.rpcCall(addressPositions, $root.ununifi.derivatives.QueryAddressPositionsRequest, $root.ununifi.derivatives.QueryAddressPositionsResponse, request, callback);
                }, "name", { value: "AddressPositions" });
    
                /**
                 * Calls AddressPositions.
                 * @function addressPositions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAddressPositionsRequest} request QueryAddressPositionsRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryAddressPositionsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#allPendingPaymentPositions}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef AllPendingPaymentPositionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} [response] QueryAllPendingPaymentPositionsResponse
                 */
    
                /**
                 * Calls AllPendingPaymentPositions.
                 * @function allPendingPaymentPositions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} request QueryAllPendingPaymentPositionsRequest message or plain object
                 * @param {ununifi.derivatives.Query.AllPendingPaymentPositionsCallback} callback Node-style callback called with the error, if any, and QueryAllPendingPaymentPositionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.allPendingPaymentPositions = function allPendingPaymentPositions(request, callback) {
                    return this.rpcCall(allPendingPaymentPositions, $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest, $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse, request, callback);
                }, "name", { value: "AllPendingPaymentPositions" });
    
                /**
                 * Calls AllPendingPaymentPositions.
                 * @function allPendingPaymentPositions
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} request QueryAllPendingPaymentPositionsRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryAllPendingPaymentPositionsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#pendingPaymentPosition}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef PendingPaymentPositionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryPendingPaymentPositionResponse} [response] QueryPendingPaymentPositionResponse
                 */
    
                /**
                 * Calls PendingPaymentPosition.
                 * @function pendingPaymentPosition
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} request QueryPendingPaymentPositionRequest message or plain object
                 * @param {ununifi.derivatives.Query.PendingPaymentPositionCallback} callback Node-style callback called with the error, if any, and QueryPendingPaymentPositionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.pendingPaymentPosition = function pendingPaymentPosition(request, callback) {
                    return this.rpcCall(pendingPaymentPosition, $root.ununifi.derivatives.QueryPendingPaymentPositionRequest, $root.ununifi.derivatives.QueryPendingPaymentPositionResponse, request, callback);
                }, "name", { value: "PendingPaymentPosition" });
    
                /**
                 * Calls PendingPaymentPosition.
                 * @function pendingPaymentPosition
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} request QueryPendingPaymentPositionRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryPendingPaymentPositionResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#dLPTokenRates}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef DLPTokenRatesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryDLPTokenRateResponse} [response] QueryDLPTokenRateResponse
                 */
    
                /**
                 * Calls DLPTokenRates.
                 * @function dLPTokenRates
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} request QueryDLPTokenRateRequest message or plain object
                 * @param {ununifi.derivatives.Query.DLPTokenRatesCallback} callback Node-style callback called with the error, if any, and QueryDLPTokenRateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.dLPTokenRates = function dLPTokenRates(request, callback) {
                    return this.rpcCall(dLPTokenRates, $root.ununifi.derivatives.QueryDLPTokenRateRequest, $root.ununifi.derivatives.QueryDLPTokenRateResponse, request, callback);
                }, "name", { value: "DLPTokenRates" });
    
                /**
                 * Calls DLPTokenRates.
                 * @function dLPTokenRates
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} request QueryDLPTokenRateRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryDLPTokenRateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#estimateDLPTokenAmount}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef EstimateDLPTokenAmountCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} [response] QueryEstimateDLPTokenAmountResponse
                 */
    
                /**
                 * Calls EstimateDLPTokenAmount.
                 * @function estimateDLPTokenAmount
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} request QueryEstimateDLPTokenAmountRequest message or plain object
                 * @param {ununifi.derivatives.Query.EstimateDLPTokenAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateDLPTokenAmountResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.estimateDLPTokenAmount = function estimateDLPTokenAmount(request, callback) {
                    return this.rpcCall(estimateDLPTokenAmount, $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest, $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse, request, callback);
                }, "name", { value: "EstimateDLPTokenAmount" });
    
                /**
                 * Calls EstimateDLPTokenAmount.
                 * @function estimateDLPTokenAmount
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} request QueryEstimateDLPTokenAmountRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryEstimateDLPTokenAmountResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#estimateRedeemTokenAmount}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef EstimateRedeemTokenAmountCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} [response] QueryEstimateRedeemTokenAmountResponse
                 */
    
                /**
                 * Calls EstimateRedeemTokenAmount.
                 * @function estimateRedeemTokenAmount
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} request QueryEstimateRedeemTokenAmountRequest message or plain object
                 * @param {ununifi.derivatives.Query.EstimateRedeemTokenAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateRedeemTokenAmountResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.estimateRedeemTokenAmount = function estimateRedeemTokenAmount(request, callback) {
                    return this.rpcCall(estimateRedeemTokenAmount, $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest, $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse, request, callback);
                }, "name", { value: "EstimateRedeemTokenAmount" });
    
                /**
                 * Calls EstimateRedeemTokenAmount.
                 * @function estimateRedeemTokenAmount
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} request QueryEstimateRedeemTokenAmountRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#availableAssetInPoolByDenom}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef AvailableAssetInPoolByDenomCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse} [response] QueryAvailableAssetInPoolByDenomResponse
                 */
    
                /**
                 * Calls AvailableAssetInPoolByDenom.
                 * @function availableAssetInPoolByDenom
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomRequest} request QueryAvailableAssetInPoolByDenomRequest message or plain object
                 * @param {ununifi.derivatives.Query.AvailableAssetInPoolByDenomCallback} callback Node-style callback called with the error, if any, and QueryAvailableAssetInPoolByDenomResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.availableAssetInPoolByDenom = function availableAssetInPoolByDenom(request, callback) {
                    return this.rpcCall(availableAssetInPoolByDenom, $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest, $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse, request, callback);
                }, "name", { value: "AvailableAssetInPoolByDenom" });
    
                /**
                 * Calls AvailableAssetInPoolByDenom.
                 * @function availableAssetInPoolByDenom
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomRequest} request QueryAvailableAssetInPoolByDenomRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.derivatives.Query#availableAssetsInPool}.
                 * @memberof ununifi.derivatives.Query
                 * @typedef AvailableAssetsInPoolCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} [response] QueryAvailableAssetsInPoolResponse
                 */
    
                /**
                 * Calls AvailableAssetsInPool.
                 * @function availableAssetsInPool
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} request QueryAvailableAssetsInPoolRequest message or plain object
                 * @param {ununifi.derivatives.Query.AvailableAssetsInPoolCallback} callback Node-style callback called with the error, if any, and QueryAvailableAssetsInPoolResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.availableAssetsInPool = function availableAssetsInPool(request, callback) {
                    return this.rpcCall(availableAssetsInPool, $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest, $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse, request, callback);
                }, "name", { value: "AvailableAssetsInPool" });
    
                /**
                 * Calls AvailableAssetsInPool.
                 * @function availableAssetsInPool
                 * @memberof ununifi.derivatives.Query
                 * @instance
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} request QueryAvailableAssetsInPoolRequest message or plain object
                 * @returns {Promise<ununifi.derivatives.QueryAvailableAssetsInPoolResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            derivatives.QueryParamsRequest = (function() {
    
                /**
                 * Properties of a QueryParamsRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryParamsRequest
                 */
    
                /**
                 * Constructs a new QueryParamsRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryParamsRequest.
                 * @implements IQueryParamsRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryParamsRequest=} [properties] Properties to set
                 */
                function QueryParamsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.derivatives.QueryParamsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryParamsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryParamsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryParamsRequest} QueryParamsRequest
                 */
                QueryParamsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryParamsRequest)
                        return object;
                    return new $root.ununifi.derivatives.QueryParamsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @static
                 * @param {ununifi.derivatives.QueryParamsRequest} message QueryParamsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryParamsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryParamsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsRequest;
            })();
    
            derivatives.QueryParamsResponse = (function() {
    
                /**
                 * Properties of a QueryParamsResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryParamsResponse
                 * @property {ununifi.derivatives.IParams|null} [params] QueryParamsResponse params
                 */
    
                /**
                 * Constructs a new QueryParamsResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryParamsResponse.
                 * @implements IQueryParamsResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryParamsResponse=} [properties] Properties to set
                 */
                function QueryParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryParamsResponse params.
                 * @member {ununifi.derivatives.IParams|null|undefined} params
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @instance
                 */
                QueryParamsResponse.prototype.params = null;
    
                /**
                 * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.derivatives.QueryParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.derivatives.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.derivatives.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.derivatives.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryParamsResponse} QueryParamsResponse
                 */
                QueryParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryParamsResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryParamsResponse();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.derivatives.QueryParamsResponse.params: object expected");
                        message.params = $root.ununifi.derivatives.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @static
                 * @param {ununifi.derivatives.QueryParamsResponse} message QueryParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.derivatives.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this QueryParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsResponse;
            })();
    
            derivatives.QueryPoolRequest = (function() {
    
                /**
                 * Properties of a QueryPoolRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPoolRequest
                 */
    
                /**
                 * Constructs a new QueryPoolRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPoolRequest.
                 * @implements IQueryPoolRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPoolRequest=} [properties] Properties to set
                 */
                function QueryPoolRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryPoolRequest message. Does not implicitly {@link ununifi.derivatives.QueryPoolRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPoolRequest} message QueryPoolRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPoolRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPoolRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPoolRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPoolRequest} message QueryPoolRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPoolRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPoolRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPoolRequest} QueryPoolRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPoolRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPoolRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPoolRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPoolRequest} QueryPoolRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPoolRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPoolRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPoolRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPoolRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPoolRequest} QueryPoolRequest
                 */
                QueryPoolRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPoolRequest)
                        return object;
                    return new $root.ununifi.derivatives.QueryPoolRequest();
                };
    
                /**
                 * Creates a plain object from a QueryPoolRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPoolRequest} message QueryPoolRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPoolRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryPoolRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPoolRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPoolRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPoolRequest;
            })();
    
            derivatives.QueryPoolResponse = (function() {
    
                /**
                 * Properties of a QueryPoolResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPoolResponse
                 * @property {string|null} [metrics_quote_ticker] QueryPoolResponse metrics_quote_ticker
                 * @property {ununifi.derivatives.IPoolMarketCap|null} [pool_market_cap] QueryPoolResponse pool_market_cap
                 */
    
                /**
                 * Constructs a new QueryPoolResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPoolResponse.
                 * @implements IQueryPoolResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPoolResponse=} [properties] Properties to set
                 */
                function QueryPoolResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPoolResponse metrics_quote_ticker.
                 * @member {string} metrics_quote_ticker
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @instance
                 */
                QueryPoolResponse.prototype.metrics_quote_ticker = "";
    
                /**
                 * QueryPoolResponse pool_market_cap.
                 * @member {ununifi.derivatives.IPoolMarketCap|null|undefined} pool_market_cap
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @instance
                 */
                QueryPoolResponse.prototype.pool_market_cap = null;
    
                /**
                 * Encodes the specified QueryPoolResponse message. Does not implicitly {@link ununifi.derivatives.QueryPoolResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPoolResponse} message QueryPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPoolResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.metrics_quote_ticker != null && Object.hasOwnProperty.call(message, "metrics_quote_ticker"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.metrics_quote_ticker);
                    if (message.pool_market_cap != null && Object.hasOwnProperty.call(message, "pool_market_cap"))
                        $root.ununifi.derivatives.PoolMarketCap.encode(message.pool_market_cap, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPoolResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPoolResponse} message QueryPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPoolResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPoolResponse} QueryPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPoolResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPoolResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.metrics_quote_ticker = reader.string();
                            break;
                        case 2:
                            message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPoolResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPoolResponse} QueryPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPoolResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPoolResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPoolResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.metrics_quote_ticker != null && message.hasOwnProperty("metrics_quote_ticker"))
                        if (!$util.isString(message.metrics_quote_ticker))
                            return "metrics_quote_ticker: string expected";
                    if (message.pool_market_cap != null && message.hasOwnProperty("pool_market_cap")) {
                        var error = $root.ununifi.derivatives.PoolMarketCap.verify(message.pool_market_cap);
                        if (error)
                            return "pool_market_cap." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryPoolResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPoolResponse} QueryPoolResponse
                 */
                QueryPoolResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPoolResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPoolResponse();
                    if (object.metrics_quote_ticker != null)
                        message.metrics_quote_ticker = String(object.metrics_quote_ticker);
                    if (object.pool_market_cap != null) {
                        if (typeof object.pool_market_cap !== "object")
                            throw TypeError(".ununifi.derivatives.QueryPoolResponse.pool_market_cap: object expected");
                        message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.fromObject(object.pool_market_cap);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPoolResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPoolResponse} message QueryPoolResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPoolResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.metrics_quote_ticker = "";
                        object.pool_market_cap = null;
                    }
                    if (message.metrics_quote_ticker != null && message.hasOwnProperty("metrics_quote_ticker"))
                        object.metrics_quote_ticker = message.metrics_quote_ticker;
                    if (message.pool_market_cap != null && message.hasOwnProperty("pool_market_cap"))
                        object.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.toObject(message.pool_market_cap, options);
                    return object;
                };
    
                /**
                 * Converts this QueryPoolResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPoolResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPoolResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPoolResponse;
            })();
    
            derivatives.QueryLiquidityProviderTokenRealAPYRequest = (function() {
    
                /**
                 * Properties of a QueryLiquidityProviderTokenRealAPYRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryLiquidityProviderTokenRealAPYRequest
                 * @property {Long|null} [before_height] QueryLiquidityProviderTokenRealAPYRequest before_height
                 * @property {Long|null} [after_height] QueryLiquidityProviderTokenRealAPYRequest after_height
                 */
    
                /**
                 * Constructs a new QueryLiquidityProviderTokenRealAPYRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryLiquidityProviderTokenRealAPYRequest.
                 * @implements IQueryLiquidityProviderTokenRealAPYRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest=} [properties] Properties to set
                 */
                function QueryLiquidityProviderTokenRealAPYRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLiquidityProviderTokenRealAPYRequest before_height.
                 * @member {Long} before_height
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @instance
                 */
                QueryLiquidityProviderTokenRealAPYRequest.prototype.before_height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * QueryLiquidityProviderTokenRealAPYRequest after_height.
                 * @member {Long} after_height
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @instance
                 */
                QueryLiquidityProviderTokenRealAPYRequest.prototype.after_height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenRealAPYRequest message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} message QueryLiquidityProviderTokenRealAPYRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenRealAPYRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.before_height != null && Object.hasOwnProperty.call(message, "before_height"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.before_height);
                    if (message.after_height != null && Object.hasOwnProperty.call(message, "after_height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.after_height);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenRealAPYRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} message QueryLiquidityProviderTokenRealAPYRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenRealAPYRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenRealAPYRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} QueryLiquidityProviderTokenRealAPYRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenRealAPYRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.before_height = reader.int64();
                            break;
                        case 2:
                            message.after_height = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenRealAPYRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} QueryLiquidityProviderTokenRealAPYRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenRealAPYRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLiquidityProviderTokenRealAPYRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLiquidityProviderTokenRealAPYRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.before_height != null && message.hasOwnProperty("before_height"))
                        if (!$util.isInteger(message.before_height) && !(message.before_height && $util.isInteger(message.before_height.low) && $util.isInteger(message.before_height.high)))
                            return "before_height: integer|Long expected";
                    if (message.after_height != null && message.hasOwnProperty("after_height"))
                        if (!$util.isInteger(message.after_height) && !(message.after_height && $util.isInteger(message.after_height.low) && $util.isInteger(message.after_height.high)))
                            return "after_height: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryLiquidityProviderTokenRealAPYRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} QueryLiquidityProviderTokenRealAPYRequest
                 */
                QueryLiquidityProviderTokenRealAPYRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest();
                    if (object.before_height != null)
                        if ($util.Long)
                            (message.before_height = $util.Long.fromValue(object.before_height)).unsigned = false;
                        else if (typeof object.before_height === "string")
                            message.before_height = parseInt(object.before_height, 10);
                        else if (typeof object.before_height === "number")
                            message.before_height = object.before_height;
                        else if (typeof object.before_height === "object")
                            message.before_height = new $util.LongBits(object.before_height.low >>> 0, object.before_height.high >>> 0).toNumber();
                    if (object.after_height != null)
                        if ($util.Long)
                            (message.after_height = $util.Long.fromValue(object.after_height)).unsigned = false;
                        else if (typeof object.after_height === "string")
                            message.after_height = parseInt(object.after_height, 10);
                        else if (typeof object.after_height === "number")
                            message.after_height = object.after_height;
                        else if (typeof object.after_height === "object")
                            message.after_height = new $util.LongBits(object.after_height.low >>> 0, object.after_height.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLiquidityProviderTokenRealAPYRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @static
                 * @param {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} message QueryLiquidityProviderTokenRealAPYRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLiquidityProviderTokenRealAPYRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.before_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.before_height = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.after_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.after_height = options.longs === String ? "0" : 0;
                    }
                    if (message.before_height != null && message.hasOwnProperty("before_height"))
                        if (typeof message.before_height === "number")
                            object.before_height = options.longs === String ? String(message.before_height) : message.before_height;
                        else
                            object.before_height = options.longs === String ? $util.Long.prototype.toString.call(message.before_height) : options.longs === Number ? new $util.LongBits(message.before_height.low >>> 0, message.before_height.high >>> 0).toNumber() : message.before_height;
                    if (message.after_height != null && message.hasOwnProperty("after_height"))
                        if (typeof message.after_height === "number")
                            object.after_height = options.longs === String ? String(message.after_height) : message.after_height;
                        else
                            object.after_height = options.longs === String ? $util.Long.prototype.toString.call(message.after_height) : options.longs === Number ? new $util.LongBits(message.after_height.low >>> 0, message.after_height.high >>> 0).toNumber() : message.after_height;
                    return object;
                };
    
                /**
                 * Converts this QueryLiquidityProviderTokenRealAPYRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLiquidityProviderTokenRealAPYRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLiquidityProviderTokenRealAPYRequest;
            })();
    
            derivatives.QueryLiquidityProviderTokenRealAPYResponse = (function() {
    
                /**
                 * Properties of a QueryLiquidityProviderTokenRealAPYResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryLiquidityProviderTokenRealAPYResponse
                 * @property {string|null} [apy] QueryLiquidityProviderTokenRealAPYResponse apy
                 */
    
                /**
                 * Constructs a new QueryLiquidityProviderTokenRealAPYResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryLiquidityProviderTokenRealAPYResponse.
                 * @implements IQueryLiquidityProviderTokenRealAPYResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYResponse=} [properties] Properties to set
                 */
                function QueryLiquidityProviderTokenRealAPYResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLiquidityProviderTokenRealAPYResponse apy.
                 * @member {string} apy
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @instance
                 */
                QueryLiquidityProviderTokenRealAPYResponse.prototype.apy = "";
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenRealAPYResponse message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYResponse} message QueryLiquidityProviderTokenRealAPYResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenRealAPYResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.apy != null && Object.hasOwnProperty.call(message, "apy"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.apy);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenRealAPYResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYResponse} message QueryLiquidityProviderTokenRealAPYResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenRealAPYResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenRealAPYResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} QueryLiquidityProviderTokenRealAPYResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenRealAPYResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.apy = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenRealAPYResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} QueryLiquidityProviderTokenRealAPYResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenRealAPYResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLiquidityProviderTokenRealAPYResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLiquidityProviderTokenRealAPYResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.apy != null && message.hasOwnProperty("apy"))
                        if (!$util.isString(message.apy))
                            return "apy: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryLiquidityProviderTokenRealAPYResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} QueryLiquidityProviderTokenRealAPYResponse
                 */
                QueryLiquidityProviderTokenRealAPYResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse();
                    if (object.apy != null)
                        message.apy = String(object.apy);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLiquidityProviderTokenRealAPYResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @static
                 * @param {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} message QueryLiquidityProviderTokenRealAPYResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLiquidityProviderTokenRealAPYResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.apy = "";
                    if (message.apy != null && message.hasOwnProperty("apy"))
                        object.apy = message.apy;
                    return object;
                };
    
                /**
                 * Converts this QueryLiquidityProviderTokenRealAPYResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLiquidityProviderTokenRealAPYResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLiquidityProviderTokenRealAPYResponse;
            })();
    
            derivatives.QueryLiquidityProviderTokenNominalAPYRequest = (function() {
    
                /**
                 * Properties of a QueryLiquidityProviderTokenNominalAPYRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryLiquidityProviderTokenNominalAPYRequest
                 * @property {Long|null} [before_height] QueryLiquidityProviderTokenNominalAPYRequest before_height
                 * @property {Long|null} [after_height] QueryLiquidityProviderTokenNominalAPYRequest after_height
                 */
    
                /**
                 * Constructs a new QueryLiquidityProviderTokenNominalAPYRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryLiquidityProviderTokenNominalAPYRequest.
                 * @implements IQueryLiquidityProviderTokenNominalAPYRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest=} [properties] Properties to set
                 */
                function QueryLiquidityProviderTokenNominalAPYRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLiquidityProviderTokenNominalAPYRequest before_height.
                 * @member {Long} before_height
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @instance
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.prototype.before_height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * QueryLiquidityProviderTokenNominalAPYRequest after_height.
                 * @member {Long} after_height
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @instance
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.prototype.after_height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenNominalAPYRequest message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} message QueryLiquidityProviderTokenNominalAPYRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.before_height != null && Object.hasOwnProperty.call(message, "before_height"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.before_height);
                    if (message.after_height != null && Object.hasOwnProperty.call(message, "after_height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.after_height);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenNominalAPYRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} message QueryLiquidityProviderTokenNominalAPYRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenNominalAPYRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} QueryLiquidityProviderTokenNominalAPYRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.before_height = reader.int64();
                            break;
                        case 2:
                            message.after_height = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenNominalAPYRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} QueryLiquidityProviderTokenNominalAPYRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLiquidityProviderTokenNominalAPYRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.before_height != null && message.hasOwnProperty("before_height"))
                        if (!$util.isInteger(message.before_height) && !(message.before_height && $util.isInteger(message.before_height.low) && $util.isInteger(message.before_height.high)))
                            return "before_height: integer|Long expected";
                    if (message.after_height != null && message.hasOwnProperty("after_height"))
                        if (!$util.isInteger(message.after_height) && !(message.after_height && $util.isInteger(message.after_height.low) && $util.isInteger(message.after_height.high)))
                            return "after_height: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryLiquidityProviderTokenNominalAPYRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} QueryLiquidityProviderTokenNominalAPYRequest
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest();
                    if (object.before_height != null)
                        if ($util.Long)
                            (message.before_height = $util.Long.fromValue(object.before_height)).unsigned = false;
                        else if (typeof object.before_height === "string")
                            message.before_height = parseInt(object.before_height, 10);
                        else if (typeof object.before_height === "number")
                            message.before_height = object.before_height;
                        else if (typeof object.before_height === "object")
                            message.before_height = new $util.LongBits(object.before_height.low >>> 0, object.before_height.high >>> 0).toNumber();
                    if (object.after_height != null)
                        if ($util.Long)
                            (message.after_height = $util.Long.fromValue(object.after_height)).unsigned = false;
                        else if (typeof object.after_height === "string")
                            message.after_height = parseInt(object.after_height, 10);
                        else if (typeof object.after_height === "number")
                            message.after_height = object.after_height;
                        else if (typeof object.after_height === "object")
                            message.after_height = new $util.LongBits(object.after_height.low >>> 0, object.after_height.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLiquidityProviderTokenNominalAPYRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @static
                 * @param {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} message QueryLiquidityProviderTokenNominalAPYRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.before_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.before_height = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.after_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.after_height = options.longs === String ? "0" : 0;
                    }
                    if (message.before_height != null && message.hasOwnProperty("before_height"))
                        if (typeof message.before_height === "number")
                            object.before_height = options.longs === String ? String(message.before_height) : message.before_height;
                        else
                            object.before_height = options.longs === String ? $util.Long.prototype.toString.call(message.before_height) : options.longs === Number ? new $util.LongBits(message.before_height.low >>> 0, message.before_height.high >>> 0).toNumber() : message.before_height;
                    if (message.after_height != null && message.hasOwnProperty("after_height"))
                        if (typeof message.after_height === "number")
                            object.after_height = options.longs === String ? String(message.after_height) : message.after_height;
                        else
                            object.after_height = options.longs === String ? $util.Long.prototype.toString.call(message.after_height) : options.longs === Number ? new $util.LongBits(message.after_height.low >>> 0, message.after_height.high >>> 0).toNumber() : message.after_height;
                    return object;
                };
    
                /**
                 * Converts this QueryLiquidityProviderTokenNominalAPYRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLiquidityProviderTokenNominalAPYRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLiquidityProviderTokenNominalAPYRequest;
            })();
    
            derivatives.QueryLiquidityProviderTokenNominalAPYResponse = (function() {
    
                /**
                 * Properties of a QueryLiquidityProviderTokenNominalAPYResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryLiquidityProviderTokenNominalAPYResponse
                 * @property {string|null} [apy] QueryLiquidityProviderTokenNominalAPYResponse apy
                 */
    
                /**
                 * Constructs a new QueryLiquidityProviderTokenNominalAPYResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryLiquidityProviderTokenNominalAPYResponse.
                 * @implements IQueryLiquidityProviderTokenNominalAPYResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYResponse=} [properties] Properties to set
                 */
                function QueryLiquidityProviderTokenNominalAPYResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLiquidityProviderTokenNominalAPYResponse apy.
                 * @member {string} apy
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @instance
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.prototype.apy = "";
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenNominalAPYResponse message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYResponse} message QueryLiquidityProviderTokenNominalAPYResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.apy != null && Object.hasOwnProperty.call(message, "apy"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.apy);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLiquidityProviderTokenNominalAPYResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYResponse} message QueryLiquidityProviderTokenNominalAPYResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenNominalAPYResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} QueryLiquidityProviderTokenNominalAPYResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.apy = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLiquidityProviderTokenNominalAPYResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} QueryLiquidityProviderTokenNominalAPYResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLiquidityProviderTokenNominalAPYResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.apy != null && message.hasOwnProperty("apy"))
                        if (!$util.isString(message.apy))
                            return "apy: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryLiquidityProviderTokenNominalAPYResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} QueryLiquidityProviderTokenNominalAPYResponse
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse();
                    if (object.apy != null)
                        message.apy = String(object.apy);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLiquidityProviderTokenNominalAPYResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @static
                 * @param {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} message QueryLiquidityProviderTokenNominalAPYResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.apy = "";
                    if (message.apy != null && message.hasOwnProperty("apy"))
                        object.apy = message.apy;
                    return object;
                };
    
                /**
                 * Converts this QueryLiquidityProviderTokenNominalAPYResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLiquidityProviderTokenNominalAPYResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLiquidityProviderTokenNominalAPYResponse;
            })();
    
            derivatives.QueryPerpetualFuturesRequest = (function() {
    
                /**
                 * Properties of a QueryPerpetualFuturesRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualFuturesRequest
                 */
    
                /**
                 * Constructs a new QueryPerpetualFuturesRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualFuturesRequest.
                 * @implements IQueryPerpetualFuturesRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest=} [properties] Properties to set
                 */
                function QueryPerpetualFuturesRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryPerpetualFuturesRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} message QueryPerpetualFuturesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualFuturesRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} message QueryPerpetualFuturesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesRequest} QueryPerpetualFuturesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualFuturesRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesRequest} QueryPerpetualFuturesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualFuturesRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualFuturesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualFuturesRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesRequest} QueryPerpetualFuturesRequest
                 */
                QueryPerpetualFuturesRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesRequest)
                        return object;
                    return new $root.ununifi.derivatives.QueryPerpetualFuturesRequest();
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualFuturesRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualFuturesRequest} message QueryPerpetualFuturesRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualFuturesRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryPerpetualFuturesRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualFuturesRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualFuturesRequest;
            })();
    
            derivatives.QueryPerpetualFuturesResponse = (function() {
    
                /**
                 * Properties of a QueryPerpetualFuturesResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualFuturesResponse
                 * @property {string|null} [metrics_quote_ticker] QueryPerpetualFuturesResponse metrics_quote_ticker
                 * @property {string|null} [long_positions] QueryPerpetualFuturesResponse long_positions
                 * @property {string|null} [short_positions] QueryPerpetualFuturesResponse short_positions
                 */
    
                /**
                 * Constructs a new QueryPerpetualFuturesResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualFuturesResponse.
                 * @implements IQueryPerpetualFuturesResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesResponse=} [properties] Properties to set
                 */
                function QueryPerpetualFuturesResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPerpetualFuturesResponse metrics_quote_ticker.
                 * @member {string} metrics_quote_ticker
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @instance
                 */
                QueryPerpetualFuturesResponse.prototype.metrics_quote_ticker = "";
    
                /**
                 * QueryPerpetualFuturesResponse long_positions.
                 * @member {string} long_positions
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @instance
                 */
                QueryPerpetualFuturesResponse.prototype.long_positions = "";
    
                /**
                 * QueryPerpetualFuturesResponse short_positions.
                 * @member {string} short_positions
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @instance
                 */
                QueryPerpetualFuturesResponse.prototype.short_positions = "";
    
                /**
                 * Encodes the specified QueryPerpetualFuturesResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesResponse} message QueryPerpetualFuturesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.metrics_quote_ticker != null && Object.hasOwnProperty.call(message, "metrics_quote_ticker"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.metrics_quote_ticker);
                    if (message.long_positions != null && Object.hasOwnProperty.call(message, "long_positions"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.long_positions);
                    if (message.short_positions != null && Object.hasOwnProperty.call(message, "short_positions"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.short_positions);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualFuturesResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesResponse} message QueryPerpetualFuturesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesResponse} QueryPerpetualFuturesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualFuturesResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.metrics_quote_ticker = reader.string();
                            break;
                        case 2:
                            message.long_positions = reader.string();
                            break;
                        case 3:
                            message.short_positions = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesResponse} QueryPerpetualFuturesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualFuturesResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualFuturesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.metrics_quote_ticker != null && message.hasOwnProperty("metrics_quote_ticker"))
                        if (!$util.isString(message.metrics_quote_ticker))
                            return "metrics_quote_ticker: string expected";
                    if (message.long_positions != null && message.hasOwnProperty("long_positions"))
                        if (!$util.isString(message.long_positions))
                            return "long_positions: string expected";
                    if (message.short_positions != null && message.hasOwnProperty("short_positions"))
                        if (!$util.isString(message.short_positions))
                            return "short_positions: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualFuturesResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesResponse} QueryPerpetualFuturesResponse
                 */
                QueryPerpetualFuturesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPerpetualFuturesResponse();
                    if (object.metrics_quote_ticker != null)
                        message.metrics_quote_ticker = String(object.metrics_quote_ticker);
                    if (object.long_positions != null)
                        message.long_positions = String(object.long_positions);
                    if (object.short_positions != null)
                        message.short_positions = String(object.short_positions);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualFuturesResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualFuturesResponse} message QueryPerpetualFuturesResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualFuturesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.metrics_quote_ticker = "";
                        object.long_positions = "";
                        object.short_positions = "";
                    }
                    if (message.metrics_quote_ticker != null && message.hasOwnProperty("metrics_quote_ticker"))
                        object.metrics_quote_ticker = message.metrics_quote_ticker;
                    if (message.long_positions != null && message.hasOwnProperty("long_positions"))
                        object.long_positions = message.long_positions;
                    if (message.short_positions != null && message.hasOwnProperty("short_positions"))
                        object.short_positions = message.short_positions;
                    return object;
                };
    
                /**
                 * Converts this QueryPerpetualFuturesResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualFuturesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualFuturesResponse;
            })();
    
            derivatives.QueryPerpetualFuturesMarketRequest = (function() {
    
                /**
                 * Properties of a QueryPerpetualFuturesMarketRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualFuturesMarketRequest
                 * @property {string|null} [base_denom] QueryPerpetualFuturesMarketRequest base_denom
                 * @property {string|null} [quote_denom] QueryPerpetualFuturesMarketRequest quote_denom
                 */
    
                /**
                 * Constructs a new QueryPerpetualFuturesMarketRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualFuturesMarketRequest.
                 * @implements IQueryPerpetualFuturesMarketRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest=} [properties] Properties to set
                 */
                function QueryPerpetualFuturesMarketRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPerpetualFuturesMarketRequest base_denom.
                 * @member {string} base_denom
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @instance
                 */
                QueryPerpetualFuturesMarketRequest.prototype.base_denom = "";
    
                /**
                 * QueryPerpetualFuturesMarketRequest quote_denom.
                 * @member {string} quote_denom
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @instance
                 */
                QueryPerpetualFuturesMarketRequest.prototype.quote_denom = "";
    
                /**
                 * Encodes the specified QueryPerpetualFuturesMarketRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} message QueryPerpetualFuturesMarketRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesMarketRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.base_denom != null && Object.hasOwnProperty.call(message, "base_denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.base_denom);
                    if (message.quote_denom != null && Object.hasOwnProperty.call(message, "quote_denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.quote_denom);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualFuturesMarketRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} message QueryPerpetualFuturesMarketRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesMarketRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} QueryPerpetualFuturesMarketRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesMarketRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.base_denom = reader.string();
                            break;
                        case 2:
                            message.quote_denom = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesMarketRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} QueryPerpetualFuturesMarketRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesMarketRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualFuturesMarketRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualFuturesMarketRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.base_denom != null && message.hasOwnProperty("base_denom"))
                        if (!$util.isString(message.base_denom))
                            return "base_denom: string expected";
                    if (message.quote_denom != null && message.hasOwnProperty("quote_denom"))
                        if (!$util.isString(message.quote_denom))
                            return "quote_denom: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualFuturesMarketRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} QueryPerpetualFuturesMarketRequest
                 */
                QueryPerpetualFuturesMarketRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest();
                    if (object.base_denom != null)
                        message.base_denom = String(object.base_denom);
                    if (object.quote_denom != null)
                        message.quote_denom = String(object.quote_denom);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualFuturesMarketRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} message QueryPerpetualFuturesMarketRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualFuturesMarketRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.base_denom = "";
                        object.quote_denom = "";
                    }
                    if (message.base_denom != null && message.hasOwnProperty("base_denom"))
                        object.base_denom = message.base_denom;
                    if (message.quote_denom != null && message.hasOwnProperty("quote_denom"))
                        object.quote_denom = message.quote_denom;
                    return object;
                };
    
                /**
                 * Converts this QueryPerpetualFuturesMarketRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualFuturesMarketRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualFuturesMarketRequest;
            })();
    
            derivatives.QueryPerpetualFuturesMarketResponse = (function() {
    
                /**
                 * Properties of a QueryPerpetualFuturesMarketResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualFuturesMarketResponse
                 * @property {string|null} [price] QueryPerpetualFuturesMarketResponse price
                 * @property {string|null} [metrics_quote_ticker] QueryPerpetualFuturesMarketResponse metrics_quote_ticker
                 * @property {string|null} [long_positions] QueryPerpetualFuturesMarketResponse long_positions
                 * @property {string|null} [short_positions] QueryPerpetualFuturesMarketResponse short_positions
                 */
    
                /**
                 * Constructs a new QueryPerpetualFuturesMarketResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualFuturesMarketResponse.
                 * @implements IQueryPerpetualFuturesMarketResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketResponse=} [properties] Properties to set
                 */
                function QueryPerpetualFuturesMarketResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPerpetualFuturesMarketResponse price.
                 * @member {string} price
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @instance
                 */
                QueryPerpetualFuturesMarketResponse.prototype.price = "";
    
                /**
                 * QueryPerpetualFuturesMarketResponse metrics_quote_ticker.
                 * @member {string} metrics_quote_ticker
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @instance
                 */
                QueryPerpetualFuturesMarketResponse.prototype.metrics_quote_ticker = "";
    
                /**
                 * QueryPerpetualFuturesMarketResponse long_positions.
                 * @member {string} long_positions
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @instance
                 */
                QueryPerpetualFuturesMarketResponse.prototype.long_positions = "";
    
                /**
                 * QueryPerpetualFuturesMarketResponse short_positions.
                 * @member {string} short_positions
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @instance
                 */
                QueryPerpetualFuturesMarketResponse.prototype.short_positions = "";
    
                /**
                 * Encodes the specified QueryPerpetualFuturesMarketResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketResponse} message QueryPerpetualFuturesMarketResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesMarketResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.price);
                    if (message.metrics_quote_ticker != null && Object.hasOwnProperty.call(message, "metrics_quote_ticker"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.metrics_quote_ticker);
                    if (message.long_positions != null && Object.hasOwnProperty.call(message, "long_positions"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.long_positions);
                    if (message.short_positions != null && Object.hasOwnProperty.call(message, "short_positions"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.short_positions);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualFuturesMarketResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketResponse} message QueryPerpetualFuturesMarketResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesMarketResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} QueryPerpetualFuturesMarketResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesMarketResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.price = reader.string();
                            break;
                        case 2:
                            message.metrics_quote_ticker = reader.string();
                            break;
                        case 3:
                            message.long_positions = reader.string();
                            break;
                        case 4:
                            message.short_positions = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesMarketResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} QueryPerpetualFuturesMarketResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesMarketResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualFuturesMarketResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualFuturesMarketResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.price != null && message.hasOwnProperty("price"))
                        if (!$util.isString(message.price))
                            return "price: string expected";
                    if (message.metrics_quote_ticker != null && message.hasOwnProperty("metrics_quote_ticker"))
                        if (!$util.isString(message.metrics_quote_ticker))
                            return "metrics_quote_ticker: string expected";
                    if (message.long_positions != null && message.hasOwnProperty("long_positions"))
                        if (!$util.isString(message.long_positions))
                            return "long_positions: string expected";
                    if (message.short_positions != null && message.hasOwnProperty("short_positions"))
                        if (!$util.isString(message.short_positions))
                            return "short_positions: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualFuturesMarketResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} QueryPerpetualFuturesMarketResponse
                 */
                QueryPerpetualFuturesMarketResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse();
                    if (object.price != null)
                        message.price = String(object.price);
                    if (object.metrics_quote_ticker != null)
                        message.metrics_quote_ticker = String(object.metrics_quote_ticker);
                    if (object.long_positions != null)
                        message.long_positions = String(object.long_positions);
                    if (object.short_positions != null)
                        message.short_positions = String(object.short_positions);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualFuturesMarketResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} message QueryPerpetualFuturesMarketResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualFuturesMarketResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.price = "";
                        object.metrics_quote_ticker = "";
                        object.long_positions = "";
                        object.short_positions = "";
                    }
                    if (message.price != null && message.hasOwnProperty("price"))
                        object.price = message.price;
                    if (message.metrics_quote_ticker != null && message.hasOwnProperty("metrics_quote_ticker"))
                        object.metrics_quote_ticker = message.metrics_quote_ticker;
                    if (message.long_positions != null && message.hasOwnProperty("long_positions"))
                        object.long_positions = message.long_positions;
                    if (message.short_positions != null && message.hasOwnProperty("short_positions"))
                        object.short_positions = message.short_positions;
                    return object;
                };
    
                /**
                 * Converts this QueryPerpetualFuturesMarketResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualFuturesMarketResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualFuturesMarketResponse;
            })();
    
            derivatives.QueryPerpetualOptionsRequest = (function() {
    
                /**
                 * Properties of a QueryPerpetualOptionsRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualOptionsRequest
                 */
    
                /**
                 * Constructs a new QueryPerpetualOptionsRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualOptionsRequest.
                 * @implements IQueryPerpetualOptionsRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest=} [properties] Properties to set
                 */
                function QueryPerpetualOptionsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryPerpetualOptionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} message QueryPerpetualOptionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualOptionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} message QueryPerpetualOptionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsRequest} QueryPerpetualOptionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualOptionsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsRequest} QueryPerpetualOptionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualOptionsRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualOptionsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualOptionsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsRequest} QueryPerpetualOptionsRequest
                 */
                QueryPerpetualOptionsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsRequest)
                        return object;
                    return new $root.ununifi.derivatives.QueryPerpetualOptionsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualOptionsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualOptionsRequest} message QueryPerpetualOptionsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualOptionsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryPerpetualOptionsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualOptionsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualOptionsRequest;
            })();
    
            derivatives.QueryPerpetualOptionsResponse = (function() {
    
                /**
                 * Properties of a QueryPerpetualOptionsResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualOptionsResponse
                 */
    
                /**
                 * Constructs a new QueryPerpetualOptionsResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualOptionsResponse.
                 * @implements IQueryPerpetualOptionsResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsResponse=} [properties] Properties to set
                 */
                function QueryPerpetualOptionsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryPerpetualOptionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsResponse} message QueryPerpetualOptionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualOptionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsResponse} message QueryPerpetualOptionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsResponse} QueryPerpetualOptionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualOptionsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsResponse} QueryPerpetualOptionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualOptionsResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualOptionsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualOptionsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsResponse} QueryPerpetualOptionsResponse
                 */
                QueryPerpetualOptionsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsResponse)
                        return object;
                    return new $root.ununifi.derivatives.QueryPerpetualOptionsResponse();
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualOptionsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualOptionsResponse} message QueryPerpetualOptionsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualOptionsResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryPerpetualOptionsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualOptionsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualOptionsResponse;
            })();
    
            derivatives.QueryPerpetualOptionsMarketRequest = (function() {
    
                /**
                 * Properties of a QueryPerpetualOptionsMarketRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualOptionsMarketRequest
                 * @property {string|null} [base_denom] QueryPerpetualOptionsMarketRequest base_denom
                 * @property {string|null} [quote_denom] QueryPerpetualOptionsMarketRequest quote_denom
                 */
    
                /**
                 * Constructs a new QueryPerpetualOptionsMarketRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualOptionsMarketRequest.
                 * @implements IQueryPerpetualOptionsMarketRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest=} [properties] Properties to set
                 */
                function QueryPerpetualOptionsMarketRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPerpetualOptionsMarketRequest base_denom.
                 * @member {string} base_denom
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @instance
                 */
                QueryPerpetualOptionsMarketRequest.prototype.base_denom = "";
    
                /**
                 * QueryPerpetualOptionsMarketRequest quote_denom.
                 * @member {string} quote_denom
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @instance
                 */
                QueryPerpetualOptionsMarketRequest.prototype.quote_denom = "";
    
                /**
                 * Encodes the specified QueryPerpetualOptionsMarketRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} message QueryPerpetualOptionsMarketRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsMarketRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.base_denom != null && Object.hasOwnProperty.call(message, "base_denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.base_denom);
                    if (message.quote_denom != null && Object.hasOwnProperty.call(message, "quote_denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.quote_denom);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualOptionsMarketRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} message QueryPerpetualOptionsMarketRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsMarketRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} QueryPerpetualOptionsMarketRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsMarketRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.base_denom = reader.string();
                            break;
                        case 2:
                            message.quote_denom = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsMarketRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} QueryPerpetualOptionsMarketRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsMarketRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualOptionsMarketRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualOptionsMarketRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.base_denom != null && message.hasOwnProperty("base_denom"))
                        if (!$util.isString(message.base_denom))
                            return "base_denom: string expected";
                    if (message.quote_denom != null && message.hasOwnProperty("quote_denom"))
                        if (!$util.isString(message.quote_denom))
                            return "quote_denom: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualOptionsMarketRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} QueryPerpetualOptionsMarketRequest
                 */
                QueryPerpetualOptionsMarketRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest();
                    if (object.base_denom != null)
                        message.base_denom = String(object.base_denom);
                    if (object.quote_denom != null)
                        message.quote_denom = String(object.quote_denom);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualOptionsMarketRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} message QueryPerpetualOptionsMarketRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualOptionsMarketRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.base_denom = "";
                        object.quote_denom = "";
                    }
                    if (message.base_denom != null && message.hasOwnProperty("base_denom"))
                        object.base_denom = message.base_denom;
                    if (message.quote_denom != null && message.hasOwnProperty("quote_denom"))
                        object.quote_denom = message.quote_denom;
                    return object;
                };
    
                /**
                 * Converts this QueryPerpetualOptionsMarketRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualOptionsMarketRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualOptionsMarketRequest;
            })();
    
            derivatives.QueryPerpetualOptionsMarketResponse = (function() {
    
                /**
                 * Properties of a QueryPerpetualOptionsMarketResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualOptionsMarketResponse
                 */
    
                /**
                 * Constructs a new QueryPerpetualOptionsMarketResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualOptionsMarketResponse.
                 * @implements IQueryPerpetualOptionsMarketResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketResponse=} [properties] Properties to set
                 */
                function QueryPerpetualOptionsMarketResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryPerpetualOptionsMarketResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketResponse} message QueryPerpetualOptionsMarketResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsMarketResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualOptionsMarketResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketResponse} message QueryPerpetualOptionsMarketResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualOptionsMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsMarketResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} QueryPerpetualOptionsMarketResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsMarketResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualOptionsMarketResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} QueryPerpetualOptionsMarketResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualOptionsMarketResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualOptionsMarketResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualOptionsMarketResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualOptionsMarketResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} QueryPerpetualOptionsMarketResponse
                 */
                QueryPerpetualOptionsMarketResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse)
                        return object;
                    return new $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse();
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualOptionsMarketResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} message QueryPerpetualOptionsMarketResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualOptionsMarketResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryPerpetualOptionsMarketResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualOptionsMarketResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualOptionsMarketResponse;
            })();
    
            derivatives.QueryAllPositionsRequest = (function() {
    
                /**
                 * Properties of a QueryAllPositionsRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAllPositionsRequest
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllPositionsRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllPositionsRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAllPositionsRequest.
                 * @implements IQueryAllPositionsRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAllPositionsRequest=} [properties] Properties to set
                 */
                function QueryAllPositionsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllPositionsRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @instance
                 */
                QueryAllPositionsRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllPositionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPositionsRequest} message QueryAllPositionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPositionsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllPositionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPositionsRequest} message QueryAllPositionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllPositionsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAllPositionsRequest} QueryAllPositionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPositionsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAllPositionsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllPositionsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAllPositionsRequest} QueryAllPositionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllPositionsRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllPositionsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllPositionsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAllPositionsRequest} QueryAllPositionsRequest
                 */
                QueryAllPositionsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAllPositionsRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAllPositionsRequest();
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.derivatives.QueryAllPositionsRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllPositionsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.QueryAllPositionsRequest} message QueryAllPositionsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllPositionsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pagination = null;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllPositionsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAllPositionsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllPositionsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllPositionsRequest;
            })();
    
            derivatives.QueryAllPositionsResponse = (function() {
    
                /**
                 * Properties of a QueryAllPositionsResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAllPositionsResponse
                 * @property {Array.<ununifi.derivatives.IPosition>|null} [positions] QueryAllPositionsResponse positions
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllPositionsResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllPositionsResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAllPositionsResponse.
                 * @implements IQueryAllPositionsResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAllPositionsResponse=} [properties] Properties to set
                 */
                function QueryAllPositionsResponse(properties) {
                    this.positions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllPositionsResponse positions.
                 * @member {Array.<ununifi.derivatives.IPosition>} positions
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @instance
                 */
                QueryAllPositionsResponse.prototype.positions = $util.emptyArray;
    
                /**
                 * QueryAllPositionsResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @instance
                 */
                QueryAllPositionsResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllPositionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPositionsResponse} message QueryAllPositionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPositionsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.positions != null && message.positions.length)
                        for (var i = 0; i < message.positions.length; ++i)
                            $root.ununifi.derivatives.Position.encode(message.positions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllPositionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPositionsResponse} message QueryAllPositionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllPositionsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAllPositionsResponse} QueryAllPositionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPositionsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAllPositionsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.positions && message.positions.length))
                                message.positions = [];
                            message.positions.push($root.ununifi.derivatives.Position.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllPositionsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAllPositionsResponse} QueryAllPositionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllPositionsResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllPositionsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.positions != null && message.hasOwnProperty("positions")) {
                        if (!Array.isArray(message.positions))
                            return "positions: array expected";
                        for (var i = 0; i < message.positions.length; ++i) {
                            var error = $root.ununifi.derivatives.Position.verify(message.positions[i]);
                            if (error)
                                return "positions." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllPositionsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAllPositionsResponse} QueryAllPositionsResponse
                 */
                QueryAllPositionsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAllPositionsResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAllPositionsResponse();
                    if (object.positions) {
                        if (!Array.isArray(object.positions))
                            throw TypeError(".ununifi.derivatives.QueryAllPositionsResponse.positions: array expected");
                        message.positions = [];
                        for (var i = 0; i < object.positions.length; ++i) {
                            if (typeof object.positions[i] !== "object")
                                throw TypeError(".ununifi.derivatives.QueryAllPositionsResponse.positions: object expected");
                            message.positions[i] = $root.ununifi.derivatives.Position.fromObject(object.positions[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.derivatives.QueryAllPositionsResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllPositionsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.QueryAllPositionsResponse} message QueryAllPositionsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllPositionsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.positions = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.positions && message.positions.length) {
                        object.positions = [];
                        for (var j = 0; j < message.positions.length; ++j)
                            object.positions[j] = $root.ununifi.derivatives.Position.toObject(message.positions[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllPositionsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAllPositionsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllPositionsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllPositionsResponse;
            })();
    
            derivatives.QueryPositionRequest = (function() {
    
                /**
                 * Properties of a QueryPositionRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPositionRequest
                 * @property {string|null} [position_id] QueryPositionRequest position_id
                 */
    
                /**
                 * Constructs a new QueryPositionRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPositionRequest.
                 * @implements IQueryPositionRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPositionRequest=} [properties] Properties to set
                 */
                function QueryPositionRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPositionRequest position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @instance
                 */
                QueryPositionRequest.prototype.position_id = "";
    
                /**
                 * Encodes the specified QueryPositionRequest message. Does not implicitly {@link ununifi.derivatives.QueryPositionRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPositionRequest} message QueryPositionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPositionRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPositionRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPositionRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPositionRequest} message QueryPositionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPositionRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPositionRequest} QueryPositionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPositionRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPositionRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPositionRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPositionRequest} QueryPositionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPositionRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPositionRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPositionRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPositionRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPositionRequest} QueryPositionRequest
                 */
                QueryPositionRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPositionRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPositionRequest();
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPositionRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPositionRequest} message QueryPositionRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPositionRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.position_id = "";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this QueryPositionRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPositionRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPositionRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPositionRequest;
            })();
    
            derivatives.QueryPositionResponse = (function() {
    
                /**
                 * Properties of a QueryPositionResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPositionResponse
                 * @property {ununifi.derivatives.IPosition|null} [position] QueryPositionResponse position
                 * @property {cosmos.base.v1beta1.ICoin|null} [valuation_profit] QueryPositionResponse valuation_profit
                 * @property {string|null} [margin_maintenance_rate] QueryPositionResponse margin_maintenance_rate
                 * @property {cosmos.base.v1beta1.ICoin|null} [effective_margin] QueryPositionResponse effective_margin
                 */
    
                /**
                 * Constructs a new QueryPositionResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPositionResponse.
                 * @implements IQueryPositionResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPositionResponse=} [properties] Properties to set
                 */
                function QueryPositionResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPositionResponse position.
                 * @member {ununifi.derivatives.IPosition|null|undefined} position
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @instance
                 */
                QueryPositionResponse.prototype.position = null;
    
                /**
                 * QueryPositionResponse valuation_profit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} valuation_profit
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @instance
                 */
                QueryPositionResponse.prototype.valuation_profit = null;
    
                /**
                 * QueryPositionResponse margin_maintenance_rate.
                 * @member {string} margin_maintenance_rate
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @instance
                 */
                QueryPositionResponse.prototype.margin_maintenance_rate = "";
    
                /**
                 * QueryPositionResponse effective_margin.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} effective_margin
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @instance
                 */
                QueryPositionResponse.prototype.effective_margin = null;
    
                /**
                 * Encodes the specified QueryPositionResponse message. Does not implicitly {@link ununifi.derivatives.QueryPositionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPositionResponse} message QueryPositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPositionResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.ununifi.derivatives.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.valuation_profit != null && Object.hasOwnProperty.call(message, "valuation_profit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.valuation_profit, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, "margin_maintenance_rate"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.margin_maintenance_rate);
                    if (message.effective_margin != null && Object.hasOwnProperty.call(message, "effective_margin"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.effective_margin, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPositionResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPositionResponse} message QueryPositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPositionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPositionResponse} QueryPositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPositionResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPositionResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position = $root.ununifi.derivatives.Position.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.valuation_profit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.margin_maintenance_rate = reader.string();
                            break;
                        case 4:
                            message.effective_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPositionResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPositionResponse} QueryPositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPositionResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPositionResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPositionResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.ununifi.derivatives.Position.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.valuation_profit != null && message.hasOwnProperty("valuation_profit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.valuation_profit);
                        if (error)
                            return "valuation_profit." + error;
                    }
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        if (!$util.isString(message.margin_maintenance_rate))
                            return "margin_maintenance_rate: string expected";
                    if (message.effective_margin != null && message.hasOwnProperty("effective_margin")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.effective_margin);
                        if (error)
                            return "effective_margin." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryPositionResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPositionResponse} QueryPositionResponse
                 */
                QueryPositionResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPositionResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPositionResponse();
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".ununifi.derivatives.QueryPositionResponse.position: object expected");
                        message.position = $root.ununifi.derivatives.Position.fromObject(object.position);
                    }
                    if (object.valuation_profit != null) {
                        if (typeof object.valuation_profit !== "object")
                            throw TypeError(".ununifi.derivatives.QueryPositionResponse.valuation_profit: object expected");
                        message.valuation_profit = $root.cosmos.base.v1beta1.Coin.fromObject(object.valuation_profit);
                    }
                    if (object.margin_maintenance_rate != null)
                        message.margin_maintenance_rate = String(object.margin_maintenance_rate);
                    if (object.effective_margin != null) {
                        if (typeof object.effective_margin !== "object")
                            throw TypeError(".ununifi.derivatives.QueryPositionResponse.effective_margin: object expected");
                        message.effective_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.effective_margin);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPositionResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPositionResponse} message QueryPositionResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPositionResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.position = null;
                        object.valuation_profit = null;
                        object.margin_maintenance_rate = "";
                        object.effective_margin = null;
                    }
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.ununifi.derivatives.Position.toObject(message.position, options);
                    if (message.valuation_profit != null && message.hasOwnProperty("valuation_profit"))
                        object.valuation_profit = $root.cosmos.base.v1beta1.Coin.toObject(message.valuation_profit, options);
                    if (message.margin_maintenance_rate != null && message.hasOwnProperty("margin_maintenance_rate"))
                        object.margin_maintenance_rate = message.margin_maintenance_rate;
                    if (message.effective_margin != null && message.hasOwnProperty("effective_margin"))
                        object.effective_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.effective_margin, options);
                    return object;
                };
    
                /**
                 * Converts this QueryPositionResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPositionResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPositionResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPositionResponse;
            })();
    
            derivatives.QueryPerpetualFuturesPositionSizeRequest = (function() {
    
                /**
                 * Properties of a QueryPerpetualFuturesPositionSizeRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualFuturesPositionSizeRequest
                 * @property {ununifi.derivatives.PositionType|null} [position_type] QueryPerpetualFuturesPositionSizeRequest position_type
                 * @property {string|null} [address] QueryPerpetualFuturesPositionSizeRequest address
                 */
    
                /**
                 * Constructs a new QueryPerpetualFuturesPositionSizeRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualFuturesPositionSizeRequest.
                 * @implements IQueryPerpetualFuturesPositionSizeRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest=} [properties] Properties to set
                 */
                function QueryPerpetualFuturesPositionSizeRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPerpetualFuturesPositionSizeRequest position_type.
                 * @member {ununifi.derivatives.PositionType} position_type
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @instance
                 */
                QueryPerpetualFuturesPositionSizeRequest.prototype.position_type = 0;
    
                /**
                 * QueryPerpetualFuturesPositionSizeRequest address.
                 * @member {string} address
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @instance
                 */
                QueryPerpetualFuturesPositionSizeRequest.prototype.address = "";
    
                /**
                 * Encodes the specified QueryPerpetualFuturesPositionSizeRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} message QueryPerpetualFuturesPositionSizeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesPositionSizeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position_type != null && Object.hasOwnProperty.call(message, "position_type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.position_type);
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualFuturesPositionSizeRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} message QueryPerpetualFuturesPositionSizeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesPositionSizeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesPositionSizeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} QueryPerpetualFuturesPositionSizeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesPositionSizeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position_type = reader.int32();
                            break;
                        case 2:
                            message.address = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesPositionSizeRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} QueryPerpetualFuturesPositionSizeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesPositionSizeRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualFuturesPositionSizeRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualFuturesPositionSizeRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        switch (message.position_type) {
                        default:
                            return "position_type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isString(message.address))
                            return "address: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualFuturesPositionSizeRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} QueryPerpetualFuturesPositionSizeRequest
                 */
                QueryPerpetualFuturesPositionSizeRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest();
                    switch (object.position_type) {
                    case "POSITION_UNKNOWN":
                    case 0:
                        message.position_type = 0;
                        break;
                    case "LONG":
                    case 1:
                        message.position_type = 1;
                        break;
                    case "SHORT":
                    case 2:
                        message.position_type = 2;
                        break;
                    }
                    if (object.address != null)
                        message.address = String(object.address);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualFuturesPositionSizeRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} message QueryPerpetualFuturesPositionSizeRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualFuturesPositionSizeRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.position_type = options.enums === String ? "POSITION_UNKNOWN" : 0;
                        object.address = "";
                    }
                    if (message.position_type != null && message.hasOwnProperty("position_type"))
                        object.position_type = options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = message.address;
                    return object;
                };
    
                /**
                 * Converts this QueryPerpetualFuturesPositionSizeRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualFuturesPositionSizeRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualFuturesPositionSizeRequest;
            })();
    
            derivatives.QueryPerpetualFuturesPositionSizeResponse = (function() {
    
                /**
                 * Properties of a QueryPerpetualFuturesPositionSizeResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPerpetualFuturesPositionSizeResponse
                 * @property {cosmos.base.v1beta1.ICoin|null} [total_position_size_usd] QueryPerpetualFuturesPositionSizeResponse total_position_size_usd
                 */
    
                /**
                 * Constructs a new QueryPerpetualFuturesPositionSizeResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPerpetualFuturesPositionSizeResponse.
                 * @implements IQueryPerpetualFuturesPositionSizeResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeResponse=} [properties] Properties to set
                 */
                function QueryPerpetualFuturesPositionSizeResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPerpetualFuturesPositionSizeResponse total_position_size_usd.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} total_position_size_usd
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @instance
                 */
                QueryPerpetualFuturesPositionSizeResponse.prototype.total_position_size_usd = null;
    
                /**
                 * Encodes the specified QueryPerpetualFuturesPositionSizeResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeResponse} message QueryPerpetualFuturesPositionSizeResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesPositionSizeResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.total_position_size_usd != null && Object.hasOwnProperty.call(message, "total_position_size_usd"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.total_position_size_usd, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPerpetualFuturesPositionSizeResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeResponse} message QueryPerpetualFuturesPositionSizeResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPerpetualFuturesPositionSizeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesPositionSizeResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} QueryPerpetualFuturesPositionSizeResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesPositionSizeResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.total_position_size_usd = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPerpetualFuturesPositionSizeResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} QueryPerpetualFuturesPositionSizeResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPerpetualFuturesPositionSizeResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPerpetualFuturesPositionSizeResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPerpetualFuturesPositionSizeResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.total_position_size_usd != null && message.hasOwnProperty("total_position_size_usd")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.total_position_size_usd);
                        if (error)
                            return "total_position_size_usd." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryPerpetualFuturesPositionSizeResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} QueryPerpetualFuturesPositionSizeResponse
                 */
                QueryPerpetualFuturesPositionSizeResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse();
                    if (object.total_position_size_usd != null) {
                        if (typeof object.total_position_size_usd !== "object")
                            throw TypeError(".ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse.total_position_size_usd: object expected");
                        message.total_position_size_usd = $root.cosmos.base.v1beta1.Coin.fromObject(object.total_position_size_usd);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPerpetualFuturesPositionSizeResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} message QueryPerpetualFuturesPositionSizeResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPerpetualFuturesPositionSizeResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.total_position_size_usd = null;
                    if (message.total_position_size_usd != null && message.hasOwnProperty("total_position_size_usd"))
                        object.total_position_size_usd = $root.cosmos.base.v1beta1.Coin.toObject(message.total_position_size_usd, options);
                    return object;
                };
    
                /**
                 * Converts this QueryPerpetualFuturesPositionSizeResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPerpetualFuturesPositionSizeResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPerpetualFuturesPositionSizeResponse;
            })();
    
            derivatives.QueryAddressPositionsRequest = (function() {
    
                /**
                 * Properties of a QueryAddressPositionsRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAddressPositionsRequest
                 * @property {string|null} [address] QueryAddressPositionsRequest address
                 */
    
                /**
                 * Constructs a new QueryAddressPositionsRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAddressPositionsRequest.
                 * @implements IQueryAddressPositionsRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAddressPositionsRequest=} [properties] Properties to set
                 */
                function QueryAddressPositionsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAddressPositionsRequest address.
                 * @member {string} address
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @instance
                 */
                QueryAddressPositionsRequest.prototype.address = "";
    
                /**
                 * Encodes the specified QueryAddressPositionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAddressPositionsRequest} message QueryAddressPositionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAddressPositionsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAddressPositionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAddressPositionsRequest} message QueryAddressPositionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAddressPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAddressPositionsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAddressPositionsRequest} QueryAddressPositionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAddressPositionsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAddressPositionsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAddressPositionsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAddressPositionsRequest} QueryAddressPositionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAddressPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAddressPositionsRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAddressPositionsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isString(message.address))
                            return "address: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryAddressPositionsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAddressPositionsRequest} QueryAddressPositionsRequest
                 */
                QueryAddressPositionsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAddressPositionsRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAddressPositionsRequest();
                    if (object.address != null)
                        message.address = String(object.address);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAddressPositionsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.QueryAddressPositionsRequest} message QueryAddressPositionsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAddressPositionsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.address = "";
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = message.address;
                    return object;
                };
    
                /**
                 * Converts this QueryAddressPositionsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAddressPositionsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAddressPositionsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAddressPositionsRequest;
            })();
    
            derivatives.QueryAddressPositionsResponse = (function() {
    
                /**
                 * Properties of a QueryAddressPositionsResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAddressPositionsResponse
                 * @property {Array.<ununifi.derivatives.IQueriedPosition>|null} [positions] QueryAddressPositionsResponse positions
                 */
    
                /**
                 * Constructs a new QueryAddressPositionsResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAddressPositionsResponse.
                 * @implements IQueryAddressPositionsResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAddressPositionsResponse=} [properties] Properties to set
                 */
                function QueryAddressPositionsResponse(properties) {
                    this.positions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAddressPositionsResponse positions.
                 * @member {Array.<ununifi.derivatives.IQueriedPosition>} positions
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @instance
                 */
                QueryAddressPositionsResponse.prototype.positions = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryAddressPositionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAddressPositionsResponse} message QueryAddressPositionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAddressPositionsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.positions != null && message.positions.length)
                        for (var i = 0; i < message.positions.length; ++i)
                            $root.ununifi.derivatives.QueriedPosition.encode(message.positions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAddressPositionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAddressPositionsResponse} message QueryAddressPositionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAddressPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAddressPositionsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAddressPositionsResponse} QueryAddressPositionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAddressPositionsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAddressPositionsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.positions && message.positions.length))
                                message.positions = [];
                            message.positions.push($root.ununifi.derivatives.QueriedPosition.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAddressPositionsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAddressPositionsResponse} QueryAddressPositionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAddressPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAddressPositionsResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAddressPositionsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.positions != null && message.hasOwnProperty("positions")) {
                        if (!Array.isArray(message.positions))
                            return "positions: array expected";
                        for (var i = 0; i < message.positions.length; ++i) {
                            var error = $root.ununifi.derivatives.QueriedPosition.verify(message.positions[i]);
                            if (error)
                                return "positions." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAddressPositionsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAddressPositionsResponse} QueryAddressPositionsResponse
                 */
                QueryAddressPositionsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAddressPositionsResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAddressPositionsResponse();
                    if (object.positions) {
                        if (!Array.isArray(object.positions))
                            throw TypeError(".ununifi.derivatives.QueryAddressPositionsResponse.positions: array expected");
                        message.positions = [];
                        for (var i = 0; i < object.positions.length; ++i) {
                            if (typeof object.positions[i] !== "object")
                                throw TypeError(".ununifi.derivatives.QueryAddressPositionsResponse.positions: object expected");
                            message.positions[i] = $root.ununifi.derivatives.QueriedPosition.fromObject(object.positions[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAddressPositionsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.QueryAddressPositionsResponse} message QueryAddressPositionsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAddressPositionsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.positions = [];
                    if (message.positions && message.positions.length) {
                        object.positions = [];
                        for (var j = 0; j < message.positions.length; ++j)
                            object.positions[j] = $root.ununifi.derivatives.QueriedPosition.toObject(message.positions[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryAddressPositionsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAddressPositionsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAddressPositionsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAddressPositionsResponse;
            })();
    
            derivatives.QueryAllPendingPaymentPositionsRequest = (function() {
    
                /**
                 * Properties of a QueryAllPendingPaymentPositionsRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAllPendingPaymentPositionsRequest
                 */
    
                /**
                 * Constructs a new QueryAllPendingPaymentPositionsRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAllPendingPaymentPositionsRequest.
                 * @implements IQueryAllPendingPaymentPositionsRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest=} [properties] Properties to set
                 */
                function QueryAllPendingPaymentPositionsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryAllPendingPaymentPositionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} message QueryAllPendingPaymentPositionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPendingPaymentPositionsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllPendingPaymentPositionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} message QueryAllPendingPaymentPositionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPendingPaymentPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllPendingPaymentPositionsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} QueryAllPendingPaymentPositionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPendingPaymentPositionsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllPendingPaymentPositionsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} QueryAllPendingPaymentPositionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPendingPaymentPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllPendingPaymentPositionsRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllPendingPaymentPositionsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryAllPendingPaymentPositionsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} QueryAllPendingPaymentPositionsRequest
                 */
                QueryAllPendingPaymentPositionsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest)
                        return object;
                    return new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryAllPendingPaymentPositionsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @static
                 * @param {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} message QueryAllPendingPaymentPositionsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllPendingPaymentPositionsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryAllPendingPaymentPositionsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllPendingPaymentPositionsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllPendingPaymentPositionsRequest;
            })();
    
            derivatives.QueryAllPendingPaymentPositionsResponse = (function() {
    
                /**
                 * Properties of a QueryAllPendingPaymentPositionsResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAllPendingPaymentPositionsResponse
                 * @property {Array.<ununifi.derivatives.IPendingPaymentPosition>|null} [pending_payment_positions] QueryAllPendingPaymentPositionsResponse pending_payment_positions
                 */
    
                /**
                 * Constructs a new QueryAllPendingPaymentPositionsResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAllPendingPaymentPositionsResponse.
                 * @implements IQueryAllPendingPaymentPositionsResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsResponse=} [properties] Properties to set
                 */
                function QueryAllPendingPaymentPositionsResponse(properties) {
                    this.pending_payment_positions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllPendingPaymentPositionsResponse pending_payment_positions.
                 * @member {Array.<ununifi.derivatives.IPendingPaymentPosition>} pending_payment_positions
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @instance
                 */
                QueryAllPendingPaymentPositionsResponse.prototype.pending_payment_positions = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryAllPendingPaymentPositionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsResponse} message QueryAllPendingPaymentPositionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPendingPaymentPositionsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pending_payment_positions != null && message.pending_payment_positions.length)
                        for (var i = 0; i < message.pending_payment_positions.length; ++i)
                            $root.ununifi.derivatives.PendingPaymentPosition.encode(message.pending_payment_positions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllPendingPaymentPositionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsResponse} message QueryAllPendingPaymentPositionsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPendingPaymentPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllPendingPaymentPositionsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} QueryAllPendingPaymentPositionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPendingPaymentPositionsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.pending_payment_positions && message.pending_payment_positions.length))
                                message.pending_payment_positions = [];
                            message.pending_payment_positions.push($root.ununifi.derivatives.PendingPaymentPosition.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllPendingPaymentPositionsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} QueryAllPendingPaymentPositionsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPendingPaymentPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllPendingPaymentPositionsResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllPendingPaymentPositionsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pending_payment_positions != null && message.hasOwnProperty("pending_payment_positions")) {
                        if (!Array.isArray(message.pending_payment_positions))
                            return "pending_payment_positions: array expected";
                        for (var i = 0; i < message.pending_payment_positions.length; ++i) {
                            var error = $root.ununifi.derivatives.PendingPaymentPosition.verify(message.pending_payment_positions[i]);
                            if (error)
                                return "pending_payment_positions." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllPendingPaymentPositionsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} QueryAllPendingPaymentPositionsResponse
                 */
                QueryAllPendingPaymentPositionsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse();
                    if (object.pending_payment_positions) {
                        if (!Array.isArray(object.pending_payment_positions))
                            throw TypeError(".ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.pending_payment_positions: array expected");
                        message.pending_payment_positions = [];
                        for (var i = 0; i < object.pending_payment_positions.length; ++i) {
                            if (typeof object.pending_payment_positions[i] !== "object")
                                throw TypeError(".ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.pending_payment_positions: object expected");
                            message.pending_payment_positions[i] = $root.ununifi.derivatives.PendingPaymentPosition.fromObject(object.pending_payment_positions[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllPendingPaymentPositionsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @static
                 * @param {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} message QueryAllPendingPaymentPositionsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllPendingPaymentPositionsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.pending_payment_positions = [];
                    if (message.pending_payment_positions && message.pending_payment_positions.length) {
                        object.pending_payment_positions = [];
                        for (var j = 0; j < message.pending_payment_positions.length; ++j)
                            object.pending_payment_positions[j] = $root.ununifi.derivatives.PendingPaymentPosition.toObject(message.pending_payment_positions[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryAllPendingPaymentPositionsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllPendingPaymentPositionsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllPendingPaymentPositionsResponse;
            })();
    
            derivatives.QueryPendingPaymentPositionRequest = (function() {
    
                /**
                 * Properties of a QueryPendingPaymentPositionRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPendingPaymentPositionRequest
                 * @property {string|null} [position_id] QueryPendingPaymentPositionRequest position_id
                 */
    
                /**
                 * Constructs a new QueryPendingPaymentPositionRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPendingPaymentPositionRequest.
                 * @implements IQueryPendingPaymentPositionRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest=} [properties] Properties to set
                 */
                function QueryPendingPaymentPositionRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPendingPaymentPositionRequest position_id.
                 * @member {string} position_id
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @instance
                 */
                QueryPendingPaymentPositionRequest.prototype.position_id = "";
    
                /**
                 * Encodes the specified QueryPendingPaymentPositionRequest message. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} message QueryPendingPaymentPositionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPendingPaymentPositionRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position_id != null && Object.hasOwnProperty.call(message, "position_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.position_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPendingPaymentPositionRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} message QueryPendingPaymentPositionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPendingPaymentPositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPendingPaymentPositionRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPendingPaymentPositionRequest} QueryPendingPaymentPositionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPendingPaymentPositionRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPendingPaymentPositionRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPendingPaymentPositionRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPendingPaymentPositionRequest} QueryPendingPaymentPositionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPendingPaymentPositionRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPendingPaymentPositionRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPendingPaymentPositionRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        if (!$util.isString(message.position_id))
                            return "position_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryPendingPaymentPositionRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPendingPaymentPositionRequest} QueryPendingPaymentPositionRequest
                 */
                QueryPendingPaymentPositionRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPendingPaymentPositionRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPendingPaymentPositionRequest();
                    if (object.position_id != null)
                        message.position_id = String(object.position_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPendingPaymentPositionRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @static
                 * @param {ununifi.derivatives.QueryPendingPaymentPositionRequest} message QueryPendingPaymentPositionRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPendingPaymentPositionRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.position_id = "";
                    if (message.position_id != null && message.hasOwnProperty("position_id"))
                        object.position_id = message.position_id;
                    return object;
                };
    
                /**
                 * Converts this QueryPendingPaymentPositionRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPendingPaymentPositionRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPendingPaymentPositionRequest;
            })();
    
            derivatives.QueryPendingPaymentPositionResponse = (function() {
    
                /**
                 * Properties of a QueryPendingPaymentPositionResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryPendingPaymentPositionResponse
                 * @property {ununifi.derivatives.IPendingPaymentPosition|null} [pending_payment_position] QueryPendingPaymentPositionResponse pending_payment_position
                 */
    
                /**
                 * Constructs a new QueryPendingPaymentPositionResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryPendingPaymentPositionResponse.
                 * @implements IQueryPendingPaymentPositionResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionResponse=} [properties] Properties to set
                 */
                function QueryPendingPaymentPositionResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryPendingPaymentPositionResponse pending_payment_position.
                 * @member {ununifi.derivatives.IPendingPaymentPosition|null|undefined} pending_payment_position
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @instance
                 */
                QueryPendingPaymentPositionResponse.prototype.pending_payment_position = null;
    
                /**
                 * Encodes the specified QueryPendingPaymentPositionResponse message. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionResponse} message QueryPendingPaymentPositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPendingPaymentPositionResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pending_payment_position != null && Object.hasOwnProperty.call(message, "pending_payment_position"))
                        $root.ununifi.derivatives.PendingPaymentPosition.encode(message.pending_payment_position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryPendingPaymentPositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryPendingPaymentPositionResponse} message QueryPendingPaymentPositionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryPendingPaymentPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryPendingPaymentPositionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryPendingPaymentPositionResponse} QueryPendingPaymentPositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPendingPaymentPositionResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryPendingPaymentPositionResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pending_payment_position = $root.ununifi.derivatives.PendingPaymentPosition.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryPendingPaymentPositionResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryPendingPaymentPositionResponse} QueryPendingPaymentPositionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryPendingPaymentPositionResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryPendingPaymentPositionResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryPendingPaymentPositionResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pending_payment_position != null && message.hasOwnProperty("pending_payment_position")) {
                        var error = $root.ununifi.derivatives.PendingPaymentPosition.verify(message.pending_payment_position);
                        if (error)
                            return "pending_payment_position." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryPendingPaymentPositionResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryPendingPaymentPositionResponse} QueryPendingPaymentPositionResponse
                 */
                QueryPendingPaymentPositionResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryPendingPaymentPositionResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryPendingPaymentPositionResponse();
                    if (object.pending_payment_position != null) {
                        if (typeof object.pending_payment_position !== "object")
                            throw TypeError(".ununifi.derivatives.QueryPendingPaymentPositionResponse.pending_payment_position: object expected");
                        message.pending_payment_position = $root.ununifi.derivatives.PendingPaymentPosition.fromObject(object.pending_payment_position);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryPendingPaymentPositionResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @static
                 * @param {ununifi.derivatives.QueryPendingPaymentPositionResponse} message QueryPendingPaymentPositionResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryPendingPaymentPositionResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pending_payment_position = null;
                    if (message.pending_payment_position != null && message.hasOwnProperty("pending_payment_position"))
                        object.pending_payment_position = $root.ununifi.derivatives.PendingPaymentPosition.toObject(message.pending_payment_position, options);
                    return object;
                };
    
                /**
                 * Converts this QueryPendingPaymentPositionResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryPendingPaymentPositionResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryPendingPaymentPositionResponse;
            })();
    
            derivatives.QueryDLPTokenRateRequest = (function() {
    
                /**
                 * Properties of a QueryDLPTokenRateRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryDLPTokenRateRequest
                 */
    
                /**
                 * Constructs a new QueryDLPTokenRateRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryDLPTokenRateRequest.
                 * @implements IQueryDLPTokenRateRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryDLPTokenRateRequest=} [properties] Properties to set
                 */
                function QueryDLPTokenRateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryDLPTokenRateRequest message. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} message QueryDLPTokenRateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryDLPTokenRateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryDLPTokenRateRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} message QueryDLPTokenRateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryDLPTokenRateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryDLPTokenRateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryDLPTokenRateRequest} QueryDLPTokenRateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryDLPTokenRateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryDLPTokenRateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryDLPTokenRateRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryDLPTokenRateRequest} QueryDLPTokenRateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryDLPTokenRateRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryDLPTokenRateRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryDLPTokenRateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryDLPTokenRateRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryDLPTokenRateRequest} QueryDLPTokenRateRequest
                 */
                QueryDLPTokenRateRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryDLPTokenRateRequest)
                        return object;
                    return new $root.ununifi.derivatives.QueryDLPTokenRateRequest();
                };
    
                /**
                 * Creates a plain object from a QueryDLPTokenRateRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @static
                 * @param {ununifi.derivatives.QueryDLPTokenRateRequest} message QueryDLPTokenRateRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryDLPTokenRateRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryDLPTokenRateRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryDLPTokenRateRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryDLPTokenRateRequest;
            })();
    
            derivatives.QueryDLPTokenRateResponse = (function() {
    
                /**
                 * Properties of a QueryDLPTokenRateResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryDLPTokenRateResponse
                 * @property {string|null} [symbol] QueryDLPTokenRateResponse symbol
                 * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rates] QueryDLPTokenRateResponse rates
                 */
    
                /**
                 * Constructs a new QueryDLPTokenRateResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryDLPTokenRateResponse.
                 * @implements IQueryDLPTokenRateResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryDLPTokenRateResponse=} [properties] Properties to set
                 */
                function QueryDLPTokenRateResponse(properties) {
                    this.rates = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryDLPTokenRateResponse symbol.
                 * @member {string} symbol
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @instance
                 */
                QueryDLPTokenRateResponse.prototype.symbol = "";
    
                /**
                 * QueryDLPTokenRateResponse rates.
                 * @member {Array.<cosmos.base.v1beta1.ICoin>} rates
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @instance
                 */
                QueryDLPTokenRateResponse.prototype.rates = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryDLPTokenRateResponse message. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryDLPTokenRateResponse} message QueryDLPTokenRateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryDLPTokenRateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol);
                    if (message.rates != null && message.rates.length)
                        for (var i = 0; i < message.rates.length; ++i)
                            $root.cosmos.base.v1beta1.Coin.encode(message.rates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryDLPTokenRateResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryDLPTokenRateResponse} message QueryDLPTokenRateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryDLPTokenRateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryDLPTokenRateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryDLPTokenRateResponse} QueryDLPTokenRateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryDLPTokenRateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryDLPTokenRateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.symbol = reader.string();
                            break;
                        case 2:
                            if (!(message.rates && message.rates.length))
                                message.rates = [];
                            message.rates.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryDLPTokenRateResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryDLPTokenRateResponse} QueryDLPTokenRateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryDLPTokenRateResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryDLPTokenRateResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryDLPTokenRateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        if (!$util.isString(message.symbol))
                            return "symbol: string expected";
                    if (message.rates != null && message.hasOwnProperty("rates")) {
                        if (!Array.isArray(message.rates))
                            return "rates: array expected";
                        for (var i = 0; i < message.rates.length; ++i) {
                            var error = $root.cosmos.base.v1beta1.Coin.verify(message.rates[i]);
                            if (error)
                                return "rates." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryDLPTokenRateResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryDLPTokenRateResponse} QueryDLPTokenRateResponse
                 */
                QueryDLPTokenRateResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryDLPTokenRateResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryDLPTokenRateResponse();
                    if (object.symbol != null)
                        message.symbol = String(object.symbol);
                    if (object.rates) {
                        if (!Array.isArray(object.rates))
                            throw TypeError(".ununifi.derivatives.QueryDLPTokenRateResponse.rates: array expected");
                        message.rates = [];
                        for (var i = 0; i < object.rates.length; ++i) {
                            if (typeof object.rates[i] !== "object")
                                throw TypeError(".ununifi.derivatives.QueryDLPTokenRateResponse.rates: object expected");
                            message.rates[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rates[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryDLPTokenRateResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @static
                 * @param {ununifi.derivatives.QueryDLPTokenRateResponse} message QueryDLPTokenRateResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryDLPTokenRateResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rates = [];
                    if (options.defaults)
                        object.symbol = "";
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        object.symbol = message.symbol;
                    if (message.rates && message.rates.length) {
                        object.rates = [];
                        for (var j = 0; j < message.rates.length; ++j)
                            object.rates[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rates[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryDLPTokenRateResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryDLPTokenRateResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryDLPTokenRateResponse;
            })();
    
            derivatives.QueryEstimateDLPTokenAmountRequest = (function() {
    
                /**
                 * Properties of a QueryEstimateDLPTokenAmountRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryEstimateDLPTokenAmountRequest
                 * @property {string|null} [mint_denom] QueryEstimateDLPTokenAmountRequest mint_denom
                 * @property {string|null} [amount] QueryEstimateDLPTokenAmountRequest amount
                 */
    
                /**
                 * Constructs a new QueryEstimateDLPTokenAmountRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryEstimateDLPTokenAmountRequest.
                 * @implements IQueryEstimateDLPTokenAmountRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest=} [properties] Properties to set
                 */
                function QueryEstimateDLPTokenAmountRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateDLPTokenAmountRequest mint_denom.
                 * @member {string} mint_denom
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @instance
                 */
                QueryEstimateDLPTokenAmountRequest.prototype.mint_denom = "";
    
                /**
                 * QueryEstimateDLPTokenAmountRequest amount.
                 * @member {string} amount
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @instance
                 */
                QueryEstimateDLPTokenAmountRequest.prototype.amount = "";
    
                /**
                 * Encodes the specified QueryEstimateDLPTokenAmountRequest message. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} message QueryEstimateDLPTokenAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateDLPTokenAmountRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mint_denom != null && Object.hasOwnProperty.call(message, "mint_denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.mint_denom);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateDLPTokenAmountRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} message QueryEstimateDLPTokenAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateDLPTokenAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateDLPTokenAmountRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} QueryEstimateDLPTokenAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateDLPTokenAmountRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mint_denom = reader.string();
                            break;
                        case 2:
                            message.amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateDLPTokenAmountRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} QueryEstimateDLPTokenAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateDLPTokenAmountRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateDLPTokenAmountRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateDLPTokenAmountRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mint_denom != null && message.hasOwnProperty("mint_denom"))
                        if (!$util.isString(message.mint_denom))
                            return "mint_denom: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        if (!$util.isString(message.amount))
                            return "amount: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateDLPTokenAmountRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} QueryEstimateDLPTokenAmountRequest
                 */
                QueryEstimateDLPTokenAmountRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest();
                    if (object.mint_denom != null)
                        message.mint_denom = String(object.mint_denom);
                    if (object.amount != null)
                        message.amount = String(object.amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateDLPTokenAmountRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @static
                 * @param {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} message QueryEstimateDLPTokenAmountRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateDLPTokenAmountRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mint_denom = "";
                        object.amount = "";
                    }
                    if (message.mint_denom != null && message.hasOwnProperty("mint_denom"))
                        object.mint_denom = message.mint_denom;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = message.amount;
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateDLPTokenAmountRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateDLPTokenAmountRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateDLPTokenAmountRequest;
            })();
    
            derivatives.QueryEstimateDLPTokenAmountResponse = (function() {
    
                /**
                 * Properties of a QueryEstimateDLPTokenAmountResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryEstimateDLPTokenAmountResponse
                 * @property {cosmos.base.v1beta1.ICoin|null} [estimated_dlp_amount] QueryEstimateDLPTokenAmountResponse estimated_dlp_amount
                 * @property {cosmos.base.v1beta1.ICoin|null} [deposit_fee] QueryEstimateDLPTokenAmountResponse deposit_fee
                 */
    
                /**
                 * Constructs a new QueryEstimateDLPTokenAmountResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryEstimateDLPTokenAmountResponse.
                 * @implements IQueryEstimateDLPTokenAmountResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountResponse=} [properties] Properties to set
                 */
                function QueryEstimateDLPTokenAmountResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateDLPTokenAmountResponse estimated_dlp_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} estimated_dlp_amount
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @instance
                 */
                QueryEstimateDLPTokenAmountResponse.prototype.estimated_dlp_amount = null;
    
                /**
                 * QueryEstimateDLPTokenAmountResponse deposit_fee.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit_fee
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @instance
                 */
                QueryEstimateDLPTokenAmountResponse.prototype.deposit_fee = null;
    
                /**
                 * Encodes the specified QueryEstimateDLPTokenAmountResponse message. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountResponse} message QueryEstimateDLPTokenAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateDLPTokenAmountResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.estimated_dlp_amount != null && Object.hasOwnProperty.call(message, "estimated_dlp_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.estimated_dlp_amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.deposit_fee != null && Object.hasOwnProperty.call(message, "deposit_fee"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.deposit_fee, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateDLPTokenAmountResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountResponse} message QueryEstimateDLPTokenAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateDLPTokenAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateDLPTokenAmountResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} QueryEstimateDLPTokenAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateDLPTokenAmountResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.estimated_dlp_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.deposit_fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateDLPTokenAmountResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} QueryEstimateDLPTokenAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateDLPTokenAmountResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateDLPTokenAmountResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateDLPTokenAmountResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.estimated_dlp_amount != null && message.hasOwnProperty("estimated_dlp_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.estimated_dlp_amount);
                        if (error)
                            return "estimated_dlp_amount." + error;
                    }
                    if (message.deposit_fee != null && message.hasOwnProperty("deposit_fee")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit_fee);
                        if (error)
                            return "deposit_fee." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateDLPTokenAmountResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} QueryEstimateDLPTokenAmountResponse
                 */
                QueryEstimateDLPTokenAmountResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse();
                    if (object.estimated_dlp_amount != null) {
                        if (typeof object.estimated_dlp_amount !== "object")
                            throw TypeError(".ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.estimated_dlp_amount: object expected");
                        message.estimated_dlp_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.estimated_dlp_amount);
                    }
                    if (object.deposit_fee != null) {
                        if (typeof object.deposit_fee !== "object")
                            throw TypeError(".ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.deposit_fee: object expected");
                        message.deposit_fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit_fee);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateDLPTokenAmountResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @static
                 * @param {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} message QueryEstimateDLPTokenAmountResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateDLPTokenAmountResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.estimated_dlp_amount = null;
                        object.deposit_fee = null;
                    }
                    if (message.estimated_dlp_amount != null && message.hasOwnProperty("estimated_dlp_amount"))
                        object.estimated_dlp_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.estimated_dlp_amount, options);
                    if (message.deposit_fee != null && message.hasOwnProperty("deposit_fee"))
                        object.deposit_fee = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit_fee, options);
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateDLPTokenAmountResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateDLPTokenAmountResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateDLPTokenAmountResponse;
            })();
    
            derivatives.QueryEstimateRedeemTokenAmountRequest = (function() {
    
                /**
                 * Properties of a QueryEstimateRedeemTokenAmountRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryEstimateRedeemTokenAmountRequest
                 * @property {string|null} [redeem_denom] QueryEstimateRedeemTokenAmountRequest redeem_denom
                 * @property {string|null} [lpt_amount] QueryEstimateRedeemTokenAmountRequest lpt_amount
                 */
    
                /**
                 * Constructs a new QueryEstimateRedeemTokenAmountRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryEstimateRedeemTokenAmountRequest.
                 * @implements IQueryEstimateRedeemTokenAmountRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest=} [properties] Properties to set
                 */
                function QueryEstimateRedeemTokenAmountRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateRedeemTokenAmountRequest redeem_denom.
                 * @member {string} redeem_denom
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @instance
                 */
                QueryEstimateRedeemTokenAmountRequest.prototype.redeem_denom = "";
    
                /**
                 * QueryEstimateRedeemTokenAmountRequest lpt_amount.
                 * @member {string} lpt_amount
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @instance
                 */
                QueryEstimateRedeemTokenAmountRequest.prototype.lpt_amount = "";
    
                /**
                 * Encodes the specified QueryEstimateRedeemTokenAmountRequest message. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} message QueryEstimateRedeemTokenAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemTokenAmountRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.redeem_denom != null && Object.hasOwnProperty.call(message, "redeem_denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.redeem_denom);
                    if (message.lpt_amount != null && Object.hasOwnProperty.call(message, "lpt_amount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.lpt_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateRedeemTokenAmountRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} message QueryEstimateRedeemTokenAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemTokenAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateRedeemTokenAmountRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} QueryEstimateRedeemTokenAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemTokenAmountRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.redeem_denom = reader.string();
                            break;
                        case 2:
                            message.lpt_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateRedeemTokenAmountRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} QueryEstimateRedeemTokenAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemTokenAmountRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateRedeemTokenAmountRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateRedeemTokenAmountRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.redeem_denom != null && message.hasOwnProperty("redeem_denom"))
                        if (!$util.isString(message.redeem_denom))
                            return "redeem_denom: string expected";
                    if (message.lpt_amount != null && message.hasOwnProperty("lpt_amount"))
                        if (!$util.isString(message.lpt_amount))
                            return "lpt_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateRedeemTokenAmountRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} QueryEstimateRedeemTokenAmountRequest
                 */
                QueryEstimateRedeemTokenAmountRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest();
                    if (object.redeem_denom != null)
                        message.redeem_denom = String(object.redeem_denom);
                    if (object.lpt_amount != null)
                        message.lpt_amount = String(object.lpt_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateRedeemTokenAmountRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @static
                 * @param {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} message QueryEstimateRedeemTokenAmountRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateRedeemTokenAmountRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.redeem_denom = "";
                        object.lpt_amount = "";
                    }
                    if (message.redeem_denom != null && message.hasOwnProperty("redeem_denom"))
                        object.redeem_denom = message.redeem_denom;
                    if (message.lpt_amount != null && message.hasOwnProperty("lpt_amount"))
                        object.lpt_amount = message.lpt_amount;
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateRedeemTokenAmountRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateRedeemTokenAmountRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateRedeemTokenAmountRequest;
            })();
    
            derivatives.QueryEstimateRedeemTokenAmountResponse = (function() {
    
                /**
                 * Properties of a QueryEstimateRedeemTokenAmountResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryEstimateRedeemTokenAmountResponse
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] QueryEstimateRedeemTokenAmountResponse amount
                 * @property {cosmos.base.v1beta1.ICoin|null} [fee] QueryEstimateRedeemTokenAmountResponse fee
                 */
    
                /**
                 * Constructs a new QueryEstimateRedeemTokenAmountResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryEstimateRedeemTokenAmountResponse.
                 * @implements IQueryEstimateRedeemTokenAmountResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountResponse=} [properties] Properties to set
                 */
                function QueryEstimateRedeemTokenAmountResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateRedeemTokenAmountResponse amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @instance
                 */
                QueryEstimateRedeemTokenAmountResponse.prototype.amount = null;
    
                /**
                 * QueryEstimateRedeemTokenAmountResponse fee.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @instance
                 */
                QueryEstimateRedeemTokenAmountResponse.prototype.fee = null;
    
                /**
                 * Encodes the specified QueryEstimateRedeemTokenAmountResponse message. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountResponse} message QueryEstimateRedeemTokenAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemTokenAmountResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateRedeemTokenAmountResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountResponse} message QueryEstimateRedeemTokenAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemTokenAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateRedeemTokenAmountResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} QueryEstimateRedeemTokenAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemTokenAmountResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateRedeemTokenAmountResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} QueryEstimateRedeemTokenAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemTokenAmountResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateRedeemTokenAmountResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateRedeemTokenAmountResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.fee != null && message.hasOwnProperty("fee")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
                        if (error)
                            return "fee." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateRedeemTokenAmountResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} QueryEstimateRedeemTokenAmountResponse
                 */
                QueryEstimateRedeemTokenAmountResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse();
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    if (object.fee != null) {
                        if (typeof object.fee !== "object")
                            throw TypeError(".ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.fee: object expected");
                        message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateRedeemTokenAmountResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @static
                 * @param {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} message QueryEstimateRedeemTokenAmountResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateRedeemTokenAmountResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.amount = null;
                        object.fee = null;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    if (message.fee != null && message.hasOwnProperty("fee"))
                        object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateRedeemTokenAmountResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateRedeemTokenAmountResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateRedeemTokenAmountResponse;
            })();
    
            derivatives.QueryAvailableAssetInPoolByDenomRequest = (function() {
    
                /**
                 * Properties of a QueryAvailableAssetInPoolByDenomRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAvailableAssetInPoolByDenomRequest
                 * @property {string|null} [denom] QueryAvailableAssetInPoolByDenomRequest denom
                 */
    
                /**
                 * Constructs a new QueryAvailableAssetInPoolByDenomRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAvailableAssetInPoolByDenomRequest.
                 * @implements IQueryAvailableAssetInPoolByDenomRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomRequest=} [properties] Properties to set
                 */
                function QueryAvailableAssetInPoolByDenomRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAvailableAssetInPoolByDenomRequest denom.
                 * @member {string} denom
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @instance
                 */
                QueryAvailableAssetInPoolByDenomRequest.prototype.denom = "";
    
                /**
                 * Encodes the specified QueryAvailableAssetInPoolByDenomRequest message. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomRequest} message QueryAvailableAssetInPoolByDenomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetInPoolByDenomRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAvailableAssetInPoolByDenomRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomRequest} message QueryAvailableAssetInPoolByDenomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetInPoolByDenomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAvailableAssetInPoolByDenomRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest} QueryAvailableAssetInPoolByDenomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetInPoolByDenomRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.denom = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAvailableAssetInPoolByDenomRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest} QueryAvailableAssetInPoolByDenomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetInPoolByDenomRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAvailableAssetInPoolByDenomRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAvailableAssetInPoolByDenomRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryAvailableAssetInPoolByDenomRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest} QueryAvailableAssetInPoolByDenomRequest
                 */
                QueryAvailableAssetInPoolByDenomRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest();
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAvailableAssetInPoolByDenomRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @static
                 * @param {ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest} message QueryAvailableAssetInPoolByDenomRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAvailableAssetInPoolByDenomRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.denom = "";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    return object;
                };
    
                /**
                 * Converts this QueryAvailableAssetInPoolByDenomRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAvailableAssetInPoolByDenomRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAvailableAssetInPoolByDenomRequest;
            })();
    
            derivatives.QueryAvailableAssetInPoolByDenomResponse = (function() {
    
                /**
                 * Properties of a QueryAvailableAssetInPoolByDenomResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAvailableAssetInPoolByDenomResponse
                 * @property {cosmos.base.v1beta1.ICoin|null} [available_asset] QueryAvailableAssetInPoolByDenomResponse available_asset
                 */
    
                /**
                 * Constructs a new QueryAvailableAssetInPoolByDenomResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAvailableAssetInPoolByDenomResponse.
                 * @implements IQueryAvailableAssetInPoolByDenomResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomResponse=} [properties] Properties to set
                 */
                function QueryAvailableAssetInPoolByDenomResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAvailableAssetInPoolByDenomResponse available_asset.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} available_asset
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @instance
                 */
                QueryAvailableAssetInPoolByDenomResponse.prototype.available_asset = null;
    
                /**
                 * Encodes the specified QueryAvailableAssetInPoolByDenomResponse message. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomResponse} message QueryAvailableAssetInPoolByDenomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetInPoolByDenomResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.available_asset != null && Object.hasOwnProperty.call(message, "available_asset"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.available_asset, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAvailableAssetInPoolByDenomResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetInPoolByDenomResponse} message QueryAvailableAssetInPoolByDenomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetInPoolByDenomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAvailableAssetInPoolByDenomResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse} QueryAvailableAssetInPoolByDenomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetInPoolByDenomResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.available_asset = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAvailableAssetInPoolByDenomResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse} QueryAvailableAssetInPoolByDenomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetInPoolByDenomResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAvailableAssetInPoolByDenomResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAvailableAssetInPoolByDenomResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.available_asset != null && message.hasOwnProperty("available_asset")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.available_asset);
                        if (error)
                            return "available_asset." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAvailableAssetInPoolByDenomResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse} QueryAvailableAssetInPoolByDenomResponse
                 */
                QueryAvailableAssetInPoolByDenomResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse();
                    if (object.available_asset != null) {
                        if (typeof object.available_asset !== "object")
                            throw TypeError(".ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse.available_asset: object expected");
                        message.available_asset = $root.cosmos.base.v1beta1.Coin.fromObject(object.available_asset);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAvailableAssetInPoolByDenomResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @static
                 * @param {ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse} message QueryAvailableAssetInPoolByDenomResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAvailableAssetInPoolByDenomResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.available_asset = null;
                    if (message.available_asset != null && message.hasOwnProperty("available_asset"))
                        object.available_asset = $root.cosmos.base.v1beta1.Coin.toObject(message.available_asset, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAvailableAssetInPoolByDenomResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAvailableAssetInPoolByDenomResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAvailableAssetInPoolByDenomResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAvailableAssetInPoolByDenomResponse;
            })();
    
            derivatives.QueryAvailableAssetsInPoolRequest = (function() {
    
                /**
                 * Properties of a QueryAvailableAssetsInPoolRequest.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAvailableAssetsInPoolRequest
                 */
    
                /**
                 * Constructs a new QueryAvailableAssetsInPoolRequest.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAvailableAssetsInPoolRequest.
                 * @implements IQueryAvailableAssetsInPoolRequest
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest=} [properties] Properties to set
                 */
                function QueryAvailableAssetsInPoolRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryAvailableAssetsInPoolRequest message. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} message QueryAvailableAssetsInPoolRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetsInPoolRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAvailableAssetsInPoolRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} message QueryAvailableAssetsInPoolRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetsInPoolRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAvailableAssetsInPoolRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} QueryAvailableAssetsInPoolRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetsInPoolRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAvailableAssetsInPoolRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} QueryAvailableAssetsInPoolRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetsInPoolRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAvailableAssetsInPoolRequest message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAvailableAssetsInPoolRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryAvailableAssetsInPoolRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} QueryAvailableAssetsInPoolRequest
                 */
                QueryAvailableAssetsInPoolRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest)
                        return object;
                    return new $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest();
                };
    
                /**
                 * Creates a plain object from a QueryAvailableAssetsInPoolRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @static
                 * @param {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} message QueryAvailableAssetsInPoolRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAvailableAssetsInPoolRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryAvailableAssetsInPoolRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAvailableAssetsInPoolRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAvailableAssetsInPoolRequest;
            })();
    
            derivatives.QueryAvailableAssetsInPoolResponse = (function() {
    
                /**
                 * Properties of a QueryAvailableAssetsInPoolResponse.
                 * @memberof ununifi.derivatives
                 * @interface IQueryAvailableAssetsInPoolResponse
                 * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [available_assets] QueryAvailableAssetsInPoolResponse available_assets
                 */
    
                /**
                 * Constructs a new QueryAvailableAssetsInPoolResponse.
                 * @memberof ununifi.derivatives
                 * @classdesc Represents a QueryAvailableAssetsInPoolResponse.
                 * @implements IQueryAvailableAssetsInPoolResponse
                 * @constructor
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolResponse=} [properties] Properties to set
                 */
                function QueryAvailableAssetsInPoolResponse(properties) {
                    this.available_assets = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAvailableAssetsInPoolResponse available_assets.
                 * @member {Array.<cosmos.base.v1beta1.ICoin>} available_assets
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @instance
                 */
                QueryAvailableAssetsInPoolResponse.prototype.available_assets = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryAvailableAssetsInPoolResponse message. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolResponse} message QueryAvailableAssetsInPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetsInPoolResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.available_assets != null && message.available_assets.length)
                        for (var i = 0; i < message.available_assets.length; ++i)
                            $root.cosmos.base.v1beta1.Coin.encode(message.available_assets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAvailableAssetsInPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @static
                 * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolResponse} message QueryAvailableAssetsInPoolResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAvailableAssetsInPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAvailableAssetsInPoolResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} QueryAvailableAssetsInPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetsInPoolResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.available_assets && message.available_assets.length))
                                message.available_assets = [];
                            message.available_assets.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAvailableAssetsInPoolResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} QueryAvailableAssetsInPoolResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAvailableAssetsInPoolResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAvailableAssetsInPoolResponse message.
                 * @function verify
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAvailableAssetsInPoolResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.available_assets != null && message.hasOwnProperty("available_assets")) {
                        if (!Array.isArray(message.available_assets))
                            return "available_assets: array expected";
                        for (var i = 0; i < message.available_assets.length; ++i) {
                            var error = $root.cosmos.base.v1beta1.Coin.verify(message.available_assets[i]);
                            if (error)
                                return "available_assets." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAvailableAssetsInPoolResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} QueryAvailableAssetsInPoolResponse
                 */
                QueryAvailableAssetsInPoolResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse)
                        return object;
                    var message = new $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse();
                    if (object.available_assets) {
                        if (!Array.isArray(object.available_assets))
                            throw TypeError(".ununifi.derivatives.QueryAvailableAssetsInPoolResponse.available_assets: array expected");
                        message.available_assets = [];
                        for (var i = 0; i < object.available_assets.length; ++i) {
                            if (typeof object.available_assets[i] !== "object")
                                throw TypeError(".ununifi.derivatives.QueryAvailableAssetsInPoolResponse.available_assets: object expected");
                            message.available_assets[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.available_assets[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAvailableAssetsInPoolResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @static
                 * @param {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} message QueryAvailableAssetsInPoolResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAvailableAssetsInPoolResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.available_assets = [];
                    if (message.available_assets && message.available_assets.length) {
                        object.available_assets = [];
                        for (var j = 0; j < message.available_assets.length; ++j)
                            object.available_assets[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.available_assets[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryAvailableAssetsInPoolResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAvailableAssetsInPoolResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAvailableAssetsInPoolResponse;
            })();
    
            return derivatives;
        })();
    
        ununifi.ecosystemincentive = (function() {
    
            /**
             * Namespace ecosystemincentive.
             * @memberof ununifi
             * @namespace
             */
            var ecosystemincentive = {};
    
            ecosystemincentive.FrontendMetadata = (function() {
    
                /**
                 * Properties of a FrontendMetadata.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IFrontendMetadata
                 * @property {number|null} [version] FrontendMetadata version
                 * @property {string|null} [recipient] FrontendMetadata recipient
                 */
    
                /**
                 * Constructs a new FrontendMetadata.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a FrontendMetadata.
                 * @implements IFrontendMetadata
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IFrontendMetadata=} [properties] Properties to set
                 */
                function FrontendMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FrontendMetadata version.
                 * @member {number} version
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @instance
                 */
                FrontendMetadata.prototype.version = 0;
    
                /**
                 * FrontendMetadata recipient.
                 * @member {string} recipient
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @instance
                 */
                FrontendMetadata.prototype.recipient = "";
    
                /**
                 * Encodes the specified FrontendMetadata message. Does not implicitly {@link ununifi.ecosystemincentive.FrontendMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @static
                 * @param {ununifi.ecosystemincentive.IFrontendMetadata} message FrontendMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FrontendMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                    if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.recipient);
                    return writer;
                };
    
                /**
                 * Encodes the specified FrontendMetadata message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.FrontendMetadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @static
                 * @param {ununifi.ecosystemincentive.IFrontendMetadata} message FrontendMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FrontendMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FrontendMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.FrontendMetadata} FrontendMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FrontendMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.FrontendMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.version = reader.uint32();
                            break;
                        case 2:
                            message.recipient = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FrontendMetadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.FrontendMetadata} FrontendMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FrontendMetadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FrontendMetadata message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FrontendMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isInteger(message.version))
                            return "version: integer expected";
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        if (!$util.isString(message.recipient))
                            return "recipient: string expected";
                    return null;
                };
    
                /**
                 * Creates a FrontendMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.FrontendMetadata} FrontendMetadata
                 */
                FrontendMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.FrontendMetadata)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.FrontendMetadata();
                    if (object.version != null)
                        message.version = object.version >>> 0;
                    if (object.recipient != null)
                        message.recipient = String(object.recipient);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FrontendMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @static
                 * @param {ununifi.ecosystemincentive.FrontendMetadata} message FrontendMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FrontendMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.version = 0;
                        object.recipient = "";
                    }
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        object.recipient = message.recipient;
                    return object;
                };
    
                /**
                 * Converts this FrontendMetadata to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.FrontendMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FrontendMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FrontendMetadata;
            })();
    
            ecosystemincentive.Msg = (function() {
    
                /**
                 * Constructs a new Msg service.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a Msg
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Msg(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;
    
                /**
                 * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawAllRewards}.
                 * @memberof ununifi.ecosystemincentive.Msg
                 * @typedef WithdrawAllRewardsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} [response] MsgWithdrawAllRewardsResponse
                 */
    
                /**
                 * Calls WithdrawAllRewards.
                 * @function withdrawAllRewards
                 * @memberof ununifi.ecosystemincentive.Msg
                 * @instance
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
                 * @param {ununifi.ecosystemincentive.Msg.WithdrawAllRewardsCallback} callback Node-style callback called with the error, if any, and MsgWithdrawAllRewardsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.withdrawAllRewards = function withdrawAllRewards(request, callback) {
                    return this.rpcCall(withdrawAllRewards, $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards, $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse, request, callback);
                }, "name", { value: "WithdrawAllRewards" });
    
                /**
                 * Calls WithdrawAllRewards.
                 * @function withdrawAllRewards
                 * @memberof ununifi.ecosystemincentive.Msg
                 * @instance
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
                 * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawReward}.
                 * @memberof ununifi.ecosystemincentive.Msg
                 * @typedef WithdrawRewardCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} [response] MsgWithdrawRewardResponse
                 */
    
                /**
                 * Calls WithdrawReward.
                 * @function withdrawReward
                 * @memberof ununifi.ecosystemincentive.Msg
                 * @instance
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
                 * @param {ununifi.ecosystemincentive.Msg.WithdrawRewardCallback} callback Node-style callback called with the error, if any, and MsgWithdrawRewardResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.withdrawReward = function withdrawReward(request, callback) {
                    return this.rpcCall(withdrawReward, $root.ununifi.ecosystemincentive.MsgWithdrawReward, $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse, request, callback);
                }, "name", { value: "WithdrawReward" });
    
                /**
                 * Calls WithdrawReward.
                 * @function withdrawReward
                 * @memberof ununifi.ecosystemincentive.Msg
                 * @instance
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
                 * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawRewardResponse>} Promise
                 * @variation 2
                 */
    
                return Msg;
            })();
    
            ecosystemincentive.MsgWithdrawAllRewards = (function() {
    
                /**
                 * Properties of a MsgWithdrawAllRewards.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IMsgWithdrawAllRewards
                 * @property {string|null} [sender] MsgWithdrawAllRewards sender
                 */
    
                /**
                 * Constructs a new MsgWithdrawAllRewards.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a MsgWithdrawAllRewards.
                 * @implements IMsgWithdrawAllRewards
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards=} [properties] Properties to set
                 */
                function MsgWithdrawAllRewards(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgWithdrawAllRewards sender.
                 * @member {string} sender
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @instance
                 */
                MsgWithdrawAllRewards.prototype.sender = "";
    
                /**
                 * Encodes the specified MsgWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawAllRewards.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawAllRewards.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawAllRewards message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawAllRewards.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
                 */
                MsgWithdrawAllRewards.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawAllRewards message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @static
                 * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewards} message MsgWithdrawAllRewards
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawAllRewards.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.sender = "";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    return object;
                };
    
                /**
                 * Converts this MsgWithdrawAllRewards to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawAllRewards.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawAllRewards;
            })();
    
            ecosystemincentive.MsgWithdrawAllRewardsResponse = (function() {
    
                /**
                 * Properties of a MsgWithdrawAllRewardsResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IMsgWithdrawAllRewardsResponse
                 */
    
                /**
                 * Constructs a new MsgWithdrawAllRewardsResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a MsgWithdrawAllRewardsResponse.
                 * @implements IMsgWithdrawAllRewardsResponse
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse=} [properties] Properties to set
                 */
                function MsgWithdrawAllRewardsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgWithdrawAllRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawAllRewardsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawAllRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawAllRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawAllRewardsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawAllRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawAllRewardsResponse message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawAllRewardsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawAllRewardsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
                 */
                MsgWithdrawAllRewardsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse)
                        return object;
                    return new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawAllRewardsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawAllRewardsResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgWithdrawAllRewardsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawAllRewardsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawAllRewardsResponse;
            })();
    
            ecosystemincentive.MsgWithdrawReward = (function() {
    
                /**
                 * Properties of a MsgWithdrawReward.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IMsgWithdrawReward
                 * @property {string|null} [sender] MsgWithdrawReward sender
                 * @property {string|null} [denom] MsgWithdrawReward denom
                 */
    
                /**
                 * Constructs a new MsgWithdrawReward.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a MsgWithdrawReward.
                 * @implements IMsgWithdrawReward
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawReward=} [properties] Properties to set
                 */
                function MsgWithdrawReward(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgWithdrawReward sender.
                 * @member {string} sender
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @instance
                 */
                MsgWithdrawReward.prototype.sender = "";
    
                /**
                 * MsgWithdrawReward denom.
                 * @member {string} denom
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @instance
                 */
                MsgWithdrawReward.prototype.denom = "";
    
                /**
                 * Encodes the specified MsgWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawReward.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawReward message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawReward.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.denom = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawReward message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawReward message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawReward.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawReward message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
                 */
                MsgWithdrawReward.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawReward)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawReward message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @static
                 * @param {ununifi.ecosystemincentive.MsgWithdrawReward} message MsgWithdrawReward
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawReward.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.denom = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    return object;
                };
    
                /**
                 * Converts this MsgWithdrawReward to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawReward.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawReward;
            })();
    
            ecosystemincentive.MsgWithdrawRewardResponse = (function() {
    
                /**
                 * Properties of a MsgWithdrawRewardResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IMsgWithdrawRewardResponse
                 */
    
                /**
                 * Constructs a new MsgWithdrawRewardResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a MsgWithdrawRewardResponse.
                 * @implements IMsgWithdrawRewardResponse
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse=} [properties] Properties to set
                 */
                function MsgWithdrawRewardResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgWithdrawRewardResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawRewardResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawRewardResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawRewardResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawRewardResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawRewardResponse message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawRewardResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawRewardResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
                 */
                MsgWithdrawRewardResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse)
                        return object;
                    return new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawRewardResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} message MsgWithdrawRewardResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawRewardResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgWithdrawRewardResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawRewardResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawRewardResponse;
            })();
    
            ecosystemincentive.RewardRecord = (function() {
    
                /**
                 * Properties of a RewardRecord.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IRewardRecord
                 * @property {string|null} [address] RewardRecord address
                 * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] RewardRecord rewards
                 */
    
                /**
                 * Constructs a new RewardRecord.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a RewardRecord.
                 * @implements IRewardRecord
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IRewardRecord=} [properties] Properties to set
                 */
                function RewardRecord(properties) {
                    this.rewards = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RewardRecord address.
                 * @member {string} address
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @instance
                 */
                RewardRecord.prototype.address = "";
    
                /**
                 * RewardRecord rewards.
                 * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @instance
                 */
                RewardRecord.prototype.rewards = $util.emptyArray;
    
                /**
                 * Encodes the specified RewardRecord message. Does not implicitly {@link ununifi.ecosystemincentive.RewardRecord.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @static
                 * @param {ununifi.ecosystemincentive.IRewardRecord} message RewardRecord message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardRecord.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                    if (message.rewards != null && message.rewards.length)
                        for (var i = 0; i < message.rewards.length; ++i)
                            $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified RewardRecord message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardRecord.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @static
                 * @param {ununifi.ecosystemincentive.IRewardRecord} message RewardRecord message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardRecord.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RewardRecord message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.RewardRecord} RewardRecord
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardRecord.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.RewardRecord();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.string();
                            break;
                        case 2:
                            if (!(message.rewards && message.rewards.length))
                                message.rewards = [];
                            message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RewardRecord message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.RewardRecord} RewardRecord
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardRecord.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RewardRecord message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RewardRecord.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isString(message.address))
                            return "address: string expected";
                    if (message.rewards != null && message.hasOwnProperty("rewards")) {
                        if (!Array.isArray(message.rewards))
                            return "rewards: array expected";
                        for (var i = 0; i < message.rewards.length; ++i) {
                            var error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
                            if (error)
                                return "rewards." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a RewardRecord message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.RewardRecord} RewardRecord
                 */
                RewardRecord.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.RewardRecord)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.RewardRecord();
                    if (object.address != null)
                        message.address = String(object.address);
                    if (object.rewards) {
                        if (!Array.isArray(object.rewards))
                            throw TypeError(".ununifi.ecosystemincentive.RewardRecord.rewards: array expected");
                        message.rewards = [];
                        for (var i = 0; i < object.rewards.length; ++i) {
                            if (typeof object.rewards[i] !== "object")
                                throw TypeError(".ununifi.ecosystemincentive.RewardRecord.rewards: object expected");
                            message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a RewardRecord message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @static
                 * @param {ununifi.ecosystemincentive.RewardRecord} message RewardRecord
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RewardRecord.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rewards = [];
                    if (options.defaults)
                        object.address = "";
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = message.address;
                    if (message.rewards && message.rewards.length) {
                        object.rewards = [];
                        for (var j = 0; j < message.rewards.length; ++j)
                            object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this RewardRecord to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.RewardRecord
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RewardRecord.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RewardRecord;
            })();
    
            ecosystemincentive.EventWithdrawAllRewards = (function() {
    
                /**
                 * Properties of an EventWithdrawAllRewards.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IEventWithdrawAllRewards
                 * @property {string|null} [sender] EventWithdrawAllRewards sender
                 * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [all_withdrawn_rewards] EventWithdrawAllRewards all_withdrawn_rewards
                 */
    
                /**
                 * Constructs a new EventWithdrawAllRewards.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents an EventWithdrawAllRewards.
                 * @implements IEventWithdrawAllRewards
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards=} [properties] Properties to set
                 */
                function EventWithdrawAllRewards(properties) {
                    this.all_withdrawn_rewards = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventWithdrawAllRewards sender.
                 * @member {string} sender
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @instance
                 */
                EventWithdrawAllRewards.prototype.sender = "";
    
                /**
                 * EventWithdrawAllRewards all_withdrawn_rewards.
                 * @member {Array.<cosmos.base.v1beta1.ICoin>} all_withdrawn_rewards
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @instance
                 */
                EventWithdrawAllRewards.prototype.all_withdrawn_rewards = $util.emptyArray;
    
                /**
                 * Encodes the specified EventWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventWithdrawAllRewards.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.all_withdrawn_rewards != null && message.all_withdrawn_rewards.length)
                        for (var i = 0; i < message.all_withdrawn_rewards.length; ++i)
                            $root.cosmos.base.v1beta1.Coin.encode(message.all_withdrawn_rewards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EventWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventWithdrawAllRewards message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventWithdrawAllRewards.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            if (!(message.all_withdrawn_rewards && message.all_withdrawn_rewards.length))
                                message.all_withdrawn_rewards = [];
                            message.all_withdrawn_rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventWithdrawAllRewards message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventWithdrawAllRewards message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventWithdrawAllRewards.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.all_withdrawn_rewards != null && message.hasOwnProperty("all_withdrawn_rewards")) {
                        if (!Array.isArray(message.all_withdrawn_rewards))
                            return "all_withdrawn_rewards: array expected";
                        for (var i = 0; i < message.all_withdrawn_rewards.length; ++i) {
                            var error = $root.cosmos.base.v1beta1.Coin.verify(message.all_withdrawn_rewards[i]);
                            if (error)
                                return "all_withdrawn_rewards." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EventWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
                 */
                EventWithdrawAllRewards.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawAllRewards)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.all_withdrawn_rewards) {
                        if (!Array.isArray(object.all_withdrawn_rewards))
                            throw TypeError(".ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: array expected");
                        message.all_withdrawn_rewards = [];
                        for (var i = 0; i < object.all_withdrawn_rewards.length; ++i) {
                            if (typeof object.all_withdrawn_rewards[i] !== "object")
                                throw TypeError(".ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: object expected");
                            message.all_withdrawn_rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.all_withdrawn_rewards[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventWithdrawAllRewards message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @static
                 * @param {ununifi.ecosystemincentive.EventWithdrawAllRewards} message EventWithdrawAllRewards
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventWithdrawAllRewards.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.all_withdrawn_rewards = [];
                    if (options.defaults)
                        object.sender = "";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.all_withdrawn_rewards && message.all_withdrawn_rewards.length) {
                        object.all_withdrawn_rewards = [];
                        for (var j = 0; j < message.all_withdrawn_rewards.length; ++j)
                            object.all_withdrawn_rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.all_withdrawn_rewards[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EventWithdrawAllRewards to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventWithdrawAllRewards.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventWithdrawAllRewards;
            })();
    
            ecosystemincentive.EventWithdrawReward = (function() {
    
                /**
                 * Properties of an EventWithdrawReward.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IEventWithdrawReward
                 * @property {string|null} [sender] EventWithdrawReward sender
                 * @property {cosmos.base.v1beta1.ICoin|null} [withdrawn_reward] EventWithdrawReward withdrawn_reward
                 */
    
                /**
                 * Constructs a new EventWithdrawReward.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents an EventWithdrawReward.
                 * @implements IEventWithdrawReward
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IEventWithdrawReward=} [properties] Properties to set
                 */
                function EventWithdrawReward(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventWithdrawReward sender.
                 * @member {string} sender
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @instance
                 */
                EventWithdrawReward.prototype.sender = "";
    
                /**
                 * EventWithdrawReward withdrawn_reward.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} withdrawn_reward
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @instance
                 */
                EventWithdrawReward.prototype.withdrawn_reward = null;
    
                /**
                 * Encodes the specified EventWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventWithdrawReward.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.withdrawn_reward != null && Object.hasOwnProperty.call(message, "withdrawn_reward"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.withdrawn_reward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EventWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventWithdrawReward message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventWithdrawReward.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventWithdrawReward message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventWithdrawReward message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventWithdrawReward.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.withdrawn_reward != null && message.hasOwnProperty("withdrawn_reward")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.withdrawn_reward);
                        if (error)
                            return "withdrawn_reward." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EventWithdrawReward message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
                 */
                EventWithdrawReward.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawReward)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.withdrawn_reward != null) {
                        if (typeof object.withdrawn_reward !== "object")
                            throw TypeError(".ununifi.ecosystemincentive.EventWithdrawReward.withdrawn_reward: object expected");
                        message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.withdrawn_reward);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventWithdrawReward message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @static
                 * @param {ununifi.ecosystemincentive.EventWithdrawReward} message EventWithdrawReward
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventWithdrawReward.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.withdrawn_reward = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.withdrawn_reward != null && message.hasOwnProperty("withdrawn_reward"))
                        object.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.withdrawn_reward, options);
                    return object;
                };
    
                /**
                 * Converts this EventWithdrawReward to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.EventWithdrawReward
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventWithdrawReward.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventWithdrawReward;
            })();
    
            ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward = (function() {
    
                /**
                 * Properties of an EventDeletedNftIdRecordedForFrontendReward.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IEventDeletedNftIdRecordedForFrontendReward
                 * @property {string|null} [recipient_container_id] EventDeletedNftIdRecordedForFrontendReward recipient_container_id
                 * @property {string|null} [class_id] EventDeletedNftIdRecordedForFrontendReward class_id
                 * @property {string|null} [token_id] EventDeletedNftIdRecordedForFrontendReward token_id
                 */
    
                /**
                 * Constructs a new EventDeletedNftIdRecordedForFrontendReward.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents an EventDeletedNftIdRecordedForFrontendReward.
                 * @implements IEventDeletedNftIdRecordedForFrontendReward
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward=} [properties] Properties to set
                 */
                function EventDeletedNftIdRecordedForFrontendReward(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventDeletedNftIdRecordedForFrontendReward recipient_container_id.
                 * @member {string} recipient_container_id
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @instance
                 */
                EventDeletedNftIdRecordedForFrontendReward.prototype.recipient_container_id = "";
    
                /**
                 * EventDeletedNftIdRecordedForFrontendReward class_id.
                 * @member {string} class_id
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @instance
                 */
                EventDeletedNftIdRecordedForFrontendReward.prototype.class_id = "";
    
                /**
                 * EventDeletedNftIdRecordedForFrontendReward token_id.
                 * @member {string} token_id
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @instance
                 */
                EventDeletedNftIdRecordedForFrontendReward.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventDeletedNftIdRecordedForFrontendReward.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.recipient_container_id != null && Object.hasOwnProperty.call(message, "recipient_container_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipient_container_id);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventDeletedNftIdRecordedForFrontendReward.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventDeletedNftIdRecordedForFrontendReward.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.recipient_container_id = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventDeletedNftIdRecordedForFrontendReward.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventDeletedNftIdRecordedForFrontendReward message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventDeletedNftIdRecordedForFrontendReward.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.recipient_container_id != null && message.hasOwnProperty("recipient_container_id"))
                        if (!$util.isString(message.recipient_container_id))
                            return "recipient_container_id: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventDeletedNftIdRecordedForFrontendReward message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
                 */
                EventDeletedNftIdRecordedForFrontendReward.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
                    if (object.recipient_container_id != null)
                        message.recipient_container_id = String(object.recipient_container_id);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventDeletedNftIdRecordedForFrontendReward message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @static
                 * @param {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventDeletedNftIdRecordedForFrontendReward.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.recipient_container_id = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.recipient_container_id != null && message.hasOwnProperty("recipient_container_id"))
                        object.recipient_container_id = message.recipient_container_id;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventDeletedNftIdRecordedForFrontendReward to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventDeletedNftIdRecordedForFrontendReward.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventDeletedNftIdRecordedForFrontendReward;
            })();
    
            ecosystemincentive.EventNotRecordedNftId = (function() {
    
                /**
                 * Properties of an EventNotRecordedNftId.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IEventNotRecordedNftId
                 * @property {string|null} [class_id] EventNotRecordedNftId class_id
                 * @property {string|null} [token_id] EventNotRecordedNftId token_id
                 */
    
                /**
                 * Constructs a new EventNotRecordedNftId.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents an EventNotRecordedNftId.
                 * @implements IEventNotRecordedNftId
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId=} [properties] Properties to set
                 */
                function EventNotRecordedNftId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventNotRecordedNftId class_id.
                 * @member {string} class_id
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @instance
                 */
                EventNotRecordedNftId.prototype.class_id = "";
    
                /**
                 * EventNotRecordedNftId token_id.
                 * @member {string} token_id
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @instance
                 */
                EventNotRecordedNftId.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventNotRecordedNftId message. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventNotRecordedNftId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventNotRecordedNftId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventNotRecordedNftId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventNotRecordedNftId message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventNotRecordedNftId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventNotRecordedNftId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventNotRecordedNftId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventNotRecordedNftId message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventNotRecordedNftId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventNotRecordedNftId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
                 */
                EventNotRecordedNftId.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.EventNotRecordedNftId)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventNotRecordedNftId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @static
                 * @param {ununifi.ecosystemincentive.EventNotRecordedNftId} message EventNotRecordedNftId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventNotRecordedNftId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventNotRecordedNftId to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventNotRecordedNftId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventNotRecordedNftId;
            })();
    
            ecosystemincentive.EventUpdatedReward = (function() {
    
                /**
                 * Properties of an EventUpdatedReward.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IEventUpdatedReward
                 * @property {string|null} [recipient_container_id] EventUpdatedReward recipient_container_id
                 * @property {cosmos.base.v1beta1.ICoin|null} [earned_reward] EventUpdatedReward earned_reward
                 */
    
                /**
                 * Constructs a new EventUpdatedReward.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents an EventUpdatedReward.
                 * @implements IEventUpdatedReward
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IEventUpdatedReward=} [properties] Properties to set
                 */
                function EventUpdatedReward(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventUpdatedReward recipient_container_id.
                 * @member {string} recipient_container_id
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @instance
                 */
                EventUpdatedReward.prototype.recipient_container_id = "";
    
                /**
                 * EventUpdatedReward earned_reward.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} earned_reward
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @instance
                 */
                EventUpdatedReward.prototype.earned_reward = null;
    
                /**
                 * Encodes the specified EventUpdatedReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventUpdatedReward.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.recipient_container_id != null && Object.hasOwnProperty.call(message, "recipient_container_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipient_container_id);
                    if (message.earned_reward != null && Object.hasOwnProperty.call(message, "earned_reward"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.earned_reward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EventUpdatedReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventUpdatedReward.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventUpdatedReward message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventUpdatedReward.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.recipient_container_id = reader.string();
                            break;
                        case 2:
                            message.earned_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventUpdatedReward message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventUpdatedReward.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventUpdatedReward message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventUpdatedReward.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.recipient_container_id != null && message.hasOwnProperty("recipient_container_id"))
                        if (!$util.isString(message.recipient_container_id))
                            return "recipient_container_id: string expected";
                    if (message.earned_reward != null && message.hasOwnProperty("earned_reward")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.earned_reward);
                        if (error)
                            return "earned_reward." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EventUpdatedReward message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
                 */
                EventUpdatedReward.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.EventUpdatedReward)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
                    if (object.recipient_container_id != null)
                        message.recipient_container_id = String(object.recipient_container_id);
                    if (object.earned_reward != null) {
                        if (typeof object.earned_reward !== "object")
                            throw TypeError(".ununifi.ecosystemincentive.EventUpdatedReward.earned_reward: object expected");
                        message.earned_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.earned_reward);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventUpdatedReward message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @static
                 * @param {ununifi.ecosystemincentive.EventUpdatedReward} message EventUpdatedReward
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventUpdatedReward.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.recipient_container_id = "";
                        object.earned_reward = null;
                    }
                    if (message.recipient_container_id != null && message.hasOwnProperty("recipient_container_id"))
                        object.recipient_container_id = message.recipient_container_id;
                    if (message.earned_reward != null && message.hasOwnProperty("earned_reward"))
                        object.earned_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.earned_reward, options);
                    return object;
                };
    
                /**
                 * Converts this EventUpdatedReward to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.EventUpdatedReward
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventUpdatedReward.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventUpdatedReward;
            })();
    
            ecosystemincentive.EventDistributionForStakers = (function() {
    
                /**
                 * Properties of an EventDistributionForStakers.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IEventDistributionForStakers
                 * @property {cosmos.base.v1beta1.ICoin|null} [distributed_amount] EventDistributionForStakers distributed_amount
                 * @property {Long|null} [block_height] EventDistributionForStakers block_height
                 */
    
                /**
                 * Constructs a new EventDistributionForStakers.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents an EventDistributionForStakers.
                 * @implements IEventDistributionForStakers
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IEventDistributionForStakers=} [properties] Properties to set
                 */
                function EventDistributionForStakers(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventDistributionForStakers distributed_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} distributed_amount
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @instance
                 */
                EventDistributionForStakers.prototype.distributed_amount = null;
    
                /**
                 * EventDistributionForStakers block_height.
                 * @member {Long} block_height
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @instance
                 */
                EventDistributionForStakers.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Encodes the specified EventDistributionForStakers message. Does not implicitly {@link ununifi.ecosystemincentive.EventDistributionForStakers.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventDistributionForStakers} message EventDistributionForStakers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventDistributionForStakers.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.distributed_amount != null && Object.hasOwnProperty.call(message, "distributed_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.distributed_amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.block_height);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventDistributionForStakers message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventDistributionForStakers.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventDistributionForStakers} message EventDistributionForStakers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventDistributionForStakers.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventDistributionForStakers message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.EventDistributionForStakers} EventDistributionForStakers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventDistributionForStakers.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.EventDistributionForStakers();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.distributed_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.block_height = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventDistributionForStakers message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.EventDistributionForStakers} EventDistributionForStakers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventDistributionForStakers.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventDistributionForStakers message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventDistributionForStakers.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.distributed_amount != null && message.hasOwnProperty("distributed_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.distributed_amount);
                        if (error)
                            return "distributed_amount." + error;
                    }
                    if (message.block_height != null && message.hasOwnProperty("block_height"))
                        if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                            return "block_height: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates an EventDistributionForStakers message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.EventDistributionForStakers} EventDistributionForStakers
                 */
                EventDistributionForStakers.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.EventDistributionForStakers)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.EventDistributionForStakers();
                    if (object.distributed_amount != null) {
                        if (typeof object.distributed_amount !== "object")
                            throw TypeError(".ununifi.ecosystemincentive.EventDistributionForStakers.distributed_amount: object expected");
                        message.distributed_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.distributed_amount);
                    }
                    if (object.block_height != null)
                        if ($util.Long)
                            (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = false;
                        else if (typeof object.block_height === "string")
                            message.block_height = parseInt(object.block_height, 10);
                        else if (typeof object.block_height === "number")
                            message.block_height = object.block_height;
                        else if (typeof object.block_height === "object")
                            message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventDistributionForStakers message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @static
                 * @param {ununifi.ecosystemincentive.EventDistributionForStakers} message EventDistributionForStakers
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventDistributionForStakers.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.distributed_amount = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.block_height = options.longs === String ? "0" : 0;
                    }
                    if (message.distributed_amount != null && message.hasOwnProperty("distributed_amount"))
                        object.distributed_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.distributed_amount, options);
                    if (message.block_height != null && message.hasOwnProperty("block_height"))
                        if (typeof message.block_height === "number")
                            object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                        else
                            object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber() : message.block_height;
                    return object;
                };
    
                /**
                 * Converts this EventDistributionForStakers to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventDistributionForStakers.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventDistributionForStakers;
            })();
    
            ecosystemincentive.EventVersionUnmatched = (function() {
    
                /**
                 * Properties of an EventVersionUnmatched.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IEventVersionUnmatched
                 * @property {number|null} [unmatched_version] EventVersionUnmatched unmatched_version
                 * @property {string|null} [class_id] EventVersionUnmatched class_id
                 * @property {string|null} [nft_id] EventVersionUnmatched nft_id
                 */
    
                /**
                 * Constructs a new EventVersionUnmatched.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents an EventVersionUnmatched.
                 * @implements IEventVersionUnmatched
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IEventVersionUnmatched=} [properties] Properties to set
                 */
                function EventVersionUnmatched(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventVersionUnmatched unmatched_version.
                 * @member {number} unmatched_version
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @instance
                 */
                EventVersionUnmatched.prototype.unmatched_version = 0;
    
                /**
                 * EventVersionUnmatched class_id.
                 * @member {string} class_id
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @instance
                 */
                EventVersionUnmatched.prototype.class_id = "";
    
                /**
                 * EventVersionUnmatched nft_id.
                 * @member {string} nft_id
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @instance
                 */
                EventVersionUnmatched.prototype.nft_id = "";
    
                /**
                 * Encodes the specified EventVersionUnmatched message. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventVersionUnmatched.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.unmatched_version != null && Object.hasOwnProperty.call(message, "unmatched_version"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.unmatched_version);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.nft_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventVersionUnmatched message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @static
                 * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventVersionUnmatched.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventVersionUnmatched message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventVersionUnmatched.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.unmatched_version = reader.uint32();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.nft_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventVersionUnmatched message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventVersionUnmatched.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventVersionUnmatched message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventVersionUnmatched.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.unmatched_version != null && message.hasOwnProperty("unmatched_version"))
                        if (!$util.isInteger(message.unmatched_version))
                            return "unmatched_version: integer expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        if (!$util.isString(message.nft_id))
                            return "nft_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventVersionUnmatched message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
                 */
                EventVersionUnmatched.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.EventVersionUnmatched)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
                    if (object.unmatched_version != null)
                        message.unmatched_version = object.unmatched_version >>> 0;
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.nft_id != null)
                        message.nft_id = String(object.nft_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventVersionUnmatched message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @static
                 * @param {ununifi.ecosystemincentive.EventVersionUnmatched} message EventVersionUnmatched
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventVersionUnmatched.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.unmatched_version = 0;
                        object.class_id = "";
                        object.nft_id = "";
                    }
                    if (message.unmatched_version != null && message.hasOwnProperty("unmatched_version"))
                        object.unmatched_version = message.unmatched_version;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = message.nft_id;
                    return object;
                };
    
                /**
                 * Converts this EventVersionUnmatched to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventVersionUnmatched.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventVersionUnmatched;
            })();
    
            ecosystemincentive.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IGenesisState
                 * @property {ununifi.ecosystemincentive.IParams|null} [params] GenesisState params
                 * @property {Array.<ununifi.ecosystemincentive.IRewardRecord>|null} [reward_records] GenesisState reward_records
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.reward_records = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState params.
                 * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @instance
                 */
                GenesisState.prototype.params = null;
    
                /**
                 * GenesisState reward_records.
                 * @member {Array.<ununifi.ecosystemincentive.IRewardRecord>} reward_records
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @instance
                 */
                GenesisState.prototype.reward_records = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @static
                 * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.reward_records != null && message.reward_records.length)
                        for (var i = 0; i < message.reward_records.length; ++i)
                            $root.ununifi.ecosystemincentive.RewardRecord.encode(message.reward_records[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @static
                 * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.reward_records && message.reward_records.length))
                                message.reward_records = [];
                            message.reward_records.push($root.ununifi.ecosystemincentive.RewardRecord.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.reward_records != null && message.hasOwnProperty("reward_records")) {
                        if (!Array.isArray(message.reward_records))
                            return "reward_records: array expected";
                        for (var i = 0; i < message.reward_records.length; ++i) {
                            var error = $root.ununifi.ecosystemincentive.RewardRecord.verify(message.reward_records[i]);
                            if (error)
                                return "reward_records." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.GenesisState)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.GenesisState();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.ecosystemincentive.GenesisState.params: object expected");
                        message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
                    }
                    if (object.reward_records) {
                        if (!Array.isArray(object.reward_records))
                            throw TypeError(".ununifi.ecosystemincentive.GenesisState.reward_records: array expected");
                        message.reward_records = [];
                        for (var i = 0; i < object.reward_records.length; ++i) {
                            if (typeof object.reward_records[i] !== "object")
                                throw TypeError(".ununifi.ecosystemincentive.GenesisState.reward_records: object expected");
                            message.reward_records[i] = $root.ununifi.ecosystemincentive.RewardRecord.fromObject(object.reward_records[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @static
                 * @param {ununifi.ecosystemincentive.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.reward_records = [];
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
                    if (message.reward_records && message.reward_records.length) {
                        object.reward_records = [];
                        for (var j = 0; j < message.reward_records.length; ++j)
                            object.reward_records[j] = $root.ununifi.ecosystemincentive.RewardRecord.toObject(message.reward_records[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            ecosystemincentive.Params = (function() {
    
                /**
                 * Properties of a Params.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IParams
                 * @property {Array.<ununifi.ecosystemincentive.IRewardParams>|null} [reward_params] Params reward_params
                 */
    
                /**
                 * Constructs a new Params.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a Params.
                 * @implements IParams
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IParams=} [properties] Properties to set
                 */
                function Params(properties) {
                    this.reward_params = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Params reward_params.
                 * @member {Array.<ununifi.ecosystemincentive.IRewardParams>} reward_params
                 * @memberof ununifi.ecosystemincentive.Params
                 * @instance
                 */
                Params.prototype.reward_params = $util.emptyArray;
    
                /**
                 * Encodes the specified Params message. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.Params
                 * @static
                 * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reward_params != null && message.reward_params.length)
                        for (var i = 0; i < message.reward_params.length; ++i)
                            $root.ununifi.ecosystemincentive.RewardParams.encode(message.reward_params[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.Params
                 * @static
                 * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.Params();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.reward_params && message.reward_params.length))
                                message.reward_params = [];
                            message.reward_params.push($root.ununifi.ecosystemincentive.RewardParams.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Params message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.Params
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Params.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reward_params != null && message.hasOwnProperty("reward_params")) {
                        if (!Array.isArray(message.reward_params))
                            return "reward_params: array expected";
                        for (var i = 0; i < message.reward_params.length; ++i) {
                            var error = $root.ununifi.ecosystemincentive.RewardParams.verify(message.reward_params[i]);
                            if (error)
                                return "reward_params." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Params message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.Params
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.Params} Params
                 */
                Params.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.Params)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.Params();
                    if (object.reward_params) {
                        if (!Array.isArray(object.reward_params))
                            throw TypeError(".ununifi.ecosystemincentive.Params.reward_params: array expected");
                        message.reward_params = [];
                        for (var i = 0; i < object.reward_params.length; ++i) {
                            if (typeof object.reward_params[i] !== "object")
                                throw TypeError(".ununifi.ecosystemincentive.Params.reward_params: object expected");
                            message.reward_params[i] = $root.ununifi.ecosystemincentive.RewardParams.fromObject(object.reward_params[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Params message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.Params
                 * @static
                 * @param {ununifi.ecosystemincentive.Params} message Params
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Params.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.reward_params = [];
                    if (message.reward_params && message.reward_params.length) {
                        object.reward_params = [];
                        for (var j = 0; j < message.reward_params.length; ++j)
                            object.reward_params[j] = $root.ununifi.ecosystemincentive.RewardParams.toObject(message.reward_params[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Params to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.Params
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Params.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Params;
            })();
    
            ecosystemincentive.RewardParams = (function() {
    
                /**
                 * Properties of a RewardParams.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IRewardParams
                 * @property {string|null} [module_name] RewardParams module_name
                 * @property {Array.<ununifi.ecosystemincentive.IRewardRate>|null} [reward_rate] RewardParams reward_rate
                 */
    
                /**
                 * Constructs a new RewardParams.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a RewardParams.
                 * @implements IRewardParams
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IRewardParams=} [properties] Properties to set
                 */
                function RewardParams(properties) {
                    this.reward_rate = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RewardParams module_name.
                 * @member {string} module_name
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @instance
                 */
                RewardParams.prototype.module_name = "";
    
                /**
                 * RewardParams reward_rate.
                 * @member {Array.<ununifi.ecosystemincentive.IRewardRate>} reward_rate
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @instance
                 */
                RewardParams.prototype.reward_rate = $util.emptyArray;
    
                /**
                 * Encodes the specified RewardParams message. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @static
                 * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.module_name != null && Object.hasOwnProperty.call(message, "module_name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.module_name);
                    if (message.reward_rate != null && message.reward_rate.length)
                        for (var i = 0; i < message.reward_rate.length; ++i)
                            $root.ununifi.ecosystemincentive.RewardRate.encode(message.reward_rate[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified RewardParams message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @static
                 * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RewardParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.RewardParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.module_name = reader.string();
                            break;
                        case 2:
                            if (!(message.reward_rate && message.reward_rate.length))
                                message.reward_rate = [];
                            message.reward_rate.push($root.ununifi.ecosystemincentive.RewardRate.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RewardParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RewardParams message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RewardParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.module_name != null && message.hasOwnProperty("module_name"))
                        if (!$util.isString(message.module_name))
                            return "module_name: string expected";
                    if (message.reward_rate != null && message.hasOwnProperty("reward_rate")) {
                        if (!Array.isArray(message.reward_rate))
                            return "reward_rate: array expected";
                        for (var i = 0; i < message.reward_rate.length; ++i) {
                            var error = $root.ununifi.ecosystemincentive.RewardRate.verify(message.reward_rate[i]);
                            if (error)
                                return "reward_rate." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a RewardParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
                 */
                RewardParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.RewardParams)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.RewardParams();
                    if (object.module_name != null)
                        message.module_name = String(object.module_name);
                    if (object.reward_rate) {
                        if (!Array.isArray(object.reward_rate))
                            throw TypeError(".ununifi.ecosystemincentive.RewardParams.reward_rate: array expected");
                        message.reward_rate = [];
                        for (var i = 0; i < object.reward_rate.length; ++i) {
                            if (typeof object.reward_rate[i] !== "object")
                                throw TypeError(".ununifi.ecosystemincentive.RewardParams.reward_rate: object expected");
                            message.reward_rate[i] = $root.ununifi.ecosystemincentive.RewardRate.fromObject(object.reward_rate[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a RewardParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @static
                 * @param {ununifi.ecosystemincentive.RewardParams} message RewardParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RewardParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.reward_rate = [];
                    if (options.defaults)
                        object.module_name = "";
                    if (message.module_name != null && message.hasOwnProperty("module_name"))
                        object.module_name = message.module_name;
                    if (message.reward_rate && message.reward_rate.length) {
                        object.reward_rate = [];
                        for (var j = 0; j < message.reward_rate.length; ++j)
                            object.reward_rate[j] = $root.ununifi.ecosystemincentive.RewardRate.toObject(message.reward_rate[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this RewardParams to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.RewardParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RewardParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RewardParams;
            })();
    
            ecosystemincentive.RewardRate = (function() {
    
                /**
                 * Properties of a RewardRate.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IRewardRate
                 * @property {ununifi.ecosystemincentive.RewardType|null} [reward_type] RewardRate reward_type
                 * @property {string|null} [rate] RewardRate rate
                 */
    
                /**
                 * Constructs a new RewardRate.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a RewardRate.
                 * @implements IRewardRate
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IRewardRate=} [properties] Properties to set
                 */
                function RewardRate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RewardRate reward_type.
                 * @member {ununifi.ecosystemincentive.RewardType} reward_type
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @instance
                 */
                RewardRate.prototype.reward_type = 0;
    
                /**
                 * RewardRate rate.
                 * @member {string} rate
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @instance
                 */
                RewardRate.prototype.rate = "";
    
                /**
                 * Encodes the specified RewardRate message. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @static
                 * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardRate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reward_type != null && Object.hasOwnProperty.call(message, "reward_type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reward_type);
                    if (message.rate != null && Object.hasOwnProperty.call(message, "rate"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.rate);
                    return writer;
                };
    
                /**
                 * Encodes the specified RewardRate message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @static
                 * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardRate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RewardRate message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardRate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.RewardRate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reward_type = reader.int32();
                            break;
                        case 2:
                            message.rate = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RewardRate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardRate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RewardRate message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RewardRate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reward_type != null && message.hasOwnProperty("reward_type"))
                        switch (message.reward_type) {
                        default:
                            return "reward_type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.rate != null && message.hasOwnProperty("rate"))
                        if (!$util.isString(message.rate))
                            return "rate: string expected";
                    return null;
                };
    
                /**
                 * Creates a RewardRate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
                 */
                RewardRate.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.RewardRate)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.RewardRate();
                    switch (object.reward_type) {
                    case "UNKNOWN":
                    case 0:
                        message.reward_type = 0;
                        break;
                    case "STAKERS":
                    case 1:
                        message.reward_type = 1;
                        break;
                    case "FRONTEND_DEVELOPERS":
                    case 2:
                        message.reward_type = 2;
                        break;
                    case "COMMUNITY_POOL":
                    case 3:
                        message.reward_type = 3;
                        break;
                    }
                    if (object.rate != null)
                        message.rate = String(object.rate);
                    return message;
                };
    
                /**
                 * Creates a plain object from a RewardRate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @static
                 * @param {ununifi.ecosystemincentive.RewardRate} message RewardRate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RewardRate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.reward_type = options.enums === String ? "UNKNOWN" : 0;
                        object.rate = "";
                    }
                    if (message.reward_type != null && message.hasOwnProperty("reward_type"))
                        object.reward_type = options.enums === String ? $root.ununifi.ecosystemincentive.RewardType[message.reward_type] : message.reward_type;
                    if (message.rate != null && message.hasOwnProperty("rate"))
                        object.rate = message.rate;
                    return object;
                };
    
                /**
                 * Converts this RewardRate to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.RewardRate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RewardRate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RewardRate;
            })();
    
            /**
             * RewardType enum.
             * @name ununifi.ecosystemincentive.RewardType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} STAKERS=1 STAKERS value
             * @property {number} FRONTEND_DEVELOPERS=2 FRONTEND_DEVELOPERS value
             * @property {number} COMMUNITY_POOL=3 COMMUNITY_POOL value
             */
            ecosystemincentive.RewardType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "STAKERS"] = 1;
                values[valuesById[2] = "FRONTEND_DEVELOPERS"] = 2;
                values[valuesById[3] = "COMMUNITY_POOL"] = 3;
                return values;
            })();
    
            ecosystemincentive.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link ununifi.ecosystemincentive.Query#params}.
                 * @memberof ununifi.ecosystemincentive.Query
                 * @typedef ParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.ecosystemincentive.QueryParamsResponse} [response] QueryParamsResponse
                 */
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.ecosystemincentive.Query
                 * @instance
                 * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @param {ununifi.ecosystemincentive.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.params = function params(request, callback) {
                    return this.rpcCall(params, $root.ununifi.ecosystemincentive.QueryParamsRequest, $root.ununifi.ecosystemincentive.QueryParamsResponse, request, callback);
                }, "name", { value: "Params" });
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.ecosystemincentive.Query
                 * @instance
                 * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @returns {Promise<ununifi.ecosystemincentive.QueryParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.ecosystemincentive.Query#allRewards}.
                 * @memberof ununifi.ecosystemincentive.Query
                 * @typedef AllRewardsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.ecosystemincentive.QueryAllRewardsResponse} [response] QueryAllRewardsResponse
                 */
    
                /**
                 * Calls AllRewards.
                 * @function allRewards
                 * @memberof ununifi.ecosystemincentive.Query
                 * @instance
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} request QueryAllRewardsRequest message or plain object
                 * @param {ununifi.ecosystemincentive.Query.AllRewardsCallback} callback Node-style callback called with the error, if any, and QueryAllRewardsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.allRewards = function allRewards(request, callback) {
                    return this.rpcCall(allRewards, $root.ununifi.ecosystemincentive.QueryAllRewardsRequest, $root.ununifi.ecosystemincentive.QueryAllRewardsResponse, request, callback);
                }, "name", { value: "AllRewards" });
    
                /**
                 * Calls AllRewards.
                 * @function allRewards
                 * @memberof ununifi.ecosystemincentive.Query
                 * @instance
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} request QueryAllRewardsRequest message or plain object
                 * @returns {Promise<ununifi.ecosystemincentive.QueryAllRewardsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.ecosystemincentive.Query#reward}.
                 * @memberof ununifi.ecosystemincentive.Query
                 * @typedef RewardCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.ecosystemincentive.QueryRewardResponse} [response] QueryRewardResponse
                 */
    
                /**
                 * Calls Reward.
                 * @function reward
                 * @memberof ununifi.ecosystemincentive.Query
                 * @instance
                 * @param {ununifi.ecosystemincentive.IQueryRewardRequest} request QueryRewardRequest message or plain object
                 * @param {ununifi.ecosystemincentive.Query.RewardCallback} callback Node-style callback called with the error, if any, and QueryRewardResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.reward = function reward(request, callback) {
                    return this.rpcCall(reward, $root.ununifi.ecosystemincentive.QueryRewardRequest, $root.ununifi.ecosystemincentive.QueryRewardResponse, request, callback);
                }, "name", { value: "Reward" });
    
                /**
                 * Calls Reward.
                 * @function reward
                 * @memberof ununifi.ecosystemincentive.Query
                 * @instance
                 * @param {ununifi.ecosystemincentive.IQueryRewardRequest} request QueryRewardRequest message or plain object
                 * @returns {Promise<ununifi.ecosystemincentive.QueryRewardResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            ecosystemincentive.QueryParamsRequest = (function() {
    
                /**
                 * Properties of a QueryParamsRequest.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IQueryParamsRequest
                 */
    
                /**
                 * Constructs a new QueryParamsRequest.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a QueryParamsRequest.
                 * @implements IQueryParamsRequest
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IQueryParamsRequest=} [properties] Properties to set
                 */
                function QueryParamsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.QueryParamsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsRequest message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
                 */
                QueryParamsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsRequest)
                        return object;
                    return new $root.ununifi.ecosystemincentive.QueryParamsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.QueryParamsRequest} message QueryParamsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryParamsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.QueryParamsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsRequest;
            })();
    
            ecosystemincentive.QueryParamsResponse = (function() {
    
                /**
                 * Properties of a QueryParamsResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IQueryParamsResponse
                 * @property {ununifi.ecosystemincentive.IParams|null} [params] QueryParamsResponse params
                 */
    
                /**
                 * Constructs a new QueryParamsResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a QueryParamsResponse.
                 * @implements IQueryParamsResponse
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IQueryParamsResponse=} [properties] Properties to set
                 */
                function QueryParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryParamsResponse params.
                 * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @instance
                 */
                QueryParamsResponse.prototype.params = null;
    
                /**
                 * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsResponse message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
                 */
                QueryParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsResponse)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.ecosystemincentive.QueryParamsResponse.params: object expected");
                        message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.QueryParamsResponse} message QueryParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this QueryParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.QueryParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsResponse;
            })();
    
            ecosystemincentive.QueryAllRewardsRequest = (function() {
    
                /**
                 * Properties of a QueryAllRewardsRequest.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IQueryAllRewardsRequest
                 * @property {string|null} [address] QueryAllRewardsRequest address
                 */
    
                /**
                 * Constructs a new QueryAllRewardsRequest.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a QueryAllRewardsRequest.
                 * @implements IQueryAllRewardsRequest
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest=} [properties] Properties to set
                 */
                function QueryAllRewardsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllRewardsRequest address.
                 * @member {string} address
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @instance
                 */
                QueryAllRewardsRequest.prototype.address = "";
    
                /**
                 * Encodes the specified QueryAllRewardsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} message QueryAllRewardsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRewardsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllRewardsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} message QueryAllRewardsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllRewardsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRewardsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.QueryAllRewardsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllRewardsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllRewardsRequest message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllRewardsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isString(message.address))
                            return "address: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryAllRewardsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
                 */
                QueryAllRewardsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.QueryAllRewardsRequest)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.QueryAllRewardsRequest();
                    if (object.address != null)
                        message.address = String(object.address);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllRewardsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.QueryAllRewardsRequest} message QueryAllRewardsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllRewardsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.address = "";
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = message.address;
                    return object;
                };
    
                /**
                 * Converts this QueryAllRewardsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllRewardsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllRewardsRequest;
            })();
    
            ecosystemincentive.QueryAllRewardsResponse = (function() {
    
                /**
                 * Properties of a QueryAllRewardsResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IQueryAllRewardsResponse
                 * @property {ununifi.ecosystemincentive.IRewardRecord|null} [reward_record] QueryAllRewardsResponse reward_record
                 */
    
                /**
                 * Constructs a new QueryAllRewardsResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a QueryAllRewardsResponse.
                 * @implements IQueryAllRewardsResponse
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse=} [properties] Properties to set
                 */
                function QueryAllRewardsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllRewardsResponse reward_record.
                 * @member {ununifi.ecosystemincentive.IRewardRecord|null|undefined} reward_record
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @instance
                 */
                QueryAllRewardsResponse.prototype.reward_record = null;
    
                /**
                 * Encodes the specified QueryAllRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse} message QueryAllRewardsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRewardsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reward_record != null && Object.hasOwnProperty.call(message, "reward_record"))
                        $root.ununifi.ecosystemincentive.RewardRecord.encode(message.reward_record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse} message QueryAllRewardsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllRewardsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRewardsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.QueryAllRewardsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reward_record = $root.ununifi.ecosystemincentive.RewardRecord.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllRewardsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllRewardsResponse message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllRewardsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reward_record != null && message.hasOwnProperty("reward_record")) {
                        var error = $root.ununifi.ecosystemincentive.RewardRecord.verify(message.reward_record);
                        if (error)
                            return "reward_record." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllRewardsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
                 */
                QueryAllRewardsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.QueryAllRewardsResponse)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.QueryAllRewardsResponse();
                    if (object.reward_record != null) {
                        if (typeof object.reward_record !== "object")
                            throw TypeError(".ununifi.ecosystemincentive.QueryAllRewardsResponse.reward_record: object expected");
                        message.reward_record = $root.ununifi.ecosystemincentive.RewardRecord.fromObject(object.reward_record);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllRewardsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.QueryAllRewardsResponse} message QueryAllRewardsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllRewardsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.reward_record = null;
                    if (message.reward_record != null && message.hasOwnProperty("reward_record"))
                        object.reward_record = $root.ununifi.ecosystemincentive.RewardRecord.toObject(message.reward_record, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllRewardsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllRewardsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllRewardsResponse;
            })();
    
            ecosystemincentive.QueryRewardRequest = (function() {
    
                /**
                 * Properties of a QueryRewardRequest.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IQueryRewardRequest
                 * @property {string|null} [address] QueryRewardRequest address
                 * @property {string|null} [denom] QueryRewardRequest denom
                 */
    
                /**
                 * Constructs a new QueryRewardRequest.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a QueryRewardRequest.
                 * @implements IQueryRewardRequest
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IQueryRewardRequest=} [properties] Properties to set
                 */
                function QueryRewardRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryRewardRequest address.
                 * @member {string} address
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @instance
                 */
                QueryRewardRequest.prototype.address = "";
    
                /**
                 * QueryRewardRequest denom.
                 * @member {string} denom
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @instance
                 */
                QueryRewardRequest.prototype.denom = "";
    
                /**
                 * Encodes the specified QueryRewardRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryRewardRequest} message QueryRewardRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryRewardRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryRewardRequest} message QueryRewardRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryRewardRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.QueryRewardRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.string();
                            break;
                        case 2:
                            message.denom = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryRewardRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryRewardRequest message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryRewardRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isString(message.address))
                            return "address: string expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryRewardRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
                 */
                QueryRewardRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.QueryRewardRequest)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.QueryRewardRequest();
                    if (object.address != null)
                        message.address = String(object.address);
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryRewardRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @static
                 * @param {ununifi.ecosystemincentive.QueryRewardRequest} message QueryRewardRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryRewardRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.address = "";
                        object.denom = "";
                    }
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = message.address;
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    return object;
                };
    
                /**
                 * Converts this QueryRewardRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.QueryRewardRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryRewardRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryRewardRequest;
            })();
    
            ecosystemincentive.QueryRewardResponse = (function() {
    
                /**
                 * Properties of a QueryRewardResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @interface IQueryRewardResponse
                 * @property {cosmos.base.v1beta1.ICoin|null} [reward] QueryRewardResponse reward
                 */
    
                /**
                 * Constructs a new QueryRewardResponse.
                 * @memberof ununifi.ecosystemincentive
                 * @classdesc Represents a QueryRewardResponse.
                 * @implements IQueryRewardResponse
                 * @constructor
                 * @param {ununifi.ecosystemincentive.IQueryRewardResponse=} [properties] Properties to set
                 */
                function QueryRewardResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryRewardResponse reward.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} reward
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @instance
                 */
                QueryRewardResponse.prototype.reward = null;
    
                /**
                 * Encodes the specified QueryRewardResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryRewardResponse} message QueryRewardResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.reward, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryRewardResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.IQueryRewardResponse} message QueryRewardResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryRewardResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.ecosystemincentive.QueryRewardResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryRewardResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryRewardResponse message.
                 * @function verify
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryRewardResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reward != null && message.hasOwnProperty("reward")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.reward);
                        if (error)
                            return "reward." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryRewardResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
                 */
                QueryRewardResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.ecosystemincentive.QueryRewardResponse)
                        return object;
                    var message = new $root.ununifi.ecosystemincentive.QueryRewardResponse();
                    if (object.reward != null) {
                        if (typeof object.reward !== "object")
                            throw TypeError(".ununifi.ecosystemincentive.QueryRewardResponse.reward: object expected");
                        message.reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.reward);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryRewardResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @static
                 * @param {ununifi.ecosystemincentive.QueryRewardResponse} message QueryRewardResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryRewardResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.reward = null;
                    if (message.reward != null && message.hasOwnProperty("reward"))
                        object.reward = $root.cosmos.base.v1beta1.Coin.toObject(message.reward, options);
                    return object;
                };
    
                /**
                 * Converts this QueryRewardResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.ecosystemincentive.QueryRewardResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryRewardResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryRewardResponse;
            })();
    
            return ecosystemincentive;
        })();
    
        ununifi.epochs = (function() {
    
            /**
             * Namespace epochs.
             * @memberof ununifi
             * @namespace
             */
            var epochs = {};
    
            epochs.EpochInfo = (function() {
    
                /**
                 * Properties of an EpochInfo.
                 * @memberof ununifi.epochs
                 * @interface IEpochInfo
                 * @property {string|null} [identifier] EpochInfo identifier
                 * @property {google.protobuf.ITimestamp|null} [start_time] EpochInfo start_time
                 * @property {google.protobuf.IDuration|null} [duration] EpochInfo duration
                 * @property {Long|null} [current_epoch] EpochInfo current_epoch
                 * @property {google.protobuf.ITimestamp|null} [current_epoch_start_time] EpochInfo current_epoch_start_time
                 * @property {boolean|null} [epoch_counting_started] EpochInfo epoch_counting_started
                 * @property {Long|null} [current_epoch_start_height] EpochInfo current_epoch_start_height
                 */
    
                /**
                 * Constructs a new EpochInfo.
                 * @memberof ununifi.epochs
                 * @classdesc Represents an EpochInfo.
                 * @implements IEpochInfo
                 * @constructor
                 * @param {ununifi.epochs.IEpochInfo=} [properties] Properties to set
                 */
                function EpochInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EpochInfo identifier.
                 * @member {string} identifier
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 */
                EpochInfo.prototype.identifier = "";
    
                /**
                 * EpochInfo start_time.
                 * @member {google.protobuf.ITimestamp|null|undefined} start_time
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 */
                EpochInfo.prototype.start_time = null;
    
                /**
                 * EpochInfo duration.
                 * @member {google.protobuf.IDuration|null|undefined} duration
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 */
                EpochInfo.prototype.duration = null;
    
                /**
                 * EpochInfo current_epoch.
                 * @member {Long} current_epoch
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 */
                EpochInfo.prototype.current_epoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * EpochInfo current_epoch_start_time.
                 * @member {google.protobuf.ITimestamp|null|undefined} current_epoch_start_time
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 */
                EpochInfo.prototype.current_epoch_start_time = null;
    
                /**
                 * EpochInfo epoch_counting_started.
                 * @member {boolean} epoch_counting_started
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 */
                EpochInfo.prototype.epoch_counting_started = false;
    
                /**
                 * EpochInfo current_epoch_start_height.
                 * @member {Long} current_epoch_start_height
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 */
                EpochInfo.prototype.current_epoch_start_height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Encodes the specified EpochInfo message. Does not implicitly {@link ununifi.epochs.EpochInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.EpochInfo
                 * @static
                 * @param {ununifi.epochs.IEpochInfo} message EpochInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EpochInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identifier != null && Object.hasOwnProperty.call(message, "identifier"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.identifier);
                    if (message.start_time != null && Object.hasOwnProperty.call(message, "start_time"))
                        $root.google.protobuf.Timestamp.encode(message.start_time, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                        $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.current_epoch != null && Object.hasOwnProperty.call(message, "current_epoch"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.current_epoch);
                    if (message.current_epoch_start_time != null && Object.hasOwnProperty.call(message, "current_epoch_start_time"))
                        $root.google.protobuf.Timestamp.encode(message.current_epoch_start_time, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.epoch_counting_started != null && Object.hasOwnProperty.call(message, "epoch_counting_started"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.epoch_counting_started);
                    if (message.current_epoch_start_height != null && Object.hasOwnProperty.call(message, "current_epoch_start_height"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int64(message.current_epoch_start_height);
                    return writer;
                };
    
                /**
                 * Encodes the specified EpochInfo message, length delimited. Does not implicitly {@link ununifi.epochs.EpochInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.EpochInfo
                 * @static
                 * @param {ununifi.epochs.IEpochInfo} message EpochInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EpochInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EpochInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.EpochInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.EpochInfo} EpochInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EpochInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.EpochInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.identifier = reader.string();
                            break;
                        case 2:
                            message.start_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.current_epoch = reader.int64();
                            break;
                        case 5:
                            message.current_epoch_start_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.epoch_counting_started = reader.bool();
                            break;
                        case 7:
                            message.current_epoch_start_height = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EpochInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.EpochInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.EpochInfo} EpochInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EpochInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EpochInfo message.
                 * @function verify
                 * @memberof ununifi.epochs.EpochInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EpochInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identifier != null && message.hasOwnProperty("identifier"))
                        if (!$util.isString(message.identifier))
                            return "identifier: string expected";
                    if (message.start_time != null && message.hasOwnProperty("start_time")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.start_time);
                        if (error)
                            return "start_time." + error;
                    }
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        var error = $root.google.protobuf.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                    if (message.current_epoch != null && message.hasOwnProperty("current_epoch"))
                        if (!$util.isInteger(message.current_epoch) && !(message.current_epoch && $util.isInteger(message.current_epoch.low) && $util.isInteger(message.current_epoch.high)))
                            return "current_epoch: integer|Long expected";
                    if (message.current_epoch_start_time != null && message.hasOwnProperty("current_epoch_start_time")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.current_epoch_start_time);
                        if (error)
                            return "current_epoch_start_time." + error;
                    }
                    if (message.epoch_counting_started != null && message.hasOwnProperty("epoch_counting_started"))
                        if (typeof message.epoch_counting_started !== "boolean")
                            return "epoch_counting_started: boolean expected";
                    if (message.current_epoch_start_height != null && message.hasOwnProperty("current_epoch_start_height"))
                        if (!$util.isInteger(message.current_epoch_start_height) && !(message.current_epoch_start_height && $util.isInteger(message.current_epoch_start_height.low) && $util.isInteger(message.current_epoch_start_height.high)))
                            return "current_epoch_start_height: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates an EpochInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.EpochInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.EpochInfo} EpochInfo
                 */
                EpochInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.EpochInfo)
                        return object;
                    var message = new $root.ununifi.epochs.EpochInfo();
                    if (object.identifier != null)
                        message.identifier = String(object.identifier);
                    if (object.start_time != null) {
                        if (typeof object.start_time !== "object")
                            throw TypeError(".ununifi.epochs.EpochInfo.start_time: object expected");
                        message.start_time = $root.google.protobuf.Timestamp.fromObject(object.start_time);
                    }
                    if (object.duration != null) {
                        if (typeof object.duration !== "object")
                            throw TypeError(".ununifi.epochs.EpochInfo.duration: object expected");
                        message.duration = $root.google.protobuf.Duration.fromObject(object.duration);
                    }
                    if (object.current_epoch != null)
                        if ($util.Long)
                            (message.current_epoch = $util.Long.fromValue(object.current_epoch)).unsigned = false;
                        else if (typeof object.current_epoch === "string")
                            message.current_epoch = parseInt(object.current_epoch, 10);
                        else if (typeof object.current_epoch === "number")
                            message.current_epoch = object.current_epoch;
                        else if (typeof object.current_epoch === "object")
                            message.current_epoch = new $util.LongBits(object.current_epoch.low >>> 0, object.current_epoch.high >>> 0).toNumber();
                    if (object.current_epoch_start_time != null) {
                        if (typeof object.current_epoch_start_time !== "object")
                            throw TypeError(".ununifi.epochs.EpochInfo.current_epoch_start_time: object expected");
                        message.current_epoch_start_time = $root.google.protobuf.Timestamp.fromObject(object.current_epoch_start_time);
                    }
                    if (object.epoch_counting_started != null)
                        message.epoch_counting_started = Boolean(object.epoch_counting_started);
                    if (object.current_epoch_start_height != null)
                        if ($util.Long)
                            (message.current_epoch_start_height = $util.Long.fromValue(object.current_epoch_start_height)).unsigned = false;
                        else if (typeof object.current_epoch_start_height === "string")
                            message.current_epoch_start_height = parseInt(object.current_epoch_start_height, 10);
                        else if (typeof object.current_epoch_start_height === "number")
                            message.current_epoch_start_height = object.current_epoch_start_height;
                        else if (typeof object.current_epoch_start_height === "object")
                            message.current_epoch_start_height = new $util.LongBits(object.current_epoch_start_height.low >>> 0, object.current_epoch_start_height.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from an EpochInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.EpochInfo
                 * @static
                 * @param {ununifi.epochs.EpochInfo} message EpochInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EpochInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.identifier = "";
                        object.start_time = null;
                        object.duration = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.current_epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.current_epoch = options.longs === String ? "0" : 0;
                        object.current_epoch_start_time = null;
                        object.epoch_counting_started = false;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.current_epoch_start_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.current_epoch_start_height = options.longs === String ? "0" : 0;
                    }
                    if (message.identifier != null && message.hasOwnProperty("identifier"))
                        object.identifier = message.identifier;
                    if (message.start_time != null && message.hasOwnProperty("start_time"))
                        object.start_time = $root.google.protobuf.Timestamp.toObject(message.start_time, options);
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        object.duration = $root.google.protobuf.Duration.toObject(message.duration, options);
                    if (message.current_epoch != null && message.hasOwnProperty("current_epoch"))
                        if (typeof message.current_epoch === "number")
                            object.current_epoch = options.longs === String ? String(message.current_epoch) : message.current_epoch;
                        else
                            object.current_epoch = options.longs === String ? $util.Long.prototype.toString.call(message.current_epoch) : options.longs === Number ? new $util.LongBits(message.current_epoch.low >>> 0, message.current_epoch.high >>> 0).toNumber() : message.current_epoch;
                    if (message.current_epoch_start_time != null && message.hasOwnProperty("current_epoch_start_time"))
                        object.current_epoch_start_time = $root.google.protobuf.Timestamp.toObject(message.current_epoch_start_time, options);
                    if (message.epoch_counting_started != null && message.hasOwnProperty("epoch_counting_started"))
                        object.epoch_counting_started = message.epoch_counting_started;
                    if (message.current_epoch_start_height != null && message.hasOwnProperty("current_epoch_start_height"))
                        if (typeof message.current_epoch_start_height === "number")
                            object.current_epoch_start_height = options.longs === String ? String(message.current_epoch_start_height) : message.current_epoch_start_height;
                        else
                            object.current_epoch_start_height = options.longs === String ? $util.Long.prototype.toString.call(message.current_epoch_start_height) : options.longs === Number ? new $util.LongBits(message.current_epoch_start_height.low >>> 0, message.current_epoch_start_height.high >>> 0).toNumber() : message.current_epoch_start_height;
                    return object;
                };
    
                /**
                 * Converts this EpochInfo to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.EpochInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EpochInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EpochInfo;
            })();
    
            epochs.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof ununifi.epochs
                 * @interface IGenesisState
                 * @property {Array.<ununifi.epochs.IEpochInfo>|null} [epochs] GenesisState epochs
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {ununifi.epochs.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.epochs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState epochs.
                 * @member {Array.<ununifi.epochs.IEpochInfo>} epochs
                 * @memberof ununifi.epochs.GenesisState
                 * @instance
                 */
                GenesisState.prototype.epochs = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.epochs.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.GenesisState
                 * @static
                 * @param {ununifi.epochs.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.epochs != null && message.epochs.length)
                        for (var i = 0; i < message.epochs.length; ++i)
                            $root.ununifi.epochs.EpochInfo.encode(message.epochs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.epochs.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.GenesisState
                 * @static
                 * @param {ununifi.epochs.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.epochs && message.epochs.length))
                                message.epochs = [];
                            message.epochs.push($root.ununifi.epochs.EpochInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof ununifi.epochs.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.epochs != null && message.hasOwnProperty("epochs")) {
                        if (!Array.isArray(message.epochs))
                            return "epochs: array expected";
                        for (var i = 0; i < message.epochs.length; ++i) {
                            var error = $root.ununifi.epochs.EpochInfo.verify(message.epochs[i]);
                            if (error)
                                return "epochs." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.GenesisState)
                        return object;
                    var message = new $root.ununifi.epochs.GenesisState();
                    if (object.epochs) {
                        if (!Array.isArray(object.epochs))
                            throw TypeError(".ununifi.epochs.GenesisState.epochs: array expected");
                        message.epochs = [];
                        for (var i = 0; i < object.epochs.length; ++i) {
                            if (typeof object.epochs[i] !== "object")
                                throw TypeError(".ununifi.epochs.GenesisState.epochs: object expected");
                            message.epochs[i] = $root.ununifi.epochs.EpochInfo.fromObject(object.epochs[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.GenesisState
                 * @static
                 * @param {ununifi.epochs.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.epochs = [];
                    if (message.epochs && message.epochs.length) {
                        object.epochs = [];
                        for (var j = 0; j < message.epochs.length; ++j)
                            object.epochs[j] = $root.ununifi.epochs.EpochInfo.toObject(message.epochs[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            epochs.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link ununifi.epochs.Query#epochInfos}.
                 * @memberof ununifi.epochs.Query
                 * @typedef EpochInfosCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.epochs.QueryEpochsInfoResponse} [response] QueryEpochsInfoResponse
                 */
    
                /**
                 * Calls EpochInfos.
                 * @function epochInfos
                 * @memberof ununifi.epochs.Query
                 * @instance
                 * @param {ununifi.epochs.IQueryEpochsInfoRequest} request QueryEpochsInfoRequest message or plain object
                 * @param {ununifi.epochs.Query.EpochInfosCallback} callback Node-style callback called with the error, if any, and QueryEpochsInfoResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.epochInfos = function epochInfos(request, callback) {
                    return this.rpcCall(epochInfos, $root.ununifi.epochs.QueryEpochsInfoRequest, $root.ununifi.epochs.QueryEpochsInfoResponse, request, callback);
                }, "name", { value: "EpochInfos" });
    
                /**
                 * Calls EpochInfos.
                 * @function epochInfos
                 * @memberof ununifi.epochs.Query
                 * @instance
                 * @param {ununifi.epochs.IQueryEpochsInfoRequest} request QueryEpochsInfoRequest message or plain object
                 * @returns {Promise<ununifi.epochs.QueryEpochsInfoResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.epochs.Query#currentEpoch}.
                 * @memberof ununifi.epochs.Query
                 * @typedef CurrentEpochCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.epochs.QueryCurrentEpochResponse} [response] QueryCurrentEpochResponse
                 */
    
                /**
                 * Calls CurrentEpoch.
                 * @function currentEpoch
                 * @memberof ununifi.epochs.Query
                 * @instance
                 * @param {ununifi.epochs.IQueryCurrentEpochRequest} request QueryCurrentEpochRequest message or plain object
                 * @param {ununifi.epochs.Query.CurrentEpochCallback} callback Node-style callback called with the error, if any, and QueryCurrentEpochResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.currentEpoch = function currentEpoch(request, callback) {
                    return this.rpcCall(currentEpoch, $root.ununifi.epochs.QueryCurrentEpochRequest, $root.ununifi.epochs.QueryCurrentEpochResponse, request, callback);
                }, "name", { value: "CurrentEpoch" });
    
                /**
                 * Calls CurrentEpoch.
                 * @function currentEpoch
                 * @memberof ununifi.epochs.Query
                 * @instance
                 * @param {ununifi.epochs.IQueryCurrentEpochRequest} request QueryCurrentEpochRequest message or plain object
                 * @returns {Promise<ununifi.epochs.QueryCurrentEpochResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.epochs.Query#epochInfo}.
                 * @memberof ununifi.epochs.Query
                 * @typedef EpochInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.epochs.QueryEpochInfoResponse} [response] QueryEpochInfoResponse
                 */
    
                /**
                 * Calls EpochInfo.
                 * @function epochInfo
                 * @memberof ununifi.epochs.Query
                 * @instance
                 * @param {ununifi.epochs.IQueryEpochInfoRequest} request QueryEpochInfoRequest message or plain object
                 * @param {ununifi.epochs.Query.EpochInfoCallback} callback Node-style callback called with the error, if any, and QueryEpochInfoResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.epochInfo = function epochInfo(request, callback) {
                    return this.rpcCall(epochInfo, $root.ununifi.epochs.QueryEpochInfoRequest, $root.ununifi.epochs.QueryEpochInfoResponse, request, callback);
                }, "name", { value: "EpochInfo" });
    
                /**
                 * Calls EpochInfo.
                 * @function epochInfo
                 * @memberof ununifi.epochs.Query
                 * @instance
                 * @param {ununifi.epochs.IQueryEpochInfoRequest} request QueryEpochInfoRequest message or plain object
                 * @returns {Promise<ununifi.epochs.QueryEpochInfoResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            epochs.QueryEpochsInfoRequest = (function() {
    
                /**
                 * Properties of a QueryEpochsInfoRequest.
                 * @memberof ununifi.epochs
                 * @interface IQueryEpochsInfoRequest
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryEpochsInfoRequest pagination
                 */
    
                /**
                 * Constructs a new QueryEpochsInfoRequest.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a QueryEpochsInfoRequest.
                 * @implements IQueryEpochsInfoRequest
                 * @constructor
                 * @param {ununifi.epochs.IQueryEpochsInfoRequest=} [properties] Properties to set
                 */
                function QueryEpochsInfoRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEpochsInfoRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @instance
                 */
                QueryEpochsInfoRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryEpochsInfoRequest message. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @static
                 * @param {ununifi.epochs.IQueryEpochsInfoRequest} message QueryEpochsInfoRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochsInfoRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEpochsInfoRequest message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @static
                 * @param {ununifi.epochs.IQueryEpochsInfoRequest} message QueryEpochsInfoRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochsInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEpochsInfoRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.QueryEpochsInfoRequest} QueryEpochsInfoRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochsInfoRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.QueryEpochsInfoRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEpochsInfoRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.QueryEpochsInfoRequest} QueryEpochsInfoRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochsInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEpochsInfoRequest message.
                 * @function verify
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEpochsInfoRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryEpochsInfoRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.QueryEpochsInfoRequest} QueryEpochsInfoRequest
                 */
                QueryEpochsInfoRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.QueryEpochsInfoRequest)
                        return object;
                    var message = new $root.ununifi.epochs.QueryEpochsInfoRequest();
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.epochs.QueryEpochsInfoRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEpochsInfoRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @static
                 * @param {ununifi.epochs.QueryEpochsInfoRequest} message QueryEpochsInfoRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEpochsInfoRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pagination = null;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryEpochsInfoRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.QueryEpochsInfoRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEpochsInfoRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEpochsInfoRequest;
            })();
    
            epochs.QueryEpochsInfoResponse = (function() {
    
                /**
                 * Properties of a QueryEpochsInfoResponse.
                 * @memberof ununifi.epochs
                 * @interface IQueryEpochsInfoResponse
                 * @property {Array.<ununifi.epochs.IEpochInfo>|null} [epochs] QueryEpochsInfoResponse epochs
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryEpochsInfoResponse pagination
                 */
    
                /**
                 * Constructs a new QueryEpochsInfoResponse.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a QueryEpochsInfoResponse.
                 * @implements IQueryEpochsInfoResponse
                 * @constructor
                 * @param {ununifi.epochs.IQueryEpochsInfoResponse=} [properties] Properties to set
                 */
                function QueryEpochsInfoResponse(properties) {
                    this.epochs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEpochsInfoResponse epochs.
                 * @member {Array.<ununifi.epochs.IEpochInfo>} epochs
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @instance
                 */
                QueryEpochsInfoResponse.prototype.epochs = $util.emptyArray;
    
                /**
                 * QueryEpochsInfoResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @instance
                 */
                QueryEpochsInfoResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryEpochsInfoResponse message. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @static
                 * @param {ununifi.epochs.IQueryEpochsInfoResponse} message QueryEpochsInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochsInfoResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.epochs != null && message.epochs.length)
                        for (var i = 0; i < message.epochs.length; ++i)
                            $root.ununifi.epochs.EpochInfo.encode(message.epochs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEpochsInfoResponse message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @static
                 * @param {ununifi.epochs.IQueryEpochsInfoResponse} message QueryEpochsInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochsInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEpochsInfoResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.QueryEpochsInfoResponse} QueryEpochsInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochsInfoResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.QueryEpochsInfoResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.epochs && message.epochs.length))
                                message.epochs = [];
                            message.epochs.push($root.ununifi.epochs.EpochInfo.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEpochsInfoResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.QueryEpochsInfoResponse} QueryEpochsInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochsInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEpochsInfoResponse message.
                 * @function verify
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEpochsInfoResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.epochs != null && message.hasOwnProperty("epochs")) {
                        if (!Array.isArray(message.epochs))
                            return "epochs: array expected";
                        for (var i = 0; i < message.epochs.length; ++i) {
                            var error = $root.ununifi.epochs.EpochInfo.verify(message.epochs[i]);
                            if (error)
                                return "epochs." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryEpochsInfoResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.QueryEpochsInfoResponse} QueryEpochsInfoResponse
                 */
                QueryEpochsInfoResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.QueryEpochsInfoResponse)
                        return object;
                    var message = new $root.ununifi.epochs.QueryEpochsInfoResponse();
                    if (object.epochs) {
                        if (!Array.isArray(object.epochs))
                            throw TypeError(".ununifi.epochs.QueryEpochsInfoResponse.epochs: array expected");
                        message.epochs = [];
                        for (var i = 0; i < object.epochs.length; ++i) {
                            if (typeof object.epochs[i] !== "object")
                                throw TypeError(".ununifi.epochs.QueryEpochsInfoResponse.epochs: object expected");
                            message.epochs[i] = $root.ununifi.epochs.EpochInfo.fromObject(object.epochs[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.epochs.QueryEpochsInfoResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEpochsInfoResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @static
                 * @param {ununifi.epochs.QueryEpochsInfoResponse} message QueryEpochsInfoResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEpochsInfoResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.epochs = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.epochs && message.epochs.length) {
                        object.epochs = [];
                        for (var j = 0; j < message.epochs.length; ++j)
                            object.epochs[j] = $root.ununifi.epochs.EpochInfo.toObject(message.epochs[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryEpochsInfoResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.QueryEpochsInfoResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEpochsInfoResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEpochsInfoResponse;
            })();
    
            epochs.QueryCurrentEpochRequest = (function() {
    
                /**
                 * Properties of a QueryCurrentEpochRequest.
                 * @memberof ununifi.epochs
                 * @interface IQueryCurrentEpochRequest
                 * @property {string|null} [identifier] QueryCurrentEpochRequest identifier
                 */
    
                /**
                 * Constructs a new QueryCurrentEpochRequest.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a QueryCurrentEpochRequest.
                 * @implements IQueryCurrentEpochRequest
                 * @constructor
                 * @param {ununifi.epochs.IQueryCurrentEpochRequest=} [properties] Properties to set
                 */
                function QueryCurrentEpochRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryCurrentEpochRequest identifier.
                 * @member {string} identifier
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @instance
                 */
                QueryCurrentEpochRequest.prototype.identifier = "";
    
                /**
                 * Encodes the specified QueryCurrentEpochRequest message. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @static
                 * @param {ununifi.epochs.IQueryCurrentEpochRequest} message QueryCurrentEpochRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryCurrentEpochRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identifier != null && Object.hasOwnProperty.call(message, "identifier"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.identifier);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryCurrentEpochRequest message, length delimited. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @static
                 * @param {ununifi.epochs.IQueryCurrentEpochRequest} message QueryCurrentEpochRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryCurrentEpochRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryCurrentEpochRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.QueryCurrentEpochRequest} QueryCurrentEpochRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryCurrentEpochRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.QueryCurrentEpochRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.identifier = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryCurrentEpochRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.QueryCurrentEpochRequest} QueryCurrentEpochRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryCurrentEpochRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryCurrentEpochRequest message.
                 * @function verify
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryCurrentEpochRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identifier != null && message.hasOwnProperty("identifier"))
                        if (!$util.isString(message.identifier))
                            return "identifier: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryCurrentEpochRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.QueryCurrentEpochRequest} QueryCurrentEpochRequest
                 */
                QueryCurrentEpochRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.QueryCurrentEpochRequest)
                        return object;
                    var message = new $root.ununifi.epochs.QueryCurrentEpochRequest();
                    if (object.identifier != null)
                        message.identifier = String(object.identifier);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryCurrentEpochRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @static
                 * @param {ununifi.epochs.QueryCurrentEpochRequest} message QueryCurrentEpochRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryCurrentEpochRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.identifier = "";
                    if (message.identifier != null && message.hasOwnProperty("identifier"))
                        object.identifier = message.identifier;
                    return object;
                };
    
                /**
                 * Converts this QueryCurrentEpochRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.QueryCurrentEpochRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryCurrentEpochRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryCurrentEpochRequest;
            })();
    
            epochs.QueryCurrentEpochResponse = (function() {
    
                /**
                 * Properties of a QueryCurrentEpochResponse.
                 * @memberof ununifi.epochs
                 * @interface IQueryCurrentEpochResponse
                 * @property {Long|null} [current_epoch] QueryCurrentEpochResponse current_epoch
                 */
    
                /**
                 * Constructs a new QueryCurrentEpochResponse.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a QueryCurrentEpochResponse.
                 * @implements IQueryCurrentEpochResponse
                 * @constructor
                 * @param {ununifi.epochs.IQueryCurrentEpochResponse=} [properties] Properties to set
                 */
                function QueryCurrentEpochResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryCurrentEpochResponse current_epoch.
                 * @member {Long} current_epoch
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @instance
                 */
                QueryCurrentEpochResponse.prototype.current_epoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Encodes the specified QueryCurrentEpochResponse message. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @static
                 * @param {ununifi.epochs.IQueryCurrentEpochResponse} message QueryCurrentEpochResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryCurrentEpochResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.current_epoch != null && Object.hasOwnProperty.call(message, "current_epoch"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.current_epoch);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryCurrentEpochResponse message, length delimited. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @static
                 * @param {ununifi.epochs.IQueryCurrentEpochResponse} message QueryCurrentEpochResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryCurrentEpochResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryCurrentEpochResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.QueryCurrentEpochResponse} QueryCurrentEpochResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryCurrentEpochResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.QueryCurrentEpochResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.current_epoch = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryCurrentEpochResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.QueryCurrentEpochResponse} QueryCurrentEpochResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryCurrentEpochResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryCurrentEpochResponse message.
                 * @function verify
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryCurrentEpochResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.current_epoch != null && message.hasOwnProperty("current_epoch"))
                        if (!$util.isInteger(message.current_epoch) && !(message.current_epoch && $util.isInteger(message.current_epoch.low) && $util.isInteger(message.current_epoch.high)))
                            return "current_epoch: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryCurrentEpochResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.QueryCurrentEpochResponse} QueryCurrentEpochResponse
                 */
                QueryCurrentEpochResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.QueryCurrentEpochResponse)
                        return object;
                    var message = new $root.ununifi.epochs.QueryCurrentEpochResponse();
                    if (object.current_epoch != null)
                        if ($util.Long)
                            (message.current_epoch = $util.Long.fromValue(object.current_epoch)).unsigned = false;
                        else if (typeof object.current_epoch === "string")
                            message.current_epoch = parseInt(object.current_epoch, 10);
                        else if (typeof object.current_epoch === "number")
                            message.current_epoch = object.current_epoch;
                        else if (typeof object.current_epoch === "object")
                            message.current_epoch = new $util.LongBits(object.current_epoch.low >>> 0, object.current_epoch.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryCurrentEpochResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @static
                 * @param {ununifi.epochs.QueryCurrentEpochResponse} message QueryCurrentEpochResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryCurrentEpochResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.current_epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.current_epoch = options.longs === String ? "0" : 0;
                    if (message.current_epoch != null && message.hasOwnProperty("current_epoch"))
                        if (typeof message.current_epoch === "number")
                            object.current_epoch = options.longs === String ? String(message.current_epoch) : message.current_epoch;
                        else
                            object.current_epoch = options.longs === String ? $util.Long.prototype.toString.call(message.current_epoch) : options.longs === Number ? new $util.LongBits(message.current_epoch.low >>> 0, message.current_epoch.high >>> 0).toNumber() : message.current_epoch;
                    return object;
                };
    
                /**
                 * Converts this QueryCurrentEpochResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.QueryCurrentEpochResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryCurrentEpochResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryCurrentEpochResponse;
            })();
    
            epochs.QueryEpochInfoRequest = (function() {
    
                /**
                 * Properties of a QueryEpochInfoRequest.
                 * @memberof ununifi.epochs
                 * @interface IQueryEpochInfoRequest
                 * @property {string|null} [identifier] QueryEpochInfoRequest identifier
                 */
    
                /**
                 * Constructs a new QueryEpochInfoRequest.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a QueryEpochInfoRequest.
                 * @implements IQueryEpochInfoRequest
                 * @constructor
                 * @param {ununifi.epochs.IQueryEpochInfoRequest=} [properties] Properties to set
                 */
                function QueryEpochInfoRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEpochInfoRequest identifier.
                 * @member {string} identifier
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @instance
                 */
                QueryEpochInfoRequest.prototype.identifier = "";
    
                /**
                 * Encodes the specified QueryEpochInfoRequest message. Does not implicitly {@link ununifi.epochs.QueryEpochInfoRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @static
                 * @param {ununifi.epochs.IQueryEpochInfoRequest} message QueryEpochInfoRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochInfoRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identifier != null && Object.hasOwnProperty.call(message, "identifier"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.identifier);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEpochInfoRequest message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochInfoRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @static
                 * @param {ununifi.epochs.IQueryEpochInfoRequest} message QueryEpochInfoRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEpochInfoRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.QueryEpochInfoRequest} QueryEpochInfoRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochInfoRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.QueryEpochInfoRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.identifier = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEpochInfoRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.QueryEpochInfoRequest} QueryEpochInfoRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEpochInfoRequest message.
                 * @function verify
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEpochInfoRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identifier != null && message.hasOwnProperty("identifier"))
                        if (!$util.isString(message.identifier))
                            return "identifier: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryEpochInfoRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.QueryEpochInfoRequest} QueryEpochInfoRequest
                 */
                QueryEpochInfoRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.QueryEpochInfoRequest)
                        return object;
                    var message = new $root.ununifi.epochs.QueryEpochInfoRequest();
                    if (object.identifier != null)
                        message.identifier = String(object.identifier);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEpochInfoRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @static
                 * @param {ununifi.epochs.QueryEpochInfoRequest} message QueryEpochInfoRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEpochInfoRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.identifier = "";
                    if (message.identifier != null && message.hasOwnProperty("identifier"))
                        object.identifier = message.identifier;
                    return object;
                };
    
                /**
                 * Converts this QueryEpochInfoRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.QueryEpochInfoRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEpochInfoRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEpochInfoRequest;
            })();
    
            epochs.QueryEpochInfoResponse = (function() {
    
                /**
                 * Properties of a QueryEpochInfoResponse.
                 * @memberof ununifi.epochs
                 * @interface IQueryEpochInfoResponse
                 * @property {ununifi.epochs.IEpochInfo|null} [epoch] QueryEpochInfoResponse epoch
                 */
    
                /**
                 * Constructs a new QueryEpochInfoResponse.
                 * @memberof ununifi.epochs
                 * @classdesc Represents a QueryEpochInfoResponse.
                 * @implements IQueryEpochInfoResponse
                 * @constructor
                 * @param {ununifi.epochs.IQueryEpochInfoResponse=} [properties] Properties to set
                 */
                function QueryEpochInfoResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEpochInfoResponse epoch.
                 * @member {ununifi.epochs.IEpochInfo|null|undefined} epoch
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @instance
                 */
                QueryEpochInfoResponse.prototype.epoch = null;
    
                /**
                 * Encodes the specified QueryEpochInfoResponse message. Does not implicitly {@link ununifi.epochs.QueryEpochInfoResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @static
                 * @param {ununifi.epochs.IQueryEpochInfoResponse} message QueryEpochInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochInfoResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.epoch != null && Object.hasOwnProperty.call(message, "epoch"))
                        $root.ununifi.epochs.EpochInfo.encode(message.epoch, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEpochInfoResponse message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochInfoResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @static
                 * @param {ununifi.epochs.IQueryEpochInfoResponse} message QueryEpochInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEpochInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEpochInfoResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.epochs.QueryEpochInfoResponse} QueryEpochInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochInfoResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.epochs.QueryEpochInfoResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.epoch = $root.ununifi.epochs.EpochInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEpochInfoResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.epochs.QueryEpochInfoResponse} QueryEpochInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEpochInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEpochInfoResponse message.
                 * @function verify
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEpochInfoResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.epoch != null && message.hasOwnProperty("epoch")) {
                        var error = $root.ununifi.epochs.EpochInfo.verify(message.epoch);
                        if (error)
                            return "epoch." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryEpochInfoResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.epochs.QueryEpochInfoResponse} QueryEpochInfoResponse
                 */
                QueryEpochInfoResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.epochs.QueryEpochInfoResponse)
                        return object;
                    var message = new $root.ununifi.epochs.QueryEpochInfoResponse();
                    if (object.epoch != null) {
                        if (typeof object.epoch !== "object")
                            throw TypeError(".ununifi.epochs.QueryEpochInfoResponse.epoch: object expected");
                        message.epoch = $root.ununifi.epochs.EpochInfo.fromObject(object.epoch);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEpochInfoResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @static
                 * @param {ununifi.epochs.QueryEpochInfoResponse} message QueryEpochInfoResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEpochInfoResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.epoch = null;
                    if (message.epoch != null && message.hasOwnProperty("epoch"))
                        object.epoch = $root.ununifi.epochs.EpochInfo.toObject(message.epoch, options);
                    return object;
                };
    
                /**
                 * Converts this QueryEpochInfoResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.epochs.QueryEpochInfoResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEpochInfoResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEpochInfoResponse;
            })();
    
            return epochs;
        })();
    
        ununifi.nft = (function() {
    
            /**
             * Namespace nft.
             * @memberof ununifi
             * @namespace
             */
            var nft = {};
    
            nft.ClassData = (function() {
    
                /**
                 * Properties of a ClassData.
                 * @memberof ununifi.nft
                 * @interface IClassData
                 * @property {string|null} [send_prehook_contract] ClassData send_prehook_contract
                 */
    
                /**
                 * Constructs a new ClassData.
                 * @memberof ununifi.nft
                 * @classdesc Represents a ClassData.
                 * @implements IClassData
                 * @constructor
                 * @param {ununifi.nft.IClassData=} [properties] Properties to set
                 */
                function ClassData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ClassData send_prehook_contract.
                 * @member {string} send_prehook_contract
                 * @memberof ununifi.nft.ClassData
                 * @instance
                 */
                ClassData.prototype.send_prehook_contract = "";
    
                /**
                 * Encodes the specified ClassData message. Does not implicitly {@link ununifi.nft.ClassData.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nft.ClassData
                 * @static
                 * @param {ununifi.nft.IClassData} message ClassData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClassData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.send_prehook_contract != null && Object.hasOwnProperty.call(message, "send_prehook_contract"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.send_prehook_contract);
                    return writer;
                };
    
                /**
                 * Encodes the specified ClassData message, length delimited. Does not implicitly {@link ununifi.nft.ClassData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nft.ClassData
                 * @static
                 * @param {ununifi.nft.IClassData} message ClassData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClassData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ClassData message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nft.ClassData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nft.ClassData} ClassData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClassData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nft.ClassData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.send_prehook_contract = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ClassData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nft.ClassData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nft.ClassData} ClassData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClassData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ClassData message.
                 * @function verify
                 * @memberof ununifi.nft.ClassData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClassData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.send_prehook_contract != null && message.hasOwnProperty("send_prehook_contract"))
                        if (!$util.isString(message.send_prehook_contract))
                            return "send_prehook_contract: string expected";
                    return null;
                };
    
                /**
                 * Creates a ClassData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nft.ClassData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nft.ClassData} ClassData
                 */
                ClassData.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nft.ClassData)
                        return object;
                    var message = new $root.ununifi.nft.ClassData();
                    if (object.send_prehook_contract != null)
                        message.send_prehook_contract = String(object.send_prehook_contract);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ClassData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nft.ClassData
                 * @static
                 * @param {ununifi.nft.ClassData} message ClassData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClassData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.send_prehook_contract = "";
                    if (message.send_prehook_contract != null && message.hasOwnProperty("send_prehook_contract"))
                        object.send_prehook_contract = message.send_prehook_contract;
                    return object;
                };
    
                /**
                 * Converts this ClassData to JSON.
                 * @function toJSON
                 * @memberof ununifi.nft.ClassData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClassData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ClassData;
            })();
    
            nft.NftData = (function() {
    
                /**
                 * Properties of a NftData.
                 * @memberof ununifi.nft
                 * @interface INftData
                 * @property {boolean|null} [send_disabled] NftData send_disabled
                 */
    
                /**
                 * Constructs a new NftData.
                 * @memberof ununifi.nft
                 * @classdesc Represents a NftData.
                 * @implements INftData
                 * @constructor
                 * @param {ununifi.nft.INftData=} [properties] Properties to set
                 */
                function NftData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NftData send_disabled.
                 * @member {boolean} send_disabled
                 * @memberof ununifi.nft.NftData
                 * @instance
                 */
                NftData.prototype.send_disabled = false;
    
                /**
                 * Encodes the specified NftData message. Does not implicitly {@link ununifi.nft.NftData.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nft.NftData
                 * @static
                 * @param {ununifi.nft.INftData} message NftData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.send_disabled != null && Object.hasOwnProperty.call(message, "send_disabled"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.send_disabled);
                    return writer;
                };
    
                /**
                 * Encodes the specified NftData message, length delimited. Does not implicitly {@link ununifi.nft.NftData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nft.NftData
                 * @static
                 * @param {ununifi.nft.INftData} message NftData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NftData message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nft.NftData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nft.NftData} NftData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nft.NftData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.send_disabled = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NftData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nft.NftData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nft.NftData} NftData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NftData message.
                 * @function verify
                 * @memberof ununifi.nft.NftData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NftData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.send_disabled != null && message.hasOwnProperty("send_disabled"))
                        if (typeof message.send_disabled !== "boolean")
                            return "send_disabled: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a NftData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nft.NftData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nft.NftData} NftData
                 */
                NftData.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nft.NftData)
                        return object;
                    var message = new $root.ununifi.nft.NftData();
                    if (object.send_disabled != null)
                        message.send_disabled = Boolean(object.send_disabled);
                    return message;
                };
    
                /**
                 * Creates a plain object from a NftData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nft.NftData
                 * @static
                 * @param {ununifi.nft.NftData} message NftData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NftData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.send_disabled = false;
                    if (message.send_disabled != null && message.hasOwnProperty("send_disabled"))
                        object.send_disabled = message.send_disabled;
                    return object;
                };
    
                /**
                 * Converts this NftData to JSON.
                 * @function toJSON
                 * @memberof ununifi.nft.NftData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NftData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NftData;
            })();
    
            return nft;
        })();
    
        ununifi.nftbackedloan = (function() {
    
            /**
             * Namespace nftbackedloan.
             * @memberof ununifi
             * @namespace
             */
            var nftbackedloan = {};
    
            nftbackedloan.Msg = (function() {
    
                /**
                 * Constructs a new Msg service.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Msg
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Msg(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#listNft}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef ListNftCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgListNftResponse} [response] MsgListNftResponse
                 */
    
                /**
                 * Calls ListNft.
                 * @function listNft
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgListNft} request MsgListNft message or plain object
                 * @param {ununifi.nftbackedloan.Msg.ListNftCallback} callback Node-style callback called with the error, if any, and MsgListNftResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.listNft = function listNft(request, callback) {
                    return this.rpcCall(listNft, $root.ununifi.nftbackedloan.MsgListNft, $root.ununifi.nftbackedloan.MsgListNftResponse, request, callback);
                }, "name", { value: "ListNft" });
    
                /**
                 * Calls ListNft.
                 * @function listNft
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgListNft} request MsgListNft message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgListNftResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#cancelListing}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef CancelListingCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgCancelListingResponse} [response] MsgCancelListingResponse
                 */
    
                /**
                 * Calls CancelListing.
                 * @function cancelListing
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgCancelListing} request MsgCancelListing message or plain object
                 * @param {ununifi.nftbackedloan.Msg.CancelListingCallback} callback Node-style callback called with the error, if any, and MsgCancelListingResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.cancelListing = function cancelListing(request, callback) {
                    return this.rpcCall(cancelListing, $root.ununifi.nftbackedloan.MsgCancelListing, $root.ununifi.nftbackedloan.MsgCancelListingResponse, request, callback);
                }, "name", { value: "CancelListing" });
    
                /**
                 * Calls CancelListing.
                 * @function cancelListing
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgCancelListing} request MsgCancelListing message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgCancelListingResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#placeBid}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef PlaceBidCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgPlaceBidResponse} [response] MsgPlaceBidResponse
                 */
    
                /**
                 * Calls PlaceBid.
                 * @function placeBid
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgPlaceBid} request MsgPlaceBid message or plain object
                 * @param {ununifi.nftbackedloan.Msg.PlaceBidCallback} callback Node-style callback called with the error, if any, and MsgPlaceBidResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.placeBid = function placeBid(request, callback) {
                    return this.rpcCall(placeBid, $root.ununifi.nftbackedloan.MsgPlaceBid, $root.ununifi.nftbackedloan.MsgPlaceBidResponse, request, callback);
                }, "name", { value: "PlaceBid" });
    
                /**
                 * Calls PlaceBid.
                 * @function placeBid
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgPlaceBid} request MsgPlaceBid message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgPlaceBidResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#cancelBid}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef CancelBidCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgCancelBidResponse} [response] MsgCancelBidResponse
                 */
    
                /**
                 * Calls CancelBid.
                 * @function cancelBid
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgCancelBid} request MsgCancelBid message or plain object
                 * @param {ununifi.nftbackedloan.Msg.CancelBidCallback} callback Node-style callback called with the error, if any, and MsgCancelBidResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.cancelBid = function cancelBid(request, callback) {
                    return this.rpcCall(cancelBid, $root.ununifi.nftbackedloan.MsgCancelBid, $root.ununifi.nftbackedloan.MsgCancelBidResponse, request, callback);
                }, "name", { value: "CancelBid" });
    
                /**
                 * Calls CancelBid.
                 * @function cancelBid
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgCancelBid} request MsgCancelBid message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgCancelBidResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#sellingDecision}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef SellingDecisionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgSellingDecisionResponse} [response] MsgSellingDecisionResponse
                 */
    
                /**
                 * Calls SellingDecision.
                 * @function sellingDecision
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgSellingDecision} request MsgSellingDecision message or plain object
                 * @param {ununifi.nftbackedloan.Msg.SellingDecisionCallback} callback Node-style callback called with the error, if any, and MsgSellingDecisionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.sellingDecision = function sellingDecision(request, callback) {
                    return this.rpcCall(sellingDecision, $root.ununifi.nftbackedloan.MsgSellingDecision, $root.ununifi.nftbackedloan.MsgSellingDecisionResponse, request, callback);
                }, "name", { value: "SellingDecision" });
    
                /**
                 * Calls SellingDecision.
                 * @function sellingDecision
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgSellingDecision} request MsgSellingDecision message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgSellingDecisionResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#payRemainder}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef PayRemainderCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgPayRemainderResponse} [response] MsgPayRemainderResponse
                 */
    
                /**
                 * Calls PayRemainder.
                 * @function payRemainder
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgPayRemainder} request MsgPayRemainder message or plain object
                 * @param {ununifi.nftbackedloan.Msg.PayRemainderCallback} callback Node-style callback called with the error, if any, and MsgPayRemainderResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.payRemainder = function payRemainder(request, callback) {
                    return this.rpcCall(payRemainder, $root.ununifi.nftbackedloan.MsgPayRemainder, $root.ununifi.nftbackedloan.MsgPayRemainderResponse, request, callback);
                }, "name", { value: "PayRemainder" });
    
                /**
                 * Calls PayRemainder.
                 * @function payRemainder
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgPayRemainder} request MsgPayRemainder message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgPayRemainderResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#borrow}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef BorrowCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgBorrowResponse} [response] MsgBorrowResponse
                 */
    
                /**
                 * Calls Borrow.
                 * @function borrow
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgBorrow} request MsgBorrow message or plain object
                 * @param {ununifi.nftbackedloan.Msg.BorrowCallback} callback Node-style callback called with the error, if any, and MsgBorrowResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.borrow = function borrow(request, callback) {
                    return this.rpcCall(borrow, $root.ununifi.nftbackedloan.MsgBorrow, $root.ununifi.nftbackedloan.MsgBorrowResponse, request, callback);
                }, "name", { value: "Borrow" });
    
                /**
                 * Calls Borrow.
                 * @function borrow
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgBorrow} request MsgBorrow message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgBorrowResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Msg#repay}.
                 * @memberof ununifi.nftbackedloan.Msg
                 * @typedef RepayCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.MsgRepayResponse} [response] MsgRepayResponse
                 */
    
                /**
                 * Calls Repay.
                 * @function repay
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgRepay} request MsgRepay message or plain object
                 * @param {ununifi.nftbackedloan.Msg.RepayCallback} callback Node-style callback called with the error, if any, and MsgRepayResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.repay = function repay(request, callback) {
                    return this.rpcCall(repay, $root.ununifi.nftbackedloan.MsgRepay, $root.ununifi.nftbackedloan.MsgRepayResponse, request, callback);
                }, "name", { value: "Repay" });
    
                /**
                 * Calls Repay.
                 * @function repay
                 * @memberof ununifi.nftbackedloan.Msg
                 * @instance
                 * @param {ununifi.nftbackedloan.IMsgRepay} request MsgRepay message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.MsgRepayResponse>} Promise
                 * @variation 2
                 */
    
                return Msg;
            })();
    
            nftbackedloan.MsgListNft = (function() {
    
                /**
                 * Properties of a MsgListNft.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgListNft
                 * @property {string|null} [sender] MsgListNft sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgListNft nft_id
                 * @property {string|null} [bid_denom] MsgListNft bid_denom
                 * @property {string|null} [min_deposit_rate] MsgListNft min_deposit_rate
                 * @property {google.protobuf.IDuration|null} [min_bid_period] MsgListNft min_bid_period
                 */
    
                /**
                 * Constructs a new MsgListNft.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgListNft.
                 * @implements IMsgListNft
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgListNft=} [properties] Properties to set
                 */
                function MsgListNft(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgListNft sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @instance
                 */
                MsgListNft.prototype.sender = "";
    
                /**
                 * MsgListNft nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @instance
                 */
                MsgListNft.prototype.nft_id = null;
    
                /**
                 * MsgListNft bid_denom.
                 * @member {string} bid_denom
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @instance
                 */
                MsgListNft.prototype.bid_denom = "";
    
                /**
                 * MsgListNft min_deposit_rate.
                 * @member {string} min_deposit_rate
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @instance
                 */
                MsgListNft.prototype.min_deposit_rate = "";
    
                /**
                 * MsgListNft min_bid_period.
                 * @member {google.protobuf.IDuration|null|undefined} min_bid_period
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @instance
                 */
                MsgListNft.prototype.min_bid_period = null;
    
                /**
                 * Encodes the specified MsgListNft message. Does not implicitly {@link ununifi.nftbackedloan.MsgListNft.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgListNft} message MsgListNft message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgListNft.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.bid_denom != null && Object.hasOwnProperty.call(message, "bid_denom"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.bid_denom);
                    if (message.min_deposit_rate != null && Object.hasOwnProperty.call(message, "min_deposit_rate"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.min_deposit_rate);
                    if (message.min_bid_period != null && Object.hasOwnProperty.call(message, "min_bid_period"))
                        $root.google.protobuf.Duration.encode(message.min_bid_period, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgListNft message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgListNft.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgListNft} message MsgListNft message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgListNft.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgListNft message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgListNft} MsgListNft
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgListNft.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgListNft();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.bid_denom = reader.string();
                            break;
                        case 4:
                            message.min_deposit_rate = reader.string();
                            break;
                        case 5:
                            message.min_bid_period = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgListNft message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgListNft} MsgListNft
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgListNft.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgListNft message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgListNft.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    if (message.bid_denom != null && message.hasOwnProperty("bid_denom"))
                        if (!$util.isString(message.bid_denom))
                            return "bid_denom: string expected";
                    if (message.min_deposit_rate != null && message.hasOwnProperty("min_deposit_rate"))
                        if (!$util.isString(message.min_deposit_rate))
                            return "min_deposit_rate: string expected";
                    if (message.min_bid_period != null && message.hasOwnProperty("min_bid_period")) {
                        var error = $root.google.protobuf.Duration.verify(message.min_bid_period);
                        if (error)
                            return "min_bid_period." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgListNft message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgListNft} MsgListNft
                 */
                MsgListNft.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgListNft)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgListNft();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgListNft.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    if (object.bid_denom != null)
                        message.bid_denom = String(object.bid_denom);
                    if (object.min_deposit_rate != null)
                        message.min_deposit_rate = String(object.min_deposit_rate);
                    if (object.min_bid_period != null) {
                        if (typeof object.min_bid_period !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgListNft.min_bid_period: object expected");
                        message.min_bid_period = $root.google.protobuf.Duration.fromObject(object.min_bid_period);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgListNft message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @static
                 * @param {ununifi.nftbackedloan.MsgListNft} message MsgListNft
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgListNft.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                        object.bid_denom = "";
                        object.min_deposit_rate = "";
                        object.min_bid_period = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    if (message.bid_denom != null && message.hasOwnProperty("bid_denom"))
                        object.bid_denom = message.bid_denom;
                    if (message.min_deposit_rate != null && message.hasOwnProperty("min_deposit_rate"))
                        object.min_deposit_rate = message.min_deposit_rate;
                    if (message.min_bid_period != null && message.hasOwnProperty("min_bid_period"))
                        object.min_bid_period = $root.google.protobuf.Duration.toObject(message.min_bid_period, options);
                    return object;
                };
    
                /**
                 * Converts this MsgListNft to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgListNft
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgListNft.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgListNft;
            })();
    
            nftbackedloan.MsgListNftResponse = (function() {
    
                /**
                 * Properties of a MsgListNftResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgListNftResponse
                 */
    
                /**
                 * Constructs a new MsgListNftResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgListNftResponse.
                 * @implements IMsgListNftResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgListNftResponse=} [properties] Properties to set
                 */
                function MsgListNftResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgListNftResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgListNftResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgListNftResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgListNftResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgListNftResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgListNftResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgListNftResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgListNftResponse} MsgListNftResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgListNftResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgListNftResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgListNftResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgListNftResponse} MsgListNftResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgListNftResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgListNftResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgListNftResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgListNftResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgListNftResponse} MsgListNftResponse
                 */
                MsgListNftResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgListNftResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgListNftResponse();
                };
    
                /**
                 * Creates a plain object from a MsgListNftResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgListNftResponse} message MsgListNftResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgListNftResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgListNftResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgListNftResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgListNftResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgListNftResponse;
            })();
    
            nftbackedloan.MsgCancelListing = (function() {
    
                /**
                 * Properties of a MsgCancelListing.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgCancelListing
                 * @property {string|null} [sender] MsgCancelListing sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgCancelListing nft_id
                 */
    
                /**
                 * Constructs a new MsgCancelListing.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgCancelListing.
                 * @implements IMsgCancelListing
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgCancelListing=} [properties] Properties to set
                 */
                function MsgCancelListing(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgCancelListing sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @instance
                 */
                MsgCancelListing.prototype.sender = "";
    
                /**
                 * MsgCancelListing nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @instance
                 */
                MsgCancelListing.prototype.nft_id = null;
    
                /**
                 * Encodes the specified MsgCancelListing message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListing.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelListing} message MsgCancelListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelListing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCancelListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelListing} message MsgCancelListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelListing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCancelListing message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgCancelListing} MsgCancelListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelListing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgCancelListing();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCancelListing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgCancelListing} MsgCancelListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelListing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCancelListing message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCancelListing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgCancelListing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgCancelListing} MsgCancelListing
                 */
                MsgCancelListing.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgCancelListing)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgCancelListing();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgCancelListing.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgCancelListing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @static
                 * @param {ununifi.nftbackedloan.MsgCancelListing} message MsgCancelListing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCancelListing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    return object;
                };
    
                /**
                 * Converts this MsgCancelListing to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgCancelListing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCancelListing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCancelListing;
            })();
    
            nftbackedloan.MsgCancelListingResponse = (function() {
    
                /**
                 * Properties of a MsgCancelListingResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgCancelListingResponse
                 */
    
                /**
                 * Constructs a new MsgCancelListingResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgCancelListingResponse.
                 * @implements IMsgCancelListingResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgCancelListingResponse=} [properties] Properties to set
                 */
                function MsgCancelListingResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgCancelListingResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListingResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelListingResponse} message MsgCancelListingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelListingResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCancelListingResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListingResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelListingResponse} message MsgCancelListingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCancelListingResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgCancelListingResponse} MsgCancelListingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelListingResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgCancelListingResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCancelListingResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgCancelListingResponse} MsgCancelListingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelListingResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCancelListingResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCancelListingResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgCancelListingResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgCancelListingResponse} MsgCancelListingResponse
                 */
                MsgCancelListingResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgCancelListingResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgCancelListingResponse();
                };
    
                /**
                 * Creates a plain object from a MsgCancelListingResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgCancelListingResponse} message MsgCancelListingResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCancelListingResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgCancelListingResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCancelListingResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCancelListingResponse;
            })();
    
            nftbackedloan.MsgPlaceBid = (function() {
    
                /**
                 * Properties of a MsgPlaceBid.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgPlaceBid
                 * @property {string|null} [sender] MsgPlaceBid sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgPlaceBid nft_id
                 * @property {cosmos.base.v1beta1.ICoin|null} [price] MsgPlaceBid price
                 * @property {google.protobuf.ITimestamp|null} [expiry] MsgPlaceBid expiry
                 * @property {string|null} [interest_rate] MsgPlaceBid interest_rate
                 * @property {boolean|null} [automatic_payment] MsgPlaceBid automatic_payment
                 * @property {cosmos.base.v1beta1.ICoin|null} [deposit] MsgPlaceBid deposit
                 */
    
                /**
                 * Constructs a new MsgPlaceBid.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgPlaceBid.
                 * @implements IMsgPlaceBid
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgPlaceBid=} [properties] Properties to set
                 */
                function MsgPlaceBid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgPlaceBid sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 */
                MsgPlaceBid.prototype.sender = "";
    
                /**
                 * MsgPlaceBid nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 */
                MsgPlaceBid.prototype.nft_id = null;
    
                /**
                 * MsgPlaceBid price.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} price
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 */
                MsgPlaceBid.prototype.price = null;
    
                /**
                 * MsgPlaceBid expiry.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiry
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 */
                MsgPlaceBid.prototype.expiry = null;
    
                /**
                 * MsgPlaceBid interest_rate.
                 * @member {string} interest_rate
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 */
                MsgPlaceBid.prototype.interest_rate = "";
    
                /**
                 * MsgPlaceBid automatic_payment.
                 * @member {boolean} automatic_payment
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 */
                MsgPlaceBid.prototype.automatic_payment = false;
    
                /**
                 * MsgPlaceBid deposit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 */
                MsgPlaceBid.prototype.deposit = null;
    
                /**
                 * Encodes the specified MsgPlaceBid message. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBid.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPlaceBid.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.price, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                        $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.interest_rate != null && Object.hasOwnProperty.call(message, "interest_rate"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.interest_rate);
                    if (message.automatic_payment != null && Object.hasOwnProperty.call(message, "automatic_payment"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.automatic_payment);
                    if (message.deposit != null && Object.hasOwnProperty.call(message, "deposit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.deposit, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBid.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgPlaceBid message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgPlaceBid} MsgPlaceBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPlaceBid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgPlaceBid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.price = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.interest_rate = reader.string();
                            break;
                        case 6:
                            message.automatic_payment = reader.bool();
                            break;
                        case 7:
                            message.deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgPlaceBid message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgPlaceBid} MsgPlaceBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPlaceBid.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgPlaceBid message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgPlaceBid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    if (message.price != null && message.hasOwnProperty("price")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.price);
                        if (error)
                            return "price." + error;
                    }
                    if (message.expiry != null && message.hasOwnProperty("expiry")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiry);
                        if (error)
                            return "expiry." + error;
                    }
                    if (message.interest_rate != null && message.hasOwnProperty("interest_rate"))
                        if (!$util.isString(message.interest_rate))
                            return "interest_rate: string expected";
                    if (message.automatic_payment != null && message.hasOwnProperty("automatic_payment"))
                        if (typeof message.automatic_payment !== "boolean")
                            return "automatic_payment: boolean expected";
                    if (message.deposit != null && message.hasOwnProperty("deposit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit);
                        if (error)
                            return "deposit." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgPlaceBid message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgPlaceBid} MsgPlaceBid
                 */
                MsgPlaceBid.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgPlaceBid)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgPlaceBid();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgPlaceBid.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    if (object.price != null) {
                        if (typeof object.price !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgPlaceBid.price: object expected");
                        message.price = $root.cosmos.base.v1beta1.Coin.fromObject(object.price);
                    }
                    if (object.expiry != null) {
                        if (typeof object.expiry !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgPlaceBid.expiry: object expected");
                        message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
                    }
                    if (object.interest_rate != null)
                        message.interest_rate = String(object.interest_rate);
                    if (object.automatic_payment != null)
                        message.automatic_payment = Boolean(object.automatic_payment);
                    if (object.deposit != null) {
                        if (typeof object.deposit !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgPlaceBid.deposit: object expected");
                        message.deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgPlaceBid message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @static
                 * @param {ununifi.nftbackedloan.MsgPlaceBid} message MsgPlaceBid
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgPlaceBid.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                        object.price = null;
                        object.expiry = null;
                        object.interest_rate = "";
                        object.automatic_payment = false;
                        object.deposit = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    if (message.price != null && message.hasOwnProperty("price"))
                        object.price = $root.cosmos.base.v1beta1.Coin.toObject(message.price, options);
                    if (message.expiry != null && message.hasOwnProperty("expiry"))
                        object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
                    if (message.interest_rate != null && message.hasOwnProperty("interest_rate"))
                        object.interest_rate = message.interest_rate;
                    if (message.automatic_payment != null && message.hasOwnProperty("automatic_payment"))
                        object.automatic_payment = message.automatic_payment;
                    if (message.deposit != null && message.hasOwnProperty("deposit"))
                        object.deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit, options);
                    return object;
                };
    
                /**
                 * Converts this MsgPlaceBid to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgPlaceBid
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgPlaceBid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgPlaceBid;
            })();
    
            nftbackedloan.MsgPlaceBidResponse = (function() {
    
                /**
                 * Properties of a MsgPlaceBidResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgPlaceBidResponse
                 */
    
                /**
                 * Constructs a new MsgPlaceBidResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgPlaceBidResponse.
                 * @implements IMsgPlaceBidResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgPlaceBidResponse=} [properties] Properties to set
                 */
                function MsgPlaceBidResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgPlaceBidResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBidResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPlaceBidResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgPlaceBidResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBidResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPlaceBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgPlaceBidResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgPlaceBidResponse} MsgPlaceBidResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPlaceBidResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgPlaceBidResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgPlaceBidResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgPlaceBidResponse} MsgPlaceBidResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPlaceBidResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgPlaceBidResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgPlaceBidResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgPlaceBidResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgPlaceBidResponse} MsgPlaceBidResponse
                 */
                MsgPlaceBidResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgPlaceBidResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgPlaceBidResponse();
                };
    
                /**
                 * Creates a plain object from a MsgPlaceBidResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgPlaceBidResponse} message MsgPlaceBidResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgPlaceBidResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgPlaceBidResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgPlaceBidResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgPlaceBidResponse;
            })();
    
            nftbackedloan.MsgCancelBid = (function() {
    
                /**
                 * Properties of a MsgCancelBid.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgCancelBid
                 * @property {string|null} [sender] MsgCancelBid sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgCancelBid nft_id
                 */
    
                /**
                 * Constructs a new MsgCancelBid.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgCancelBid.
                 * @implements IMsgCancelBid
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgCancelBid=} [properties] Properties to set
                 */
                function MsgCancelBid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgCancelBid sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @instance
                 */
                MsgCancelBid.prototype.sender = "";
    
                /**
                 * MsgCancelBid nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @instance
                 */
                MsgCancelBid.prototype.nft_id = null;
    
                /**
                 * Encodes the specified MsgCancelBid message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBid.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelBid} message MsgCancelBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelBid.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCancelBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBid.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelBid} message MsgCancelBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCancelBid message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgCancelBid} MsgCancelBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelBid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgCancelBid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCancelBid message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgCancelBid} MsgCancelBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelBid.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCancelBid message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCancelBid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgCancelBid message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgCancelBid} MsgCancelBid
                 */
                MsgCancelBid.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgCancelBid)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgCancelBid();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgCancelBid.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgCancelBid message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @static
                 * @param {ununifi.nftbackedloan.MsgCancelBid} message MsgCancelBid
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCancelBid.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    return object;
                };
    
                /**
                 * Converts this MsgCancelBid to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgCancelBid
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCancelBid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCancelBid;
            })();
    
            nftbackedloan.MsgCancelBidResponse = (function() {
    
                /**
                 * Properties of a MsgCancelBidResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgCancelBidResponse
                 */
    
                /**
                 * Constructs a new MsgCancelBidResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgCancelBidResponse.
                 * @implements IMsgCancelBidResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgCancelBidResponse=} [properties] Properties to set
                 */
                function MsgCancelBidResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgCancelBidResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBidResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelBidResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCancelBidResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBidResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCancelBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCancelBidResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgCancelBidResponse} MsgCancelBidResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelBidResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgCancelBidResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCancelBidResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgCancelBidResponse} MsgCancelBidResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCancelBidResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCancelBidResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCancelBidResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgCancelBidResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgCancelBidResponse} MsgCancelBidResponse
                 */
                MsgCancelBidResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgCancelBidResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgCancelBidResponse();
                };
    
                /**
                 * Creates a plain object from a MsgCancelBidResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgCancelBidResponse} message MsgCancelBidResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCancelBidResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgCancelBidResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCancelBidResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCancelBidResponse;
            })();
    
            nftbackedloan.MsgEndNftListing = (function() {
    
                /**
                 * Properties of a MsgEndNftListing.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgEndNftListing
                 * @property {string|null} [sender] MsgEndNftListing sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgEndNftListing nft_id
                 */
    
                /**
                 * Constructs a new MsgEndNftListing.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgEndNftListing.
                 * @implements IMsgEndNftListing
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgEndNftListing=} [properties] Properties to set
                 */
                function MsgEndNftListing(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgEndNftListing sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @instance
                 */
                MsgEndNftListing.prototype.sender = "";
    
                /**
                 * MsgEndNftListing nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @instance
                 */
                MsgEndNftListing.prototype.nft_id = null;
    
                /**
                 * Encodes the specified MsgEndNftListing message. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListing.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgEndNftListing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgEndNftListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgEndNftListing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgEndNftListing message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgEndNftListing} MsgEndNftListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgEndNftListing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgEndNftListing();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgEndNftListing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgEndNftListing} MsgEndNftListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgEndNftListing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgEndNftListing message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgEndNftListing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgEndNftListing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgEndNftListing} MsgEndNftListing
                 */
                MsgEndNftListing.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgEndNftListing)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgEndNftListing();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgEndNftListing.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgEndNftListing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @static
                 * @param {ununifi.nftbackedloan.MsgEndNftListing} message MsgEndNftListing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgEndNftListing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    return object;
                };
    
                /**
                 * Converts this MsgEndNftListing to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgEndNftListing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgEndNftListing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgEndNftListing;
            })();
    
            nftbackedloan.MsgEndNftListingResponse = (function() {
    
                /**
                 * Properties of a MsgEndNftListingResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgEndNftListingResponse
                 */
    
                /**
                 * Constructs a new MsgEndNftListingResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgEndNftListingResponse.
                 * @implements IMsgEndNftListingResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgEndNftListingResponse=} [properties] Properties to set
                 */
                function MsgEndNftListingResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgEndNftListingResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListingResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgEndNftListingResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgEndNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListingResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgEndNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgEndNftListingResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgEndNftListingResponse} MsgEndNftListingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgEndNftListingResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgEndNftListingResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgEndNftListingResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgEndNftListingResponse} MsgEndNftListingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgEndNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgEndNftListingResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgEndNftListingResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgEndNftListingResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgEndNftListingResponse} MsgEndNftListingResponse
                 */
                MsgEndNftListingResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgEndNftListingResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgEndNftListingResponse();
                };
    
                /**
                 * Creates a plain object from a MsgEndNftListingResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgEndNftListingResponse} message MsgEndNftListingResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgEndNftListingResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgEndNftListingResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgEndNftListingResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgEndNftListingResponse;
            })();
    
            nftbackedloan.MsgSellingDecision = (function() {
    
                /**
                 * Properties of a MsgSellingDecision.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgSellingDecision
                 * @property {string|null} [sender] MsgSellingDecision sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgSellingDecision nft_id
                 */
    
                /**
                 * Constructs a new MsgSellingDecision.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgSellingDecision.
                 * @implements IMsgSellingDecision
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgSellingDecision=} [properties] Properties to set
                 */
                function MsgSellingDecision(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgSellingDecision sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @instance
                 */
                MsgSellingDecision.prototype.sender = "";
    
                /**
                 * MsgSellingDecision nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @instance
                 */
                MsgSellingDecision.prototype.nft_id = null;
    
                /**
                 * Encodes the specified MsgSellingDecision message. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecision.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSellingDecision.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecision.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgSellingDecision message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgSellingDecision} MsgSellingDecision
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSellingDecision.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgSellingDecision();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgSellingDecision message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgSellingDecision} MsgSellingDecision
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSellingDecision.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgSellingDecision message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgSellingDecision.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgSellingDecision message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgSellingDecision} MsgSellingDecision
                 */
                MsgSellingDecision.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgSellingDecision)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgSellingDecision();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgSellingDecision.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgSellingDecision message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @static
                 * @param {ununifi.nftbackedloan.MsgSellingDecision} message MsgSellingDecision
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgSellingDecision.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    return object;
                };
    
                /**
                 * Converts this MsgSellingDecision to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgSellingDecision
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgSellingDecision.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgSellingDecision;
            })();
    
            nftbackedloan.MsgSellingDecisionResponse = (function() {
    
                /**
                 * Properties of a MsgSellingDecisionResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgSellingDecisionResponse
                 */
    
                /**
                 * Constructs a new MsgSellingDecisionResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgSellingDecisionResponse.
                 * @implements IMsgSellingDecisionResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgSellingDecisionResponse=} [properties] Properties to set
                 */
                function MsgSellingDecisionResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgSellingDecisionResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecisionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSellingDecisionResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgSellingDecisionResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecisionResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSellingDecisionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgSellingDecisionResponse} MsgSellingDecisionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSellingDecisionResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgSellingDecisionResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgSellingDecisionResponse} MsgSellingDecisionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSellingDecisionResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgSellingDecisionResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgSellingDecisionResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgSellingDecisionResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgSellingDecisionResponse} MsgSellingDecisionResponse
                 */
                MsgSellingDecisionResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgSellingDecisionResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgSellingDecisionResponse();
                };
    
                /**
                 * Creates a plain object from a MsgSellingDecisionResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgSellingDecisionResponse} message MsgSellingDecisionResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgSellingDecisionResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgSellingDecisionResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgSellingDecisionResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgSellingDecisionResponse;
            })();
    
            nftbackedloan.MsgPayRemainder = (function() {
    
                /**
                 * Properties of a MsgPayRemainder.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgPayRemainder
                 * @property {string|null} [sender] MsgPayRemainder sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgPayRemainder nft_id
                 */
    
                /**
                 * Constructs a new MsgPayRemainder.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgPayRemainder.
                 * @implements IMsgPayRemainder
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgPayRemainder=} [properties] Properties to set
                 */
                function MsgPayRemainder(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgPayRemainder sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @instance
                 */
                MsgPayRemainder.prototype.sender = "";
    
                /**
                 * MsgPayRemainder nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @instance
                 */
                MsgPayRemainder.prototype.nft_id = null;
    
                /**
                 * Encodes the specified MsgPayRemainder message. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainder.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPayRemainder} message MsgPayRemainder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPayRemainder.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgPayRemainder message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainder.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPayRemainder} message MsgPayRemainder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPayRemainder.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgPayRemainder message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgPayRemainder} MsgPayRemainder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPayRemainder.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgPayRemainder();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgPayRemainder message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgPayRemainder} MsgPayRemainder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPayRemainder.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgPayRemainder message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgPayRemainder.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgPayRemainder message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgPayRemainder} MsgPayRemainder
                 */
                MsgPayRemainder.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgPayRemainder)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgPayRemainder();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgPayRemainder.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgPayRemainder message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @static
                 * @param {ununifi.nftbackedloan.MsgPayRemainder} message MsgPayRemainder
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgPayRemainder.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    return object;
                };
    
                /**
                 * Converts this MsgPayRemainder to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgPayRemainder
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgPayRemainder.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgPayRemainder;
            })();
    
            nftbackedloan.MsgPayRemainderResponse = (function() {
    
                /**
                 * Properties of a MsgPayRemainderResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgPayRemainderResponse
                 */
    
                /**
                 * Constructs a new MsgPayRemainderResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgPayRemainderResponse.
                 * @implements IMsgPayRemainderResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgPayRemainderResponse=} [properties] Properties to set
                 */
                function MsgPayRemainderResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgPayRemainderResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainderResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPayRemainderResponse} message MsgPayRemainderResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPayRemainderResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgPayRemainderResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainderResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgPayRemainderResponse} message MsgPayRemainderResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPayRemainderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgPayRemainderResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgPayRemainderResponse} MsgPayRemainderResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPayRemainderResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgPayRemainderResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgPayRemainderResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgPayRemainderResponse} MsgPayRemainderResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPayRemainderResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgPayRemainderResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgPayRemainderResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgPayRemainderResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgPayRemainderResponse} MsgPayRemainderResponse
                 */
                MsgPayRemainderResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgPayRemainderResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgPayRemainderResponse();
                };
    
                /**
                 * Creates a plain object from a MsgPayRemainderResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgPayRemainderResponse} message MsgPayRemainderResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgPayRemainderResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgPayRemainderResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgPayRemainderResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgPayRemainderResponse;
            })();
    
            nftbackedloan.BorrowBid = (function() {
    
                /**
                 * Properties of a BorrowBid.
                 * @memberof ununifi.nftbackedloan
                 * @interface IBorrowBid
                 * @property {string|null} [bidder] BorrowBid bidder
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] BorrowBid amount
                 */
    
                /**
                 * Constructs a new BorrowBid.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a BorrowBid.
                 * @implements IBorrowBid
                 * @constructor
                 * @param {ununifi.nftbackedloan.IBorrowBid=} [properties] Properties to set
                 */
                function BorrowBid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BorrowBid bidder.
                 * @member {string} bidder
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @instance
                 */
                BorrowBid.prototype.bidder = "";
    
                /**
                 * BorrowBid amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @instance
                 */
                BorrowBid.prototype.amount = null;
    
                /**
                 * Encodes the specified BorrowBid message. Does not implicitly {@link ununifi.nftbackedloan.BorrowBid.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @static
                 * @param {ununifi.nftbackedloan.IBorrowBid} message BorrowBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BorrowBid.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bidder != null && Object.hasOwnProperty.call(message, "bidder"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bidder);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified BorrowBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.BorrowBid.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @static
                 * @param {ununifi.nftbackedloan.IBorrowBid} message BorrowBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BorrowBid.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BorrowBid message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.BorrowBid} BorrowBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BorrowBid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.BorrowBid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bidder = reader.string();
                            break;
                        case 2:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BorrowBid message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.BorrowBid} BorrowBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BorrowBid.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BorrowBid message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BorrowBid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        if (!$util.isString(message.bidder))
                            return "bidder: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a BorrowBid message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.BorrowBid} BorrowBid
                 */
                BorrowBid.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.BorrowBid)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.BorrowBid();
                    if (object.bidder != null)
                        message.bidder = String(object.bidder);
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.BorrowBid.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a BorrowBid message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @static
                 * @param {ununifi.nftbackedloan.BorrowBid} message BorrowBid
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BorrowBid.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.bidder = "";
                        object.amount = null;
                    }
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        object.bidder = message.bidder;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    return object;
                };
    
                /**
                 * Converts this BorrowBid to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.BorrowBid
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BorrowBid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BorrowBid;
            })();
    
            nftbackedloan.MsgBorrow = (function() {
    
                /**
                 * Properties of a MsgBorrow.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgBorrow
                 * @property {string|null} [sender] MsgBorrow sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgBorrow nft_id
                 * @property {Array.<ununifi.nftbackedloan.IBorrowBid>|null} [borrow_bids] MsgBorrow borrow_bids
                 */
    
                /**
                 * Constructs a new MsgBorrow.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgBorrow.
                 * @implements IMsgBorrow
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgBorrow=} [properties] Properties to set
                 */
                function MsgBorrow(properties) {
                    this.borrow_bids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgBorrow sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @instance
                 */
                MsgBorrow.prototype.sender = "";
    
                /**
                 * MsgBorrow nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @instance
                 */
                MsgBorrow.prototype.nft_id = null;
    
                /**
                 * MsgBorrow borrow_bids.
                 * @member {Array.<ununifi.nftbackedloan.IBorrowBid>} borrow_bids
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @instance
                 */
                MsgBorrow.prototype.borrow_bids = $util.emptyArray;
    
                /**
                 * Encodes the specified MsgBorrow message. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrow.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgBorrow} message MsgBorrow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBorrow.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.borrow_bids != null && message.borrow_bids.length)
                        for (var i = 0; i < message.borrow_bids.length; ++i)
                            $root.ununifi.nftbackedloan.BorrowBid.encode(message.borrow_bids[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgBorrow message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrow.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgBorrow} message MsgBorrow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBorrow.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgBorrow message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgBorrow} MsgBorrow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBorrow.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgBorrow();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.borrow_bids && message.borrow_bids.length))
                                message.borrow_bids = [];
                            message.borrow_bids.push($root.ununifi.nftbackedloan.BorrowBid.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgBorrow message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgBorrow} MsgBorrow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBorrow.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgBorrow message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgBorrow.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    if (message.borrow_bids != null && message.hasOwnProperty("borrow_bids")) {
                        if (!Array.isArray(message.borrow_bids))
                            return "borrow_bids: array expected";
                        for (var i = 0; i < message.borrow_bids.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.BorrowBid.verify(message.borrow_bids[i]);
                            if (error)
                                return "borrow_bids." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgBorrow message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgBorrow} MsgBorrow
                 */
                MsgBorrow.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgBorrow)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgBorrow();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgBorrow.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    if (object.borrow_bids) {
                        if (!Array.isArray(object.borrow_bids))
                            throw TypeError(".ununifi.nftbackedloan.MsgBorrow.borrow_bids: array expected");
                        message.borrow_bids = [];
                        for (var i = 0; i < object.borrow_bids.length; ++i) {
                            if (typeof object.borrow_bids[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.MsgBorrow.borrow_bids: object expected");
                            message.borrow_bids[i] = $root.ununifi.nftbackedloan.BorrowBid.fromObject(object.borrow_bids[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgBorrow message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @static
                 * @param {ununifi.nftbackedloan.MsgBorrow} message MsgBorrow
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgBorrow.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.borrow_bids = [];
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    if (message.borrow_bids && message.borrow_bids.length) {
                        object.borrow_bids = [];
                        for (var j = 0; j < message.borrow_bids.length; ++j)
                            object.borrow_bids[j] = $root.ununifi.nftbackedloan.BorrowBid.toObject(message.borrow_bids[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MsgBorrow to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgBorrow
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgBorrow.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgBorrow;
            })();
    
            nftbackedloan.MsgBorrowResponse = (function() {
    
                /**
                 * Properties of a MsgBorrowResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgBorrowResponse
                 */
    
                /**
                 * Constructs a new MsgBorrowResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgBorrowResponse.
                 * @implements IMsgBorrowResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgBorrowResponse=} [properties] Properties to set
                 */
                function MsgBorrowResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgBorrowResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrowResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBorrowResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgBorrowResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrowResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBorrowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgBorrowResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgBorrowResponse} MsgBorrowResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBorrowResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgBorrowResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgBorrowResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgBorrowResponse} MsgBorrowResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBorrowResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgBorrowResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgBorrowResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgBorrowResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgBorrowResponse} MsgBorrowResponse
                 */
                MsgBorrowResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgBorrowResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgBorrowResponse();
                };
    
                /**
                 * Creates a plain object from a MsgBorrowResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgBorrowResponse} message MsgBorrowResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgBorrowResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgBorrowResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgBorrowResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgBorrowResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgBorrowResponse;
            })();
    
            nftbackedloan.MsgRepay = (function() {
    
                /**
                 * Properties of a MsgRepay.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgRepay
                 * @property {string|null} [sender] MsgRepay sender
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgRepay nft_id
                 * @property {Array.<ununifi.nftbackedloan.IBorrowBid>|null} [repay_bids] MsgRepay repay_bids
                 */
    
                /**
                 * Constructs a new MsgRepay.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgRepay.
                 * @implements IMsgRepay
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgRepay=} [properties] Properties to set
                 */
                function MsgRepay(properties) {
                    this.repay_bids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgRepay sender.
                 * @member {string} sender
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @instance
                 */
                MsgRepay.prototype.sender = "";
    
                /**
                 * MsgRepay nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @instance
                 */
                MsgRepay.prototype.nft_id = null;
    
                /**
                 * MsgRepay repay_bids.
                 * @member {Array.<ununifi.nftbackedloan.IBorrowBid>} repay_bids
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @instance
                 */
                MsgRepay.prototype.repay_bids = $util.emptyArray;
    
                /**
                 * Encodes the specified MsgRepay message. Does not implicitly {@link ununifi.nftbackedloan.MsgRepay.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgRepay} message MsgRepay message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRepay.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.repay_bids != null && message.repay_bids.length)
                        for (var i = 0; i < message.repay_bids.length; ++i)
                            $root.ununifi.nftbackedloan.BorrowBid.encode(message.repay_bids[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRepay message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgRepay.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgRepay} message MsgRepay message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRepay.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRepay message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgRepay} MsgRepay
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRepay.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgRepay();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.repay_bids && message.repay_bids.length))
                                message.repay_bids = [];
                            message.repay_bids.push($root.ununifi.nftbackedloan.BorrowBid.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRepay message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgRepay} MsgRepay
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRepay.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRepay message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRepay.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    if (message.repay_bids != null && message.hasOwnProperty("repay_bids")) {
                        if (!Array.isArray(message.repay_bids))
                            return "repay_bids: array expected";
                        for (var i = 0; i < message.repay_bids.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.BorrowBid.verify(message.repay_bids[i]);
                            if (error)
                                return "repay_bids." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgRepay message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgRepay} MsgRepay
                 */
                MsgRepay.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgRepay)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.MsgRepay();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.MsgRepay.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    if (object.repay_bids) {
                        if (!Array.isArray(object.repay_bids))
                            throw TypeError(".ununifi.nftbackedloan.MsgRepay.repay_bids: array expected");
                        message.repay_bids = [];
                        for (var i = 0; i < object.repay_bids.length; ++i) {
                            if (typeof object.repay_bids[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.MsgRepay.repay_bids: object expected");
                            message.repay_bids[i] = $root.ununifi.nftbackedloan.BorrowBid.fromObject(object.repay_bids[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgRepay message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @static
                 * @param {ununifi.nftbackedloan.MsgRepay} message MsgRepay
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRepay.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.repay_bids = [];
                    if (options.defaults) {
                        object.sender = "";
                        object.nft_id = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    if (message.repay_bids && message.repay_bids.length) {
                        object.repay_bids = [];
                        for (var j = 0; j < message.repay_bids.length; ++j)
                            object.repay_bids[j] = $root.ununifi.nftbackedloan.BorrowBid.toObject(message.repay_bids[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MsgRepay to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgRepay
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRepay.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRepay;
            })();
    
            nftbackedloan.MsgRepayResponse = (function() {
    
                /**
                 * Properties of a MsgRepayResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IMsgRepayResponse
                 */
    
                /**
                 * Constructs a new MsgRepayResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a MsgRepayResponse.
                 * @implements IMsgRepayResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IMsgRepayResponse=} [properties] Properties to set
                 */
                function MsgRepayResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgRepayResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgRepayResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRepayResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRepayResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgRepayResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRepayResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRepayResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.MsgRepayResponse} MsgRepayResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRepayResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.MsgRepayResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRepayResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.MsgRepayResponse} MsgRepayResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRepayResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRepayResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRepayResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgRepayResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.MsgRepayResponse} MsgRepayResponse
                 */
                MsgRepayResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.MsgRepayResponse)
                        return object;
                    return new $root.ununifi.nftbackedloan.MsgRepayResponse();
                };
    
                /**
                 * Creates a plain object from a MsgRepayResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @static
                 * @param {ununifi.nftbackedloan.MsgRepayResponse} message MsgRepayResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRepayResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgRepayResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.MsgRepayResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRepayResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRepayResponse;
            })();
    
            /**
             * ListingState enum.
             * @name ununifi.nftbackedloan.ListingState
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} LISTING=1 LISTING value
             * @property {number} BIDDING=2 BIDDING value
             * @property {number} SELLING_DECISION=3 SELLING_DECISION value
             * @property {number} LIQUIDATION=4 LIQUIDATION value
             * @property {number} SUCCESSFUL_BID=5 SUCCESSFUL_BID value
             */
            nftbackedloan.ListingState = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "LISTING"] = 1;
                values[valuesById[2] = "BIDDING"] = 2;
                values[valuesById[3] = "SELLING_DECISION"] = 3;
                values[valuesById[4] = "LIQUIDATION"] = 4;
                values[valuesById[5] = "SUCCESSFUL_BID"] = 5;
                return values;
            })();
    
            nftbackedloan.NftId = (function() {
    
                /**
                 * Properties of a NftId.
                 * @memberof ununifi.nftbackedloan
                 * @interface INftId
                 * @property {string|null} [class_id] NftId class_id
                 * @property {string|null} [token_id] NftId token_id
                 */
    
                /**
                 * Constructs a new NftId.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a NftId.
                 * @implements INftId
                 * @constructor
                 * @param {ununifi.nftbackedloan.INftId=} [properties] Properties to set
                 */
                function NftId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NftId class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.NftId
                 * @instance
                 */
                NftId.prototype.class_id = "";
    
                /**
                 * NftId token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.NftId
                 * @instance
                 */
                NftId.prototype.token_id = "";
    
                /**
                 * Encodes the specified NftId message. Does not implicitly {@link ununifi.nftbackedloan.NftId.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.NftId
                 * @static
                 * @param {ununifi.nftbackedloan.INftId} message NftId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified NftId message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.NftId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.NftId
                 * @static
                 * @param {ununifi.nftbackedloan.INftId} message NftId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NftId message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.NftId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.NftId} NftId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.NftId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NftId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.NftId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.NftId} NftId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NftId message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.NftId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NftId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a NftId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.NftId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.NftId} NftId
                 */
                NftId.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.NftId)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.NftId();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a NftId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.NftId
                 * @static
                 * @param {ununifi.nftbackedloan.NftId} message NftId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NftId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this NftId to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.NftId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NftId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NftId;
            })();
    
            nftbackedloan.BidId = (function() {
    
                /**
                 * Properties of a BidId.
                 * @memberof ununifi.nftbackedloan
                 * @interface IBidId
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] BidId nft_id
                 * @property {string|null} [bidder] BidId bidder
                 */
    
                /**
                 * Constructs a new BidId.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a BidId.
                 * @implements IBidId
                 * @constructor
                 * @param {ununifi.nftbackedloan.IBidId=} [properties] Properties to set
                 */
                function BidId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BidId nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.BidId
                 * @instance
                 */
                BidId.prototype.nft_id = null;
    
                /**
                 * BidId bidder.
                 * @member {string} bidder
                 * @memberof ununifi.nftbackedloan.BidId
                 * @instance
                 */
                BidId.prototype.bidder = "";
    
                /**
                 * Encodes the specified BidId message. Does not implicitly {@link ununifi.nftbackedloan.BidId.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.BidId
                 * @static
                 * @param {ununifi.nftbackedloan.IBidId} message BidId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BidId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.bidder != null && Object.hasOwnProperty.call(message, "bidder"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.bidder);
                    return writer;
                };
    
                /**
                 * Encodes the specified BidId message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.BidId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.BidId
                 * @static
                 * @param {ununifi.nftbackedloan.IBidId} message BidId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BidId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BidId message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.BidId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.BidId} BidId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BidId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.BidId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.bidder = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BidId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.BidId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.BidId} BidId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BidId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BidId message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.BidId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BidId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        if (!$util.isString(message.bidder))
                            return "bidder: string expected";
                    return null;
                };
    
                /**
                 * Creates a BidId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.BidId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.BidId} BidId
                 */
                BidId.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.BidId)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.BidId();
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.BidId.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    if (object.bidder != null)
                        message.bidder = String(object.bidder);
                    return message;
                };
    
                /**
                 * Creates a plain object from a BidId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.BidId
                 * @static
                 * @param {ununifi.nftbackedloan.BidId} message BidId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BidId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.nft_id = null;
                        object.bidder = "";
                    }
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        object.bidder = message.bidder;
                    return object;
                };
    
                /**
                 * Converts this BidId to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.BidId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BidId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BidId;
            })();
    
            nftbackedloan.ListedClass = (function() {
    
                /**
                 * Properties of a ListedClass.
                 * @memberof ununifi.nftbackedloan
                 * @interface IListedClass
                 * @property {string|null} [class_id] ListedClass class_id
                 * @property {Array.<string>|null} [nft_ids] ListedClass nft_ids
                 */
    
                /**
                 * Constructs a new ListedClass.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a ListedClass.
                 * @implements IListedClass
                 * @constructor
                 * @param {ununifi.nftbackedloan.IListedClass=} [properties] Properties to set
                 */
                function ListedClass(properties) {
                    this.nft_ids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ListedClass class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @instance
                 */
                ListedClass.prototype.class_id = "";
    
                /**
                 * ListedClass nft_ids.
                 * @member {Array.<string>} nft_ids
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @instance
                 */
                ListedClass.prototype.nft_ids = $util.emptyArray;
    
                /**
                 * Encodes the specified ListedClass message. Does not implicitly {@link ununifi.nftbackedloan.ListedClass.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @static
                 * @param {ununifi.nftbackedloan.IListedClass} message ListedClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListedClass.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.nft_ids != null && message.nft_ids.length)
                        for (var i = 0; i < message.nft_ids.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.nft_ids[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified ListedClass message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.ListedClass.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @static
                 * @param {ununifi.nftbackedloan.IListedClass} message ListedClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListedClass.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ListedClass message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.ListedClass} ListedClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListedClass.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.ListedClass();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            if (!(message.nft_ids && message.nft_ids.length))
                                message.nft_ids = [];
                            message.nft_ids.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ListedClass message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.ListedClass} ListedClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListedClass.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ListedClass message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListedClass.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.nft_ids != null && message.hasOwnProperty("nft_ids")) {
                        if (!Array.isArray(message.nft_ids))
                            return "nft_ids: array expected";
                        for (var i = 0; i < message.nft_ids.length; ++i)
                            if (!$util.isString(message.nft_ids[i]))
                                return "nft_ids: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a ListedClass message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.ListedClass} ListedClass
                 */
                ListedClass.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.ListedClass)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.ListedClass();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.nft_ids) {
                        if (!Array.isArray(object.nft_ids))
                            throw TypeError(".ununifi.nftbackedloan.ListedClass.nft_ids: array expected");
                        message.nft_ids = [];
                        for (var i = 0; i < object.nft_ids.length; ++i)
                            message.nft_ids[i] = String(object.nft_ids[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ListedClass message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @static
                 * @param {ununifi.nftbackedloan.ListedClass} message ListedClass
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListedClass.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.nft_ids = [];
                    if (options.defaults)
                        object.class_id = "";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.nft_ids && message.nft_ids.length) {
                        object.nft_ids = [];
                        for (var j = 0; j < message.nft_ids.length; ++j)
                            object.nft_ids[j] = message.nft_ids[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this ListedClass to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.ListedClass
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListedClass.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ListedClass;
            })();
    
            nftbackedloan.NftInfo = (function() {
    
                /**
                 * Properties of a NftInfo.
                 * @memberof ununifi.nftbackedloan
                 * @interface INftInfo
                 * @property {string|null} [id] NftInfo id
                 * @property {string|null} [uri] NftInfo uri
                 * @property {string|null} [uri_hash] NftInfo uri_hash
                 */
    
                /**
                 * Constructs a new NftInfo.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a NftInfo.
                 * @implements INftInfo
                 * @constructor
                 * @param {ununifi.nftbackedloan.INftInfo=} [properties] Properties to set
                 */
                function NftInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NftInfo id.
                 * @member {string} id
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @instance
                 */
                NftInfo.prototype.id = "";
    
                /**
                 * NftInfo uri.
                 * @member {string} uri
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @instance
                 */
                NftInfo.prototype.uri = "";
    
                /**
                 * NftInfo uri_hash.
                 * @member {string} uri_hash
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @instance
                 */
                NftInfo.prototype.uri_hash = "";
    
                /**
                 * Encodes the specified NftInfo message. Does not implicitly {@link ununifi.nftbackedloan.NftInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @static
                 * @param {ununifi.nftbackedloan.INftInfo} message NftInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                    if (message.uri_hash != null && Object.hasOwnProperty.call(message, "uri_hash"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.uri_hash);
                    return writer;
                };
    
                /**
                 * Encodes the specified NftInfo message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.NftInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @static
                 * @param {ununifi.nftbackedloan.INftInfo} message NftInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NftInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.NftInfo} NftInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.NftInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.uri = reader.string();
                            break;
                        case 3:
                            message.uri_hash = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NftInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.NftInfo} NftInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NftInfo message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NftInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        if (!$util.isString(message.uri_hash))
                            return "uri_hash: string expected";
                    return null;
                };
    
                /**
                 * Creates a NftInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.NftInfo} NftInfo
                 */
                NftInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.NftInfo)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.NftInfo();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.uri_hash != null)
                        message.uri_hash = String(object.uri_hash);
                    return message;
                };
    
                /**
                 * Creates a plain object from a NftInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @static
                 * @param {ununifi.nftbackedloan.NftInfo} message NftInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NftInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.uri = "";
                        object.uri_hash = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        object.uri_hash = message.uri_hash;
                    return object;
                };
    
                /**
                 * Converts this NftInfo to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.NftInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NftInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NftInfo;
            })();
    
            nftbackedloan.Listing = (function() {
    
                /**
                 * Properties of a Listing.
                 * @memberof ununifi.nftbackedloan
                 * @interface IListing
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] Listing nft_id
                 * @property {string|null} [owner] Listing owner
                 * @property {ununifi.nftbackedloan.ListingState|null} [state] Listing state
                 * @property {string|null} [bid_denom] Listing bid_denom
                 * @property {string|null} [min_deposit_rate] Listing min_deposit_rate
                 * @property {google.protobuf.IDuration|null} [min_bid_period] Listing min_bid_period
                 * @property {google.protobuf.ITimestamp|null} [started_at] Listing started_at
                 * @property {google.protobuf.ITimestamp|null} [liquidated_at] Listing liquidated_at
                 * @property {google.protobuf.ITimestamp|null} [full_payment_end_at] Listing full_payment_end_at
                 * @property {google.protobuf.ITimestamp|null} [successful_bid_end_at] Listing successful_bid_end_at
                 * @property {cosmos.base.v1beta1.ICoin|null} [collected_amount] Listing collected_amount
                 * @property {boolean|null} [collected_amount_negative] Listing collected_amount_negative
                 */
    
                /**
                 * Constructs a new Listing.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Listing.
                 * @implements IListing
                 * @constructor
                 * @param {ununifi.nftbackedloan.IListing=} [properties] Properties to set
                 */
                function Listing(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Listing nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.nft_id = null;
    
                /**
                 * Listing owner.
                 * @member {string} owner
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.owner = "";
    
                /**
                 * Listing state.
                 * @member {ununifi.nftbackedloan.ListingState} state
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.state = 0;
    
                /**
                 * Listing bid_denom.
                 * @member {string} bid_denom
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.bid_denom = "";
    
                /**
                 * Listing min_deposit_rate.
                 * @member {string} min_deposit_rate
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.min_deposit_rate = "";
    
                /**
                 * Listing min_bid_period.
                 * @member {google.protobuf.IDuration|null|undefined} min_bid_period
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.min_bid_period = null;
    
                /**
                 * Listing started_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} started_at
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.started_at = null;
    
                /**
                 * Listing liquidated_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} liquidated_at
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.liquidated_at = null;
    
                /**
                 * Listing full_payment_end_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} full_payment_end_at
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.full_payment_end_at = null;
    
                /**
                 * Listing successful_bid_end_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} successful_bid_end_at
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.successful_bid_end_at = null;
    
                /**
                 * Listing collected_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} collected_amount
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.collected_amount = null;
    
                /**
                 * Listing collected_amount_negative.
                 * @member {boolean} collected_amount_negative
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 */
                Listing.prototype.collected_amount_negative = false;
    
                /**
                 * Encodes the specified Listing message. Does not implicitly {@link ununifi.nftbackedloan.Listing.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.Listing
                 * @static
                 * @param {ununifi.nftbackedloan.IListing} message Listing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Listing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.owner);
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
                    if (message.bid_denom != null && Object.hasOwnProperty.call(message, "bid_denom"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.bid_denom);
                    if (message.min_deposit_rate != null && Object.hasOwnProperty.call(message, "min_deposit_rate"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.min_deposit_rate);
                    if (message.min_bid_period != null && Object.hasOwnProperty.call(message, "min_bid_period"))
                        $root.google.protobuf.Duration.encode(message.min_bid_period, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.started_at != null && Object.hasOwnProperty.call(message, "started_at"))
                        $root.google.protobuf.Timestamp.encode(message.started_at, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.liquidated_at != null && Object.hasOwnProperty.call(message, "liquidated_at"))
                        $root.google.protobuf.Timestamp.encode(message.liquidated_at, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.full_payment_end_at != null && Object.hasOwnProperty.call(message, "full_payment_end_at"))
                        $root.google.protobuf.Timestamp.encode(message.full_payment_end_at, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.successful_bid_end_at != null && Object.hasOwnProperty.call(message, "successful_bid_end_at"))
                        $root.google.protobuf.Timestamp.encode(message.successful_bid_end_at, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.collected_amount != null && Object.hasOwnProperty.call(message, "collected_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.collected_amount, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.collected_amount_negative != null && Object.hasOwnProperty.call(message, "collected_amount_negative"))
                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.collected_amount_negative);
                    return writer;
                };
    
                /**
                 * Encodes the specified Listing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Listing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.Listing
                 * @static
                 * @param {ununifi.nftbackedloan.IListing} message Listing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Listing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Listing message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.Listing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.Listing} Listing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Listing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.Listing();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.owner = reader.string();
                            break;
                        case 3:
                            message.state = reader.int32();
                            break;
                        case 4:
                            message.bid_denom = reader.string();
                            break;
                        case 5:
                            message.min_deposit_rate = reader.string();
                            break;
                        case 6:
                            message.min_bid_period = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.started_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.liquidated_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.full_payment_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.successful_bid_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.collected_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.collected_amount_negative = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Listing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.Listing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.Listing} Listing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Listing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Listing message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.Listing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Listing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.bid_denom != null && message.hasOwnProperty("bid_denom"))
                        if (!$util.isString(message.bid_denom))
                            return "bid_denom: string expected";
                    if (message.min_deposit_rate != null && message.hasOwnProperty("min_deposit_rate"))
                        if (!$util.isString(message.min_deposit_rate))
                            return "min_deposit_rate: string expected";
                    if (message.min_bid_period != null && message.hasOwnProperty("min_bid_period")) {
                        var error = $root.google.protobuf.Duration.verify(message.min_bid_period);
                        if (error)
                            return "min_bid_period." + error;
                    }
                    if (message.started_at != null && message.hasOwnProperty("started_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.started_at);
                        if (error)
                            return "started_at." + error;
                    }
                    if (message.liquidated_at != null && message.hasOwnProperty("liquidated_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.liquidated_at);
                        if (error)
                            return "liquidated_at." + error;
                    }
                    if (message.full_payment_end_at != null && message.hasOwnProperty("full_payment_end_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.full_payment_end_at);
                        if (error)
                            return "full_payment_end_at." + error;
                    }
                    if (message.successful_bid_end_at != null && message.hasOwnProperty("successful_bid_end_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.successful_bid_end_at);
                        if (error)
                            return "successful_bid_end_at." + error;
                    }
                    if (message.collected_amount != null && message.hasOwnProperty("collected_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.collected_amount);
                        if (error)
                            return "collected_amount." + error;
                    }
                    if (message.collected_amount_negative != null && message.hasOwnProperty("collected_amount_negative"))
                        if (typeof message.collected_amount_negative !== "boolean")
                            return "collected_amount_negative: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a Listing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.Listing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.Listing} Listing
                 */
                Listing.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.Listing)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.Listing();
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Listing.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    switch (object.state) {
                    case "UNKNOWN":
                    case 0:
                        message.state = 0;
                        break;
                    case "LISTING":
                    case 1:
                        message.state = 1;
                        break;
                    case "BIDDING":
                    case 2:
                        message.state = 2;
                        break;
                    case "SELLING_DECISION":
                    case 3:
                        message.state = 3;
                        break;
                    case "LIQUIDATION":
                    case 4:
                        message.state = 4;
                        break;
                    case "SUCCESSFUL_BID":
                    case 5:
                        message.state = 5;
                        break;
                    }
                    if (object.bid_denom != null)
                        message.bid_denom = String(object.bid_denom);
                    if (object.min_deposit_rate != null)
                        message.min_deposit_rate = String(object.min_deposit_rate);
                    if (object.min_bid_period != null) {
                        if (typeof object.min_bid_period !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Listing.min_bid_period: object expected");
                        message.min_bid_period = $root.google.protobuf.Duration.fromObject(object.min_bid_period);
                    }
                    if (object.started_at != null) {
                        if (typeof object.started_at !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Listing.started_at: object expected");
                        message.started_at = $root.google.protobuf.Timestamp.fromObject(object.started_at);
                    }
                    if (object.liquidated_at != null) {
                        if (typeof object.liquidated_at !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Listing.liquidated_at: object expected");
                        message.liquidated_at = $root.google.protobuf.Timestamp.fromObject(object.liquidated_at);
                    }
                    if (object.full_payment_end_at != null) {
                        if (typeof object.full_payment_end_at !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Listing.full_payment_end_at: object expected");
                        message.full_payment_end_at = $root.google.protobuf.Timestamp.fromObject(object.full_payment_end_at);
                    }
                    if (object.successful_bid_end_at != null) {
                        if (typeof object.successful_bid_end_at !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Listing.successful_bid_end_at: object expected");
                        message.successful_bid_end_at = $root.google.protobuf.Timestamp.fromObject(object.successful_bid_end_at);
                    }
                    if (object.collected_amount != null) {
                        if (typeof object.collected_amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Listing.collected_amount: object expected");
                        message.collected_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.collected_amount);
                    }
                    if (object.collected_amount_negative != null)
                        message.collected_amount_negative = Boolean(object.collected_amount_negative);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Listing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.Listing
                 * @static
                 * @param {ununifi.nftbackedloan.Listing} message Listing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Listing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.nft_id = null;
                        object.owner = "";
                        object.state = options.enums === String ? "UNKNOWN" : 0;
                        object.bid_denom = "";
                        object.min_deposit_rate = "";
                        object.min_bid_period = null;
                        object.started_at = null;
                        object.liquidated_at = null;
                        object.full_payment_end_at = null;
                        object.successful_bid_end_at = null;
                        object.collected_amount = null;
                        object.collected_amount_negative = false;
                    }
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.ununifi.nftbackedloan.ListingState[message.state] : message.state;
                    if (message.bid_denom != null && message.hasOwnProperty("bid_denom"))
                        object.bid_denom = message.bid_denom;
                    if (message.min_deposit_rate != null && message.hasOwnProperty("min_deposit_rate"))
                        object.min_deposit_rate = message.min_deposit_rate;
                    if (message.min_bid_period != null && message.hasOwnProperty("min_bid_period"))
                        object.min_bid_period = $root.google.protobuf.Duration.toObject(message.min_bid_period, options);
                    if (message.started_at != null && message.hasOwnProperty("started_at"))
                        object.started_at = $root.google.protobuf.Timestamp.toObject(message.started_at, options);
                    if (message.liquidated_at != null && message.hasOwnProperty("liquidated_at"))
                        object.liquidated_at = $root.google.protobuf.Timestamp.toObject(message.liquidated_at, options);
                    if (message.full_payment_end_at != null && message.hasOwnProperty("full_payment_end_at"))
                        object.full_payment_end_at = $root.google.protobuf.Timestamp.toObject(message.full_payment_end_at, options);
                    if (message.successful_bid_end_at != null && message.hasOwnProperty("successful_bid_end_at"))
                        object.successful_bid_end_at = $root.google.protobuf.Timestamp.toObject(message.successful_bid_end_at, options);
                    if (message.collected_amount != null && message.hasOwnProperty("collected_amount"))
                        object.collected_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.collected_amount, options);
                    if (message.collected_amount_negative != null && message.hasOwnProperty("collected_amount_negative"))
                        object.collected_amount_negative = message.collected_amount_negative;
                    return object;
                };
    
                /**
                 * Converts this Listing to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.Listing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Listing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Listing;
            })();
    
            nftbackedloan.Bid = (function() {
    
                /**
                 * Properties of a Bid.
                 * @memberof ununifi.nftbackedloan
                 * @interface IBid
                 * @property {ununifi.nftbackedloan.IBidId|null} [id] Bid id
                 * @property {cosmos.base.v1beta1.ICoin|null} [price] Bid price
                 * @property {cosmos.base.v1beta1.ICoin|null} [deposit] Bid deposit
                 * @property {cosmos.base.v1beta1.ICoin|null} [paid_amount] Bid paid_amount
                 * @property {google.protobuf.ITimestamp|null} [expiry] Bid expiry
                 * @property {string|null} [interest_rate] Bid interest_rate
                 * @property {boolean|null} [automatic_payment] Bid automatic_payment
                 * @property {google.protobuf.ITimestamp|null} [created_at] Bid created_at
                 * @property {ununifi.nftbackedloan.ILoan|null} [loan] Bid loan
                 */
    
                /**
                 * Constructs a new Bid.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Bid.
                 * @implements IBid
                 * @constructor
                 * @param {ununifi.nftbackedloan.IBid=} [properties] Properties to set
                 */
                function Bid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Bid id.
                 * @member {ununifi.nftbackedloan.IBidId|null|undefined} id
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.id = null;
    
                /**
                 * Bid price.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} price
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.price = null;
    
                /**
                 * Bid deposit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.deposit = null;
    
                /**
                 * Bid paid_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} paid_amount
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.paid_amount = null;
    
                /**
                 * Bid expiry.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiry
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.expiry = null;
    
                /**
                 * Bid interest_rate.
                 * @member {string} interest_rate
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.interest_rate = "";
    
                /**
                 * Bid automatic_payment.
                 * @member {boolean} automatic_payment
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.automatic_payment = false;
    
                /**
                 * Bid created_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} created_at
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.created_at = null;
    
                /**
                 * Bid loan.
                 * @member {ununifi.nftbackedloan.ILoan|null|undefined} loan
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 */
                Bid.prototype.loan = null;
    
                /**
                 * Encodes the specified Bid message. Does not implicitly {@link ununifi.nftbackedloan.Bid.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.Bid
                 * @static
                 * @param {ununifi.nftbackedloan.IBid} message Bid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bid.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        $root.ununifi.nftbackedloan.BidId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.price, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.deposit != null && Object.hasOwnProperty.call(message, "deposit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.deposit, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.paid_amount != null && Object.hasOwnProperty.call(message, "paid_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.paid_amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                        $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.interest_rate != null && Object.hasOwnProperty.call(message, "interest_rate"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.interest_rate);
                    if (message.automatic_payment != null && Object.hasOwnProperty.call(message, "automatic_payment"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.automatic_payment);
                    if (message.created_at != null && Object.hasOwnProperty.call(message, "created_at"))
                        $root.google.protobuf.Timestamp.encode(message.created_at, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.loan != null && Object.hasOwnProperty.call(message, "loan"))
                        $root.ununifi.nftbackedloan.Loan.encode(message.loan, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Bid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Bid.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.Bid
                 * @static
                 * @param {ununifi.nftbackedloan.IBid} message Bid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bid.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Bid message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.Bid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.Bid} Bid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.Bid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.ununifi.nftbackedloan.BidId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.price = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.paid_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.interest_rate = reader.string();
                            break;
                        case 7:
                            message.automatic_payment = reader.bool();
                            break;
                        case 8:
                            message.created_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.loan = $root.ununifi.nftbackedloan.Loan.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Bid message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.Bid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.Bid} Bid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bid.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Bid message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.Bid
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Bid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.ununifi.nftbackedloan.BidId.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.price != null && message.hasOwnProperty("price")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.price);
                        if (error)
                            return "price." + error;
                    }
                    if (message.deposit != null && message.hasOwnProperty("deposit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit);
                        if (error)
                            return "deposit." + error;
                    }
                    if (message.paid_amount != null && message.hasOwnProperty("paid_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.paid_amount);
                        if (error)
                            return "paid_amount." + error;
                    }
                    if (message.expiry != null && message.hasOwnProperty("expiry")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiry);
                        if (error)
                            return "expiry." + error;
                    }
                    if (message.interest_rate != null && message.hasOwnProperty("interest_rate"))
                        if (!$util.isString(message.interest_rate))
                            return "interest_rate: string expected";
                    if (message.automatic_payment != null && message.hasOwnProperty("automatic_payment"))
                        if (typeof message.automatic_payment !== "boolean")
                            return "automatic_payment: boolean expected";
                    if (message.created_at != null && message.hasOwnProperty("created_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.created_at);
                        if (error)
                            return "created_at." + error;
                    }
                    if (message.loan != null && message.hasOwnProperty("loan")) {
                        var error = $root.ununifi.nftbackedloan.Loan.verify(message.loan);
                        if (error)
                            return "loan." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Bid message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.Bid
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.Bid} Bid
                 */
                Bid.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.Bid)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.Bid();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Bid.id: object expected");
                        message.id = $root.ununifi.nftbackedloan.BidId.fromObject(object.id);
                    }
                    if (object.price != null) {
                        if (typeof object.price !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Bid.price: object expected");
                        message.price = $root.cosmos.base.v1beta1.Coin.fromObject(object.price);
                    }
                    if (object.deposit != null) {
                        if (typeof object.deposit !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Bid.deposit: object expected");
                        message.deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit);
                    }
                    if (object.paid_amount != null) {
                        if (typeof object.paid_amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Bid.paid_amount: object expected");
                        message.paid_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.paid_amount);
                    }
                    if (object.expiry != null) {
                        if (typeof object.expiry !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Bid.expiry: object expected");
                        message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
                    }
                    if (object.interest_rate != null)
                        message.interest_rate = String(object.interest_rate);
                    if (object.automatic_payment != null)
                        message.automatic_payment = Boolean(object.automatic_payment);
                    if (object.created_at != null) {
                        if (typeof object.created_at !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Bid.created_at: object expected");
                        message.created_at = $root.google.protobuf.Timestamp.fromObject(object.created_at);
                    }
                    if (object.loan != null) {
                        if (typeof object.loan !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Bid.loan: object expected");
                        message.loan = $root.ununifi.nftbackedloan.Loan.fromObject(object.loan);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Bid message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.Bid
                 * @static
                 * @param {ununifi.nftbackedloan.Bid} message Bid
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Bid.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = null;
                        object.price = null;
                        object.deposit = null;
                        object.paid_amount = null;
                        object.expiry = null;
                        object.interest_rate = "";
                        object.automatic_payment = false;
                        object.created_at = null;
                        object.loan = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.ununifi.nftbackedloan.BidId.toObject(message.id, options);
                    if (message.price != null && message.hasOwnProperty("price"))
                        object.price = $root.cosmos.base.v1beta1.Coin.toObject(message.price, options);
                    if (message.deposit != null && message.hasOwnProperty("deposit"))
                        object.deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit, options);
                    if (message.paid_amount != null && message.hasOwnProperty("paid_amount"))
                        object.paid_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.paid_amount, options);
                    if (message.expiry != null && message.hasOwnProperty("expiry"))
                        object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
                    if (message.interest_rate != null && message.hasOwnProperty("interest_rate"))
                        object.interest_rate = message.interest_rate;
                    if (message.automatic_payment != null && message.hasOwnProperty("automatic_payment"))
                        object.automatic_payment = message.automatic_payment;
                    if (message.created_at != null && message.hasOwnProperty("created_at"))
                        object.created_at = $root.google.protobuf.Timestamp.toObject(message.created_at, options);
                    if (message.loan != null && message.hasOwnProperty("loan"))
                        object.loan = $root.ununifi.nftbackedloan.Loan.toObject(message.loan, options);
                    return object;
                };
    
                /**
                 * Converts this Bid to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.Bid
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Bid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Bid;
            })();
    
            nftbackedloan.Loan = (function() {
    
                /**
                 * Properties of a Loan.
                 * @memberof ununifi.nftbackedloan
                 * @interface ILoan
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] Loan amount
                 * @property {google.protobuf.ITimestamp|null} [last_repaid_at] Loan last_repaid_at
                 */
    
                /**
                 * Constructs a new Loan.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Loan.
                 * @implements ILoan
                 * @constructor
                 * @param {ununifi.nftbackedloan.ILoan=} [properties] Properties to set
                 */
                function Loan(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Loan amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.nftbackedloan.Loan
                 * @instance
                 */
                Loan.prototype.amount = null;
    
                /**
                 * Loan last_repaid_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} last_repaid_at
                 * @memberof ununifi.nftbackedloan.Loan
                 * @instance
                 */
                Loan.prototype.last_repaid_at = null;
    
                /**
                 * Encodes the specified Loan message. Does not implicitly {@link ununifi.nftbackedloan.Loan.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.Loan
                 * @static
                 * @param {ununifi.nftbackedloan.ILoan} message Loan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Loan.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.last_repaid_at != null && Object.hasOwnProperty.call(message, "last_repaid_at"))
                        $root.google.protobuf.Timestamp.encode(message.last_repaid_at, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Loan message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Loan.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.Loan
                 * @static
                 * @param {ununifi.nftbackedloan.ILoan} message Loan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Loan.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Loan message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.Loan
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.Loan} Loan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Loan.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.Loan();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.last_repaid_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Loan message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.Loan
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.Loan} Loan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Loan.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Loan message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.Loan
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Loan.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.last_repaid_at != null && message.hasOwnProperty("last_repaid_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.last_repaid_at);
                        if (error)
                            return "last_repaid_at." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Loan message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.Loan
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.Loan} Loan
                 */
                Loan.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.Loan)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.Loan();
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Loan.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    if (object.last_repaid_at != null) {
                        if (typeof object.last_repaid_at !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Loan.last_repaid_at: object expected");
                        message.last_repaid_at = $root.google.protobuf.Timestamp.fromObject(object.last_repaid_at);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Loan message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.Loan
                 * @static
                 * @param {ununifi.nftbackedloan.Loan} message Loan
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Loan.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.amount = null;
                        object.last_repaid_at = null;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    if (message.last_repaid_at != null && message.hasOwnProperty("last_repaid_at"))
                        object.last_repaid_at = $root.google.protobuf.Timestamp.toObject(message.last_repaid_at, options);
                    return object;
                };
    
                /**
                 * Converts this Loan to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.Loan
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Loan.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Loan;
            })();
    
            nftbackedloan.Liquidation = (function() {
    
                /**
                 * Properties of a Liquidation.
                 * @memberof ununifi.nftbackedloan
                 * @interface ILiquidation
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] Liquidation amount
                 * @property {google.protobuf.ITimestamp|null} [liquidation_date] Liquidation liquidation_date
                 */
    
                /**
                 * Constructs a new Liquidation.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Liquidation.
                 * @implements ILiquidation
                 * @constructor
                 * @param {ununifi.nftbackedloan.ILiquidation=} [properties] Properties to set
                 */
                function Liquidation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Liquidation amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @instance
                 */
                Liquidation.prototype.amount = null;
    
                /**
                 * Liquidation liquidation_date.
                 * @member {google.protobuf.ITimestamp|null|undefined} liquidation_date
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @instance
                 */
                Liquidation.prototype.liquidation_date = null;
    
                /**
                 * Encodes the specified Liquidation message. Does not implicitly {@link ununifi.nftbackedloan.Liquidation.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @static
                 * @param {ununifi.nftbackedloan.ILiquidation} message Liquidation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Liquidation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.liquidation_date != null && Object.hasOwnProperty.call(message, "liquidation_date"))
                        $root.google.protobuf.Timestamp.encode(message.liquidation_date, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Liquidation message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Liquidation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @static
                 * @param {ununifi.nftbackedloan.ILiquidation} message Liquidation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Liquidation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Liquidation message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.Liquidation} Liquidation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Liquidation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.Liquidation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.liquidation_date = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Liquidation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.Liquidation} Liquidation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Liquidation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Liquidation message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Liquidation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.liquidation_date != null && message.hasOwnProperty("liquidation_date")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.liquidation_date);
                        if (error)
                            return "liquidation_date." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Liquidation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.Liquidation} Liquidation
                 */
                Liquidation.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.Liquidation)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.Liquidation();
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Liquidation.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    if (object.liquidation_date != null) {
                        if (typeof object.liquidation_date !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Liquidation.liquidation_date: object expected");
                        message.liquidation_date = $root.google.protobuf.Timestamp.fromObject(object.liquidation_date);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Liquidation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @static
                 * @param {ununifi.nftbackedloan.Liquidation} message Liquidation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Liquidation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.amount = null;
                        object.liquidation_date = null;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    if (message.liquidation_date != null && message.hasOwnProperty("liquidation_date"))
                        object.liquidation_date = $root.google.protobuf.Timestamp.toObject(message.liquidation_date, options);
                    return object;
                };
    
                /**
                 * Converts this Liquidation to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.Liquidation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Liquidation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Liquidation;
            })();
    
            nftbackedloan.Liquidations = (function() {
    
                /**
                 * Properties of a Liquidations.
                 * @memberof ununifi.nftbackedloan
                 * @interface ILiquidations
                 * @property {ununifi.nftbackedloan.ILiquidation|null} [liquidation] Liquidations liquidation
                 * @property {Array.<ununifi.nftbackedloan.ILiquidation>|null} [next_liquidation] Liquidations next_liquidation
                 */
    
                /**
                 * Constructs a new Liquidations.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Liquidations.
                 * @implements ILiquidations
                 * @constructor
                 * @param {ununifi.nftbackedloan.ILiquidations=} [properties] Properties to set
                 */
                function Liquidations(properties) {
                    this.next_liquidation = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Liquidations liquidation.
                 * @member {ununifi.nftbackedloan.ILiquidation|null|undefined} liquidation
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @instance
                 */
                Liquidations.prototype.liquidation = null;
    
                /**
                 * Liquidations next_liquidation.
                 * @member {Array.<ununifi.nftbackedloan.ILiquidation>} next_liquidation
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @instance
                 */
                Liquidations.prototype.next_liquidation = $util.emptyArray;
    
                /**
                 * Encodes the specified Liquidations message. Does not implicitly {@link ununifi.nftbackedloan.Liquidations.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @static
                 * @param {ununifi.nftbackedloan.ILiquidations} message Liquidations message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Liquidations.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.liquidation != null && Object.hasOwnProperty.call(message, "liquidation"))
                        $root.ununifi.nftbackedloan.Liquidation.encode(message.liquidation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.next_liquidation != null && message.next_liquidation.length)
                        for (var i = 0; i < message.next_liquidation.length; ++i)
                            $root.ununifi.nftbackedloan.Liquidation.encode(message.next_liquidation[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Liquidations message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Liquidations.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @static
                 * @param {ununifi.nftbackedloan.ILiquidations} message Liquidations message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Liquidations.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Liquidations message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.Liquidations} Liquidations
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Liquidations.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.Liquidations();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.liquidation = $root.ununifi.nftbackedloan.Liquidation.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.next_liquidation && message.next_liquidation.length))
                                message.next_liquidation = [];
                            message.next_liquidation.push($root.ununifi.nftbackedloan.Liquidation.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Liquidations message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.Liquidations} Liquidations
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Liquidations.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Liquidations message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Liquidations.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.liquidation != null && message.hasOwnProperty("liquidation")) {
                        var error = $root.ununifi.nftbackedloan.Liquidation.verify(message.liquidation);
                        if (error)
                            return "liquidation." + error;
                    }
                    if (message.next_liquidation != null && message.hasOwnProperty("next_liquidation")) {
                        if (!Array.isArray(message.next_liquidation))
                            return "next_liquidation: array expected";
                        for (var i = 0; i < message.next_liquidation.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.Liquidation.verify(message.next_liquidation[i]);
                            if (error)
                                return "next_liquidation." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Liquidations message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.Liquidations} Liquidations
                 */
                Liquidations.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.Liquidations)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.Liquidations();
                    if (object.liquidation != null) {
                        if (typeof object.liquidation !== "object")
                            throw TypeError(".ununifi.nftbackedloan.Liquidations.liquidation: object expected");
                        message.liquidation = $root.ununifi.nftbackedloan.Liquidation.fromObject(object.liquidation);
                    }
                    if (object.next_liquidation) {
                        if (!Array.isArray(object.next_liquidation))
                            throw TypeError(".ununifi.nftbackedloan.Liquidations.next_liquidation: array expected");
                        message.next_liquidation = [];
                        for (var i = 0; i < object.next_liquidation.length; ++i) {
                            if (typeof object.next_liquidation[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.Liquidations.next_liquidation: object expected");
                            message.next_liquidation[i] = $root.ununifi.nftbackedloan.Liquidation.fromObject(object.next_liquidation[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Liquidations message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @static
                 * @param {ununifi.nftbackedloan.Liquidations} message Liquidations
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Liquidations.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.next_liquidation = [];
                    if (options.defaults)
                        object.liquidation = null;
                    if (message.liquidation != null && message.hasOwnProperty("liquidation"))
                        object.liquidation = $root.ununifi.nftbackedloan.Liquidation.toObject(message.liquidation, options);
                    if (message.next_liquidation && message.next_liquidation.length) {
                        object.next_liquidation = [];
                        for (var j = 0; j < message.next_liquidation.length; ++j)
                            object.next_liquidation[j] = $root.ununifi.nftbackedloan.Liquidation.toObject(message.next_liquidation[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Liquidations to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.Liquidations
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Liquidations.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Liquidations;
            })();
    
            nftbackedloan.RepayInfo = (function() {
    
                /**
                 * Properties of a RepayInfo.
                 * @memberof ununifi.nftbackedloan
                 * @interface IRepayInfo
                 * @property {cosmos.base.v1beta1.ICoin|null} [repaid_amount] RepayInfo repaid_amount
                 * @property {cosmos.base.v1beta1.ICoin|null} [repaid_interest_amount] RepayInfo repaid_interest_amount
                 * @property {cosmos.base.v1beta1.ICoin|null} [remaining_amount] RepayInfo remaining_amount
                 * @property {google.protobuf.ITimestamp|null} [last_repaid_at] RepayInfo last_repaid_at
                 */
    
                /**
                 * Constructs a new RepayInfo.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a RepayInfo.
                 * @implements IRepayInfo
                 * @constructor
                 * @param {ununifi.nftbackedloan.IRepayInfo=} [properties] Properties to set
                 */
                function RepayInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RepayInfo repaid_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} repaid_amount
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @instance
                 */
                RepayInfo.prototype.repaid_amount = null;
    
                /**
                 * RepayInfo repaid_interest_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} repaid_interest_amount
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @instance
                 */
                RepayInfo.prototype.repaid_interest_amount = null;
    
                /**
                 * RepayInfo remaining_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} remaining_amount
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @instance
                 */
                RepayInfo.prototype.remaining_amount = null;
    
                /**
                 * RepayInfo last_repaid_at.
                 * @member {google.protobuf.ITimestamp|null|undefined} last_repaid_at
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @instance
                 */
                RepayInfo.prototype.last_repaid_at = null;
    
                /**
                 * Encodes the specified RepayInfo message. Does not implicitly {@link ununifi.nftbackedloan.RepayInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @static
                 * @param {ununifi.nftbackedloan.IRepayInfo} message RepayInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RepayInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.repaid_amount != null && Object.hasOwnProperty.call(message, "repaid_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.repaid_amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.repaid_interest_amount != null && Object.hasOwnProperty.call(message, "repaid_interest_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.repaid_interest_amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.remaining_amount != null && Object.hasOwnProperty.call(message, "remaining_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.remaining_amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.last_repaid_at != null && Object.hasOwnProperty.call(message, "last_repaid_at"))
                        $root.google.protobuf.Timestamp.encode(message.last_repaid_at, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified RepayInfo message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.RepayInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @static
                 * @param {ununifi.nftbackedloan.IRepayInfo} message RepayInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RepayInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RepayInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.RepayInfo} RepayInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RepayInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.RepayInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.repaid_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.repaid_interest_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.remaining_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.last_repaid_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RepayInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.RepayInfo} RepayInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RepayInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RepayInfo message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RepayInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.repaid_amount != null && message.hasOwnProperty("repaid_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.repaid_amount);
                        if (error)
                            return "repaid_amount." + error;
                    }
                    if (message.repaid_interest_amount != null && message.hasOwnProperty("repaid_interest_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.repaid_interest_amount);
                        if (error)
                            return "repaid_interest_amount." + error;
                    }
                    if (message.remaining_amount != null && message.hasOwnProperty("remaining_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.remaining_amount);
                        if (error)
                            return "remaining_amount." + error;
                    }
                    if (message.last_repaid_at != null && message.hasOwnProperty("last_repaid_at")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.last_repaid_at);
                        if (error)
                            return "last_repaid_at." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a RepayInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.RepayInfo} RepayInfo
                 */
                RepayInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.RepayInfo)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.RepayInfo();
                    if (object.repaid_amount != null) {
                        if (typeof object.repaid_amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.RepayInfo.repaid_amount: object expected");
                        message.repaid_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.repaid_amount);
                    }
                    if (object.repaid_interest_amount != null) {
                        if (typeof object.repaid_interest_amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.RepayInfo.repaid_interest_amount: object expected");
                        message.repaid_interest_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.repaid_interest_amount);
                    }
                    if (object.remaining_amount != null) {
                        if (typeof object.remaining_amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.RepayInfo.remaining_amount: object expected");
                        message.remaining_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.remaining_amount);
                    }
                    if (object.last_repaid_at != null) {
                        if (typeof object.last_repaid_at !== "object")
                            throw TypeError(".ununifi.nftbackedloan.RepayInfo.last_repaid_at: object expected");
                        message.last_repaid_at = $root.google.protobuf.Timestamp.fromObject(object.last_repaid_at);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a RepayInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @static
                 * @param {ununifi.nftbackedloan.RepayInfo} message RepayInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RepayInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.repaid_amount = null;
                        object.repaid_interest_amount = null;
                        object.remaining_amount = null;
                        object.last_repaid_at = null;
                    }
                    if (message.repaid_amount != null && message.hasOwnProperty("repaid_amount"))
                        object.repaid_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.repaid_amount, options);
                    if (message.repaid_interest_amount != null && message.hasOwnProperty("repaid_interest_amount"))
                        object.repaid_interest_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.repaid_interest_amount, options);
                    if (message.remaining_amount != null && message.hasOwnProperty("remaining_amount"))
                        object.remaining_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.remaining_amount, options);
                    if (message.last_repaid_at != null && message.hasOwnProperty("last_repaid_at"))
                        object.last_repaid_at = $root.google.protobuf.Timestamp.toObject(message.last_repaid_at, options);
                    return object;
                };
    
                /**
                 * Converts this RepayInfo to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.RepayInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RepayInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RepayInfo;
            })();
    
            nftbackedloan.EventListNft = (function() {
    
                /**
                 * Properties of an EventListNft.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventListNft
                 * @property {string|null} [owner] EventListNft owner
                 * @property {string|null} [class_id] EventListNft class_id
                 * @property {string|null} [token_id] EventListNft token_id
                 */
    
                /**
                 * Constructs a new EventListNft.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventListNft.
                 * @implements IEventListNft
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventListNft=} [properties] Properties to set
                 */
                function EventListNft(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventListNft owner.
                 * @member {string} owner
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @instance
                 */
                EventListNft.prototype.owner = "";
    
                /**
                 * EventListNft class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @instance
                 */
                EventListNft.prototype.class_id = "";
    
                /**
                 * EventListNft token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @instance
                 */
                EventListNft.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventListNft message. Does not implicitly {@link ununifi.nftbackedloan.EventListNft.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @static
                 * @param {ununifi.nftbackedloan.IEventListNft} message EventListNft message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventListNft.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventListNft message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventListNft.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @static
                 * @param {ununifi.nftbackedloan.IEventListNft} message EventListNft message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventListNft.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventListNft message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventListNft} EventListNft
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventListNft.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventListNft();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.owner = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventListNft message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventListNft} EventListNft
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventListNft.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventListNft message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventListNft.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventListNft message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventListNft} EventListNft
                 */
                EventListNft.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventListNft)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventListNft();
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventListNft message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @static
                 * @param {ununifi.nftbackedloan.EventListNft} message EventListNft
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventListNft.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.owner = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventListNft to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventListNft
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventListNft.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventListNft;
            })();
    
            nftbackedloan.EventCancelListing = (function() {
    
                /**
                 * Properties of an EventCancelListing.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventCancelListing
                 * @property {string|null} [owner] EventCancelListing owner
                 * @property {string|null} [class_id] EventCancelListing class_id
                 * @property {string|null} [token_id] EventCancelListing token_id
                 */
    
                /**
                 * Constructs a new EventCancelListing.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventCancelListing.
                 * @implements IEventCancelListing
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventCancelListing=} [properties] Properties to set
                 */
                function EventCancelListing(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventCancelListing owner.
                 * @member {string} owner
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @instance
                 */
                EventCancelListing.prototype.owner = "";
    
                /**
                 * EventCancelListing class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @instance
                 */
                EventCancelListing.prototype.class_id = "";
    
                /**
                 * EventCancelListing token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @instance
                 */
                EventCancelListing.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventCancelListing message. Does not implicitly {@link ununifi.nftbackedloan.EventCancelListing.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @static
                 * @param {ununifi.nftbackedloan.IEventCancelListing} message EventCancelListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventCancelListing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventCancelListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventCancelListing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @static
                 * @param {ununifi.nftbackedloan.IEventCancelListing} message EventCancelListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventCancelListing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventCancelListing message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventCancelListing} EventCancelListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventCancelListing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventCancelListing();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.owner = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventCancelListing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventCancelListing} EventCancelListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventCancelListing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventCancelListing message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventCancelListing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventCancelListing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventCancelListing} EventCancelListing
                 */
                EventCancelListing.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventCancelListing)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventCancelListing();
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventCancelListing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @static
                 * @param {ununifi.nftbackedloan.EventCancelListing} message EventCancelListing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventCancelListing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.owner = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventCancelListing to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventCancelListing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventCancelListing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventCancelListing;
            })();
    
            nftbackedloan.EventSellingDecision = (function() {
    
                /**
                 * Properties of an EventSellingDecision.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventSellingDecision
                 * @property {string|null} [owner] EventSellingDecision owner
                 * @property {string|null} [class_id] EventSellingDecision class_id
                 * @property {string|null} [token_id] EventSellingDecision token_id
                 */
    
                /**
                 * Constructs a new EventSellingDecision.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventSellingDecision.
                 * @implements IEventSellingDecision
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventSellingDecision=} [properties] Properties to set
                 */
                function EventSellingDecision(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventSellingDecision owner.
                 * @member {string} owner
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @instance
                 */
                EventSellingDecision.prototype.owner = "";
    
                /**
                 * EventSellingDecision class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @instance
                 */
                EventSellingDecision.prototype.class_id = "";
    
                /**
                 * EventSellingDecision token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @instance
                 */
                EventSellingDecision.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventSellingDecision message. Does not implicitly {@link ununifi.nftbackedloan.EventSellingDecision.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @static
                 * @param {ununifi.nftbackedloan.IEventSellingDecision} message EventSellingDecision message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventSellingDecision.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventSellingDecision.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @static
                 * @param {ununifi.nftbackedloan.IEventSellingDecision} message EventSellingDecision message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventSellingDecision message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventSellingDecision} EventSellingDecision
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventSellingDecision.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventSellingDecision();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.owner = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventSellingDecision message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventSellingDecision} EventSellingDecision
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventSellingDecision.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventSellingDecision message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventSellingDecision.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventSellingDecision message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventSellingDecision} EventSellingDecision
                 */
                EventSellingDecision.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventSellingDecision)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventSellingDecision();
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventSellingDecision message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @static
                 * @param {ununifi.nftbackedloan.EventSellingDecision} message EventSellingDecision
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventSellingDecision.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.owner = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventSellingDecision to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventSellingDecision
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventSellingDecision.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventSellingDecision;
            })();
    
            nftbackedloan.EventEndListing = (function() {
    
                /**
                 * Properties of an EventEndListing.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventEndListing
                 * @property {string|null} [owner] EventEndListing owner
                 * @property {string|null} [class_id] EventEndListing class_id
                 * @property {string|null} [token_id] EventEndListing token_id
                 */
    
                /**
                 * Constructs a new EventEndListing.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventEndListing.
                 * @implements IEventEndListing
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventEndListing=} [properties] Properties to set
                 */
                function EventEndListing(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventEndListing owner.
                 * @member {string} owner
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @instance
                 */
                EventEndListing.prototype.owner = "";
    
                /**
                 * EventEndListing class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @instance
                 */
                EventEndListing.prototype.class_id = "";
    
                /**
                 * EventEndListing token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @instance
                 */
                EventEndListing.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventEndListing message. Does not implicitly {@link ununifi.nftbackedloan.EventEndListing.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @static
                 * @param {ununifi.nftbackedloan.IEventEndListing} message EventEndListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventEndListing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventEndListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventEndListing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @static
                 * @param {ununifi.nftbackedloan.IEventEndListing} message EventEndListing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventEndListing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventEndListing message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventEndListing} EventEndListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventEndListing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventEndListing();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.owner = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventEndListing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventEndListing} EventEndListing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventEndListing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventEndListing message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventEndListing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventEndListing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventEndListing} EventEndListing
                 */
                EventEndListing.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventEndListing)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventEndListing();
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventEndListing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @static
                 * @param {ununifi.nftbackedloan.EventEndListing} message EventEndListing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventEndListing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.owner = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventEndListing to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventEndListing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventEndListing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventEndListing;
            })();
    
            nftbackedloan.EventPlaceBid = (function() {
    
                /**
                 * Properties of an EventPlaceBid.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventPlaceBid
                 * @property {string|null} [bidder] EventPlaceBid bidder
                 * @property {string|null} [class_id] EventPlaceBid class_id
                 * @property {string|null} [token_id] EventPlaceBid token_id
                 * @property {string|null} [amount] EventPlaceBid amount
                 */
    
                /**
                 * Constructs a new EventPlaceBid.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventPlaceBid.
                 * @implements IEventPlaceBid
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventPlaceBid=} [properties] Properties to set
                 */
                function EventPlaceBid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPlaceBid bidder.
                 * @member {string} bidder
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @instance
                 */
                EventPlaceBid.prototype.bidder = "";
    
                /**
                 * EventPlaceBid class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @instance
                 */
                EventPlaceBid.prototype.class_id = "";
    
                /**
                 * EventPlaceBid token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @instance
                 */
                EventPlaceBid.prototype.token_id = "";
    
                /**
                 * EventPlaceBid amount.
                 * @member {string} amount
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @instance
                 */
                EventPlaceBid.prototype.amount = "";
    
                /**
                 * Encodes the specified EventPlaceBid message. Does not implicitly {@link ununifi.nftbackedloan.EventPlaceBid.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @static
                 * @param {ununifi.nftbackedloan.IEventPlaceBid} message EventPlaceBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPlaceBid.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bidder != null && Object.hasOwnProperty.call(message, "bidder"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bidder);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventPlaceBid.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @static
                 * @param {ununifi.nftbackedloan.IEventPlaceBid} message EventPlaceBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPlaceBid message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventPlaceBid} EventPlaceBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPlaceBid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventPlaceBid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bidder = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        case 4:
                            message.amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPlaceBid message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventPlaceBid} EventPlaceBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPlaceBid.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPlaceBid message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPlaceBid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        if (!$util.isString(message.bidder))
                            return "bidder: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        if (!$util.isString(message.amount))
                            return "amount: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPlaceBid message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventPlaceBid} EventPlaceBid
                 */
                EventPlaceBid.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventPlaceBid)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventPlaceBid();
                    if (object.bidder != null)
                        message.bidder = String(object.bidder);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    if (object.amount != null)
                        message.amount = String(object.amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPlaceBid message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @static
                 * @param {ununifi.nftbackedloan.EventPlaceBid} message EventPlaceBid
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPlaceBid.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.bidder = "";
                        object.class_id = "";
                        object.token_id = "";
                        object.amount = "";
                    }
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        object.bidder = message.bidder;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = message.amount;
                    return object;
                };
    
                /**
                 * Converts this EventPlaceBid to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventPlaceBid
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPlaceBid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPlaceBid;
            })();
    
            nftbackedloan.EventCancelBid = (function() {
    
                /**
                 * Properties of an EventCancelBid.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventCancelBid
                 * @property {string|null} [bidder] EventCancelBid bidder
                 * @property {string|null} [class_id] EventCancelBid class_id
                 * @property {string|null} [token_id] EventCancelBid token_id
                 */
    
                /**
                 * Constructs a new EventCancelBid.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventCancelBid.
                 * @implements IEventCancelBid
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventCancelBid=} [properties] Properties to set
                 */
                function EventCancelBid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventCancelBid bidder.
                 * @member {string} bidder
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @instance
                 */
                EventCancelBid.prototype.bidder = "";
    
                /**
                 * EventCancelBid class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @instance
                 */
                EventCancelBid.prototype.class_id = "";
    
                /**
                 * EventCancelBid token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @instance
                 */
                EventCancelBid.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventCancelBid message. Does not implicitly {@link ununifi.nftbackedloan.EventCancelBid.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @static
                 * @param {ununifi.nftbackedloan.IEventCancelBid} message EventCancelBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventCancelBid.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bidder != null && Object.hasOwnProperty.call(message, "bidder"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bidder);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventCancelBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventCancelBid.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @static
                 * @param {ununifi.nftbackedloan.IEventCancelBid} message EventCancelBid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventCancelBid message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventCancelBid} EventCancelBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventCancelBid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventCancelBid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bidder = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventCancelBid message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventCancelBid} EventCancelBid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventCancelBid.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventCancelBid message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventCancelBid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        if (!$util.isString(message.bidder))
                            return "bidder: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventCancelBid message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventCancelBid} EventCancelBid
                 */
                EventCancelBid.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventCancelBid)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventCancelBid();
                    if (object.bidder != null)
                        message.bidder = String(object.bidder);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventCancelBid message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @static
                 * @param {ununifi.nftbackedloan.EventCancelBid} message EventCancelBid
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventCancelBid.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.bidder = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        object.bidder = message.bidder;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventCancelBid to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventCancelBid
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventCancelBid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventCancelBid;
            })();
    
            nftbackedloan.EventPayRemainder = (function() {
    
                /**
                 * Properties of an EventPayRemainder.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventPayRemainder
                 * @property {string|null} [bidder] EventPayRemainder bidder
                 * @property {string|null} [class_id] EventPayRemainder class_id
                 * @property {string|null} [token_id] EventPayRemainder token_id
                 */
    
                /**
                 * Constructs a new EventPayRemainder.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventPayRemainder.
                 * @implements IEventPayRemainder
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventPayRemainder=} [properties] Properties to set
                 */
                function EventPayRemainder(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventPayRemainder bidder.
                 * @member {string} bidder
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @instance
                 */
                EventPayRemainder.prototype.bidder = "";
    
                /**
                 * EventPayRemainder class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @instance
                 */
                EventPayRemainder.prototype.class_id = "";
    
                /**
                 * EventPayRemainder token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @instance
                 */
                EventPayRemainder.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventPayRemainder message. Does not implicitly {@link ununifi.nftbackedloan.EventPayRemainder.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @static
                 * @param {ununifi.nftbackedloan.IEventPayRemainder} message EventPayRemainder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPayRemainder.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bidder != null && Object.hasOwnProperty.call(message, "bidder"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bidder);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventPayRemainder message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventPayRemainder.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @static
                 * @param {ununifi.nftbackedloan.IEventPayRemainder} message EventPayRemainder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventPayRemainder.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventPayRemainder message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventPayRemainder} EventPayRemainder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPayRemainder.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventPayRemainder();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bidder = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventPayRemainder message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventPayRemainder} EventPayRemainder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventPayRemainder.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventPayRemainder message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventPayRemainder.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        if (!$util.isString(message.bidder))
                            return "bidder: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventPayRemainder message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventPayRemainder} EventPayRemainder
                 */
                EventPayRemainder.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventPayRemainder)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventPayRemainder();
                    if (object.bidder != null)
                        message.bidder = String(object.bidder);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventPayRemainder message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @static
                 * @param {ununifi.nftbackedloan.EventPayRemainder} message EventPayRemainder
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventPayRemainder.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.bidder = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        object.bidder = message.bidder;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventPayRemainder to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventPayRemainder
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventPayRemainder.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventPayRemainder;
            })();
    
            nftbackedloan.EventBorrow = (function() {
    
                /**
                 * Properties of an EventBorrow.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventBorrow
                 * @property {string|null} [borrower] EventBorrow borrower
                 * @property {string|null} [class_id] EventBorrow class_id
                 * @property {string|null} [token_id] EventBorrow token_id
                 * @property {string|null} [amount] EventBorrow amount
                 */
    
                /**
                 * Constructs a new EventBorrow.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventBorrow.
                 * @implements IEventBorrow
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventBorrow=} [properties] Properties to set
                 */
                function EventBorrow(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventBorrow borrower.
                 * @member {string} borrower
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @instance
                 */
                EventBorrow.prototype.borrower = "";
    
                /**
                 * EventBorrow class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @instance
                 */
                EventBorrow.prototype.class_id = "";
    
                /**
                 * EventBorrow token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @instance
                 */
                EventBorrow.prototype.token_id = "";
    
                /**
                 * EventBorrow amount.
                 * @member {string} amount
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @instance
                 */
                EventBorrow.prototype.amount = "";
    
                /**
                 * Encodes the specified EventBorrow message. Does not implicitly {@link ununifi.nftbackedloan.EventBorrow.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @static
                 * @param {ununifi.nftbackedloan.IEventBorrow} message EventBorrow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventBorrow.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.borrower != null && Object.hasOwnProperty.call(message, "borrower"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.borrower);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventBorrow message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventBorrow.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @static
                 * @param {ununifi.nftbackedloan.IEventBorrow} message EventBorrow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventBorrow.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventBorrow message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventBorrow} EventBorrow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventBorrow.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventBorrow();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.borrower = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        case 4:
                            message.amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventBorrow message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventBorrow} EventBorrow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventBorrow.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventBorrow message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventBorrow.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.borrower != null && message.hasOwnProperty("borrower"))
                        if (!$util.isString(message.borrower))
                            return "borrower: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        if (!$util.isString(message.amount))
                            return "amount: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventBorrow message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventBorrow} EventBorrow
                 */
                EventBorrow.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventBorrow)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventBorrow();
                    if (object.borrower != null)
                        message.borrower = String(object.borrower);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    if (object.amount != null)
                        message.amount = String(object.amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventBorrow message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @static
                 * @param {ununifi.nftbackedloan.EventBorrow} message EventBorrow
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventBorrow.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.borrower = "";
                        object.class_id = "";
                        object.token_id = "";
                        object.amount = "";
                    }
                    if (message.borrower != null && message.hasOwnProperty("borrower"))
                        object.borrower = message.borrower;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = message.amount;
                    return object;
                };
    
                /**
                 * Converts this EventBorrow to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventBorrow
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventBorrow.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventBorrow;
            })();
    
            nftbackedloan.EventRepay = (function() {
    
                /**
                 * Properties of an EventRepay.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventRepay
                 * @property {string|null} [borrower] EventRepay borrower
                 * @property {string|null} [class_id] EventRepay class_id
                 * @property {string|null} [token_id] EventRepay token_id
                 * @property {string|null} [amount] EventRepay amount
                 */
    
                /**
                 * Constructs a new EventRepay.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventRepay.
                 * @implements IEventRepay
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventRepay=} [properties] Properties to set
                 */
                function EventRepay(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventRepay borrower.
                 * @member {string} borrower
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @instance
                 */
                EventRepay.prototype.borrower = "";
    
                /**
                 * EventRepay class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @instance
                 */
                EventRepay.prototype.class_id = "";
    
                /**
                 * EventRepay token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @instance
                 */
                EventRepay.prototype.token_id = "";
    
                /**
                 * EventRepay amount.
                 * @member {string} amount
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @instance
                 */
                EventRepay.prototype.amount = "";
    
                /**
                 * Encodes the specified EventRepay message. Does not implicitly {@link ununifi.nftbackedloan.EventRepay.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @static
                 * @param {ununifi.nftbackedloan.IEventRepay} message EventRepay message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventRepay.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.borrower != null && Object.hasOwnProperty.call(message, "borrower"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.borrower);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventRepay message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventRepay.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @static
                 * @param {ununifi.nftbackedloan.IEventRepay} message EventRepay message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventRepay.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventRepay message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventRepay} EventRepay
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventRepay.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventRepay();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.borrower = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        case 4:
                            message.amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventRepay message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventRepay} EventRepay
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventRepay.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventRepay message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventRepay.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.borrower != null && message.hasOwnProperty("borrower"))
                        if (!$util.isString(message.borrower))
                            return "borrower: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        if (!$util.isString(message.amount))
                            return "amount: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventRepay message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventRepay} EventRepay
                 */
                EventRepay.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventRepay)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventRepay();
                    if (object.borrower != null)
                        message.borrower = String(object.borrower);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    if (object.amount != null)
                        message.amount = String(object.amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventRepay message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @static
                 * @param {ununifi.nftbackedloan.EventRepay} message EventRepay
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventRepay.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.borrower = "";
                        object.class_id = "";
                        object.token_id = "";
                        object.amount = "";
                    }
                    if (message.borrower != null && message.hasOwnProperty("borrower"))
                        object.borrower = message.borrower;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = message.amount;
                    return object;
                };
    
                /**
                 * Converts this EventRepay to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventRepay
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventRepay.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventRepay;
            })();
    
            nftbackedloan.EventLiquidate = (function() {
    
                /**
                 * Properties of an EventLiquidate.
                 * @memberof ununifi.nftbackedloan
                 * @interface IEventLiquidate
                 * @property {string|null} [liquidator] EventLiquidate liquidator
                 * @property {string|null} [class_id] EventLiquidate class_id
                 * @property {string|null} [token_id] EventLiquidate token_id
                 */
    
                /**
                 * Constructs a new EventLiquidate.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents an EventLiquidate.
                 * @implements IEventLiquidate
                 * @constructor
                 * @param {ununifi.nftbackedloan.IEventLiquidate=} [properties] Properties to set
                 */
                function EventLiquidate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventLiquidate liquidator.
                 * @member {string} liquidator
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @instance
                 */
                EventLiquidate.prototype.liquidator = "";
    
                /**
                 * EventLiquidate class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @instance
                 */
                EventLiquidate.prototype.class_id = "";
    
                /**
                 * EventLiquidate token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @instance
                 */
                EventLiquidate.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventLiquidate message. Does not implicitly {@link ununifi.nftbackedloan.EventLiquidate.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @static
                 * @param {ununifi.nftbackedloan.IEventLiquidate} message EventLiquidate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventLiquidate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.liquidator != null && Object.hasOwnProperty.call(message, "liquidator"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.liquidator);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventLiquidate message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventLiquidate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @static
                 * @param {ununifi.nftbackedloan.IEventLiquidate} message EventLiquidate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventLiquidate message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.EventLiquidate} EventLiquidate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventLiquidate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.EventLiquidate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.liquidator = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventLiquidate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.EventLiquidate} EventLiquidate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventLiquidate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventLiquidate message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventLiquidate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.liquidator != null && message.hasOwnProperty("liquidator"))
                        if (!$util.isString(message.liquidator))
                            return "liquidator: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventLiquidate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.EventLiquidate} EventLiquidate
                 */
                EventLiquidate.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.EventLiquidate)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.EventLiquidate();
                    if (object.liquidator != null)
                        message.liquidator = String(object.liquidator);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventLiquidate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @static
                 * @param {ununifi.nftbackedloan.EventLiquidate} message EventLiquidate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventLiquidate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.liquidator = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.liquidator != null && message.hasOwnProperty("liquidator"))
                        object.liquidator = message.liquidator;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventLiquidate to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.EventLiquidate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventLiquidate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventLiquidate;
            })();
    
            nftbackedloan.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof ununifi.nftbackedloan
                 * @interface IGenesisState
                 * @property {ununifi.nftbackedloan.IParams|null} [params] GenesisState params
                 * @property {Array.<ununifi.nftbackedloan.IListing>|null} [listings] GenesisState listings
                 * @property {Array.<ununifi.nftbackedloan.IBid>|null} [bids] GenesisState bids
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {ununifi.nftbackedloan.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.listings = [];
                    this.bids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState params.
                 * @member {ununifi.nftbackedloan.IParams|null|undefined} params
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @instance
                 */
                GenesisState.prototype.params = null;
    
                /**
                 * GenesisState listings.
                 * @member {Array.<ununifi.nftbackedloan.IListing>} listings
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @instance
                 */
                GenesisState.prototype.listings = $util.emptyArray;
    
                /**
                 * GenesisState bids.
                 * @member {Array.<ununifi.nftbackedloan.IBid>} bids
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @instance
                 */
                GenesisState.prototype.bids = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftbackedloan.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @static
                 * @param {ununifi.nftbackedloan.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.nftbackedloan.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.listings != null && message.listings.length)
                        for (var i = 0; i < message.listings.length; ++i)
                            $root.ununifi.nftbackedloan.Listing.encode(message.listings[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.bids != null && message.bids.length)
                        for (var i = 0; i < message.bids.length; ++i)
                            $root.ununifi.nftbackedloan.Bid.encode(message.bids[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @static
                 * @param {ununifi.nftbackedloan.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.nftbackedloan.Params.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.listings && message.listings.length))
                                message.listings = [];
                            message.listings.push($root.ununifi.nftbackedloan.Listing.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.bids && message.bids.length))
                                message.bids = [];
                            message.bids.push($root.ununifi.nftbackedloan.Bid.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.nftbackedloan.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.listings != null && message.hasOwnProperty("listings")) {
                        if (!Array.isArray(message.listings))
                            return "listings: array expected";
                        for (var i = 0; i < message.listings.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.Listing.verify(message.listings[i]);
                            if (error)
                                return "listings." + error;
                        }
                    }
                    if (message.bids != null && message.hasOwnProperty("bids")) {
                        if (!Array.isArray(message.bids))
                            return "bids: array expected";
                        for (var i = 0; i < message.bids.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.Bid.verify(message.bids[i]);
                            if (error)
                                return "bids." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.GenesisState)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.GenesisState();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.nftbackedloan.GenesisState.params: object expected");
                        message.params = $root.ununifi.nftbackedloan.Params.fromObject(object.params);
                    }
                    if (object.listings) {
                        if (!Array.isArray(object.listings))
                            throw TypeError(".ununifi.nftbackedloan.GenesisState.listings: array expected");
                        message.listings = [];
                        for (var i = 0; i < object.listings.length; ++i) {
                            if (typeof object.listings[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.GenesisState.listings: object expected");
                            message.listings[i] = $root.ununifi.nftbackedloan.Listing.fromObject(object.listings[i]);
                        }
                    }
                    if (object.bids) {
                        if (!Array.isArray(object.bids))
                            throw TypeError(".ununifi.nftbackedloan.GenesisState.bids: array expected");
                        message.bids = [];
                        for (var i = 0; i < object.bids.length; ++i) {
                            if (typeof object.bids[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.GenesisState.bids: object expected");
                            message.bids[i] = $root.ununifi.nftbackedloan.Bid.fromObject(object.bids[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @static
                 * @param {ununifi.nftbackedloan.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.listings = [];
                        object.bids = [];
                    }
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.nftbackedloan.Params.toObject(message.params, options);
                    if (message.listings && message.listings.length) {
                        object.listings = [];
                        for (var j = 0; j < message.listings.length; ++j)
                            object.listings[j] = $root.ununifi.nftbackedloan.Listing.toObject(message.listings[j], options);
                    }
                    if (message.bids && message.bids.length) {
                        object.bids = [];
                        for (var j = 0; j < message.bids.length; ++j)
                            object.bids[j] = $root.ununifi.nftbackedloan.Bid.toObject(message.bids[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            nftbackedloan.Params = (function() {
    
                /**
                 * Properties of a Params.
                 * @memberof ununifi.nftbackedloan
                 * @interface IParams
                 * @property {string|null} [min_staking_for_listing] Params min_staking_for_listing
                 * @property {Array.<string>|null} [bid_tokens] Params bid_tokens
                 * @property {Long|null} [nft_listing_cancel_required_seconds] Params nft_listing_cancel_required_seconds
                 * @property {Long|null} [bid_cancel_required_seconds] Params bid_cancel_required_seconds
                 * @property {Long|null} [nft_listing_full_payment_period] Params nft_listing_full_payment_period
                 * @property {Long|null} [nft_listing_nft_delivery_period] Params nft_listing_nft_delivery_period
                 * @property {string|null} [nft_listing_commission_rate] Params nft_listing_commission_rate
                 */
    
                /**
                 * Constructs a new Params.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Params.
                 * @implements IParams
                 * @constructor
                 * @param {ununifi.nftbackedloan.IParams=} [properties] Properties to set
                 */
                function Params(properties) {
                    this.bid_tokens = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Params min_staking_for_listing.
                 * @member {string} min_staking_for_listing
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 */
                Params.prototype.min_staking_for_listing = "";
    
                /**
                 * Params bid_tokens.
                 * @member {Array.<string>} bid_tokens
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 */
                Params.prototype.bid_tokens = $util.emptyArray;
    
                /**
                 * Params nft_listing_cancel_required_seconds.
                 * @member {Long} nft_listing_cancel_required_seconds
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 */
                Params.prototype.nft_listing_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Params bid_cancel_required_seconds.
                 * @member {Long} bid_cancel_required_seconds
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 */
                Params.prototype.bid_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Params nft_listing_full_payment_period.
                 * @member {Long} nft_listing_full_payment_period
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 */
                Params.prototype.nft_listing_full_payment_period = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Params nft_listing_nft_delivery_period.
                 * @member {Long} nft_listing_nft_delivery_period
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 */
                Params.prototype.nft_listing_nft_delivery_period = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Params nft_listing_commission_rate.
                 * @member {string} nft_listing_commission_rate
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 */
                Params.prototype.nft_listing_commission_rate = "";
    
                /**
                 * Encodes the specified Params message. Does not implicitly {@link ununifi.nftbackedloan.Params.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.Params
                 * @static
                 * @param {ununifi.nftbackedloan.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.min_staking_for_listing != null && Object.hasOwnProperty.call(message, "min_staking_for_listing"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.min_staking_for_listing);
                    if (message.bid_tokens != null && message.bid_tokens.length)
                        for (var i = 0; i < message.bid_tokens.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.bid_tokens[i]);
                    if (message.nft_listing_cancel_required_seconds != null && Object.hasOwnProperty.call(message, "nft_listing_cancel_required_seconds"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.nft_listing_cancel_required_seconds);
                    if (message.bid_cancel_required_seconds != null && Object.hasOwnProperty.call(message, "bid_cancel_required_seconds"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.bid_cancel_required_seconds);
                    if (message.nft_listing_full_payment_period != null && Object.hasOwnProperty.call(message, "nft_listing_full_payment_period"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.nft_listing_full_payment_period);
                    if (message.nft_listing_nft_delivery_period != null && Object.hasOwnProperty.call(message, "nft_listing_nft_delivery_period"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.nft_listing_nft_delivery_period);
                    if (message.nft_listing_commission_rate != null && Object.hasOwnProperty.call(message, "nft_listing_commission_rate"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.nft_listing_commission_rate);
                    return writer;
                };
    
                /**
                 * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Params.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.Params
                 * @static
                 * @param {ununifi.nftbackedloan.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.Params();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.min_staking_for_listing = reader.string();
                            break;
                        case 2:
                            if (!(message.bid_tokens && message.bid_tokens.length))
                                message.bid_tokens = [];
                            message.bid_tokens.push(reader.string());
                            break;
                        case 3:
                            message.nft_listing_cancel_required_seconds = reader.uint64();
                            break;
                        case 4:
                            message.bid_cancel_required_seconds = reader.uint64();
                            break;
                        case 5:
                            message.nft_listing_full_payment_period = reader.uint64();
                            break;
                        case 6:
                            message.nft_listing_nft_delivery_period = reader.uint64();
                            break;
                        case 7:
                            message.nft_listing_commission_rate = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Params message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.Params
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Params.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.min_staking_for_listing != null && message.hasOwnProperty("min_staking_for_listing"))
                        if (!$util.isString(message.min_staking_for_listing))
                            return "min_staking_for_listing: string expected";
                    if (message.bid_tokens != null && message.hasOwnProperty("bid_tokens")) {
                        if (!Array.isArray(message.bid_tokens))
                            return "bid_tokens: array expected";
                        for (var i = 0; i < message.bid_tokens.length; ++i)
                            if (!$util.isString(message.bid_tokens[i]))
                                return "bid_tokens: string[] expected";
                    }
                    if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty("nft_listing_cancel_required_seconds"))
                        if (!$util.isInteger(message.nft_listing_cancel_required_seconds) && !(message.nft_listing_cancel_required_seconds && $util.isInteger(message.nft_listing_cancel_required_seconds.low) && $util.isInteger(message.nft_listing_cancel_required_seconds.high)))
                            return "nft_listing_cancel_required_seconds: integer|Long expected";
                    if (message.bid_cancel_required_seconds != null && message.hasOwnProperty("bid_cancel_required_seconds"))
                        if (!$util.isInteger(message.bid_cancel_required_seconds) && !(message.bid_cancel_required_seconds && $util.isInteger(message.bid_cancel_required_seconds.low) && $util.isInteger(message.bid_cancel_required_seconds.high)))
                            return "bid_cancel_required_seconds: integer|Long expected";
                    if (message.nft_listing_full_payment_period != null && message.hasOwnProperty("nft_listing_full_payment_period"))
                        if (!$util.isInteger(message.nft_listing_full_payment_period) && !(message.nft_listing_full_payment_period && $util.isInteger(message.nft_listing_full_payment_period.low) && $util.isInteger(message.nft_listing_full_payment_period.high)))
                            return "nft_listing_full_payment_period: integer|Long expected";
                    if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty("nft_listing_nft_delivery_period"))
                        if (!$util.isInteger(message.nft_listing_nft_delivery_period) && !(message.nft_listing_nft_delivery_period && $util.isInteger(message.nft_listing_nft_delivery_period.low) && $util.isInteger(message.nft_listing_nft_delivery_period.high)))
                            return "nft_listing_nft_delivery_period: integer|Long expected";
                    if (message.nft_listing_commission_rate != null && message.hasOwnProperty("nft_listing_commission_rate"))
                        if (!$util.isString(message.nft_listing_commission_rate))
                            return "nft_listing_commission_rate: string expected";
                    return null;
                };
    
                /**
                 * Creates a Params message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.Params
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.Params} Params
                 */
                Params.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.Params)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.Params();
                    if (object.min_staking_for_listing != null)
                        message.min_staking_for_listing = String(object.min_staking_for_listing);
                    if (object.bid_tokens) {
                        if (!Array.isArray(object.bid_tokens))
                            throw TypeError(".ununifi.nftbackedloan.Params.bid_tokens: array expected");
                        message.bid_tokens = [];
                        for (var i = 0; i < object.bid_tokens.length; ++i)
                            message.bid_tokens[i] = String(object.bid_tokens[i]);
                    }
                    if (object.nft_listing_cancel_required_seconds != null)
                        if ($util.Long)
                            (message.nft_listing_cancel_required_seconds = $util.Long.fromValue(object.nft_listing_cancel_required_seconds)).unsigned = true;
                        else if (typeof object.nft_listing_cancel_required_seconds === "string")
                            message.nft_listing_cancel_required_seconds = parseInt(object.nft_listing_cancel_required_seconds, 10);
                        else if (typeof object.nft_listing_cancel_required_seconds === "number")
                            message.nft_listing_cancel_required_seconds = object.nft_listing_cancel_required_seconds;
                        else if (typeof object.nft_listing_cancel_required_seconds === "object")
                            message.nft_listing_cancel_required_seconds = new $util.LongBits(object.nft_listing_cancel_required_seconds.low >>> 0, object.nft_listing_cancel_required_seconds.high >>> 0).toNumber(true);
                    if (object.bid_cancel_required_seconds != null)
                        if ($util.Long)
                            (message.bid_cancel_required_seconds = $util.Long.fromValue(object.bid_cancel_required_seconds)).unsigned = true;
                        else if (typeof object.bid_cancel_required_seconds === "string")
                            message.bid_cancel_required_seconds = parseInt(object.bid_cancel_required_seconds, 10);
                        else if (typeof object.bid_cancel_required_seconds === "number")
                            message.bid_cancel_required_seconds = object.bid_cancel_required_seconds;
                        else if (typeof object.bid_cancel_required_seconds === "object")
                            message.bid_cancel_required_seconds = new $util.LongBits(object.bid_cancel_required_seconds.low >>> 0, object.bid_cancel_required_seconds.high >>> 0).toNumber(true);
                    if (object.nft_listing_full_payment_period != null)
                        if ($util.Long)
                            (message.nft_listing_full_payment_period = $util.Long.fromValue(object.nft_listing_full_payment_period)).unsigned = true;
                        else if (typeof object.nft_listing_full_payment_period === "string")
                            message.nft_listing_full_payment_period = parseInt(object.nft_listing_full_payment_period, 10);
                        else if (typeof object.nft_listing_full_payment_period === "number")
                            message.nft_listing_full_payment_period = object.nft_listing_full_payment_period;
                        else if (typeof object.nft_listing_full_payment_period === "object")
                            message.nft_listing_full_payment_period = new $util.LongBits(object.nft_listing_full_payment_period.low >>> 0, object.nft_listing_full_payment_period.high >>> 0).toNumber(true);
                    if (object.nft_listing_nft_delivery_period != null)
                        if ($util.Long)
                            (message.nft_listing_nft_delivery_period = $util.Long.fromValue(object.nft_listing_nft_delivery_period)).unsigned = true;
                        else if (typeof object.nft_listing_nft_delivery_period === "string")
                            message.nft_listing_nft_delivery_period = parseInt(object.nft_listing_nft_delivery_period, 10);
                        else if (typeof object.nft_listing_nft_delivery_period === "number")
                            message.nft_listing_nft_delivery_period = object.nft_listing_nft_delivery_period;
                        else if (typeof object.nft_listing_nft_delivery_period === "object")
                            message.nft_listing_nft_delivery_period = new $util.LongBits(object.nft_listing_nft_delivery_period.low >>> 0, object.nft_listing_nft_delivery_period.high >>> 0).toNumber(true);
                    if (object.nft_listing_commission_rate != null)
                        message.nft_listing_commission_rate = String(object.nft_listing_commission_rate);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Params message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.Params
                 * @static
                 * @param {ununifi.nftbackedloan.Params} message Params
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Params.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.bid_tokens = [];
                    if (options.defaults) {
                        object.min_staking_for_listing = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nft_listing_cancel_required_seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nft_listing_cancel_required_seconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.bid_cancel_required_seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.bid_cancel_required_seconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nft_listing_full_payment_period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nft_listing_full_payment_period = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nft_listing_nft_delivery_period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nft_listing_nft_delivery_period = options.longs === String ? "0" : 0;
                        object.nft_listing_commission_rate = "";
                    }
                    if (message.min_staking_for_listing != null && message.hasOwnProperty("min_staking_for_listing"))
                        object.min_staking_for_listing = message.min_staking_for_listing;
                    if (message.bid_tokens && message.bid_tokens.length) {
                        object.bid_tokens = [];
                        for (var j = 0; j < message.bid_tokens.length; ++j)
                            object.bid_tokens[j] = message.bid_tokens[j];
                    }
                    if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty("nft_listing_cancel_required_seconds"))
                        if (typeof message.nft_listing_cancel_required_seconds === "number")
                            object.nft_listing_cancel_required_seconds = options.longs === String ? String(message.nft_listing_cancel_required_seconds) : message.nft_listing_cancel_required_seconds;
                        else
                            object.nft_listing_cancel_required_seconds = options.longs === String ? $util.Long.prototype.toString.call(message.nft_listing_cancel_required_seconds) : options.longs === Number ? new $util.LongBits(message.nft_listing_cancel_required_seconds.low >>> 0, message.nft_listing_cancel_required_seconds.high >>> 0).toNumber(true) : message.nft_listing_cancel_required_seconds;
                    if (message.bid_cancel_required_seconds != null && message.hasOwnProperty("bid_cancel_required_seconds"))
                        if (typeof message.bid_cancel_required_seconds === "number")
                            object.bid_cancel_required_seconds = options.longs === String ? String(message.bid_cancel_required_seconds) : message.bid_cancel_required_seconds;
                        else
                            object.bid_cancel_required_seconds = options.longs === String ? $util.Long.prototype.toString.call(message.bid_cancel_required_seconds) : options.longs === Number ? new $util.LongBits(message.bid_cancel_required_seconds.low >>> 0, message.bid_cancel_required_seconds.high >>> 0).toNumber(true) : message.bid_cancel_required_seconds;
                    if (message.nft_listing_full_payment_period != null && message.hasOwnProperty("nft_listing_full_payment_period"))
                        if (typeof message.nft_listing_full_payment_period === "number")
                            object.nft_listing_full_payment_period = options.longs === String ? String(message.nft_listing_full_payment_period) : message.nft_listing_full_payment_period;
                        else
                            object.nft_listing_full_payment_period = options.longs === String ? $util.Long.prototype.toString.call(message.nft_listing_full_payment_period) : options.longs === Number ? new $util.LongBits(message.nft_listing_full_payment_period.low >>> 0, message.nft_listing_full_payment_period.high >>> 0).toNumber(true) : message.nft_listing_full_payment_period;
                    if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty("nft_listing_nft_delivery_period"))
                        if (typeof message.nft_listing_nft_delivery_period === "number")
                            object.nft_listing_nft_delivery_period = options.longs === String ? String(message.nft_listing_nft_delivery_period) : message.nft_listing_nft_delivery_period;
                        else
                            object.nft_listing_nft_delivery_period = options.longs === String ? $util.Long.prototype.toString.call(message.nft_listing_nft_delivery_period) : options.longs === Number ? new $util.LongBits(message.nft_listing_nft_delivery_period.low >>> 0, message.nft_listing_nft_delivery_period.high >>> 0).toNumber(true) : message.nft_listing_nft_delivery_period;
                    if (message.nft_listing_commission_rate != null && message.hasOwnProperty("nft_listing_commission_rate"))
                        object.nft_listing_commission_rate = message.nft_listing_commission_rate;
                    return object;
                };
    
                /**
                 * Converts this Params to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.Params
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Params.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Params;
            })();
    
            nftbackedloan.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#params}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef ParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryParamsResponse} [response] QueryParamsResponse
                 */
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.params = function params(request, callback) {
                    return this.rpcCall(params, $root.ununifi.nftbackedloan.QueryParamsRequest, $root.ununifi.nftbackedloan.QueryParamsResponse, request, callback);
                }, "name", { value: "Params" });
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#nftListing}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef NftListingCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryNftListingResponse} [response] QueryNftListingResponse
                 */
    
                /**
                 * Calls NftListing.
                 * @function nftListing
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryNftListingRequest} request QueryNftListingRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.NftListingCallback} callback Node-style callback called with the error, if any, and QueryNftListingResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.nftListing = function nftListing(request, callback) {
                    return this.rpcCall(nftListing, $root.ununifi.nftbackedloan.QueryNftListingRequest, $root.ununifi.nftbackedloan.QueryNftListingResponse, request, callback);
                }, "name", { value: "NftListing" });
    
                /**
                 * Calls NftListing.
                 * @function nftListing
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryNftListingRequest} request QueryNftListingRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryNftListingResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#listedNfts}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef ListedNftsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryListedNftsResponse} [response] QueryListedNftsResponse
                 */
    
                /**
                 * Calls ListedNfts.
                 * @function listedNfts
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.ListedNftsCallback} callback Node-style callback called with the error, if any, and QueryListedNftsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.listedNfts = function listedNfts(request, callback) {
                    return this.rpcCall(listedNfts, $root.ununifi.nftbackedloan.QueryListedNftsRequest, $root.ununifi.nftbackedloan.QueryListedNftsResponse, request, callback);
                }, "name", { value: "ListedNfts" });
    
                /**
                 * Calls ListedNfts.
                 * @function listedNfts
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryListedNftsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#listedClasses}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef ListedClassesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryListedClassesResponse} [response] QueryListedClassesResponse
                 */
    
                /**
                 * Calls ListedClasses.
                 * @function listedClasses
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.ListedClassesCallback} callback Node-style callback called with the error, if any, and QueryListedClassesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.listedClasses = function listedClasses(request, callback) {
                    return this.rpcCall(listedClasses, $root.ununifi.nftbackedloan.QueryListedClassesRequest, $root.ununifi.nftbackedloan.QueryListedClassesResponse, request, callback);
                }, "name", { value: "ListedClasses" });
    
                /**
                 * Calls ListedClasses.
                 * @function listedClasses
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryListedClassesResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#listedClass}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef ListedClassCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryListedClassResponse} [response] QueryListedClassResponse
                 */
    
                /**
                 * Calls ListedClass.
                 * @function listedClass
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.ListedClassCallback} callback Node-style callback called with the error, if any, and QueryListedClassResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.listedClass = function listedClass(request, callback) {
                    return this.rpcCall(listedClass, $root.ununifi.nftbackedloan.QueryListedClassRequest, $root.ununifi.nftbackedloan.QueryListedClassResponse, request, callback);
                }, "name", { value: "ListedClass" });
    
                /**
                 * Calls ListedClass.
                 * @function listedClass
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryListedClassResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#loan}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef LoanCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryLoanResponse} [response] QueryLoanResponse
                 */
    
                /**
                 * Calls Loan.
                 * @function loan
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryLoanRequest} request QueryLoanRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.LoanCallback} callback Node-style callback called with the error, if any, and QueryLoanResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.loan = function loan(request, callback) {
                    return this.rpcCall(loan, $root.ununifi.nftbackedloan.QueryLoanRequest, $root.ununifi.nftbackedloan.QueryLoanResponse, request, callback);
                }, "name", { value: "Loan" });
    
                /**
                 * Calls Loan.
                 * @function loan
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryLoanRequest} request QueryLoanRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryLoanResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#nftBids}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef NftBidsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryNftBidsResponse} [response] QueryNftBidsResponse
                 */
    
                /**
                 * Calls NftBids.
                 * @function nftBids
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.NftBidsCallback} callback Node-style callback called with the error, if any, and QueryNftBidsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.nftBids = function nftBids(request, callback) {
                    return this.rpcCall(nftBids, $root.ununifi.nftbackedloan.QueryNftBidsRequest, $root.ununifi.nftbackedloan.QueryNftBidsResponse, request, callback);
                }, "name", { value: "NftBids" });
    
                /**
                 * Calls NftBids.
                 * @function nftBids
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryNftBidsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#bidderBids}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef BidderBidsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryBidderBidsResponse} [response] QueryBidderBidsResponse
                 */
    
                /**
                 * Calls BidderBids.
                 * @function bidderBids
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.BidderBidsCallback} callback Node-style callback called with the error, if any, and QueryBidderBidsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.bidderBids = function bidderBids(request, callback) {
                    return this.rpcCall(bidderBids, $root.ununifi.nftbackedloan.QueryBidderBidsRequest, $root.ununifi.nftbackedloan.QueryBidderBidsResponse, request, callback);
                }, "name", { value: "BidderBids" });
    
                /**
                 * Calls BidderBids.
                 * @function bidderBids
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryBidderBidsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#rewards}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef RewardsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryRewardsResponse} [response] QueryRewardsResponse
                 */
    
                /**
                 * Calls Rewards.
                 * @function rewards
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.RewardsCallback} callback Node-style callback called with the error, if any, and QueryRewardsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.rewards = function rewards(request, callback) {
                    return this.rpcCall(rewards, $root.ununifi.nftbackedloan.QueryRewardsRequest, $root.ununifi.nftbackedloan.QueryRewardsResponse, request, callback);
                }, "name", { value: "Rewards" });
    
                /**
                 * Calls Rewards.
                 * @function rewards
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryRewardsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftbackedloan.Query#liquidation}.
                 * @memberof ununifi.nftbackedloan.Query
                 * @typedef LiquidationCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftbackedloan.QueryLiquidationResponse} [response] QueryLiquidationResponse
                 */
    
                /**
                 * Calls Liquidation.
                 * @function liquidation
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} request QueryLiquidationRequest message or plain object
                 * @param {ununifi.nftbackedloan.Query.LiquidationCallback} callback Node-style callback called with the error, if any, and QueryLiquidationResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.liquidation = function liquidation(request, callback) {
                    return this.rpcCall(liquidation, $root.ununifi.nftbackedloan.QueryLiquidationRequest, $root.ununifi.nftbackedloan.QueryLiquidationResponse, request, callback);
                }, "name", { value: "Liquidation" });
    
                /**
                 * Calls Liquidation.
                 * @function liquidation
                 * @memberof ununifi.nftbackedloan.Query
                 * @instance
                 * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} request QueryLiquidationRequest message or plain object
                 * @returns {Promise<ununifi.nftbackedloan.QueryLiquidationResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            nftbackedloan.QueryParamsRequest = (function() {
    
                /**
                 * Properties of a QueryParamsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryParamsRequest
                 */
    
                /**
                 * Constructs a new QueryParamsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryParamsRequest.
                 * @implements IQueryParamsRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryParamsRequest=} [properties] Properties to set
                 */
                function QueryParamsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryParamsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryParamsRequest} QueryParamsRequest
                 */
                QueryParamsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryParamsRequest)
                        return object;
                    return new $root.ununifi.nftbackedloan.QueryParamsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryParamsRequest} message QueryParamsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryParamsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryParamsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsRequest;
            })();
    
            nftbackedloan.QueryParamsResponse = (function() {
    
                /**
                 * Properties of a QueryParamsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryParamsResponse
                 * @property {ununifi.nftbackedloan.IParams|null} [params] QueryParamsResponse params
                 */
    
                /**
                 * Constructs a new QueryParamsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryParamsResponse.
                 * @implements IQueryParamsResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryParamsResponse=} [properties] Properties to set
                 */
                function QueryParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryParamsResponse params.
                 * @member {ununifi.nftbackedloan.IParams|null|undefined} params
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @instance
                 */
                QueryParamsResponse.prototype.params = null;
    
                /**
                 * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.nftbackedloan.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.nftbackedloan.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.nftbackedloan.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryParamsResponse} QueryParamsResponse
                 */
                QueryParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryParamsResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryParamsResponse();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.nftbackedloan.QueryParamsResponse.params: object expected");
                        message.params = $root.ununifi.nftbackedloan.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryParamsResponse} message QueryParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.nftbackedloan.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this QueryParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsResponse;
            })();
    
            nftbackedloan.QueryNftListingRequest = (function() {
    
                /**
                 * Properties of a QueryNftListingRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryNftListingRequest
                 * @property {string|null} [class_id] QueryNftListingRequest class_id
                 * @property {string|null} [nft_id] QueryNftListingRequest nft_id
                 */
    
                /**
                 * Constructs a new QueryNftListingRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryNftListingRequest.
                 * @implements IQueryNftListingRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryNftListingRequest=} [properties] Properties to set
                 */
                function QueryNftListingRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryNftListingRequest class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @instance
                 */
                QueryNftListingRequest.prototype.class_id = "";
    
                /**
                 * QueryNftListingRequest nft_id.
                 * @member {string} nft_id
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @instance
                 */
                QueryNftListingRequest.prototype.nft_id = "";
    
                /**
                 * Encodes the specified QueryNftListingRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryNftListingRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftListingRequest} message QueryNftListingRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftListingRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nft_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryNftListingRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryNftListingRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftListingRequest} message QueryNftListingRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftListingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryNftListingRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryNftListingRequest} QueryNftListingRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftListingRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryNftListingRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.nft_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryNftListingRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryNftListingRequest} QueryNftListingRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftListingRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryNftListingRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryNftListingRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        if (!$util.isString(message.nft_id))
                            return "nft_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryNftListingRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryNftListingRequest} QueryNftListingRequest
                 */
                QueryNftListingRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryNftListingRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryNftListingRequest();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.nft_id != null)
                        message.nft_id = String(object.nft_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryNftListingRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryNftListingRequest} message QueryNftListingRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryNftListingRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.nft_id = "";
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = message.nft_id;
                    return object;
                };
    
                /**
                 * Converts this QueryNftListingRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryNftListingRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryNftListingRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryNftListingRequest;
            })();
    
            nftbackedloan.QueryNftListingResponse = (function() {
    
                /**
                 * Properties of a QueryNftListingResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryNftListingResponse
                 * @property {ununifi.nftbackedloan.IListing|null} [listing] QueryNftListingResponse listing
                 */
    
                /**
                 * Constructs a new QueryNftListingResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryNftListingResponse.
                 * @implements IQueryNftListingResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryNftListingResponse=} [properties] Properties to set
                 */
                function QueryNftListingResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryNftListingResponse listing.
                 * @member {ununifi.nftbackedloan.IListing|null|undefined} listing
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @instance
                 */
                QueryNftListingResponse.prototype.listing = null;
    
                /**
                 * Encodes the specified QueryNftListingResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryNftListingResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftListingResponse} message QueryNftListingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftListingResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.listing != null && Object.hasOwnProperty.call(message, "listing"))
                        $root.ununifi.nftbackedloan.Listing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryNftListingResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftListingResponse} message QueryNftListingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryNftListingResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryNftListingResponse} QueryNftListingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftListingResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryNftListingResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.listing = $root.ununifi.nftbackedloan.Listing.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryNftListingResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryNftListingResponse} QueryNftListingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryNftListingResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryNftListingResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.listing != null && message.hasOwnProperty("listing")) {
                        var error = $root.ununifi.nftbackedloan.Listing.verify(message.listing);
                        if (error)
                            return "listing." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryNftListingResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryNftListingResponse} QueryNftListingResponse
                 */
                QueryNftListingResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryNftListingResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryNftListingResponse();
                    if (object.listing != null) {
                        if (typeof object.listing !== "object")
                            throw TypeError(".ununifi.nftbackedloan.QueryNftListingResponse.listing: object expected");
                        message.listing = $root.ununifi.nftbackedloan.Listing.fromObject(object.listing);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryNftListingResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryNftListingResponse} message QueryNftListingResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryNftListingResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.listing = null;
                    if (message.listing != null && message.hasOwnProperty("listing"))
                        object.listing = $root.ununifi.nftbackedloan.Listing.toObject(message.listing, options);
                    return object;
                };
    
                /**
                 * Converts this QueryNftListingResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryNftListingResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryNftListingResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryNftListingResponse;
            })();
    
            nftbackedloan.QueryListedNftsRequest = (function() {
    
                /**
                 * Properties of a QueryListedNftsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryListedNftsRequest
                 * @property {string|null} [owner] QueryListedNftsRequest owner
                 */
    
                /**
                 * Constructs a new QueryListedNftsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryListedNftsRequest.
                 * @implements IQueryListedNftsRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryListedNftsRequest=} [properties] Properties to set
                 */
                function QueryListedNftsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryListedNftsRequest owner.
                 * @member {string} owner
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @instance
                 */
                QueryListedNftsRequest.prototype.owner = "";
    
                /**
                 * Encodes the specified QueryListedNftsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedNftsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryListedNftsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedNftsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryListedNftsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryListedNftsRequest} QueryListedNftsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedNftsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryListedNftsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.owner = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryListedNftsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryListedNftsRequest} QueryListedNftsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedNftsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryListedNftsRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryListedNftsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryListedNftsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryListedNftsRequest} QueryListedNftsRequest
                 */
                QueryListedNftsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryListedNftsRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryListedNftsRequest();
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryListedNftsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryListedNftsRequest} message QueryListedNftsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryListedNftsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.owner = "";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    return object;
                };
    
                /**
                 * Converts this QueryListedNftsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryListedNftsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryListedNftsRequest;
            })();
    
            nftbackedloan.QueryListedClassesRequest = (function() {
    
                /**
                 * Properties of a QueryListedClassesRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryListedClassesRequest
                 * @property {number|null} [nft_limit] QueryListedClassesRequest nft_limit
                 */
    
                /**
                 * Constructs a new QueryListedClassesRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryListedClassesRequest.
                 * @implements IQueryListedClassesRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryListedClassesRequest=} [properties] Properties to set
                 */
                function QueryListedClassesRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryListedClassesRequest nft_limit.
                 * @member {number} nft_limit
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @instance
                 */
                QueryListedClassesRequest.prototype.nft_limit = 0;
    
                /**
                 * Encodes the specified QueryListedClassesRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nft_limit != null && Object.hasOwnProperty.call(message, "nft_limit"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nft_limit);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryListedClassesRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryListedClassesRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryListedClassesRequest} QueryListedClassesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryListedClassesRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nft_limit = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryListedClassesRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryListedClassesRequest} QueryListedClassesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassesRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryListedClassesRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryListedClassesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nft_limit != null && message.hasOwnProperty("nft_limit"))
                        if (!$util.isInteger(message.nft_limit))
                            return "nft_limit: integer expected";
                    return null;
                };
    
                /**
                 * Creates a QueryListedClassesRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryListedClassesRequest} QueryListedClassesRequest
                 */
                QueryListedClassesRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassesRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryListedClassesRequest();
                    if (object.nft_limit != null)
                        message.nft_limit = object.nft_limit | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryListedClassesRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryListedClassesRequest} message QueryListedClassesRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryListedClassesRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.nft_limit = 0;
                    if (message.nft_limit != null && message.hasOwnProperty("nft_limit"))
                        object.nft_limit = message.nft_limit;
                    return object;
                };
    
                /**
                 * Converts this QueryListedClassesRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryListedClassesRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryListedClassesRequest;
            })();
    
            nftbackedloan.QueryListedClassRequest = (function() {
    
                /**
                 * Properties of a QueryListedClassRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryListedClassRequest
                 * @property {string|null} [class_id] QueryListedClassRequest class_id
                 * @property {number|null} [nft_limit] QueryListedClassRequest nft_limit
                 */
    
                /**
                 * Constructs a new QueryListedClassRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryListedClassRequest.
                 * @implements IQueryListedClassRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryListedClassRequest=} [properties] Properties to set
                 */
                function QueryListedClassRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryListedClassRequest class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @instance
                 */
                QueryListedClassRequest.prototype.class_id = "";
    
                /**
                 * QueryListedClassRequest nft_limit.
                 * @member {number} nft_limit
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @instance
                 */
                QueryListedClassRequest.prototype.nft_limit = 0;
    
                /**
                 * Encodes the specified QueryListedClassRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.nft_limit != null && Object.hasOwnProperty.call(message, "nft_limit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nft_limit);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryListedClassRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryListedClassRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryListedClassRequest} QueryListedClassRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryListedClassRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.nft_limit = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryListedClassRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryListedClassRequest} QueryListedClassRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryListedClassRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryListedClassRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.nft_limit != null && message.hasOwnProperty("nft_limit"))
                        if (!$util.isInteger(message.nft_limit))
                            return "nft_limit: integer expected";
                    return null;
                };
    
                /**
                 * Creates a QueryListedClassRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryListedClassRequest} QueryListedClassRequest
                 */
                QueryListedClassRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryListedClassRequest();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.nft_limit != null)
                        message.nft_limit = object.nft_limit | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryListedClassRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryListedClassRequest} message QueryListedClassRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryListedClassRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.nft_limit = 0;
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.nft_limit != null && message.hasOwnProperty("nft_limit"))
                        object.nft_limit = message.nft_limit;
                    return object;
                };
    
                /**
                 * Converts this QueryListedClassRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryListedClassRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryListedClassRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryListedClassRequest;
            })();
    
            nftbackedloan.NftListingDetail = (function() {
    
                /**
                 * Properties of a NftListingDetail.
                 * @memberof ununifi.nftbackedloan
                 * @interface INftListingDetail
                 * @property {ununifi.nftbackedloan.IListing|null} [listing] NftListingDetail listing
                 * @property {ununifi.nftbackedloan.INftInfo|null} [nft_info] NftListingDetail nft_info
                 */
    
                /**
                 * Constructs a new NftListingDetail.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a NftListingDetail.
                 * @implements INftListingDetail
                 * @constructor
                 * @param {ununifi.nftbackedloan.INftListingDetail=} [properties] Properties to set
                 */
                function NftListingDetail(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NftListingDetail listing.
                 * @member {ununifi.nftbackedloan.IListing|null|undefined} listing
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @instance
                 */
                NftListingDetail.prototype.listing = null;
    
                /**
                 * NftListingDetail nft_info.
                 * @member {ununifi.nftbackedloan.INftInfo|null|undefined} nft_info
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @instance
                 */
                NftListingDetail.prototype.nft_info = null;
    
                /**
                 * Encodes the specified NftListingDetail message. Does not implicitly {@link ununifi.nftbackedloan.NftListingDetail.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @static
                 * @param {ununifi.nftbackedloan.INftListingDetail} message NftListingDetail message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftListingDetail.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.listing != null && Object.hasOwnProperty.call(message, "listing"))
                        $root.ununifi.nftbackedloan.Listing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.nft_info != null && Object.hasOwnProperty.call(message, "nft_info"))
                        $root.ununifi.nftbackedloan.NftInfo.encode(message.nft_info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NftListingDetail message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.NftListingDetail.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @static
                 * @param {ununifi.nftbackedloan.INftListingDetail} message NftListingDetail message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NftListingDetail.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NftListingDetail message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.NftListingDetail} NftListingDetail
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftListingDetail.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.NftListingDetail();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.listing = $root.ununifi.nftbackedloan.Listing.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.nft_info = $root.ununifi.nftbackedloan.NftInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NftListingDetail message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.NftListingDetail} NftListingDetail
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NftListingDetail.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NftListingDetail message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NftListingDetail.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.listing != null && message.hasOwnProperty("listing")) {
                        var error = $root.ununifi.nftbackedloan.Listing.verify(message.listing);
                        if (error)
                            return "listing." + error;
                    }
                    if (message.nft_info != null && message.hasOwnProperty("nft_info")) {
                        var error = $root.ununifi.nftbackedloan.NftInfo.verify(message.nft_info);
                        if (error)
                            return "nft_info." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a NftListingDetail message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.NftListingDetail} NftListingDetail
                 */
                NftListingDetail.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.NftListingDetail)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.NftListingDetail();
                    if (object.listing != null) {
                        if (typeof object.listing !== "object")
                            throw TypeError(".ununifi.nftbackedloan.NftListingDetail.listing: object expected");
                        message.listing = $root.ununifi.nftbackedloan.Listing.fromObject(object.listing);
                    }
                    if (object.nft_info != null) {
                        if (typeof object.nft_info !== "object")
                            throw TypeError(".ununifi.nftbackedloan.NftListingDetail.nft_info: object expected");
                        message.nft_info = $root.ununifi.nftbackedloan.NftInfo.fromObject(object.nft_info);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NftListingDetail message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @static
                 * @param {ununifi.nftbackedloan.NftListingDetail} message NftListingDetail
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NftListingDetail.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.listing = null;
                        object.nft_info = null;
                    }
                    if (message.listing != null && message.hasOwnProperty("listing"))
                        object.listing = $root.ununifi.nftbackedloan.Listing.toObject(message.listing, options);
                    if (message.nft_info != null && message.hasOwnProperty("nft_info"))
                        object.nft_info = $root.ununifi.nftbackedloan.NftInfo.toObject(message.nft_info, options);
                    return object;
                };
    
                /**
                 * Converts this NftListingDetail to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.NftListingDetail
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NftListingDetail.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NftListingDetail;
            })();
    
            nftbackedloan.QueryListedNftsResponse = (function() {
    
                /**
                 * Properties of a QueryListedNftsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryListedNftsResponse
                 * @property {Array.<ununifi.nftbackedloan.INftListingDetail>|null} [listings] QueryListedNftsResponse listings
                 */
    
                /**
                 * Constructs a new QueryListedNftsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryListedNftsResponse.
                 * @implements IQueryListedNftsResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryListedNftsResponse=} [properties] Properties to set
                 */
                function QueryListedNftsResponse(properties) {
                    this.listings = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryListedNftsResponse listings.
                 * @member {Array.<ununifi.nftbackedloan.INftListingDetail>} listings
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @instance
                 */
                QueryListedNftsResponse.prototype.listings = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryListedNftsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedNftsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.listings != null && message.listings.length)
                        for (var i = 0; i < message.listings.length; ++i)
                            $root.ununifi.nftbackedloan.NftListingDetail.encode(message.listings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryListedNftsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedNftsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryListedNftsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryListedNftsResponse} QueryListedNftsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedNftsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryListedNftsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.listings && message.listings.length))
                                message.listings = [];
                            message.listings.push($root.ununifi.nftbackedloan.NftListingDetail.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryListedNftsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryListedNftsResponse} QueryListedNftsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedNftsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryListedNftsResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryListedNftsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.listings != null && message.hasOwnProperty("listings")) {
                        if (!Array.isArray(message.listings))
                            return "listings: array expected";
                        for (var i = 0; i < message.listings.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.NftListingDetail.verify(message.listings[i]);
                            if (error)
                                return "listings." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryListedNftsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryListedNftsResponse} QueryListedNftsResponse
                 */
                QueryListedNftsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryListedNftsResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryListedNftsResponse();
                    if (object.listings) {
                        if (!Array.isArray(object.listings))
                            throw TypeError(".ununifi.nftbackedloan.QueryListedNftsResponse.listings: array expected");
                        message.listings = [];
                        for (var i = 0; i < object.listings.length; ++i) {
                            if (typeof object.listings[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.QueryListedNftsResponse.listings: object expected");
                            message.listings[i] = $root.ununifi.nftbackedloan.NftListingDetail.fromObject(object.listings[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryListedNftsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryListedNftsResponse} message QueryListedNftsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryListedNftsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.listings = [];
                    if (message.listings && message.listings.length) {
                        object.listings = [];
                        for (var j = 0; j < message.listings.length; ++j)
                            object.listings[j] = $root.ununifi.nftbackedloan.NftListingDetail.toObject(message.listings[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryListedNftsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryListedNftsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryListedNftsResponse;
            })();
    
            nftbackedloan.QueryListedClassesResponse = (function() {
    
                /**
                 * Properties of a QueryListedClassesResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryListedClassesResponse
                 * @property {Array.<ununifi.nftbackedloan.IQueryListedClassResponse>|null} [classes] QueryListedClassesResponse classes
                 */
    
                /**
                 * Constructs a new QueryListedClassesResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryListedClassesResponse.
                 * @implements IQueryListedClassesResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryListedClassesResponse=} [properties] Properties to set
                 */
                function QueryListedClassesResponse(properties) {
                    this.classes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryListedClassesResponse classes.
                 * @member {Array.<ununifi.nftbackedloan.IQueryListedClassResponse>} classes
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @instance
                 */
                QueryListedClassesResponse.prototype.classes = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryListedClassesResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.classes != null && message.classes.length)
                        for (var i = 0; i < message.classes.length; ++i)
                            $root.ununifi.nftbackedloan.QueryListedClassResponse.encode(message.classes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryListedClassesResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryListedClassesResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryListedClassesResponse} QueryListedClassesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryListedClassesResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.classes && message.classes.length))
                                message.classes = [];
                            message.classes.push($root.ununifi.nftbackedloan.QueryListedClassResponse.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryListedClassesResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryListedClassesResponse} QueryListedClassesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassesResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryListedClassesResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryListedClassesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.classes != null && message.hasOwnProperty("classes")) {
                        if (!Array.isArray(message.classes))
                            return "classes: array expected";
                        for (var i = 0; i < message.classes.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.QueryListedClassResponse.verify(message.classes[i]);
                            if (error)
                                return "classes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryListedClassesResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryListedClassesResponse} QueryListedClassesResponse
                 */
                QueryListedClassesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassesResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryListedClassesResponse();
                    if (object.classes) {
                        if (!Array.isArray(object.classes))
                            throw TypeError(".ununifi.nftbackedloan.QueryListedClassesResponse.classes: array expected");
                        message.classes = [];
                        for (var i = 0; i < object.classes.length; ++i) {
                            if (typeof object.classes[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.QueryListedClassesResponse.classes: object expected");
                            message.classes[i] = $root.ununifi.nftbackedloan.QueryListedClassResponse.fromObject(object.classes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryListedClassesResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryListedClassesResponse} message QueryListedClassesResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryListedClassesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.classes = [];
                    if (message.classes && message.classes.length) {
                        object.classes = [];
                        for (var j = 0; j < message.classes.length; ++j)
                            object.classes[j] = $root.ununifi.nftbackedloan.QueryListedClassResponse.toObject(message.classes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryListedClassesResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryListedClassesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryListedClassesResponse;
            })();
    
            nftbackedloan.QueryListedClassResponse = (function() {
    
                /**
                 * Properties of a QueryListedClassResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryListedClassResponse
                 * @property {string|null} [class_id] QueryListedClassResponse class_id
                 * @property {string|null} [name] QueryListedClassResponse name
                 * @property {string|null} [description] QueryListedClassResponse description
                 * @property {string|null} [symbol] QueryListedClassResponse symbol
                 * @property {string|null} [uri] QueryListedClassResponse uri
                 * @property {string|null} [urihash] QueryListedClassResponse urihash
                 * @property {Array.<ununifi.nftbackedloan.INftInfo>|null} [nfts] QueryListedClassResponse nfts
                 * @property {Long|null} [nft_count] QueryListedClassResponse nft_count
                 */
    
                /**
                 * Constructs a new QueryListedClassResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryListedClassResponse.
                 * @implements IQueryListedClassResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryListedClassResponse=} [properties] Properties to set
                 */
                function QueryListedClassResponse(properties) {
                    this.nfts = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryListedClassResponse class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.class_id = "";
    
                /**
                 * QueryListedClassResponse name.
                 * @member {string} name
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.name = "";
    
                /**
                 * QueryListedClassResponse description.
                 * @member {string} description
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.description = "";
    
                /**
                 * QueryListedClassResponse symbol.
                 * @member {string} symbol
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.symbol = "";
    
                /**
                 * QueryListedClassResponse uri.
                 * @member {string} uri
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.uri = "";
    
                /**
                 * QueryListedClassResponse urihash.
                 * @member {string} urihash
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.urihash = "";
    
                /**
                 * QueryListedClassResponse nfts.
                 * @member {Array.<ununifi.nftbackedloan.INftInfo>} nfts
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.nfts = $util.emptyArray;
    
                /**
                 * QueryListedClassResponse nft_count.
                 * @member {Long} nft_count
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 */
                QueryListedClassResponse.prototype.nft_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified QueryListedClassResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                    if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.symbol);
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.uri);
                    if (message.urihash != null && Object.hasOwnProperty.call(message, "urihash"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.urihash);
                    if (message.nfts != null && message.nfts.length)
                        for (var i = 0; i < message.nfts.length; ++i)
                            $root.ununifi.nftbackedloan.NftInfo.encode(message.nfts[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.nft_count != null && Object.hasOwnProperty.call(message, "nft_count"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.nft_count);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryListedClassResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryListedClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryListedClassResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryListedClassResponse} QueryListedClassResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryListedClassResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.description = reader.string();
                            break;
                        case 4:
                            message.symbol = reader.string();
                            break;
                        case 5:
                            message.uri = reader.string();
                            break;
                        case 6:
                            message.urihash = reader.string();
                            break;
                        case 7:
                            if (!(message.nfts && message.nfts.length))
                                message.nfts = [];
                            message.nfts.push($root.ununifi.nftbackedloan.NftInfo.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.nft_count = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryListedClassResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryListedClassResponse} QueryListedClassResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryListedClassResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryListedClassResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryListedClassResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        if (!$util.isString(message.symbol))
                            return "symbol: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.urihash != null && message.hasOwnProperty("urihash"))
                        if (!$util.isString(message.urihash))
                            return "urihash: string expected";
                    if (message.nfts != null && message.hasOwnProperty("nfts")) {
                        if (!Array.isArray(message.nfts))
                            return "nfts: array expected";
                        for (var i = 0; i < message.nfts.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.NftInfo.verify(message.nfts[i]);
                            if (error)
                                return "nfts." + error;
                        }
                    }
                    if (message.nft_count != null && message.hasOwnProperty("nft_count"))
                        if (!$util.isInteger(message.nft_count) && !(message.nft_count && $util.isInteger(message.nft_count.low) && $util.isInteger(message.nft_count.high)))
                            return "nft_count: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryListedClassResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryListedClassResponse} QueryListedClassResponse
                 */
                QueryListedClassResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryListedClassResponse();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.symbol != null)
                        message.symbol = String(object.symbol);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.urihash != null)
                        message.urihash = String(object.urihash);
                    if (object.nfts) {
                        if (!Array.isArray(object.nfts))
                            throw TypeError(".ununifi.nftbackedloan.QueryListedClassResponse.nfts: array expected");
                        message.nfts = [];
                        for (var i = 0; i < object.nfts.length; ++i) {
                            if (typeof object.nfts[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.QueryListedClassResponse.nfts: object expected");
                            message.nfts[i] = $root.ununifi.nftbackedloan.NftInfo.fromObject(object.nfts[i]);
                        }
                    }
                    if (object.nft_count != null)
                        if ($util.Long)
                            (message.nft_count = $util.Long.fromValue(object.nft_count)).unsigned = true;
                        else if (typeof object.nft_count === "string")
                            message.nft_count = parseInt(object.nft_count, 10);
                        else if (typeof object.nft_count === "number")
                            message.nft_count = object.nft_count;
                        else if (typeof object.nft_count === "object")
                            message.nft_count = new $util.LongBits(object.nft_count.low >>> 0, object.nft_count.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryListedClassResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryListedClassResponse} message QueryListedClassResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryListedClassResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.nfts = [];
                    if (options.defaults) {
                        object.class_id = "";
                        object.name = "";
                        object.description = "";
                        object.symbol = "";
                        object.uri = "";
                        object.urihash = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nft_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nft_count = options.longs === String ? "0" : 0;
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        object.symbol = message.symbol;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.urihash != null && message.hasOwnProperty("urihash"))
                        object.urihash = message.urihash;
                    if (message.nfts && message.nfts.length) {
                        object.nfts = [];
                        for (var j = 0; j < message.nfts.length; ++j)
                            object.nfts[j] = $root.ununifi.nftbackedloan.NftInfo.toObject(message.nfts[j], options);
                    }
                    if (message.nft_count != null && message.hasOwnProperty("nft_count"))
                        if (typeof message.nft_count === "number")
                            object.nft_count = options.longs === String ? String(message.nft_count) : message.nft_count;
                        else
                            object.nft_count = options.longs === String ? $util.Long.prototype.toString.call(message.nft_count) : options.longs === Number ? new $util.LongBits(message.nft_count.low >>> 0, message.nft_count.high >>> 0).toNumber(true) : message.nft_count;
                    return object;
                };
    
                /**
                 * Converts this QueryListedClassResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryListedClassResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryListedClassResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryListedClassResponse;
            })();
    
            nftbackedloan.QueryLoanRequest = (function() {
    
                /**
                 * Properties of a QueryLoanRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryLoanRequest
                 * @property {string|null} [class_id] QueryLoanRequest class_id
                 * @property {string|null} [nft_id] QueryLoanRequest nft_id
                 */
    
                /**
                 * Constructs a new QueryLoanRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryLoanRequest.
                 * @implements IQueryLoanRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryLoanRequest=} [properties] Properties to set
                 */
                function QueryLoanRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLoanRequest class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @instance
                 */
                QueryLoanRequest.prototype.class_id = "";
    
                /**
                 * QueryLoanRequest nft_id.
                 * @member {string} nft_id
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @instance
                 */
                QueryLoanRequest.prototype.nft_id = "";
    
                /**
                 * Encodes the specified QueryLoanRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLoanRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nft_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLoanRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLoanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLoanRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryLoanRequest} QueryLoanRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLoanRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryLoanRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.nft_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLoanRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryLoanRequest} QueryLoanRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLoanRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLoanRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLoanRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        if (!$util.isString(message.nft_id))
                            return "nft_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryLoanRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryLoanRequest} QueryLoanRequest
                 */
                QueryLoanRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryLoanRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryLoanRequest();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.nft_id != null)
                        message.nft_id = String(object.nft_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLoanRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryLoanRequest} message QueryLoanRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLoanRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.nft_id = "";
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = message.nft_id;
                    return object;
                };
    
                /**
                 * Converts this QueryLoanRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryLoanRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLoanRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLoanRequest;
            })();
    
            nftbackedloan.QueryLoanResponse = (function() {
    
                /**
                 * Properties of a QueryLoanResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryLoanResponse
                 * @property {ununifi.nftbackedloan.INftId|null} [nft_id] QueryLoanResponse nft_id
                 * @property {cosmos.base.v1beta1.ICoin|null} [borrowing_amount] QueryLoanResponse borrowing_amount
                 * @property {cosmos.base.v1beta1.ICoin|null} [borrowing_limit] QueryLoanResponse borrowing_limit
                 * @property {cosmos.base.v1beta1.ICoin|null} [total_deposit] QueryLoanResponse total_deposit
                 */
    
                /**
                 * Constructs a new QueryLoanResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryLoanResponse.
                 * @implements IQueryLoanResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryLoanResponse=} [properties] Properties to set
                 */
                function QueryLoanResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLoanResponse nft_id.
                 * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @instance
                 */
                QueryLoanResponse.prototype.nft_id = null;
    
                /**
                 * QueryLoanResponse borrowing_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} borrowing_amount
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @instance
                 */
                QueryLoanResponse.prototype.borrowing_amount = null;
    
                /**
                 * QueryLoanResponse borrowing_limit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} borrowing_limit
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @instance
                 */
                QueryLoanResponse.prototype.borrowing_limit = null;
    
                /**
                 * QueryLoanResponse total_deposit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} total_deposit
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @instance
                 */
                QueryLoanResponse.prototype.total_deposit = null;
    
                /**
                 * Encodes the specified QueryLoanResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLoanResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.borrowing_amount != null && Object.hasOwnProperty.call(message, "borrowing_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.borrowing_amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.borrowing_limit != null && Object.hasOwnProperty.call(message, "borrowing_limit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.borrowing_limit, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.total_deposit != null && Object.hasOwnProperty.call(message, "total_deposit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.total_deposit, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLoanResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLoanResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLoanResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryLoanResponse} QueryLoanResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLoanResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryLoanResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.borrowing_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.borrowing_limit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.total_deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLoanResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryLoanResponse} QueryLoanResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLoanResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLoanResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLoanResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id")) {
                        var error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
                        if (error)
                            return "nft_id." + error;
                    }
                    if (message.borrowing_amount != null && message.hasOwnProperty("borrowing_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.borrowing_amount);
                        if (error)
                            return "borrowing_amount." + error;
                    }
                    if (message.borrowing_limit != null && message.hasOwnProperty("borrowing_limit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.borrowing_limit);
                        if (error)
                            return "borrowing_limit." + error;
                    }
                    if (message.total_deposit != null && message.hasOwnProperty("total_deposit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.total_deposit);
                        if (error)
                            return "total_deposit." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryLoanResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryLoanResponse} QueryLoanResponse
                 */
                QueryLoanResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryLoanResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryLoanResponse();
                    if (object.nft_id != null) {
                        if (typeof object.nft_id !== "object")
                            throw TypeError(".ununifi.nftbackedloan.QueryLoanResponse.nft_id: object expected");
                        message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
                    }
                    if (object.borrowing_amount != null) {
                        if (typeof object.borrowing_amount !== "object")
                            throw TypeError(".ununifi.nftbackedloan.QueryLoanResponse.borrowing_amount: object expected");
                        message.borrowing_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.borrowing_amount);
                    }
                    if (object.borrowing_limit != null) {
                        if (typeof object.borrowing_limit !== "object")
                            throw TypeError(".ununifi.nftbackedloan.QueryLoanResponse.borrowing_limit: object expected");
                        message.borrowing_limit = $root.cosmos.base.v1beta1.Coin.fromObject(object.borrowing_limit);
                    }
                    if (object.total_deposit != null) {
                        if (typeof object.total_deposit !== "object")
                            throw TypeError(".ununifi.nftbackedloan.QueryLoanResponse.total_deposit: object expected");
                        message.total_deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.total_deposit);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLoanResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryLoanResponse} message QueryLoanResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLoanResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.nft_id = null;
                        object.borrowing_amount = null;
                        object.borrowing_limit = null;
                        object.total_deposit = null;
                    }
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
                    if (message.borrowing_amount != null && message.hasOwnProperty("borrowing_amount"))
                        object.borrowing_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.borrowing_amount, options);
                    if (message.borrowing_limit != null && message.hasOwnProperty("borrowing_limit"))
                        object.borrowing_limit = $root.cosmos.base.v1beta1.Coin.toObject(message.borrowing_limit, options);
                    if (message.total_deposit != null && message.hasOwnProperty("total_deposit"))
                        object.total_deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.total_deposit, options);
                    return object;
                };
    
                /**
                 * Converts this QueryLoanResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryLoanResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLoanResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLoanResponse;
            })();
    
            nftbackedloan.QueryNftBidsRequest = (function() {
    
                /**
                 * Properties of a QueryNftBidsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryNftBidsRequest
                 * @property {string|null} [class_id] QueryNftBidsRequest class_id
                 * @property {string|null} [nft_id] QueryNftBidsRequest nft_id
                 */
    
                /**
                 * Constructs a new QueryNftBidsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryNftBidsRequest.
                 * @implements IQueryNftBidsRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryNftBidsRequest=} [properties] Properties to set
                 */
                function QueryNftBidsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryNftBidsRequest class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @instance
                 */
                QueryNftBidsRequest.prototype.class_id = "";
    
                /**
                 * QueryNftBidsRequest nft_id.
                 * @member {string} nft_id
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @instance
                 */
                QueryNftBidsRequest.prototype.nft_id = "";
    
                /**
                 * Encodes the specified QueryNftBidsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftBidsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nft_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryNftBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryNftBidsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryNftBidsRequest} QueryNftBidsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftBidsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryNftBidsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.nft_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryNftBidsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryNftBidsRequest} QueryNftBidsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftBidsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryNftBidsRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryNftBidsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        if (!$util.isString(message.nft_id))
                            return "nft_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryNftBidsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryNftBidsRequest} QueryNftBidsRequest
                 */
                QueryNftBidsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryNftBidsRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryNftBidsRequest();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.nft_id != null)
                        message.nft_id = String(object.nft_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryNftBidsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryNftBidsRequest} message QueryNftBidsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryNftBidsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.nft_id = "";
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = message.nft_id;
                    return object;
                };
    
                /**
                 * Converts this QueryNftBidsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryNftBidsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryNftBidsRequest;
            })();
    
            nftbackedloan.QueryNftBidsResponse = (function() {
    
                /**
                 * Properties of a QueryNftBidsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryNftBidsResponse
                 * @property {Array.<ununifi.nftbackedloan.IBid>|null} [bids] QueryNftBidsResponse bids
                 */
    
                /**
                 * Constructs a new QueryNftBidsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryNftBidsResponse.
                 * @implements IQueryNftBidsResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryNftBidsResponse=} [properties] Properties to set
                 */
                function QueryNftBidsResponse(properties) {
                    this.bids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryNftBidsResponse bids.
                 * @member {Array.<ununifi.nftbackedloan.IBid>} bids
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @instance
                 */
                QueryNftBidsResponse.prototype.bids = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryNftBidsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftBidsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bids != null && message.bids.length)
                        for (var i = 0; i < message.bids.length; ++i)
                            $root.ununifi.nftbackedloan.Bid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryNftBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryNftBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryNftBidsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryNftBidsResponse} QueryNftBidsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftBidsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryNftBidsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.bids && message.bids.length))
                                message.bids = [];
                            message.bids.push($root.ununifi.nftbackedloan.Bid.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryNftBidsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryNftBidsResponse} QueryNftBidsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryNftBidsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryNftBidsResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryNftBidsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bids != null && message.hasOwnProperty("bids")) {
                        if (!Array.isArray(message.bids))
                            return "bids: array expected";
                        for (var i = 0; i < message.bids.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.Bid.verify(message.bids[i]);
                            if (error)
                                return "bids." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryNftBidsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryNftBidsResponse} QueryNftBidsResponse
                 */
                QueryNftBidsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryNftBidsResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryNftBidsResponse();
                    if (object.bids) {
                        if (!Array.isArray(object.bids))
                            throw TypeError(".ununifi.nftbackedloan.QueryNftBidsResponse.bids: array expected");
                        message.bids = [];
                        for (var i = 0; i < object.bids.length; ++i) {
                            if (typeof object.bids[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.QueryNftBidsResponse.bids: object expected");
                            message.bids[i] = $root.ununifi.nftbackedloan.Bid.fromObject(object.bids[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryNftBidsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryNftBidsResponse} message QueryNftBidsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryNftBidsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.bids = [];
                    if (message.bids && message.bids.length) {
                        object.bids = [];
                        for (var j = 0; j < message.bids.length; ++j)
                            object.bids[j] = $root.ununifi.nftbackedloan.Bid.toObject(message.bids[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryNftBidsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryNftBidsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryNftBidsResponse;
            })();
    
            nftbackedloan.QueryBidderBidsRequest = (function() {
    
                /**
                 * Properties of a QueryBidderBidsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryBidderBidsRequest
                 * @property {string|null} [bidder] QueryBidderBidsRequest bidder
                 */
    
                /**
                 * Constructs a new QueryBidderBidsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryBidderBidsRequest.
                 * @implements IQueryBidderBidsRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest=} [properties] Properties to set
                 */
                function QueryBidderBidsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryBidderBidsRequest bidder.
                 * @member {string} bidder
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @instance
                 */
                QueryBidderBidsRequest.prototype.bidder = "";
    
                /**
                 * Encodes the specified QueryBidderBidsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryBidderBidsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bidder != null && Object.hasOwnProperty.call(message, "bidder"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bidder);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryBidderBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryBidderBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryBidderBidsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryBidderBidsRequest} QueryBidderBidsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryBidderBidsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryBidderBidsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bidder = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryBidderBidsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryBidderBidsRequest} QueryBidderBidsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryBidderBidsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryBidderBidsRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryBidderBidsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        if (!$util.isString(message.bidder))
                            return "bidder: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryBidderBidsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryBidderBidsRequest} QueryBidderBidsRequest
                 */
                QueryBidderBidsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryBidderBidsRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryBidderBidsRequest();
                    if (object.bidder != null)
                        message.bidder = String(object.bidder);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryBidderBidsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryBidderBidsRequest} message QueryBidderBidsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryBidderBidsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.bidder = "";
                    if (message.bidder != null && message.hasOwnProperty("bidder"))
                        object.bidder = message.bidder;
                    return object;
                };
    
                /**
                 * Converts this QueryBidderBidsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryBidderBidsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryBidderBidsRequest;
            })();
    
            nftbackedloan.QueryBidderBidsResponse = (function() {
    
                /**
                 * Properties of a QueryBidderBidsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryBidderBidsResponse
                 * @property {Array.<ununifi.nftbackedloan.IBid>|null} [bids] QueryBidderBidsResponse bids
                 */
    
                /**
                 * Constructs a new QueryBidderBidsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryBidderBidsResponse.
                 * @implements IQueryBidderBidsResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsResponse=} [properties] Properties to set
                 */
                function QueryBidderBidsResponse(properties) {
                    this.bids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryBidderBidsResponse bids.
                 * @member {Array.<ununifi.nftbackedloan.IBid>} bids
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @instance
                 */
                QueryBidderBidsResponse.prototype.bids = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryBidderBidsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryBidderBidsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bids != null && message.bids.length)
                        for (var i = 0; i < message.bids.length; ++i)
                            $root.ununifi.nftbackedloan.Bid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryBidderBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryBidderBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryBidderBidsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryBidderBidsResponse} QueryBidderBidsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryBidderBidsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryBidderBidsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.bids && message.bids.length))
                                message.bids = [];
                            message.bids.push($root.ununifi.nftbackedloan.Bid.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryBidderBidsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryBidderBidsResponse} QueryBidderBidsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryBidderBidsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryBidderBidsResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryBidderBidsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bids != null && message.hasOwnProperty("bids")) {
                        if (!Array.isArray(message.bids))
                            return "bids: array expected";
                        for (var i = 0; i < message.bids.length; ++i) {
                            var error = $root.ununifi.nftbackedloan.Bid.verify(message.bids[i]);
                            if (error)
                                return "bids." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryBidderBidsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryBidderBidsResponse} QueryBidderBidsResponse
                 */
                QueryBidderBidsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryBidderBidsResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryBidderBidsResponse();
                    if (object.bids) {
                        if (!Array.isArray(object.bids))
                            throw TypeError(".ununifi.nftbackedloan.QueryBidderBidsResponse.bids: array expected");
                        message.bids = [];
                        for (var i = 0; i < object.bids.length; ++i) {
                            if (typeof object.bids[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.QueryBidderBidsResponse.bids: object expected");
                            message.bids[i] = $root.ununifi.nftbackedloan.Bid.fromObject(object.bids[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryBidderBidsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryBidderBidsResponse} message QueryBidderBidsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryBidderBidsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.bids = [];
                    if (message.bids && message.bids.length) {
                        object.bids = [];
                        for (var j = 0; j < message.bids.length; ++j)
                            object.bids[j] = $root.ununifi.nftbackedloan.Bid.toObject(message.bids[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryBidderBidsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryBidderBidsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryBidderBidsResponse;
            })();
    
            nftbackedloan.QueryRewardsRequest = (function() {
    
                /**
                 * Properties of a QueryRewardsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryRewardsRequest
                 * @property {Long|null} [address] QueryRewardsRequest address
                 */
    
                /**
                 * Constructs a new QueryRewardsRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryRewardsRequest.
                 * @implements IQueryRewardsRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryRewardsRequest=} [properties] Properties to set
                 */
                function QueryRewardsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryRewardsRequest address.
                 * @member {Long} address
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @instance
                 */
                QueryRewardsRequest.prototype.address = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified QueryRewardsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.address);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryRewardsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryRewardsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryRewardsRequest} QueryRewardsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryRewardsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryRewardsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryRewardsRequest} QueryRewardsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryRewardsRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryRewardsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isInteger(message.address) && !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high)))
                            return "address: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryRewardsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryRewardsRequest} QueryRewardsRequest
                 */
                QueryRewardsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryRewardsRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryRewardsRequest();
                    if (object.address != null)
                        if ($util.Long)
                            (message.address = $util.Long.fromValue(object.address)).unsigned = true;
                        else if (typeof object.address === "string")
                            message.address = parseInt(object.address, 10);
                        else if (typeof object.address === "number")
                            message.address = object.address;
                        else if (typeof object.address === "object")
                            message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryRewardsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryRewardsRequest} message QueryRewardsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryRewardsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.address = options.longs === String ? "0" : 0;
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (typeof message.address === "number")
                            object.address = options.longs === String ? String(message.address) : message.address;
                        else
                            object.address = options.longs === String ? $util.Long.prototype.toString.call(message.address) : options.longs === Number ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true) : message.address;
                    return object;
                };
    
                /**
                 * Converts this QueryRewardsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryRewardsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryRewardsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryRewardsRequest;
            })();
    
            nftbackedloan.QueryRewardsResponse = (function() {
    
                /**
                 * Properties of a QueryRewardsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryRewardsResponse
                 * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] QueryRewardsResponse rewards
                 */
    
                /**
                 * Constructs a new QueryRewardsResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryRewardsResponse.
                 * @implements IQueryRewardsResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryRewardsResponse=} [properties] Properties to set
                 */
                function QueryRewardsResponse(properties) {
                    this.rewards = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryRewardsResponse rewards.
                 * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @instance
                 */
                QueryRewardsResponse.prototype.rewards = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryRewardsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rewards != null && message.rewards.length)
                        for (var i = 0; i < message.rewards.length; ++i)
                            $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryRewardsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryRewardsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryRewardsResponse} QueryRewardsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryRewardsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.rewards && message.rewards.length))
                                message.rewards = [];
                            message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryRewardsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryRewardsResponse} QueryRewardsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryRewardsResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryRewardsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rewards != null && message.hasOwnProperty("rewards")) {
                        if (!Array.isArray(message.rewards))
                            return "rewards: array expected";
                        for (var i = 0; i < message.rewards.length; ++i) {
                            var error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
                            if (error)
                                return "rewards." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryRewardsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryRewardsResponse} QueryRewardsResponse
                 */
                QueryRewardsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryRewardsResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryRewardsResponse();
                    if (object.rewards) {
                        if (!Array.isArray(object.rewards))
                            throw TypeError(".ununifi.nftbackedloan.QueryRewardsResponse.rewards: array expected");
                        message.rewards = [];
                        for (var i = 0; i < object.rewards.length; ++i) {
                            if (typeof object.rewards[i] !== "object")
                                throw TypeError(".ununifi.nftbackedloan.QueryRewardsResponse.rewards: object expected");
                            message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryRewardsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryRewardsResponse} message QueryRewardsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryRewardsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rewards = [];
                    if (message.rewards && message.rewards.length) {
                        object.rewards = [];
                        for (var j = 0; j < message.rewards.length; ++j)
                            object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryRewardsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryRewardsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryRewardsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryRewardsResponse;
            })();
    
            nftbackedloan.QueryLiquidationRequest = (function() {
    
                /**
                 * Properties of a QueryLiquidationRequest.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryLiquidationRequest
                 * @property {string|null} [class_id] QueryLiquidationRequest class_id
                 * @property {string|null} [nft_id] QueryLiquidationRequest nft_id
                 */
    
                /**
                 * Constructs a new QueryLiquidationRequest.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryLiquidationRequest.
                 * @implements IQueryLiquidationRequest
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryLiquidationRequest=} [properties] Properties to set
                 */
                function QueryLiquidationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLiquidationRequest class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @instance
                 */
                QueryLiquidationRequest.prototype.class_id = "";
    
                /**
                 * QueryLiquidationRequest nft_id.
                 * @member {string} nft_id
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @instance
                 */
                QueryLiquidationRequest.prototype.nft_id = "";
    
                /**
                 * Encodes the specified QueryLiquidationRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} message QueryLiquidationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.nft_id != null && Object.hasOwnProperty.call(message, "nft_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nft_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLiquidationRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} message QueryLiquidationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLiquidationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryLiquidationRequest} QueryLiquidationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryLiquidationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.nft_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLiquidationRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryLiquidationRequest} QueryLiquidationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidationRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLiquidationRequest message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLiquidationRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        if (!$util.isString(message.nft_id))
                            return "nft_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryLiquidationRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryLiquidationRequest} QueryLiquidationRequest
                 */
                QueryLiquidationRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryLiquidationRequest)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryLiquidationRequest();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.nft_id != null)
                        message.nft_id = String(object.nft_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLiquidationRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @static
                 * @param {ununifi.nftbackedloan.QueryLiquidationRequest} message QueryLiquidationRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLiquidationRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.nft_id = "";
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.nft_id != null && message.hasOwnProperty("nft_id"))
                        object.nft_id = message.nft_id;
                    return object;
                };
    
                /**
                 * Converts this QueryLiquidationRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLiquidationRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLiquidationRequest;
            })();
    
            nftbackedloan.QueryLiquidationResponse = (function() {
    
                /**
                 * Properties of a QueryLiquidationResponse.
                 * @memberof ununifi.nftbackedloan
                 * @interface IQueryLiquidationResponse
                 * @property {ununifi.nftbackedloan.ILiquidations|null} [liquidations] QueryLiquidationResponse liquidations
                 */
    
                /**
                 * Constructs a new QueryLiquidationResponse.
                 * @memberof ununifi.nftbackedloan
                 * @classdesc Represents a QueryLiquidationResponse.
                 * @implements IQueryLiquidationResponse
                 * @constructor
                 * @param {ununifi.nftbackedloan.IQueryLiquidationResponse=} [properties] Properties to set
                 */
                function QueryLiquidationResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryLiquidationResponse liquidations.
                 * @member {ununifi.nftbackedloan.ILiquidations|null|undefined} liquidations
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @instance
                 */
                QueryLiquidationResponse.prototype.liquidations = null;
    
                /**
                 * Encodes the specified QueryLiquidationResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLiquidationResponse} message QueryLiquidationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidationResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.liquidations != null && Object.hasOwnProperty.call(message, "liquidations"))
                        $root.ununifi.nftbackedloan.Liquidations.encode(message.liquidations, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryLiquidationResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @static
                 * @param {ununifi.nftbackedloan.IQueryLiquidationResponse} message QueryLiquidationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryLiquidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryLiquidationResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftbackedloan.QueryLiquidationResponse} QueryLiquidationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidationResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftbackedloan.QueryLiquidationResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.liquidations = $root.ununifi.nftbackedloan.Liquidations.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryLiquidationResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftbackedloan.QueryLiquidationResponse} QueryLiquidationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryLiquidationResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryLiquidationResponse message.
                 * @function verify
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryLiquidationResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.liquidations != null && message.hasOwnProperty("liquidations")) {
                        var error = $root.ununifi.nftbackedloan.Liquidations.verify(message.liquidations);
                        if (error)
                            return "liquidations." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryLiquidationResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftbackedloan.QueryLiquidationResponse} QueryLiquidationResponse
                 */
                QueryLiquidationResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftbackedloan.QueryLiquidationResponse)
                        return object;
                    var message = new $root.ununifi.nftbackedloan.QueryLiquidationResponse();
                    if (object.liquidations != null) {
                        if (typeof object.liquidations !== "object")
                            throw TypeError(".ununifi.nftbackedloan.QueryLiquidationResponse.liquidations: object expected");
                        message.liquidations = $root.ununifi.nftbackedloan.Liquidations.fromObject(object.liquidations);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryLiquidationResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @static
                 * @param {ununifi.nftbackedloan.QueryLiquidationResponse} message QueryLiquidationResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryLiquidationResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.liquidations = null;
                    if (message.liquidations != null && message.hasOwnProperty("liquidations"))
                        object.liquidations = $root.ununifi.nftbackedloan.Liquidations.toObject(message.liquidations, options);
                    return object;
                };
    
                /**
                 * Converts this QueryLiquidationResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryLiquidationResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryLiquidationResponse;
            })();
    
            return nftbackedloan;
        })();
    
        ununifi.nftfactory = (function() {
    
            /**
             * Namespace nftfactory.
             * @memberof ununifi
             * @namespace
             */
            var nftfactory = {};
    
            nftfactory.Msg = (function() {
    
                /**
                 * Constructs a new Msg service.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a Msg
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Msg(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Msg#createClass}.
                 * @memberof ununifi.nftfactory.Msg
                 * @typedef CreateClassCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.MsgCreateClassResponse} [response] MsgCreateClassResponse
                 */
    
                /**
                 * Calls CreateClass.
                 * @function createClass
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgCreateClass} request MsgCreateClass message or plain object
                 * @param {ununifi.nftfactory.Msg.CreateClassCallback} callback Node-style callback called with the error, if any, and MsgCreateClassResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.createClass = function createClass(request, callback) {
                    return this.rpcCall(createClass, $root.ununifi.nftfactory.MsgCreateClass, $root.ununifi.nftfactory.MsgCreateClassResponse, request, callback);
                }, "name", { value: "CreateClass" });
    
                /**
                 * Calls CreateClass.
                 * @function createClass
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgCreateClass} request MsgCreateClass message or plain object
                 * @returns {Promise<ununifi.nftfactory.MsgCreateClassResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Msg#updateClass}.
                 * @memberof ununifi.nftfactory.Msg
                 * @typedef UpdateClassCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.MsgUpdateClassResponse} [response] MsgUpdateClassResponse
                 */
    
                /**
                 * Calls UpdateClass.
                 * @function updateClass
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgUpdateClass} request MsgUpdateClass message or plain object
                 * @param {ununifi.nftfactory.Msg.UpdateClassCallback} callback Node-style callback called with the error, if any, and MsgUpdateClassResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.updateClass = function updateClass(request, callback) {
                    return this.rpcCall(updateClass, $root.ununifi.nftfactory.MsgUpdateClass, $root.ununifi.nftfactory.MsgUpdateClassResponse, request, callback);
                }, "name", { value: "UpdateClass" });
    
                /**
                 * Calls UpdateClass.
                 * @function updateClass
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgUpdateClass} request MsgUpdateClass message or plain object
                 * @returns {Promise<ununifi.nftfactory.MsgUpdateClassResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Msg#mintNFT}.
                 * @memberof ununifi.nftfactory.Msg
                 * @typedef MintNFTCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.MsgMintNFTResponse} [response] MsgMintNFTResponse
                 */
    
                /**
                 * Calls MintNFT.
                 * @function mintNFT
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgMintNFT} request MsgMintNFT message or plain object
                 * @param {ununifi.nftfactory.Msg.MintNFTCallback} callback Node-style callback called with the error, if any, and MsgMintNFTResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.mintNFT = function mintNFT(request, callback) {
                    return this.rpcCall(mintNFT, $root.ununifi.nftfactory.MsgMintNFT, $root.ununifi.nftfactory.MsgMintNFTResponse, request, callback);
                }, "name", { value: "MintNFT" });
    
                /**
                 * Calls MintNFT.
                 * @function mintNFT
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgMintNFT} request MsgMintNFT message or plain object
                 * @returns {Promise<ununifi.nftfactory.MsgMintNFTResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Msg#burnNFT}.
                 * @memberof ununifi.nftfactory.Msg
                 * @typedef BurnNFTCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.MsgBurnNFTResponse} [response] MsgBurnNFTResponse
                 */
    
                /**
                 * Calls BurnNFT.
                 * @function burnNFT
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgBurnNFT} request MsgBurnNFT message or plain object
                 * @param {ununifi.nftfactory.Msg.BurnNFTCallback} callback Node-style callback called with the error, if any, and MsgBurnNFTResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.burnNFT = function burnNFT(request, callback) {
                    return this.rpcCall(burnNFT, $root.ununifi.nftfactory.MsgBurnNFT, $root.ununifi.nftfactory.MsgBurnNFTResponse, request, callback);
                }, "name", { value: "BurnNFT" });
    
                /**
                 * Calls BurnNFT.
                 * @function burnNFT
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgBurnNFT} request MsgBurnNFT message or plain object
                 * @returns {Promise<ununifi.nftfactory.MsgBurnNFTResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Msg#changeAdmin}.
                 * @memberof ununifi.nftfactory.Msg
                 * @typedef ChangeAdminCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.MsgChangeAdminResponse} [response] MsgChangeAdminResponse
                 */
    
                /**
                 * Calls ChangeAdmin.
                 * @function changeAdmin
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgChangeAdmin} request MsgChangeAdmin message or plain object
                 * @param {ununifi.nftfactory.Msg.ChangeAdminCallback} callback Node-style callback called with the error, if any, and MsgChangeAdminResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.changeAdmin = function changeAdmin(request, callback) {
                    return this.rpcCall(changeAdmin, $root.ununifi.nftfactory.MsgChangeAdmin, $root.ununifi.nftfactory.MsgChangeAdminResponse, request, callback);
                }, "name", { value: "ChangeAdmin" });
    
                /**
                 * Calls ChangeAdmin.
                 * @function changeAdmin
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgChangeAdmin} request MsgChangeAdmin message or plain object
                 * @returns {Promise<ununifi.nftfactory.MsgChangeAdminResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Msg#updateParams}.
                 * @memberof ununifi.nftfactory.Msg
                 * @typedef UpdateParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.MsgUpdateParamsResponse} [response] MsgUpdateParamsResponse
                 */
    
                /**
                 * Calls UpdateParams.
                 * @function updateParams
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgUpdateParams} request MsgUpdateParams message or plain object
                 * @param {ununifi.nftfactory.Msg.UpdateParamsCallback} callback Node-style callback called with the error, if any, and MsgUpdateParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.updateParams = function updateParams(request, callback) {
                    return this.rpcCall(updateParams, $root.ununifi.nftfactory.MsgUpdateParams, $root.ununifi.nftfactory.MsgUpdateParamsResponse, request, callback);
                }, "name", { value: "UpdateParams" });
    
                /**
                 * Calls UpdateParams.
                 * @function updateParams
                 * @memberof ununifi.nftfactory.Msg
                 * @instance
                 * @param {ununifi.nftfactory.IMsgUpdateParams} request MsgUpdateParams message or plain object
                 * @returns {Promise<ununifi.nftfactory.MsgUpdateParamsResponse>} Promise
                 * @variation 2
                 */
    
                return Msg;
            })();
    
            nftfactory.MsgCreateClass = (function() {
    
                /**
                 * Properties of a MsgCreateClass.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgCreateClass
                 * @property {string|null} [sender] MsgCreateClass sender
                 * @property {string|null} [subclass] MsgCreateClass subclass
                 * @property {string|null} [name] MsgCreateClass name
                 * @property {string|null} [symbol] MsgCreateClass symbol
                 * @property {string|null} [description] MsgCreateClass description
                 * @property {string|null} [uri] MsgCreateClass uri
                 * @property {string|null} [uri_hash] MsgCreateClass uri_hash
                 */
    
                /**
                 * Constructs a new MsgCreateClass.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgCreateClass.
                 * @implements IMsgCreateClass
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgCreateClass=} [properties] Properties to set
                 */
                function MsgCreateClass(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgCreateClass sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 */
                MsgCreateClass.prototype.sender = "";
    
                /**
                 * MsgCreateClass subclass.
                 * @member {string} subclass
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 */
                MsgCreateClass.prototype.subclass = "";
    
                /**
                 * MsgCreateClass name.
                 * @member {string} name
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 */
                MsgCreateClass.prototype.name = "";
    
                /**
                 * MsgCreateClass symbol.
                 * @member {string} symbol
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 */
                MsgCreateClass.prototype.symbol = "";
    
                /**
                 * MsgCreateClass description.
                 * @member {string} description
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 */
                MsgCreateClass.prototype.description = "";
    
                /**
                 * MsgCreateClass uri.
                 * @member {string} uri
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 */
                MsgCreateClass.prototype.uri = "";
    
                /**
                 * MsgCreateClass uri_hash.
                 * @member {string} uri_hash
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 */
                MsgCreateClass.prototype.uri_hash = "";
    
                /**
                 * Encodes the specified MsgCreateClass message. Does not implicitly {@link ununifi.nftfactory.MsgCreateClass.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @static
                 * @param {ununifi.nftfactory.IMsgCreateClass} message MsgCreateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateClass.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.subclass != null && Object.hasOwnProperty.call(message, "subclass"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.subclass);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.symbol);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.uri);
                    if (message.uri_hash != null && Object.hasOwnProperty.call(message, "uri_hash"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.uri_hash);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCreateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgCreateClass.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @static
                 * @param {ununifi.nftfactory.IMsgCreateClass} message MsgCreateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCreateClass message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgCreateClass} MsgCreateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateClass.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgCreateClass();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.subclass = reader.string();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.symbol = reader.string();
                            break;
                        case 5:
                            message.description = reader.string();
                            break;
                        case 6:
                            message.uri = reader.string();
                            break;
                        case 7:
                            message.uri_hash = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCreateClass message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgCreateClass} MsgCreateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateClass.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCreateClass message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCreateClass.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.subclass != null && message.hasOwnProperty("subclass"))
                        if (!$util.isString(message.subclass))
                            return "subclass: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        if (!$util.isString(message.symbol))
                            return "symbol: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        if (!$util.isString(message.uri_hash))
                            return "uri_hash: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgCreateClass message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgCreateClass} MsgCreateClass
                 */
                MsgCreateClass.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgCreateClass)
                        return object;
                    var message = new $root.ununifi.nftfactory.MsgCreateClass();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.subclass != null)
                        message.subclass = String(object.subclass);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.symbol != null)
                        message.symbol = String(object.symbol);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.uri_hash != null)
                        message.uri_hash = String(object.uri_hash);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgCreateClass message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @static
                 * @param {ununifi.nftfactory.MsgCreateClass} message MsgCreateClass
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCreateClass.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.subclass = "";
                        object.name = "";
                        object.symbol = "";
                        object.description = "";
                        object.uri = "";
                        object.uri_hash = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.subclass != null && message.hasOwnProperty("subclass"))
                        object.subclass = message.subclass;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        object.symbol = message.symbol;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        object.uri_hash = message.uri_hash;
                    return object;
                };
    
                /**
                 * Converts this MsgCreateClass to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgCreateClass
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCreateClass.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCreateClass;
            })();
    
            nftfactory.MsgCreateClassResponse = (function() {
    
                /**
                 * Properties of a MsgCreateClassResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgCreateClassResponse
                 */
    
                /**
                 * Constructs a new MsgCreateClassResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgCreateClassResponse.
                 * @implements IMsgCreateClassResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgCreateClassResponse=} [properties] Properties to set
                 */
                function MsgCreateClassResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgCreateClassResponse message. Does not implicitly {@link ununifi.nftfactory.MsgCreateClassResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateClassResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCreateClassResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgCreateClassResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCreateClassResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgCreateClassResponse} MsgCreateClassResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateClassResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgCreateClassResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCreateClassResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgCreateClassResponse} MsgCreateClassResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateClassResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCreateClassResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCreateClassResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgCreateClassResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgCreateClassResponse} MsgCreateClassResponse
                 */
                MsgCreateClassResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgCreateClassResponse)
                        return object;
                    return new $root.ununifi.nftfactory.MsgCreateClassResponse();
                };
    
                /**
                 * Creates a plain object from a MsgCreateClassResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @static
                 * @param {ununifi.nftfactory.MsgCreateClassResponse} message MsgCreateClassResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCreateClassResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgCreateClassResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgCreateClassResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCreateClassResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCreateClassResponse;
            })();
    
            nftfactory.MsgUpdateClass = (function() {
    
                /**
                 * Properties of a MsgUpdateClass.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgUpdateClass
                 * @property {string|null} [sender] MsgUpdateClass sender
                 * @property {string|null} [class_id] MsgUpdateClass class_id
                 * @property {string|null} [name] MsgUpdateClass name
                 * @property {string|null} [symbol] MsgUpdateClass symbol
                 * @property {string|null} [description] MsgUpdateClass description
                 * @property {string|null} [uri] MsgUpdateClass uri
                 * @property {string|null} [uri_hash] MsgUpdateClass uri_hash
                 */
    
                /**
                 * Constructs a new MsgUpdateClass.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgUpdateClass.
                 * @implements IMsgUpdateClass
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgUpdateClass=} [properties] Properties to set
                 */
                function MsgUpdateClass(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgUpdateClass sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 */
                MsgUpdateClass.prototype.sender = "";
    
                /**
                 * MsgUpdateClass class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 */
                MsgUpdateClass.prototype.class_id = "";
    
                /**
                 * MsgUpdateClass name.
                 * @member {string} name
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 */
                MsgUpdateClass.prototype.name = "";
    
                /**
                 * MsgUpdateClass symbol.
                 * @member {string} symbol
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 */
                MsgUpdateClass.prototype.symbol = "";
    
                /**
                 * MsgUpdateClass description.
                 * @member {string} description
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 */
                MsgUpdateClass.prototype.description = "";
    
                /**
                 * MsgUpdateClass uri.
                 * @member {string} uri
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 */
                MsgUpdateClass.prototype.uri = "";
    
                /**
                 * MsgUpdateClass uri_hash.
                 * @member {string} uri_hash
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 */
                MsgUpdateClass.prototype.uri_hash = "";
    
                /**
                 * Encodes the specified MsgUpdateClass message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClass.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateClass} message MsgUpdateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateClass.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.symbol);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.uri);
                    if (message.uri_hash != null && Object.hasOwnProperty.call(message, "uri_hash"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.uri_hash);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUpdateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClass.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateClass} message MsgUpdateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateClass.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUpdateClass message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgUpdateClass} MsgUpdateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateClass.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgUpdateClass();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.symbol = reader.string();
                            break;
                        case 5:
                            message.description = reader.string();
                            break;
                        case 6:
                            message.uri = reader.string();
                            break;
                        case 7:
                            message.uri_hash = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUpdateClass message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgUpdateClass} MsgUpdateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateClass.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUpdateClass message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUpdateClass.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        if (!$util.isString(message.symbol))
                            return "symbol: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        if (!$util.isString(message.uri_hash))
                            return "uri_hash: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgUpdateClass message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgUpdateClass} MsgUpdateClass
                 */
                MsgUpdateClass.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgUpdateClass)
                        return object;
                    var message = new $root.ununifi.nftfactory.MsgUpdateClass();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.symbol != null)
                        message.symbol = String(object.symbol);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.uri_hash != null)
                        message.uri_hash = String(object.uri_hash);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgUpdateClass message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @static
                 * @param {ununifi.nftfactory.MsgUpdateClass} message MsgUpdateClass
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUpdateClass.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                        object.name = "";
                        object.symbol = "";
                        object.description = "";
                        object.uri = "";
                        object.uri_hash = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.symbol != null && message.hasOwnProperty("symbol"))
                        object.symbol = message.symbol;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        object.uri_hash = message.uri_hash;
                    return object;
                };
    
                /**
                 * Converts this MsgUpdateClass to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgUpdateClass
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUpdateClass.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUpdateClass;
            })();
    
            nftfactory.MsgUpdateClassResponse = (function() {
    
                /**
                 * Properties of a MsgUpdateClassResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgUpdateClassResponse
                 */
    
                /**
                 * Constructs a new MsgUpdateClassResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgUpdateClassResponse.
                 * @implements IMsgUpdateClassResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgUpdateClassResponse=} [properties] Properties to set
                 */
                function MsgUpdateClassResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgUpdateClassResponse message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClassResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateClassResponse} message MsgUpdateClassResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateClassResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUpdateClassResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClassResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateClassResponse} message MsgUpdateClassResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUpdateClassResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgUpdateClassResponse} MsgUpdateClassResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateClassResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgUpdateClassResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUpdateClassResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgUpdateClassResponse} MsgUpdateClassResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateClassResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUpdateClassResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUpdateClassResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgUpdateClassResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgUpdateClassResponse} MsgUpdateClassResponse
                 */
                MsgUpdateClassResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgUpdateClassResponse)
                        return object;
                    return new $root.ununifi.nftfactory.MsgUpdateClassResponse();
                };
    
                /**
                 * Creates a plain object from a MsgUpdateClassResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @static
                 * @param {ununifi.nftfactory.MsgUpdateClassResponse} message MsgUpdateClassResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUpdateClassResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgUpdateClassResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgUpdateClassResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUpdateClassResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUpdateClassResponse;
            })();
    
            nftfactory.MsgMintNFT = (function() {
    
                /**
                 * Properties of a MsgMintNFT.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgMintNFT
                 * @property {string|null} [sender] MsgMintNFT sender
                 * @property {string|null} [class_id] MsgMintNFT class_id
                 * @property {string|null} [token_id] MsgMintNFT token_id
                 * @property {string|null} [uri] MsgMintNFT uri
                 * @property {string|null} [uri_hash] MsgMintNFT uri_hash
                 * @property {string|null} [recipient] MsgMintNFT recipient
                 */
    
                /**
                 * Constructs a new MsgMintNFT.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgMintNFT.
                 * @implements IMsgMintNFT
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgMintNFT=} [properties] Properties to set
                 */
                function MsgMintNFT(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgMintNFT sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @instance
                 */
                MsgMintNFT.prototype.sender = "";
    
                /**
                 * MsgMintNFT class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @instance
                 */
                MsgMintNFT.prototype.class_id = "";
    
                /**
                 * MsgMintNFT token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @instance
                 */
                MsgMintNFT.prototype.token_id = "";
    
                /**
                 * MsgMintNFT uri.
                 * @member {string} uri
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @instance
                 */
                MsgMintNFT.prototype.uri = "";
    
                /**
                 * MsgMintNFT uri_hash.
                 * @member {string} uri_hash
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @instance
                 */
                MsgMintNFT.prototype.uri_hash = "";
    
                /**
                 * MsgMintNFT recipient.
                 * @member {string} recipient
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @instance
                 */
                MsgMintNFT.prototype.recipient = "";
    
                /**
                 * Encodes the specified MsgMintNFT message. Does not implicitly {@link ununifi.nftfactory.MsgMintNFT.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @static
                 * @param {ununifi.nftfactory.IMsgMintNFT} message MsgMintNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgMintNFT.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.uri);
                    if (message.uri_hash != null && Object.hasOwnProperty.call(message, "uri_hash"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.uri_hash);
                    if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.recipient);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgMintNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgMintNFT.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @static
                 * @param {ununifi.nftfactory.IMsgMintNFT} message MsgMintNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgMintNFT message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgMintNFT} MsgMintNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgMintNFT.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgMintNFT();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        case 4:
                            message.uri = reader.string();
                            break;
                        case 5:
                            message.uri_hash = reader.string();
                            break;
                        case 6:
                            message.recipient = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgMintNFT message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgMintNFT} MsgMintNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgMintNFT.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgMintNFT message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgMintNFT.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        if (!$util.isString(message.uri_hash))
                            return "uri_hash: string expected";
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        if (!$util.isString(message.recipient))
                            return "recipient: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgMintNFT message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgMintNFT} MsgMintNFT
                 */
                MsgMintNFT.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgMintNFT)
                        return object;
                    var message = new $root.ununifi.nftfactory.MsgMintNFT();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.uri_hash != null)
                        message.uri_hash = String(object.uri_hash);
                    if (object.recipient != null)
                        message.recipient = String(object.recipient);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgMintNFT message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @static
                 * @param {ununifi.nftfactory.MsgMintNFT} message MsgMintNFT
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgMintNFT.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                        object.token_id = "";
                        object.uri = "";
                        object.uri_hash = "";
                        object.recipient = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.uri_hash != null && message.hasOwnProperty("uri_hash"))
                        object.uri_hash = message.uri_hash;
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        object.recipient = message.recipient;
                    return object;
                };
    
                /**
                 * Converts this MsgMintNFT to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgMintNFT
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgMintNFT.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgMintNFT;
            })();
    
            nftfactory.MsgMintNFTResponse = (function() {
    
                /**
                 * Properties of a MsgMintNFTResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgMintNFTResponse
                 */
    
                /**
                 * Constructs a new MsgMintNFTResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgMintNFTResponse.
                 * @implements IMsgMintNFTResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgMintNFTResponse=} [properties] Properties to set
                 */
                function MsgMintNFTResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgMintNFTResponse message. Does not implicitly {@link ununifi.nftfactory.MsgMintNFTResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgMintNFTResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgMintNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgMintNFTResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgMintNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgMintNFTResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgMintNFTResponse} MsgMintNFTResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgMintNFTResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgMintNFTResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgMintNFTResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgMintNFTResponse} MsgMintNFTResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgMintNFTResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgMintNFTResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgMintNFTResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgMintNFTResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgMintNFTResponse} MsgMintNFTResponse
                 */
                MsgMintNFTResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgMintNFTResponse)
                        return object;
                    return new $root.ununifi.nftfactory.MsgMintNFTResponse();
                };
    
                /**
                 * Creates a plain object from a MsgMintNFTResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @static
                 * @param {ununifi.nftfactory.MsgMintNFTResponse} message MsgMintNFTResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgMintNFTResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgMintNFTResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgMintNFTResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgMintNFTResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgMintNFTResponse;
            })();
    
            nftfactory.MsgBurnNFT = (function() {
    
                /**
                 * Properties of a MsgBurnNFT.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgBurnNFT
                 * @property {string|null} [sender] MsgBurnNFT sender
                 * @property {string|null} [class_id] MsgBurnNFT class_id
                 * @property {string|null} [token_id] MsgBurnNFT token_id
                 */
    
                /**
                 * Constructs a new MsgBurnNFT.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgBurnNFT.
                 * @implements IMsgBurnNFT
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgBurnNFT=} [properties] Properties to set
                 */
                function MsgBurnNFT(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgBurnNFT sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @instance
                 */
                MsgBurnNFT.prototype.sender = "";
    
                /**
                 * MsgBurnNFT class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @instance
                 */
                MsgBurnNFT.prototype.class_id = "";
    
                /**
                 * MsgBurnNFT token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @instance
                 */
                MsgBurnNFT.prototype.token_id = "";
    
                /**
                 * Encodes the specified MsgBurnNFT message. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFT.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @static
                 * @param {ununifi.nftfactory.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBurnNFT.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFT.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @static
                 * @param {ununifi.nftfactory.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgBurnNFT message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgBurnNFT} MsgBurnNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBurnNFT.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgBurnNFT();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgBurnNFT message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgBurnNFT} MsgBurnNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBurnNFT.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgBurnNFT message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgBurnNFT.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgBurnNFT message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgBurnNFT} MsgBurnNFT
                 */
                MsgBurnNFT.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgBurnNFT)
                        return object;
                    var message = new $root.ununifi.nftfactory.MsgBurnNFT();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgBurnNFT message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @static
                 * @param {ununifi.nftfactory.MsgBurnNFT} message MsgBurnNFT
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgBurnNFT.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this MsgBurnNFT to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgBurnNFT
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgBurnNFT.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgBurnNFT;
            })();
    
            nftfactory.MsgBurnNFTResponse = (function() {
    
                /**
                 * Properties of a MsgBurnNFTResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgBurnNFTResponse
                 */
    
                /**
                 * Constructs a new MsgBurnNFTResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgBurnNFTResponse.
                 * @implements IMsgBurnNFTResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgBurnNFTResponse=} [properties] Properties to set
                 */
                function MsgBurnNFTResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgBurnNFTResponse message. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFTResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBurnNFTResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgBurnNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFTResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBurnNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgBurnNFTResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgBurnNFTResponse} MsgBurnNFTResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBurnNFTResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgBurnNFTResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgBurnNFTResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgBurnNFTResponse} MsgBurnNFTResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBurnNFTResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgBurnNFTResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgBurnNFTResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgBurnNFTResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgBurnNFTResponse} MsgBurnNFTResponse
                 */
                MsgBurnNFTResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgBurnNFTResponse)
                        return object;
                    return new $root.ununifi.nftfactory.MsgBurnNFTResponse();
                };
    
                /**
                 * Creates a plain object from a MsgBurnNFTResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @static
                 * @param {ununifi.nftfactory.MsgBurnNFTResponse} message MsgBurnNFTResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgBurnNFTResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgBurnNFTResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgBurnNFTResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgBurnNFTResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgBurnNFTResponse;
            })();
    
            nftfactory.MsgChangeAdmin = (function() {
    
                /**
                 * Properties of a MsgChangeAdmin.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgChangeAdmin
                 * @property {string|null} [sender] MsgChangeAdmin sender
                 * @property {string|null} [class_id] MsgChangeAdmin class_id
                 * @property {string|null} [new_admin] MsgChangeAdmin new_admin
                 */
    
                /**
                 * Constructs a new MsgChangeAdmin.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgChangeAdmin.
                 * @implements IMsgChangeAdmin
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgChangeAdmin=} [properties] Properties to set
                 */
                function MsgChangeAdmin(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgChangeAdmin sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @instance
                 */
                MsgChangeAdmin.prototype.sender = "";
    
                /**
                 * MsgChangeAdmin class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @instance
                 */
                MsgChangeAdmin.prototype.class_id = "";
    
                /**
                 * MsgChangeAdmin new_admin.
                 * @member {string} new_admin
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @instance
                 */
                MsgChangeAdmin.prototype.new_admin = "";
    
                /**
                 * Encodes the specified MsgChangeAdmin message. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdmin.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @static
                 * @param {ununifi.nftfactory.IMsgChangeAdmin} message MsgChangeAdmin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgChangeAdmin.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.new_admin != null && Object.hasOwnProperty.call(message, "new_admin"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.new_admin);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgChangeAdmin message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdmin.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @static
                 * @param {ununifi.nftfactory.IMsgChangeAdmin} message MsgChangeAdmin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgChangeAdmin.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgChangeAdmin message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgChangeAdmin} MsgChangeAdmin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgChangeAdmin.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgChangeAdmin();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.new_admin = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgChangeAdmin message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgChangeAdmin} MsgChangeAdmin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgChangeAdmin.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgChangeAdmin message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgChangeAdmin.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.new_admin != null && message.hasOwnProperty("new_admin"))
                        if (!$util.isString(message.new_admin))
                            return "new_admin: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgChangeAdmin message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgChangeAdmin} MsgChangeAdmin
                 */
                MsgChangeAdmin.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgChangeAdmin)
                        return object;
                    var message = new $root.ununifi.nftfactory.MsgChangeAdmin();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.new_admin != null)
                        message.new_admin = String(object.new_admin);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgChangeAdmin message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @static
                 * @param {ununifi.nftfactory.MsgChangeAdmin} message MsgChangeAdmin
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgChangeAdmin.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                        object.new_admin = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.new_admin != null && message.hasOwnProperty("new_admin"))
                        object.new_admin = message.new_admin;
                    return object;
                };
    
                /**
                 * Converts this MsgChangeAdmin to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgChangeAdmin
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgChangeAdmin.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgChangeAdmin;
            })();
    
            nftfactory.MsgChangeAdminResponse = (function() {
    
                /**
                 * Properties of a MsgChangeAdminResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgChangeAdminResponse
                 */
    
                /**
                 * Constructs a new MsgChangeAdminResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgChangeAdminResponse.
                 * @implements IMsgChangeAdminResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgChangeAdminResponse=} [properties] Properties to set
                 */
                function MsgChangeAdminResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgChangeAdminResponse message. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdminResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgChangeAdminResponse} message MsgChangeAdminResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgChangeAdminResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgChangeAdminResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdminResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgChangeAdminResponse} message MsgChangeAdminResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgChangeAdminResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgChangeAdminResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgChangeAdminResponse} MsgChangeAdminResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgChangeAdminResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgChangeAdminResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgChangeAdminResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgChangeAdminResponse} MsgChangeAdminResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgChangeAdminResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgChangeAdminResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgChangeAdminResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgChangeAdminResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgChangeAdminResponse} MsgChangeAdminResponse
                 */
                MsgChangeAdminResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgChangeAdminResponse)
                        return object;
                    return new $root.ununifi.nftfactory.MsgChangeAdminResponse();
                };
    
                /**
                 * Creates a plain object from a MsgChangeAdminResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @static
                 * @param {ununifi.nftfactory.MsgChangeAdminResponse} message MsgChangeAdminResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgChangeAdminResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgChangeAdminResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgChangeAdminResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgChangeAdminResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgChangeAdminResponse;
            })();
    
            nftfactory.MsgUpdateParams = (function() {
    
                /**
                 * Properties of a MsgUpdateParams.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgUpdateParams
                 * @property {string|null} [sender] MsgUpdateParams sender
                 * @property {ununifi.nftfactory.IParams|null} [params] MsgUpdateParams params
                 */
    
                /**
                 * Constructs a new MsgUpdateParams.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgUpdateParams.
                 * @implements IMsgUpdateParams
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgUpdateParams=} [properties] Properties to set
                 */
                function MsgUpdateParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgUpdateParams sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @instance
                 */
                MsgUpdateParams.prototype.sender = "";
    
                /**
                 * MsgUpdateParams params.
                 * @member {ununifi.nftfactory.IParams|null|undefined} params
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @instance
                 */
                MsgUpdateParams.prototype.params = null;
    
                /**
                 * Encodes the specified MsgUpdateParams message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParams.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.nftfactory.Params.encode(message.params, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUpdateParams message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUpdateParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgUpdateParams} MsgUpdateParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgUpdateParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.params = $root.ununifi.nftfactory.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUpdateParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgUpdateParams} MsgUpdateParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUpdateParams message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUpdateParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.nftfactory.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgUpdateParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgUpdateParams} MsgUpdateParams
                 */
                MsgUpdateParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgUpdateParams)
                        return object;
                    var message = new $root.ununifi.nftfactory.MsgUpdateParams();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.nftfactory.MsgUpdateParams.params: object expected");
                        message.params = $root.ununifi.nftfactory.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgUpdateParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @static
                 * @param {ununifi.nftfactory.MsgUpdateParams} message MsgUpdateParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUpdateParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.params = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.nftfactory.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this MsgUpdateParams to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgUpdateParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUpdateParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUpdateParams;
            })();
    
            nftfactory.MsgUpdateParamsResponse = (function() {
    
                /**
                 * Properties of a MsgUpdateParamsResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IMsgUpdateParamsResponse
                 */
    
                /**
                 * Constructs a new MsgUpdateParamsResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a MsgUpdateParamsResponse.
                 * @implements IMsgUpdateParamsResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IMsgUpdateParamsResponse=} [properties] Properties to set
                 */
                function MsgUpdateParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgUpdateParamsResponse message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUpdateParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @static
                 * @param {ununifi.nftfactory.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.MsgUpdateParamsResponse} MsgUpdateParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.MsgUpdateParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.MsgUpdateParamsResponse} MsgUpdateParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUpdateParamsResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUpdateParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgUpdateParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.MsgUpdateParamsResponse} MsgUpdateParamsResponse
                 */
                MsgUpdateParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.MsgUpdateParamsResponse)
                        return object;
                    return new $root.ununifi.nftfactory.MsgUpdateParamsResponse();
                };
    
                /**
                 * Creates a plain object from a MsgUpdateParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @static
                 * @param {ununifi.nftfactory.MsgUpdateParamsResponse} message MsgUpdateParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUpdateParamsResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgUpdateParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUpdateParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUpdateParamsResponse;
            })();
    
            nftfactory.ClassAuthorityMetadata = (function() {
    
                /**
                 * Properties of a ClassAuthorityMetadata.
                 * @memberof ununifi.nftfactory
                 * @interface IClassAuthorityMetadata
                 * @property {string|null} [Admin] ClassAuthorityMetadata Admin
                 */
    
                /**
                 * Constructs a new ClassAuthorityMetadata.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a ClassAuthorityMetadata.
                 * @implements IClassAuthorityMetadata
                 * @constructor
                 * @param {ununifi.nftfactory.IClassAuthorityMetadata=} [properties] Properties to set
                 */
                function ClassAuthorityMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ClassAuthorityMetadata Admin.
                 * @member {string} Admin
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @instance
                 */
                ClassAuthorityMetadata.prototype.Admin = "";
    
                /**
                 * Encodes the specified ClassAuthorityMetadata message. Does not implicitly {@link ununifi.nftfactory.ClassAuthorityMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @static
                 * @param {ununifi.nftfactory.IClassAuthorityMetadata} message ClassAuthorityMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClassAuthorityMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Admin != null && Object.hasOwnProperty.call(message, "Admin"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.Admin);
                    return writer;
                };
    
                /**
                 * Encodes the specified ClassAuthorityMetadata message, length delimited. Does not implicitly {@link ununifi.nftfactory.ClassAuthorityMetadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @static
                 * @param {ununifi.nftfactory.IClassAuthorityMetadata} message ClassAuthorityMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClassAuthorityMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ClassAuthorityMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.ClassAuthorityMetadata} ClassAuthorityMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClassAuthorityMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.ClassAuthorityMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Admin = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ClassAuthorityMetadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.ClassAuthorityMetadata} ClassAuthorityMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClassAuthorityMetadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ClassAuthorityMetadata message.
                 * @function verify
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClassAuthorityMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Admin != null && message.hasOwnProperty("Admin"))
                        if (!$util.isString(message.Admin))
                            return "Admin: string expected";
                    return null;
                };
    
                /**
                 * Creates a ClassAuthorityMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.ClassAuthorityMetadata} ClassAuthorityMetadata
                 */
                ClassAuthorityMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.ClassAuthorityMetadata)
                        return object;
                    var message = new $root.ununifi.nftfactory.ClassAuthorityMetadata();
                    if (object.Admin != null)
                        message.Admin = String(object.Admin);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ClassAuthorityMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @static
                 * @param {ununifi.nftfactory.ClassAuthorityMetadata} message ClassAuthorityMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClassAuthorityMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.Admin = "";
                    if (message.Admin != null && message.hasOwnProperty("Admin"))
                        object.Admin = message.Admin;
                    return object;
                };
    
                /**
                 * Converts this ClassAuthorityMetadata to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.ClassAuthorityMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClassAuthorityMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ClassAuthorityMetadata;
            })();
    
            nftfactory.Params = (function() {
    
                /**
                 * Properties of a Params.
                 * @memberof ununifi.nftfactory
                 * @interface IParams
                 * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [class_creation_fee] Params class_creation_fee
                 * @property {string|null} [fee_collector_address] Params fee_collector_address
                 */
    
                /**
                 * Constructs a new Params.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a Params.
                 * @implements IParams
                 * @constructor
                 * @param {ununifi.nftfactory.IParams=} [properties] Properties to set
                 */
                function Params(properties) {
                    this.class_creation_fee = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Params class_creation_fee.
                 * @member {Array.<cosmos.base.v1beta1.ICoin>} class_creation_fee
                 * @memberof ununifi.nftfactory.Params
                 * @instance
                 */
                Params.prototype.class_creation_fee = $util.emptyArray;
    
                /**
                 * Params fee_collector_address.
                 * @member {string} fee_collector_address
                 * @memberof ununifi.nftfactory.Params
                 * @instance
                 */
                Params.prototype.fee_collector_address = "";
    
                /**
                 * Encodes the specified Params message. Does not implicitly {@link ununifi.nftfactory.Params.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.Params
                 * @static
                 * @param {ununifi.nftfactory.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_creation_fee != null && message.class_creation_fee.length)
                        for (var i = 0; i < message.class_creation_fee.length; ++i)
                            $root.cosmos.base.v1beta1.Coin.encode(message.class_creation_fee[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, "fee_collector_address"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fee_collector_address);
                    return writer;
                };
    
                /**
                 * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftfactory.Params.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.Params
                 * @static
                 * @param {ununifi.nftfactory.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.Params();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.class_creation_fee && message.class_creation_fee.length))
                                message.class_creation_fee = [];
                            message.class_creation_fee.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.fee_collector_address = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Params message.
                 * @function verify
                 * @memberof ununifi.nftfactory.Params
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Params.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_creation_fee != null && message.hasOwnProperty("class_creation_fee")) {
                        if (!Array.isArray(message.class_creation_fee))
                            return "class_creation_fee: array expected";
                        for (var i = 0; i < message.class_creation_fee.length; ++i) {
                            var error = $root.cosmos.base.v1beta1.Coin.verify(message.class_creation_fee[i]);
                            if (error)
                                return "class_creation_fee." + error;
                        }
                    }
                    if (message.fee_collector_address != null && message.hasOwnProperty("fee_collector_address"))
                        if (!$util.isString(message.fee_collector_address))
                            return "fee_collector_address: string expected";
                    return null;
                };
    
                /**
                 * Creates a Params message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.Params
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.Params} Params
                 */
                Params.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.Params)
                        return object;
                    var message = new $root.ununifi.nftfactory.Params();
                    if (object.class_creation_fee) {
                        if (!Array.isArray(object.class_creation_fee))
                            throw TypeError(".ununifi.nftfactory.Params.class_creation_fee: array expected");
                        message.class_creation_fee = [];
                        for (var i = 0; i < object.class_creation_fee.length; ++i) {
                            if (typeof object.class_creation_fee[i] !== "object")
                                throw TypeError(".ununifi.nftfactory.Params.class_creation_fee: object expected");
                            message.class_creation_fee[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.class_creation_fee[i]);
                        }
                    }
                    if (object.fee_collector_address != null)
                        message.fee_collector_address = String(object.fee_collector_address);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Params message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.Params
                 * @static
                 * @param {ununifi.nftfactory.Params} message Params
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Params.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.class_creation_fee = [];
                    if (options.defaults)
                        object.fee_collector_address = "";
                    if (message.class_creation_fee && message.class_creation_fee.length) {
                        object.class_creation_fee = [];
                        for (var j = 0; j < message.class_creation_fee.length; ++j)
                            object.class_creation_fee[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.class_creation_fee[j], options);
                    }
                    if (message.fee_collector_address != null && message.hasOwnProperty("fee_collector_address"))
                        object.fee_collector_address = message.fee_collector_address;
                    return object;
                };
    
                /**
                 * Converts this Params to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.Params
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Params.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Params;
            })();
    
            nftfactory.EventCreateClass = (function() {
    
                /**
                 * Properties of an EventCreateClass.
                 * @memberof ununifi.nftfactory
                 * @interface IEventCreateClass
                 * @property {string|null} [sender] EventCreateClass sender
                 * @property {string|null} [class_id] EventCreateClass class_id
                 */
    
                /**
                 * Constructs a new EventCreateClass.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents an EventCreateClass.
                 * @implements IEventCreateClass
                 * @constructor
                 * @param {ununifi.nftfactory.IEventCreateClass=} [properties] Properties to set
                 */
                function EventCreateClass(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventCreateClass sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @instance
                 */
                EventCreateClass.prototype.sender = "";
    
                /**
                 * EventCreateClass class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @instance
                 */
                EventCreateClass.prototype.class_id = "";
    
                /**
                 * Encodes the specified EventCreateClass message. Does not implicitly {@link ununifi.nftfactory.EventCreateClass.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @static
                 * @param {ununifi.nftfactory.IEventCreateClass} message EventCreateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventCreateClass.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventCreateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventCreateClass.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @static
                 * @param {ununifi.nftfactory.IEventCreateClass} message EventCreateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventCreateClass message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.EventCreateClass} EventCreateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventCreateClass.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.EventCreateClass();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventCreateClass message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.EventCreateClass} EventCreateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventCreateClass.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventCreateClass message.
                 * @function verify
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventCreateClass.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventCreateClass message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.EventCreateClass} EventCreateClass
                 */
                EventCreateClass.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.EventCreateClass)
                        return object;
                    var message = new $root.ununifi.nftfactory.EventCreateClass();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventCreateClass message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @static
                 * @param {ununifi.nftfactory.EventCreateClass} message EventCreateClass
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventCreateClass.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    return object;
                };
    
                /**
                 * Converts this EventCreateClass to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.EventCreateClass
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventCreateClass.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventCreateClass;
            })();
    
            nftfactory.EventUpdateClass = (function() {
    
                /**
                 * Properties of an EventUpdateClass.
                 * @memberof ununifi.nftfactory
                 * @interface IEventUpdateClass
                 * @property {string|null} [sender] EventUpdateClass sender
                 * @property {string|null} [class_id] EventUpdateClass class_id
                 */
    
                /**
                 * Constructs a new EventUpdateClass.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents an EventUpdateClass.
                 * @implements IEventUpdateClass
                 * @constructor
                 * @param {ununifi.nftfactory.IEventUpdateClass=} [properties] Properties to set
                 */
                function EventUpdateClass(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventUpdateClass sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @instance
                 */
                EventUpdateClass.prototype.sender = "";
    
                /**
                 * EventUpdateClass class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @instance
                 */
                EventUpdateClass.prototype.class_id = "";
    
                /**
                 * Encodes the specified EventUpdateClass message. Does not implicitly {@link ununifi.nftfactory.EventUpdateClass.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @static
                 * @param {ununifi.nftfactory.IEventUpdateClass} message EventUpdateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventUpdateClass.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventUpdateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventUpdateClass.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @static
                 * @param {ununifi.nftfactory.IEventUpdateClass} message EventUpdateClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventUpdateClass.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventUpdateClass message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.EventUpdateClass} EventUpdateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventUpdateClass.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.EventUpdateClass();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventUpdateClass message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.EventUpdateClass} EventUpdateClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventUpdateClass.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventUpdateClass message.
                 * @function verify
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventUpdateClass.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventUpdateClass message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.EventUpdateClass} EventUpdateClass
                 */
                EventUpdateClass.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.EventUpdateClass)
                        return object;
                    var message = new $root.ununifi.nftfactory.EventUpdateClass();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventUpdateClass message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @static
                 * @param {ununifi.nftfactory.EventUpdateClass} message EventUpdateClass
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventUpdateClass.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    return object;
                };
    
                /**
                 * Converts this EventUpdateClass to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.EventUpdateClass
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventUpdateClass.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventUpdateClass;
            })();
    
            nftfactory.EventMintNFT = (function() {
    
                /**
                 * Properties of an EventMintNFT.
                 * @memberof ununifi.nftfactory
                 * @interface IEventMintNFT
                 * @property {string|null} [sender] EventMintNFT sender
                 * @property {string|null} [class_id] EventMintNFT class_id
                 * @property {string|null} [token_id] EventMintNFT token_id
                 * @property {string|null} [recipient] EventMintNFT recipient
                 */
    
                /**
                 * Constructs a new EventMintNFT.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents an EventMintNFT.
                 * @implements IEventMintNFT
                 * @constructor
                 * @param {ununifi.nftfactory.IEventMintNFT=} [properties] Properties to set
                 */
                function EventMintNFT(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventMintNFT sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @instance
                 */
                EventMintNFT.prototype.sender = "";
    
                /**
                 * EventMintNFT class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @instance
                 */
                EventMintNFT.prototype.class_id = "";
    
                /**
                 * EventMintNFT token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @instance
                 */
                EventMintNFT.prototype.token_id = "";
    
                /**
                 * EventMintNFT recipient.
                 * @member {string} recipient
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @instance
                 */
                EventMintNFT.prototype.recipient = "";
    
                /**
                 * Encodes the specified EventMintNFT message. Does not implicitly {@link ununifi.nftfactory.EventMintNFT.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @static
                 * @param {ununifi.nftfactory.IEventMintNFT} message EventMintNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventMintNFT.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.recipient);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventMintNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventMintNFT.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @static
                 * @param {ununifi.nftfactory.IEventMintNFT} message EventMintNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventMintNFT message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.EventMintNFT} EventMintNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventMintNFT.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.EventMintNFT();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        case 4:
                            message.recipient = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventMintNFT message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.EventMintNFT} EventMintNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventMintNFT.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventMintNFT message.
                 * @function verify
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventMintNFT.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        if (!$util.isString(message.recipient))
                            return "recipient: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventMintNFT message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.EventMintNFT} EventMintNFT
                 */
                EventMintNFT.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.EventMintNFT)
                        return object;
                    var message = new $root.ununifi.nftfactory.EventMintNFT();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    if (object.recipient != null)
                        message.recipient = String(object.recipient);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventMintNFT message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @static
                 * @param {ununifi.nftfactory.EventMintNFT} message EventMintNFT
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventMintNFT.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                        object.token_id = "";
                        object.recipient = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        object.recipient = message.recipient;
                    return object;
                };
    
                /**
                 * Converts this EventMintNFT to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.EventMintNFT
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventMintNFT.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventMintNFT;
            })();
    
            nftfactory.EventBurnNFT = (function() {
    
                /**
                 * Properties of an EventBurnNFT.
                 * @memberof ununifi.nftfactory
                 * @interface IEventBurnNFT
                 * @property {string|null} [sender] EventBurnNFT sender
                 * @property {string|null} [class_id] EventBurnNFT class_id
                 * @property {string|null} [token_id] EventBurnNFT token_id
                 */
    
                /**
                 * Constructs a new EventBurnNFT.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents an EventBurnNFT.
                 * @implements IEventBurnNFT
                 * @constructor
                 * @param {ununifi.nftfactory.IEventBurnNFT=} [properties] Properties to set
                 */
                function EventBurnNFT(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventBurnNFT sender.
                 * @member {string} sender
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @instance
                 */
                EventBurnNFT.prototype.sender = "";
    
                /**
                 * EventBurnNFT class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @instance
                 */
                EventBurnNFT.prototype.class_id = "";
    
                /**
                 * EventBurnNFT token_id.
                 * @member {string} token_id
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @instance
                 */
                EventBurnNFT.prototype.token_id = "";
    
                /**
                 * Encodes the specified EventBurnNFT message. Does not implicitly {@link ununifi.nftfactory.EventBurnNFT.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @static
                 * @param {ununifi.nftfactory.IEventBurnNFT} message EventBurnNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventBurnNFT.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_id);
                    if (message.token_id != null && Object.hasOwnProperty.call(message, "token_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventBurnNFT.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @static
                 * @param {ununifi.nftfactory.IEventBurnNFT} message EventBurnNFT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventBurnNFT message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.EventBurnNFT} EventBurnNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventBurnNFT.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.EventBurnNFT();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.class_id = reader.string();
                            break;
                        case 3:
                            message.token_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventBurnNFT message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.EventBurnNFT} EventBurnNFT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventBurnNFT.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventBurnNFT message.
                 * @function verify
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventBurnNFT.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        if (!$util.isString(message.token_id))
                            return "token_id: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventBurnNFT message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.EventBurnNFT} EventBurnNFT
                 */
                EventBurnNFT.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.EventBurnNFT)
                        return object;
                    var message = new $root.ununifi.nftfactory.EventBurnNFT();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.token_id != null)
                        message.token_id = String(object.token_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventBurnNFT message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @static
                 * @param {ununifi.nftfactory.EventBurnNFT} message EventBurnNFT
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventBurnNFT.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.class_id = "";
                        object.token_id = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.token_id != null && message.hasOwnProperty("token_id"))
                        object.token_id = message.token_id;
                    return object;
                };
    
                /**
                 * Converts this EventBurnNFT to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.EventBurnNFT
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventBurnNFT.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventBurnNFT;
            })();
    
            nftfactory.EventChangeAdmin = (function() {
    
                /**
                 * Properties of an EventChangeAdmin.
                 * @memberof ununifi.nftfactory
                 * @interface IEventChangeAdmin
                 * @property {string|null} [admin] EventChangeAdmin admin
                 * @property {string|null} [class_id] EventChangeAdmin class_id
                 * @property {string|null} [new_admin] EventChangeAdmin new_admin
                 */
    
                /**
                 * Constructs a new EventChangeAdmin.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents an EventChangeAdmin.
                 * @implements IEventChangeAdmin
                 * @constructor
                 * @param {ununifi.nftfactory.IEventChangeAdmin=} [properties] Properties to set
                 */
                function EventChangeAdmin(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventChangeAdmin admin.
                 * @member {string} admin
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @instance
                 */
                EventChangeAdmin.prototype.admin = "";
    
                /**
                 * EventChangeAdmin class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @instance
                 */
                EventChangeAdmin.prototype.class_id = "";
    
                /**
                 * EventChangeAdmin new_admin.
                 * @member {string} new_admin
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @instance
                 */
                EventChangeAdmin.prototype.new_admin = "";
    
                /**
                 * Encodes the specified EventChangeAdmin message. Does not implicitly {@link ununifi.nftfactory.EventChangeAdmin.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @static
                 * @param {ununifi.nftfactory.IEventChangeAdmin} message EventChangeAdmin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventChangeAdmin.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.admin != null && Object.hasOwnProperty.call(message, "admin"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.admin);
                    if (message.new_admin != null && Object.hasOwnProperty.call(message, "new_admin"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.new_admin);
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.class_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified EventChangeAdmin message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventChangeAdmin.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @static
                 * @param {ununifi.nftfactory.IEventChangeAdmin} message EventChangeAdmin message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventChangeAdmin.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EventChangeAdmin message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.EventChangeAdmin} EventChangeAdmin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventChangeAdmin.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.EventChangeAdmin();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.admin = reader.string();
                            break;
                        case 3:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.new_admin = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EventChangeAdmin message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.EventChangeAdmin} EventChangeAdmin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventChangeAdmin.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EventChangeAdmin message.
                 * @function verify
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventChangeAdmin.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.admin != null && message.hasOwnProperty("admin"))
                        if (!$util.isString(message.admin))
                            return "admin: string expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.new_admin != null && message.hasOwnProperty("new_admin"))
                        if (!$util.isString(message.new_admin))
                            return "new_admin: string expected";
                    return null;
                };
    
                /**
                 * Creates an EventChangeAdmin message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.EventChangeAdmin} EventChangeAdmin
                 */
                EventChangeAdmin.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.EventChangeAdmin)
                        return object;
                    var message = new $root.ununifi.nftfactory.EventChangeAdmin();
                    if (object.admin != null)
                        message.admin = String(object.admin);
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.new_admin != null)
                        message.new_admin = String(object.new_admin);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EventChangeAdmin message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @static
                 * @param {ununifi.nftfactory.EventChangeAdmin} message EventChangeAdmin
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventChangeAdmin.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.admin = "";
                        object.new_admin = "";
                        object.class_id = "";
                    }
                    if (message.admin != null && message.hasOwnProperty("admin"))
                        object.admin = message.admin;
                    if (message.new_admin != null && message.hasOwnProperty("new_admin"))
                        object.new_admin = message.new_admin;
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    return object;
                };
    
                /**
                 * Converts this EventChangeAdmin to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.EventChangeAdmin
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventChangeAdmin.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EventChangeAdmin;
            })();
    
            nftfactory.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof ununifi.nftfactory
                 * @interface IGenesisState
                 * @property {ununifi.nftfactory.IParams|null} [params] GenesisState params
                 * @property {Array.<ununifi.nftfactory.IGenesisClass>|null} [classes] GenesisState classes
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {ununifi.nftfactory.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.classes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState params.
                 * @member {ununifi.nftfactory.IParams|null|undefined} params
                 * @memberof ununifi.nftfactory.GenesisState
                 * @instance
                 */
                GenesisState.prototype.params = null;
    
                /**
                 * GenesisState classes.
                 * @member {Array.<ununifi.nftfactory.IGenesisClass>} classes
                 * @memberof ununifi.nftfactory.GenesisState
                 * @instance
                 */
                GenesisState.prototype.classes = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftfactory.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.GenesisState
                 * @static
                 * @param {ununifi.nftfactory.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.nftfactory.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.classes != null && message.classes.length)
                        for (var i = 0; i < message.classes.length; ++i)
                            $root.ununifi.nftfactory.GenesisClass.encode(message.classes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftfactory.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.GenesisState
                 * @static
                 * @param {ununifi.nftfactory.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.nftfactory.Params.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.classes && message.classes.length))
                                message.classes = [];
                            message.classes.push($root.ununifi.nftfactory.GenesisClass.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof ununifi.nftfactory.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.nftfactory.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.classes != null && message.hasOwnProperty("classes")) {
                        if (!Array.isArray(message.classes))
                            return "classes: array expected";
                        for (var i = 0; i < message.classes.length; ++i) {
                            var error = $root.ununifi.nftfactory.GenesisClass.verify(message.classes[i]);
                            if (error)
                                return "classes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.GenesisState)
                        return object;
                    var message = new $root.ununifi.nftfactory.GenesisState();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.nftfactory.GenesisState.params: object expected");
                        message.params = $root.ununifi.nftfactory.Params.fromObject(object.params);
                    }
                    if (object.classes) {
                        if (!Array.isArray(object.classes))
                            throw TypeError(".ununifi.nftfactory.GenesisState.classes: array expected");
                        message.classes = [];
                        for (var i = 0; i < object.classes.length; ++i) {
                            if (typeof object.classes[i] !== "object")
                                throw TypeError(".ununifi.nftfactory.GenesisState.classes: object expected");
                            message.classes[i] = $root.ununifi.nftfactory.GenesisClass.fromObject(object.classes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.GenesisState
                 * @static
                 * @param {ununifi.nftfactory.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.classes = [];
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.nftfactory.Params.toObject(message.params, options);
                    if (message.classes && message.classes.length) {
                        object.classes = [];
                        for (var j = 0; j < message.classes.length; ++j)
                            object.classes[j] = $root.ununifi.nftfactory.GenesisClass.toObject(message.classes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            nftfactory.GenesisClass = (function() {
    
                /**
                 * Properties of a GenesisClass.
                 * @memberof ununifi.nftfactory
                 * @interface IGenesisClass
                 * @property {string|null} [class_id] GenesisClass class_id
                 * @property {ununifi.nftfactory.IClassAuthorityMetadata|null} [authority_metadata] GenesisClass authority_metadata
                 */
    
                /**
                 * Constructs a new GenesisClass.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a GenesisClass.
                 * @implements IGenesisClass
                 * @constructor
                 * @param {ununifi.nftfactory.IGenesisClass=} [properties] Properties to set
                 */
                function GenesisClass(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisClass class_id.
                 * @member {string} class_id
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @instance
                 */
                GenesisClass.prototype.class_id = "";
    
                /**
                 * GenesisClass authority_metadata.
                 * @member {ununifi.nftfactory.IClassAuthorityMetadata|null|undefined} authority_metadata
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @instance
                 */
                GenesisClass.prototype.authority_metadata = null;
    
                /**
                 * Encodes the specified GenesisClass message. Does not implicitly {@link ununifi.nftfactory.GenesisClass.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @static
                 * @param {ununifi.nftfactory.IGenesisClass} message GenesisClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisClass.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.class_id);
                    if (message.authority_metadata != null && Object.hasOwnProperty.call(message, "authority_metadata"))
                        $root.ununifi.nftfactory.ClassAuthorityMetadata.encode(message.authority_metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.GenesisClass.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @static
                 * @param {ununifi.nftfactory.IGenesisClass} message GenesisClass message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisClass.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisClass message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.GenesisClass} GenesisClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisClass.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.GenesisClass();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.class_id = reader.string();
                            break;
                        case 2:
                            message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisClass message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.GenesisClass} GenesisClass
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisClass.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisClass message.
                 * @function verify
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisClass.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        if (!$util.isString(message.class_id))
                            return "class_id: string expected";
                    if (message.authority_metadata != null && message.hasOwnProperty("authority_metadata")) {
                        var error = $root.ununifi.nftfactory.ClassAuthorityMetadata.verify(message.authority_metadata);
                        if (error)
                            return "authority_metadata." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisClass message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.GenesisClass} GenesisClass
                 */
                GenesisClass.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.GenesisClass)
                        return object;
                    var message = new $root.ununifi.nftfactory.GenesisClass();
                    if (object.class_id != null)
                        message.class_id = String(object.class_id);
                    if (object.authority_metadata != null) {
                        if (typeof object.authority_metadata !== "object")
                            throw TypeError(".ununifi.nftfactory.GenesisClass.authority_metadata: object expected");
                        message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.fromObject(object.authority_metadata);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisClass message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @static
                 * @param {ununifi.nftfactory.GenesisClass} message GenesisClass
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisClass.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.class_id = "";
                        object.authority_metadata = null;
                    }
                    if (message.class_id != null && message.hasOwnProperty("class_id"))
                        object.class_id = message.class_id;
                    if (message.authority_metadata != null && message.hasOwnProperty("authority_metadata"))
                        object.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.toObject(message.authority_metadata, options);
                    return object;
                };
    
                /**
                 * Converts this GenesisClass to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.GenesisClass
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisClass.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisClass;
            })();
    
            nftfactory.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Query#params}.
                 * @memberof ununifi.nftfactory.Query
                 * @typedef ParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.QueryParamsResponse} [response] QueryParamsResponse
                 */
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.nftfactory.Query
                 * @instance
                 * @param {ununifi.nftfactory.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @param {ununifi.nftfactory.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.params = function params(request, callback) {
                    return this.rpcCall(params, $root.ununifi.nftfactory.QueryParamsRequest, $root.ununifi.nftfactory.QueryParamsResponse, request, callback);
                }, "name", { value: "Params" });
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.nftfactory.Query
                 * @instance
                 * @param {ununifi.nftfactory.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @returns {Promise<ununifi.nftfactory.QueryParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Query#classAuthorityMetadata}.
                 * @memberof ununifi.nftfactory.Query
                 * @typedef ClassAuthorityMetadataCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} [response] QueryClassAuthorityMetadataResponse
                 */
    
                /**
                 * Calls ClassAuthorityMetadata.
                 * @function classAuthorityMetadata
                 * @memberof ununifi.nftfactory.Query
                 * @instance
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} request QueryClassAuthorityMetadataRequest message or plain object
                 * @param {ununifi.nftfactory.Query.ClassAuthorityMetadataCallback} callback Node-style callback called with the error, if any, and QueryClassAuthorityMetadataResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.classAuthorityMetadata = function classAuthorityMetadata(request, callback) {
                    return this.rpcCall(classAuthorityMetadata, $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest, $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse, request, callback);
                }, "name", { value: "ClassAuthorityMetadata" });
    
                /**
                 * Calls ClassAuthorityMetadata.
                 * @function classAuthorityMetadata
                 * @memberof ununifi.nftfactory.Query
                 * @instance
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} request QueryClassAuthorityMetadataRequest message or plain object
                 * @returns {Promise<ununifi.nftfactory.QueryClassAuthorityMetadataResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.nftfactory.Query#classesFromCreator}.
                 * @memberof ununifi.nftfactory.Query
                 * @typedef ClassesFromCreatorCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.nftfactory.QueryClassesFromCreatorResponse} [response] QueryClassesFromCreatorResponse
                 */
    
                /**
                 * Calls ClassesFromCreator.
                 * @function classesFromCreator
                 * @memberof ununifi.nftfactory.Query
                 * @instance
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} request QueryClassesFromCreatorRequest message or plain object
                 * @param {ununifi.nftfactory.Query.ClassesFromCreatorCallback} callback Node-style callback called with the error, if any, and QueryClassesFromCreatorResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.classesFromCreator = function classesFromCreator(request, callback) {
                    return this.rpcCall(classesFromCreator, $root.ununifi.nftfactory.QueryClassesFromCreatorRequest, $root.ununifi.nftfactory.QueryClassesFromCreatorResponse, request, callback);
                }, "name", { value: "ClassesFromCreator" });
    
                /**
                 * Calls ClassesFromCreator.
                 * @function classesFromCreator
                 * @memberof ununifi.nftfactory.Query
                 * @instance
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} request QueryClassesFromCreatorRequest message or plain object
                 * @returns {Promise<ununifi.nftfactory.QueryClassesFromCreatorResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            nftfactory.QueryParamsRequest = (function() {
    
                /**
                 * Properties of a QueryParamsRequest.
                 * @memberof ununifi.nftfactory
                 * @interface IQueryParamsRequest
                 */
    
                /**
                 * Constructs a new QueryParamsRequest.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a QueryParamsRequest.
                 * @implements IQueryParamsRequest
                 * @constructor
                 * @param {ununifi.nftfactory.IQueryParamsRequest=} [properties] Properties to set
                 */
                function QueryParamsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftfactory.QueryParamsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @static
                 * @param {ununifi.nftfactory.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryParamsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @static
                 * @param {ununifi.nftfactory.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.QueryParamsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsRequest message.
                 * @function verify
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.QueryParamsRequest} QueryParamsRequest
                 */
                QueryParamsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.QueryParamsRequest)
                        return object;
                    return new $root.ununifi.nftfactory.QueryParamsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @static
                 * @param {ununifi.nftfactory.QueryParamsRequest} message QueryParamsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryParamsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.QueryParamsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsRequest;
            })();
    
            nftfactory.QueryParamsResponse = (function() {
    
                /**
                 * Properties of a QueryParamsResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IQueryParamsResponse
                 * @property {ununifi.nftfactory.IParams|null} [params] QueryParamsResponse params
                 */
    
                /**
                 * Constructs a new QueryParamsResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a QueryParamsResponse.
                 * @implements IQueryParamsResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IQueryParamsResponse=} [properties] Properties to set
                 */
                function QueryParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryParamsResponse params.
                 * @member {ununifi.nftfactory.IParams|null|undefined} params
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @instance
                 */
                QueryParamsResponse.prototype.params = null;
    
                /**
                 * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftfactory.QueryParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @static
                 * @param {ununifi.nftfactory.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.nftfactory.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @static
                 * @param {ununifi.nftfactory.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.QueryParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.nftfactory.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.nftfactory.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.QueryParamsResponse} QueryParamsResponse
                 */
                QueryParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.QueryParamsResponse)
                        return object;
                    var message = new $root.ununifi.nftfactory.QueryParamsResponse();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.nftfactory.QueryParamsResponse.params: object expected");
                        message.params = $root.ununifi.nftfactory.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @static
                 * @param {ununifi.nftfactory.QueryParamsResponse} message QueryParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.nftfactory.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this QueryParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.QueryParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsResponse;
            })();
    
            nftfactory.QueryClassAuthorityMetadataRequest = (function() {
    
                /**
                 * Properties of a QueryClassAuthorityMetadataRequest.
                 * @memberof ununifi.nftfactory
                 * @interface IQueryClassAuthorityMetadataRequest
                 * @property {string|null} [creator] QueryClassAuthorityMetadataRequest creator
                 * @property {string|null} [subclass] QueryClassAuthorityMetadataRequest subclass
                 */
    
                /**
                 * Constructs a new QueryClassAuthorityMetadataRequest.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a QueryClassAuthorityMetadataRequest.
                 * @implements IQueryClassAuthorityMetadataRequest
                 * @constructor
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest=} [properties] Properties to set
                 */
                function QueryClassAuthorityMetadataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryClassAuthorityMetadataRequest creator.
                 * @member {string} creator
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @instance
                 */
                QueryClassAuthorityMetadataRequest.prototype.creator = "";
    
                /**
                 * QueryClassAuthorityMetadataRequest subclass.
                 * @member {string} subclass
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @instance
                 */
                QueryClassAuthorityMetadataRequest.prototype.subclass = "";
    
                /**
                 * Encodes the specified QueryClassAuthorityMetadataRequest message. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} message QueryClassAuthorityMetadataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassAuthorityMetadataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.creator != null && Object.hasOwnProperty.call(message, "creator"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.creator);
                    if (message.subclass != null && Object.hasOwnProperty.call(message, "subclass"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.subclass);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryClassAuthorityMetadataRequest message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} message QueryClassAuthorityMetadataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassAuthorityMetadataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryClassAuthorityMetadataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} QueryClassAuthorityMetadataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassAuthorityMetadataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.creator = reader.string();
                            break;
                        case 2:
                            message.subclass = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryClassAuthorityMetadataRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} QueryClassAuthorityMetadataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassAuthorityMetadataRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryClassAuthorityMetadataRequest message.
                 * @function verify
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryClassAuthorityMetadataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.creator != null && message.hasOwnProperty("creator"))
                        if (!$util.isString(message.creator))
                            return "creator: string expected";
                    if (message.subclass != null && message.hasOwnProperty("subclass"))
                        if (!$util.isString(message.subclass))
                            return "subclass: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryClassAuthorityMetadataRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} QueryClassAuthorityMetadataRequest
                 */
                QueryClassAuthorityMetadataRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest)
                        return object;
                    var message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest();
                    if (object.creator != null)
                        message.creator = String(object.creator);
                    if (object.subclass != null)
                        message.subclass = String(object.subclass);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryClassAuthorityMetadataRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @static
                 * @param {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} message QueryClassAuthorityMetadataRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryClassAuthorityMetadataRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.creator = "";
                        object.subclass = "";
                    }
                    if (message.creator != null && message.hasOwnProperty("creator"))
                        object.creator = message.creator;
                    if (message.subclass != null && message.hasOwnProperty("subclass"))
                        object.subclass = message.subclass;
                    return object;
                };
    
                /**
                 * Converts this QueryClassAuthorityMetadataRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryClassAuthorityMetadataRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryClassAuthorityMetadataRequest;
            })();
    
            nftfactory.QueryClassAuthorityMetadataResponse = (function() {
    
                /**
                 * Properties of a QueryClassAuthorityMetadataResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IQueryClassAuthorityMetadataResponse
                 * @property {ununifi.nftfactory.IClassAuthorityMetadata|null} [authority_metadata] QueryClassAuthorityMetadataResponse authority_metadata
                 */
    
                /**
                 * Constructs a new QueryClassAuthorityMetadataResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a QueryClassAuthorityMetadataResponse.
                 * @implements IQueryClassAuthorityMetadataResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataResponse=} [properties] Properties to set
                 */
                function QueryClassAuthorityMetadataResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryClassAuthorityMetadataResponse authority_metadata.
                 * @member {ununifi.nftfactory.IClassAuthorityMetadata|null|undefined} authority_metadata
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @instance
                 */
                QueryClassAuthorityMetadataResponse.prototype.authority_metadata = null;
    
                /**
                 * Encodes the specified QueryClassAuthorityMetadataResponse message. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataResponse} message QueryClassAuthorityMetadataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassAuthorityMetadataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.authority_metadata != null && Object.hasOwnProperty.call(message, "authority_metadata"))
                        $root.ununifi.nftfactory.ClassAuthorityMetadata.encode(message.authority_metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryClassAuthorityMetadataResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataResponse} message QueryClassAuthorityMetadataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassAuthorityMetadataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryClassAuthorityMetadataResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} QueryClassAuthorityMetadataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassAuthorityMetadataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryClassAuthorityMetadataResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} QueryClassAuthorityMetadataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassAuthorityMetadataResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryClassAuthorityMetadataResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryClassAuthorityMetadataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.authority_metadata != null && message.hasOwnProperty("authority_metadata")) {
                        var error = $root.ununifi.nftfactory.ClassAuthorityMetadata.verify(message.authority_metadata);
                        if (error)
                            return "authority_metadata." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryClassAuthorityMetadataResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} QueryClassAuthorityMetadataResponse
                 */
                QueryClassAuthorityMetadataResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse)
                        return object;
                    var message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse();
                    if (object.authority_metadata != null) {
                        if (typeof object.authority_metadata !== "object")
                            throw TypeError(".ununifi.nftfactory.QueryClassAuthorityMetadataResponse.authority_metadata: object expected");
                        message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.fromObject(object.authority_metadata);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryClassAuthorityMetadataResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @static
                 * @param {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} message QueryClassAuthorityMetadataResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryClassAuthorityMetadataResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.authority_metadata = null;
                    if (message.authority_metadata != null && message.hasOwnProperty("authority_metadata"))
                        object.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.toObject(message.authority_metadata, options);
                    return object;
                };
    
                /**
                 * Converts this QueryClassAuthorityMetadataResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryClassAuthorityMetadataResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryClassAuthorityMetadataResponse;
            })();
    
            nftfactory.QueryClassesFromCreatorRequest = (function() {
    
                /**
                 * Properties of a QueryClassesFromCreatorRequest.
                 * @memberof ununifi.nftfactory
                 * @interface IQueryClassesFromCreatorRequest
                 * @property {string|null} [creator] QueryClassesFromCreatorRequest creator
                 */
    
                /**
                 * Constructs a new QueryClassesFromCreatorRequest.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a QueryClassesFromCreatorRequest.
                 * @implements IQueryClassesFromCreatorRequest
                 * @constructor
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest=} [properties] Properties to set
                 */
                function QueryClassesFromCreatorRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryClassesFromCreatorRequest creator.
                 * @member {string} creator
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @instance
                 */
                QueryClassesFromCreatorRequest.prototype.creator = "";
    
                /**
                 * Encodes the specified QueryClassesFromCreatorRequest message. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} message QueryClassesFromCreatorRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassesFromCreatorRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.creator != null && Object.hasOwnProperty.call(message, "creator"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.creator);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryClassesFromCreatorRequest message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} message QueryClassesFromCreatorRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassesFromCreatorRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryClassesFromCreatorRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.QueryClassesFromCreatorRequest} QueryClassesFromCreatorRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassesFromCreatorRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.QueryClassesFromCreatorRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.creator = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryClassesFromCreatorRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.QueryClassesFromCreatorRequest} QueryClassesFromCreatorRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassesFromCreatorRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryClassesFromCreatorRequest message.
                 * @function verify
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryClassesFromCreatorRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.creator != null && message.hasOwnProperty("creator"))
                        if (!$util.isString(message.creator))
                            return "creator: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryClassesFromCreatorRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.QueryClassesFromCreatorRequest} QueryClassesFromCreatorRequest
                 */
                QueryClassesFromCreatorRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.QueryClassesFromCreatorRequest)
                        return object;
                    var message = new $root.ununifi.nftfactory.QueryClassesFromCreatorRequest();
                    if (object.creator != null)
                        message.creator = String(object.creator);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryClassesFromCreatorRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @static
                 * @param {ununifi.nftfactory.QueryClassesFromCreatorRequest} message QueryClassesFromCreatorRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryClassesFromCreatorRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.creator = "";
                    if (message.creator != null && message.hasOwnProperty("creator"))
                        object.creator = message.creator;
                    return object;
                };
    
                /**
                 * Converts this QueryClassesFromCreatorRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryClassesFromCreatorRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryClassesFromCreatorRequest;
            })();
    
            nftfactory.QueryClassesFromCreatorResponse = (function() {
    
                /**
                 * Properties of a QueryClassesFromCreatorResponse.
                 * @memberof ununifi.nftfactory
                 * @interface IQueryClassesFromCreatorResponse
                 * @property {Array.<string>|null} [classes] QueryClassesFromCreatorResponse classes
                 */
    
                /**
                 * Constructs a new QueryClassesFromCreatorResponse.
                 * @memberof ununifi.nftfactory
                 * @classdesc Represents a QueryClassesFromCreatorResponse.
                 * @implements IQueryClassesFromCreatorResponse
                 * @constructor
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorResponse=} [properties] Properties to set
                 */
                function QueryClassesFromCreatorResponse(properties) {
                    this.classes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryClassesFromCreatorResponse classes.
                 * @member {Array.<string>} classes
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @instance
                 */
                QueryClassesFromCreatorResponse.prototype.classes = $util.emptyArray;
    
                /**
                 * Encodes the specified QueryClassesFromCreatorResponse message. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorResponse} message QueryClassesFromCreatorResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassesFromCreatorResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.classes != null && message.classes.length)
                        for (var i = 0; i < message.classes.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.classes[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryClassesFromCreatorResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @static
                 * @param {ununifi.nftfactory.IQueryClassesFromCreatorResponse} message QueryClassesFromCreatorResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryClassesFromCreatorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryClassesFromCreatorResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.nftfactory.QueryClassesFromCreatorResponse} QueryClassesFromCreatorResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassesFromCreatorResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.nftfactory.QueryClassesFromCreatorResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.classes && message.classes.length))
                                message.classes = [];
                            message.classes.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryClassesFromCreatorResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.nftfactory.QueryClassesFromCreatorResponse} QueryClassesFromCreatorResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryClassesFromCreatorResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryClassesFromCreatorResponse message.
                 * @function verify
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryClassesFromCreatorResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.classes != null && message.hasOwnProperty("classes")) {
                        if (!Array.isArray(message.classes))
                            return "classes: array expected";
                        for (var i = 0; i < message.classes.length; ++i)
                            if (!$util.isString(message.classes[i]))
                                return "classes: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryClassesFromCreatorResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.nftfactory.QueryClassesFromCreatorResponse} QueryClassesFromCreatorResponse
                 */
                QueryClassesFromCreatorResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.nftfactory.QueryClassesFromCreatorResponse)
                        return object;
                    var message = new $root.ununifi.nftfactory.QueryClassesFromCreatorResponse();
                    if (object.classes) {
                        if (!Array.isArray(object.classes))
                            throw TypeError(".ununifi.nftfactory.QueryClassesFromCreatorResponse.classes: array expected");
                        message.classes = [];
                        for (var i = 0; i < object.classes.length; ++i)
                            message.classes[i] = String(object.classes[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryClassesFromCreatorResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @static
                 * @param {ununifi.nftfactory.QueryClassesFromCreatorResponse} message QueryClassesFromCreatorResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryClassesFromCreatorResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.classes = [];
                    if (message.classes && message.classes.length) {
                        object.classes = [];
                        for (var j = 0; j < message.classes.length; ++j)
                            object.classes[j] = message.classes[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this QueryClassesFromCreatorResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryClassesFromCreatorResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryClassesFromCreatorResponse;
            })();
    
            return nftfactory;
        })();
    
        ununifi.pricefeed = (function() {
    
            /**
             * Namespace pricefeed.
             * @memberof ununifi
             * @namespace
             */
            var pricefeed = {};
    
            pricefeed.Msg = (function() {
    
                /**
                 * Constructs a new Msg service.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a Msg
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Msg(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;
    
                /**
                 * Callback as used by {@link ununifi.pricefeed.Msg#postPrice}.
                 * @memberof ununifi.pricefeed.Msg
                 * @typedef PostPriceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.pricefeed.MsgPostPriceResponse} [response] MsgPostPriceResponse
                 */
    
                /**
                 * Calls PostPrice.
                 * @function postPrice
                 * @memberof ununifi.pricefeed.Msg
                 * @instance
                 * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
                 * @param {ununifi.pricefeed.Msg.PostPriceCallback} callback Node-style callback called with the error, if any, and MsgPostPriceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.postPrice = function postPrice(request, callback) {
                    return this.rpcCall(postPrice, $root.ununifi.pricefeed.MsgPostPrice, $root.ununifi.pricefeed.MsgPostPriceResponse, request, callback);
                }, "name", { value: "PostPrice" });
    
                /**
                 * Calls PostPrice.
                 * @function postPrice
                 * @memberof ununifi.pricefeed.Msg
                 * @instance
                 * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
                 * @returns {Promise<ununifi.pricefeed.MsgPostPriceResponse>} Promise
                 * @variation 2
                 */
    
                return Msg;
            })();
    
            pricefeed.MsgPostPrice = (function() {
    
                /**
                 * Properties of a MsgPostPrice.
                 * @memberof ununifi.pricefeed
                 * @interface IMsgPostPrice
                 * @property {string|null} [from] MsgPostPrice from
                 * @property {string|null} [market_id] MsgPostPrice market_id
                 * @property {string|null} [price] MsgPostPrice price
                 * @property {google.protobuf.ITimestamp|null} [expiry] MsgPostPrice expiry
                 */
    
                /**
                 * Constructs a new MsgPostPrice.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a MsgPostPrice.
                 * @implements IMsgPostPrice
                 * @constructor
                 * @param {ununifi.pricefeed.IMsgPostPrice=} [properties] Properties to set
                 */
                function MsgPostPrice(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgPostPrice from.
                 * @member {string} from
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @instance
                 */
                MsgPostPrice.prototype.from = "";
    
                /**
                 * MsgPostPrice market_id.
                 * @member {string} market_id
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @instance
                 */
                MsgPostPrice.prototype.market_id = "";
    
                /**
                 * MsgPostPrice price.
                 * @member {string} price
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @instance
                 */
                MsgPostPrice.prototype.price = "";
    
                /**
                 * MsgPostPrice expiry.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiry
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @instance
                 */
                MsgPostPrice.prototype.expiry = null;
    
                /**
                 * Encodes the specified MsgPostPrice message. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @static
                 * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPostPrice.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.from);
                    if (message.market_id != null && Object.hasOwnProperty.call(message, "market_id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.market_id);
                    if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.price);
                    if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                        $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgPostPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @static
                 * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPostPrice.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgPostPrice message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPostPrice.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.MsgPostPrice();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.from = reader.string();
                            break;
                        case 2:
                            message.market_id = reader.string();
                            break;
                        case 3:
                            message.price = reader.string();
                            break;
                        case 4:
                            message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgPostPrice message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPostPrice.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgPostPrice message.
                 * @function verify
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgPostPrice.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.from != null && message.hasOwnProperty("from"))
                        if (!$util.isString(message.from))
                            return "from: string expected";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        if (!$util.isString(message.market_id))
                            return "market_id: string expected";
                    if (message.price != null && message.hasOwnProperty("price"))
                        if (!$util.isString(message.price))
                            return "price: string expected";
                    if (message.expiry != null && message.hasOwnProperty("expiry")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiry);
                        if (error)
                            return "expiry." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgPostPrice message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
                 */
                MsgPostPrice.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.MsgPostPrice)
                        return object;
                    var message = new $root.ununifi.pricefeed.MsgPostPrice();
                    if (object.from != null)
                        message.from = String(object.from);
                    if (object.market_id != null)
                        message.market_id = String(object.market_id);
                    if (object.price != null)
                        message.price = String(object.price);
                    if (object.expiry != null) {
                        if (typeof object.expiry !== "object")
                            throw TypeError(".ununifi.pricefeed.MsgPostPrice.expiry: object expected");
                        message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgPostPrice message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @static
                 * @param {ununifi.pricefeed.MsgPostPrice} message MsgPostPrice
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgPostPrice.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.from = "";
                        object.market_id = "";
                        object.price = "";
                        object.expiry = null;
                    }
                    if (message.from != null && message.hasOwnProperty("from"))
                        object.from = message.from;
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        object.market_id = message.market_id;
                    if (message.price != null && message.hasOwnProperty("price"))
                        object.price = message.price;
                    if (message.expiry != null && message.hasOwnProperty("expiry"))
                        object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
                    return object;
                };
    
                /**
                 * Converts this MsgPostPrice to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.MsgPostPrice
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgPostPrice.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgPostPrice;
            })();
    
            pricefeed.MsgPostPriceResponse = (function() {
    
                /**
                 * Properties of a MsgPostPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @interface IMsgPostPriceResponse
                 */
    
                /**
                 * Constructs a new MsgPostPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a MsgPostPriceResponse.
                 * @implements IMsgPostPriceResponse
                 * @constructor
                 * @param {ununifi.pricefeed.IMsgPostPriceResponse=} [properties] Properties to set
                 */
                function MsgPostPriceResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgPostPriceResponse message. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPostPriceResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgPostPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPostPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgPostPriceResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPostPriceResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.MsgPostPriceResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgPostPriceResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPostPriceResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgPostPriceResponse message.
                 * @function verify
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgPostPriceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgPostPriceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
                 */
                MsgPostPriceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.MsgPostPriceResponse)
                        return object;
                    return new $root.ununifi.pricefeed.MsgPostPriceResponse();
                };
    
                /**
                 * Creates a plain object from a MsgPostPriceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.MsgPostPriceResponse} message MsgPostPriceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgPostPriceResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgPostPriceResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.MsgPostPriceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgPostPriceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgPostPriceResponse;
            })();
    
            pricefeed.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof ununifi.pricefeed
                 * @interface IGenesisState
                 * @property {ununifi.pricefeed.IParams|null} [params] GenesisState params
                 * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [posted_prices] GenesisState posted_prices
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {ununifi.pricefeed.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.posted_prices = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState params.
                 * @member {ununifi.pricefeed.IParams|null|undefined} params
                 * @memberof ununifi.pricefeed.GenesisState
                 * @instance
                 */
                GenesisState.prototype.params = null;
    
                /**
                 * GenesisState posted_prices.
                 * @member {Array.<ununifi.pricefeed.IPostedPrice>} posted_prices
                 * @memberof ununifi.pricefeed.GenesisState
                 * @instance
                 */
                GenesisState.prototype.posted_prices = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.GenesisState
                 * @static
                 * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.posted_prices != null && message.posted_prices.length)
                        for (var i = 0; i < message.posted_prices.length; ++i)
                            $root.ununifi.pricefeed.PostedPrice.encode(message.posted_prices[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.GenesisState
                 * @static
                 * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.posted_prices && message.posted_prices.length))
                                message.posted_prices = [];
                            message.posted_prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof ununifi.pricefeed.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.pricefeed.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.posted_prices != null && message.hasOwnProperty("posted_prices")) {
                        if (!Array.isArray(message.posted_prices))
                            return "posted_prices: array expected";
                        for (var i = 0; i < message.posted_prices.length; ++i) {
                            var error = $root.ununifi.pricefeed.PostedPrice.verify(message.posted_prices[i]);
                            if (error)
                                return "posted_prices." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.GenesisState)
                        return object;
                    var message = new $root.ununifi.pricefeed.GenesisState();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.pricefeed.GenesisState.params: object expected");
                        message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
                    }
                    if (object.posted_prices) {
                        if (!Array.isArray(object.posted_prices))
                            throw TypeError(".ununifi.pricefeed.GenesisState.posted_prices: array expected");
                        message.posted_prices = [];
                        for (var i = 0; i < object.posted_prices.length; ++i) {
                            if (typeof object.posted_prices[i] !== "object")
                                throw TypeError(".ununifi.pricefeed.GenesisState.posted_prices: object expected");
                            message.posted_prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.posted_prices[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.GenesisState
                 * @static
                 * @param {ununifi.pricefeed.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.posted_prices = [];
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
                    if (message.posted_prices && message.posted_prices.length) {
                        object.posted_prices = [];
                        for (var j = 0; j < message.posted_prices.length; ++j)
                            object.posted_prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.posted_prices[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            pricefeed.Market = (function() {
    
                /**
                 * Properties of a Market.
                 * @memberof ununifi.pricefeed
                 * @interface IMarket
                 * @property {string|null} [market_id] Market market_id
                 * @property {string|null} [base_asset] Market base_asset
                 * @property {string|null} [quote_asset] Market quote_asset
                 * @property {Array.<string>|null} [oracles] Market oracles
                 * @property {boolean|null} [active] Market active
                 */
    
                /**
                 * Constructs a new Market.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a Market.
                 * @implements IMarket
                 * @constructor
                 * @param {ununifi.pricefeed.IMarket=} [properties] Properties to set
                 */
                function Market(properties) {
                    this.oracles = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Market market_id.
                 * @member {string} market_id
                 * @memberof ununifi.pricefeed.Market
                 * @instance
                 */
                Market.prototype.market_id = "";
    
                /**
                 * Market base_asset.
                 * @member {string} base_asset
                 * @memberof ununifi.pricefeed.Market
                 * @instance
                 */
                Market.prototype.base_asset = "";
    
                /**
                 * Market quote_asset.
                 * @member {string} quote_asset
                 * @memberof ununifi.pricefeed.Market
                 * @instance
                 */
                Market.prototype.quote_asset = "";
    
                /**
                 * Market oracles.
                 * @member {Array.<string>} oracles
                 * @memberof ununifi.pricefeed.Market
                 * @instance
                 */
                Market.prototype.oracles = $util.emptyArray;
    
                /**
                 * Market active.
                 * @member {boolean} active
                 * @memberof ununifi.pricefeed.Market
                 * @instance
                 */
                Market.prototype.active = false;
    
                /**
                 * Encodes the specified Market message. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.Market
                 * @static
                 * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Market.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market_id != null && Object.hasOwnProperty.call(message, "market_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.market_id);
                    if (message.base_asset != null && Object.hasOwnProperty.call(message, "base_asset"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.base_asset);
                    if (message.quote_asset != null && Object.hasOwnProperty.call(message, "quote_asset"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.quote_asset);
                    if (message.oracles != null && message.oracles.length)
                        for (var i = 0; i < message.oracles.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.oracles[i]);
                    if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.active);
                    return writer;
                };
    
                /**
                 * Encodes the specified Market message, length delimited. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.Market
                 * @static
                 * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Market.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Market message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.Market
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.Market} Market
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Market.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.Market();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market_id = reader.string();
                            break;
                        case 2:
                            message.base_asset = reader.string();
                            break;
                        case 3:
                            message.quote_asset = reader.string();
                            break;
                        case 4:
                            if (!(message.oracles && message.oracles.length))
                                message.oracles = [];
                            message.oracles.push(reader.string());
                            break;
                        case 5:
                            message.active = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Market message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.Market
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.Market} Market
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Market.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Market message.
                 * @function verify
                 * @memberof ununifi.pricefeed.Market
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Market.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        if (!$util.isString(message.market_id))
                            return "market_id: string expected";
                    if (message.base_asset != null && message.hasOwnProperty("base_asset"))
                        if (!$util.isString(message.base_asset))
                            return "base_asset: string expected";
                    if (message.quote_asset != null && message.hasOwnProperty("quote_asset"))
                        if (!$util.isString(message.quote_asset))
                            return "quote_asset: string expected";
                    if (message.oracles != null && message.hasOwnProperty("oracles")) {
                        if (!Array.isArray(message.oracles))
                            return "oracles: array expected";
                        for (var i = 0; i < message.oracles.length; ++i)
                            if (!$util.isString(message.oracles[i]))
                                return "oracles: string[] expected";
                    }
                    if (message.active != null && message.hasOwnProperty("active"))
                        if (typeof message.active !== "boolean")
                            return "active: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a Market message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.Market
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.Market} Market
                 */
                Market.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.Market)
                        return object;
                    var message = new $root.ununifi.pricefeed.Market();
                    if (object.market_id != null)
                        message.market_id = String(object.market_id);
                    if (object.base_asset != null)
                        message.base_asset = String(object.base_asset);
                    if (object.quote_asset != null)
                        message.quote_asset = String(object.quote_asset);
                    if (object.oracles) {
                        if (!Array.isArray(object.oracles))
                            throw TypeError(".ununifi.pricefeed.Market.oracles: array expected");
                        message.oracles = [];
                        for (var i = 0; i < object.oracles.length; ++i)
                            message.oracles[i] = String(object.oracles[i]);
                    }
                    if (object.active != null)
                        message.active = Boolean(object.active);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Market message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.Market
                 * @static
                 * @param {ununifi.pricefeed.Market} message Market
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Market.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.oracles = [];
                    if (options.defaults) {
                        object.market_id = "";
                        object.base_asset = "";
                        object.quote_asset = "";
                        object.active = false;
                    }
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        object.market_id = message.market_id;
                    if (message.base_asset != null && message.hasOwnProperty("base_asset"))
                        object.base_asset = message.base_asset;
                    if (message.quote_asset != null && message.hasOwnProperty("quote_asset"))
                        object.quote_asset = message.quote_asset;
                    if (message.oracles && message.oracles.length) {
                        object.oracles = [];
                        for (var j = 0; j < message.oracles.length; ++j)
                            object.oracles[j] = message.oracles[j];
                    }
                    if (message.active != null && message.hasOwnProperty("active"))
                        object.active = message.active;
                    return object;
                };
    
                /**
                 * Converts this Market to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.Market
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Market.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Market;
            })();
    
            pricefeed.CurrentPrice = (function() {
    
                /**
                 * Properties of a CurrentPrice.
                 * @memberof ununifi.pricefeed
                 * @interface ICurrentPrice
                 * @property {string|null} [market_id] CurrentPrice market_id
                 * @property {string|null} [price] CurrentPrice price
                 */
    
                /**
                 * Constructs a new CurrentPrice.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a CurrentPrice.
                 * @implements ICurrentPrice
                 * @constructor
                 * @param {ununifi.pricefeed.ICurrentPrice=} [properties] Properties to set
                 */
                function CurrentPrice(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CurrentPrice market_id.
                 * @member {string} market_id
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @instance
                 */
                CurrentPrice.prototype.market_id = "";
    
                /**
                 * CurrentPrice price.
                 * @member {string} price
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @instance
                 */
                CurrentPrice.prototype.price = "";
    
                /**
                 * Encodes the specified CurrentPrice message. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @static
                 * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CurrentPrice.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market_id != null && Object.hasOwnProperty.call(message, "market_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.market_id);
                    if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.price);
                    return writer;
                };
    
                /**
                 * Encodes the specified CurrentPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @static
                 * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CurrentPrice.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CurrentPrice message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CurrentPrice.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.CurrentPrice();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market_id = reader.string();
                            break;
                        case 2:
                            message.price = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CurrentPrice message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CurrentPrice.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CurrentPrice message.
                 * @function verify
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CurrentPrice.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        if (!$util.isString(message.market_id))
                            return "market_id: string expected";
                    if (message.price != null && message.hasOwnProperty("price"))
                        if (!$util.isString(message.price))
                            return "price: string expected";
                    return null;
                };
    
                /**
                 * Creates a CurrentPrice message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
                 */
                CurrentPrice.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.CurrentPrice)
                        return object;
                    var message = new $root.ununifi.pricefeed.CurrentPrice();
                    if (object.market_id != null)
                        message.market_id = String(object.market_id);
                    if (object.price != null)
                        message.price = String(object.price);
                    return message;
                };
    
                /**
                 * Creates a plain object from a CurrentPrice message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @static
                 * @param {ununifi.pricefeed.CurrentPrice} message CurrentPrice
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CurrentPrice.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.market_id = "";
                        object.price = "";
                    }
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        object.market_id = message.market_id;
                    if (message.price != null && message.hasOwnProperty("price"))
                        object.price = message.price;
                    return object;
                };
    
                /**
                 * Converts this CurrentPrice to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.CurrentPrice
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CurrentPrice.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CurrentPrice;
            })();
    
            pricefeed.PostedPrice = (function() {
    
                /**
                 * Properties of a PostedPrice.
                 * @memberof ununifi.pricefeed
                 * @interface IPostedPrice
                 * @property {string|null} [market_id] PostedPrice market_id
                 * @property {string|null} [oracle_address] PostedPrice oracle_address
                 * @property {string|null} [price] PostedPrice price
                 * @property {google.protobuf.ITimestamp|null} [expiry] PostedPrice expiry
                 */
    
                /**
                 * Constructs a new PostedPrice.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a PostedPrice.
                 * @implements IPostedPrice
                 * @constructor
                 * @param {ununifi.pricefeed.IPostedPrice=} [properties] Properties to set
                 */
                function PostedPrice(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PostedPrice market_id.
                 * @member {string} market_id
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @instance
                 */
                PostedPrice.prototype.market_id = "";
    
                /**
                 * PostedPrice oracle_address.
                 * @member {string} oracle_address
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @instance
                 */
                PostedPrice.prototype.oracle_address = "";
    
                /**
                 * PostedPrice price.
                 * @member {string} price
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @instance
                 */
                PostedPrice.prototype.price = "";
    
                /**
                 * PostedPrice expiry.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiry
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @instance
                 */
                PostedPrice.prototype.expiry = null;
    
                /**
                 * Encodes the specified PostedPrice message. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @static
                 * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PostedPrice.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market_id != null && Object.hasOwnProperty.call(message, "market_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.market_id);
                    if (message.oracle_address != null && Object.hasOwnProperty.call(message, "oracle_address"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.oracle_address);
                    if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.price);
                    if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                        $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PostedPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @static
                 * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PostedPrice.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PostedPrice message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PostedPrice.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.PostedPrice();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market_id = reader.string();
                            break;
                        case 2:
                            message.oracle_address = reader.string();
                            break;
                        case 3:
                            message.price = reader.string();
                            break;
                        case 4:
                            message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PostedPrice message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PostedPrice.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PostedPrice message.
                 * @function verify
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PostedPrice.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        if (!$util.isString(message.market_id))
                            return "market_id: string expected";
                    if (message.oracle_address != null && message.hasOwnProperty("oracle_address"))
                        if (!$util.isString(message.oracle_address))
                            return "oracle_address: string expected";
                    if (message.price != null && message.hasOwnProperty("price"))
                        if (!$util.isString(message.price))
                            return "price: string expected";
                    if (message.expiry != null && message.hasOwnProperty("expiry")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiry);
                        if (error)
                            return "expiry." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a PostedPrice message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
                 */
                PostedPrice.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.PostedPrice)
                        return object;
                    var message = new $root.ununifi.pricefeed.PostedPrice();
                    if (object.market_id != null)
                        message.market_id = String(object.market_id);
                    if (object.oracle_address != null)
                        message.oracle_address = String(object.oracle_address);
                    if (object.price != null)
                        message.price = String(object.price);
                    if (object.expiry != null) {
                        if (typeof object.expiry !== "object")
                            throw TypeError(".ununifi.pricefeed.PostedPrice.expiry: object expected");
                        message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PostedPrice message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @static
                 * @param {ununifi.pricefeed.PostedPrice} message PostedPrice
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PostedPrice.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.market_id = "";
                        object.oracle_address = "";
                        object.price = "";
                        object.expiry = null;
                    }
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        object.market_id = message.market_id;
                    if (message.oracle_address != null && message.hasOwnProperty("oracle_address"))
                        object.oracle_address = message.oracle_address;
                    if (message.price != null && message.hasOwnProperty("price"))
                        object.price = message.price;
                    if (message.expiry != null && message.hasOwnProperty("expiry"))
                        object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
                    return object;
                };
    
                /**
                 * Converts this PostedPrice to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.PostedPrice
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PostedPrice.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PostedPrice;
            })();
    
            pricefeed.Params = (function() {
    
                /**
                 * Properties of a Params.
                 * @memberof ununifi.pricefeed
                 * @interface IParams
                 * @property {cosmos.base.v1beta1.ICoin|null} [deposit_for_posting] Params deposit_for_posting
                 * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] Params markets
                 */
    
                /**
                 * Constructs a new Params.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a Params.
                 * @implements IParams
                 * @constructor
                 * @param {ununifi.pricefeed.IParams=} [properties] Properties to set
                 */
                function Params(properties) {
                    this.markets = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Params deposit_for_posting.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit_for_posting
                 * @memberof ununifi.pricefeed.Params
                 * @instance
                 */
                Params.prototype.deposit_for_posting = null;
    
                /**
                 * Params markets.
                 * @member {Array.<ununifi.pricefeed.IMarket>} markets
                 * @memberof ununifi.pricefeed.Params
                 * @instance
                 */
                Params.prototype.markets = $util.emptyArray;
    
                /**
                 * Encodes the specified Params message. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.Params
                 * @static
                 * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deposit_for_posting != null && Object.hasOwnProperty.call(message, "deposit_for_posting"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.deposit_for_posting, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.markets != null && message.markets.length)
                        for (var i = 0; i < message.markets.length; ++i)
                            $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.Params
                 * @static
                 * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.Params();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deposit_for_posting = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.markets && message.markets.length))
                                message.markets = [];
                            message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Params message.
                 * @function verify
                 * @memberof ununifi.pricefeed.Params
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Params.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deposit_for_posting != null && message.hasOwnProperty("deposit_for_posting")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit_for_posting);
                        if (error)
                            return "deposit_for_posting." + error;
                    }
                    if (message.markets != null && message.hasOwnProperty("markets")) {
                        if (!Array.isArray(message.markets))
                            return "markets: array expected";
                        for (var i = 0; i < message.markets.length; ++i) {
                            var error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
                            if (error)
                                return "markets." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Params message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.Params
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.Params} Params
                 */
                Params.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.Params)
                        return object;
                    var message = new $root.ununifi.pricefeed.Params();
                    if (object.deposit_for_posting != null) {
                        if (typeof object.deposit_for_posting !== "object")
                            throw TypeError(".ununifi.pricefeed.Params.deposit_for_posting: object expected");
                        message.deposit_for_posting = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit_for_posting);
                    }
                    if (object.markets) {
                        if (!Array.isArray(object.markets))
                            throw TypeError(".ununifi.pricefeed.Params.markets: array expected");
                        message.markets = [];
                        for (var i = 0; i < object.markets.length; ++i) {
                            if (typeof object.markets[i] !== "object")
                                throw TypeError(".ununifi.pricefeed.Params.markets: object expected");
                            message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Params message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.Params
                 * @static
                 * @param {ununifi.pricefeed.Params} message Params
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Params.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.markets = [];
                    if (options.defaults)
                        object.deposit_for_posting = null;
                    if (message.deposit_for_posting != null && message.hasOwnProperty("deposit_for_posting"))
                        object.deposit_for_posting = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit_for_posting, options);
                    if (message.markets && message.markets.length) {
                        object.markets = [];
                        for (var j = 0; j < message.markets.length; ++j)
                            object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Params to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.Params
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Params.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Params;
            })();
    
            pricefeed.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link ununifi.pricefeed.Query#params}.
                 * @memberof ununifi.pricefeed.Query
                 * @typedef ParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.pricefeed.QueryParamsResponse} [response] QueryParamsResponse
                 */
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @param {ununifi.pricefeed.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.params = function params(request, callback) {
                    return this.rpcCall(params, $root.ununifi.pricefeed.QueryParamsRequest, $root.ununifi.pricefeed.QueryParamsResponse, request, callback);
                }, "name", { value: "Params" });
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @returns {Promise<ununifi.pricefeed.QueryParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.pricefeed.Query#marketAll}.
                 * @memberof ununifi.pricefeed.Query
                 * @typedef MarketAllCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.pricefeed.QueryAllMarketResponse} [response] QueryAllMarketResponse
                 */
    
                /**
                 * Calls MarketAll.
                 * @function marketAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
                 * @param {ununifi.pricefeed.Query.MarketAllCallback} callback Node-style callback called with the error, if any, and QueryAllMarketResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.marketAll = function marketAll(request, callback) {
                    return this.rpcCall(marketAll, $root.ununifi.pricefeed.QueryAllMarketRequest, $root.ununifi.pricefeed.QueryAllMarketResponse, request, callback);
                }, "name", { value: "MarketAll" });
    
                /**
                 * Calls MarketAll.
                 * @function marketAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
                 * @returns {Promise<ununifi.pricefeed.QueryAllMarketResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.pricefeed.Query#oracleAll}.
                 * @memberof ununifi.pricefeed.Query
                 * @typedef OracleAllCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.pricefeed.QueryAllOracleResponse} [response] QueryAllOracleResponse
                 */
    
                /**
                 * Calls OracleAll.
                 * @function oracleAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
                 * @param {ununifi.pricefeed.Query.OracleAllCallback} callback Node-style callback called with the error, if any, and QueryAllOracleResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.oracleAll = function oracleAll(request, callback) {
                    return this.rpcCall(oracleAll, $root.ununifi.pricefeed.QueryAllOracleRequest, $root.ununifi.pricefeed.QueryAllOracleResponse, request, callback);
                }, "name", { value: "OracleAll" });
    
                /**
                 * Calls OracleAll.
                 * @function oracleAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
                 * @returns {Promise<ununifi.pricefeed.QueryAllOracleResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.pricefeed.Query#price}.
                 * @memberof ununifi.pricefeed.Query
                 * @typedef PriceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.pricefeed.QueryGetPriceResponse} [response] QueryGetPriceResponse
                 */
    
                /**
                 * Calls Price.
                 * @function price
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
                 * @param {ununifi.pricefeed.Query.PriceCallback} callback Node-style callback called with the error, if any, and QueryGetPriceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.price = function price(request, callback) {
                    return this.rpcCall(price, $root.ununifi.pricefeed.QueryGetPriceRequest, $root.ununifi.pricefeed.QueryGetPriceResponse, request, callback);
                }, "name", { value: "Price" });
    
                /**
                 * Calls Price.
                 * @function price
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
                 * @returns {Promise<ununifi.pricefeed.QueryGetPriceResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.pricefeed.Query#priceAll}.
                 * @memberof ununifi.pricefeed.Query
                 * @typedef PriceAllCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.pricefeed.QueryAllPriceResponse} [response] QueryAllPriceResponse
                 */
    
                /**
                 * Calls PriceAll.
                 * @function priceAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
                 * @param {ununifi.pricefeed.Query.PriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllPriceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.priceAll = function priceAll(request, callback) {
                    return this.rpcCall(priceAll, $root.ununifi.pricefeed.QueryAllPriceRequest, $root.ununifi.pricefeed.QueryAllPriceResponse, request, callback);
                }, "name", { value: "PriceAll" });
    
                /**
                 * Calls PriceAll.
                 * @function priceAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
                 * @returns {Promise<ununifi.pricefeed.QueryAllPriceResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.pricefeed.Query#rawPriceAll}.
                 * @memberof ununifi.pricefeed.Query
                 * @typedef RawPriceAllCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.pricefeed.QueryAllRawPriceResponse} [response] QueryAllRawPriceResponse
                 */
    
                /**
                 * Calls RawPriceAll.
                 * @function rawPriceAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
                 * @param {ununifi.pricefeed.Query.RawPriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllRawPriceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.rawPriceAll = function rawPriceAll(request, callback) {
                    return this.rpcCall(rawPriceAll, $root.ununifi.pricefeed.QueryAllRawPriceRequest, $root.ununifi.pricefeed.QueryAllRawPriceResponse, request, callback);
                }, "name", { value: "RawPriceAll" });
    
                /**
                 * Calls RawPriceAll.
                 * @function rawPriceAll
                 * @memberof ununifi.pricefeed.Query
                 * @instance
                 * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
                 * @returns {Promise<ununifi.pricefeed.QueryAllRawPriceResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            pricefeed.QueryParamsRequest = (function() {
    
                /**
                 * Properties of a QueryParamsRequest.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryParamsRequest
                 */
    
                /**
                 * Constructs a new QueryParamsRequest.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryParamsRequest.
                 * @implements IQueryParamsRequest
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryParamsRequest=} [properties] Properties to set
                 */
                function QueryParamsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryParamsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsRequest message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
                 */
                QueryParamsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryParamsRequest)
                        return object;
                    return new $root.ununifi.pricefeed.QueryParamsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @static
                 * @param {ununifi.pricefeed.QueryParamsRequest} message QueryParamsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryParamsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryParamsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsRequest;
            })();
    
            pricefeed.QueryParamsResponse = (function() {
    
                /**
                 * Properties of a QueryParamsResponse.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryParamsResponse
                 * @property {ununifi.pricefeed.IParams|null} [params] QueryParamsResponse params
                 */
    
                /**
                 * Constructs a new QueryParamsResponse.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryParamsResponse.
                 * @implements IQueryParamsResponse
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryParamsResponse=} [properties] Properties to set
                 */
                function QueryParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryParamsResponse params.
                 * @member {ununifi.pricefeed.IParams|null|undefined} params
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @instance
                 */
                QueryParamsResponse.prototype.params = null;
    
                /**
                 * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsResponse message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.pricefeed.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
                 */
                QueryParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryParamsResponse)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryParamsResponse();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryParamsResponse.params: object expected");
                        message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @static
                 * @param {ununifi.pricefeed.QueryParamsResponse} message QueryParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this QueryParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsResponse;
            })();
    
            pricefeed.QueryAllMarketRequest = (function() {
    
                /**
                 * Properties of a QueryAllMarketRequest.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllMarketRequest
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllMarketRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllMarketRequest.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllMarketRequest.
                 * @implements IQueryAllMarketRequest
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllMarketRequest=} [properties] Properties to set
                 */
                function QueryAllMarketRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllMarketRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @instance
                 */
                QueryAllMarketRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllMarketRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllMarketRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllMarketRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllMarketRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllMarketRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllMarketRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllMarketRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllMarketRequest message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllMarketRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllMarketRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
                 */
                QueryAllMarketRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllMarketRequest)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllMarketRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllMarketRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @static
                 * @param {ununifi.pricefeed.QueryAllMarketRequest} message QueryAllMarketRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllMarketRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pagination = null;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllMarketRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllMarketRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllMarketRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllMarketRequest;
            })();
    
            pricefeed.QueryAllMarketResponse = (function() {
    
                /**
                 * Properties of a QueryAllMarketResponse.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllMarketResponse
                 * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] QueryAllMarketResponse markets
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllMarketResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllMarketResponse.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllMarketResponse.
                 * @implements IQueryAllMarketResponse
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllMarketResponse=} [properties] Properties to set
                 */
                function QueryAllMarketResponse(properties) {
                    this.markets = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllMarketResponse markets.
                 * @member {Array.<ununifi.pricefeed.IMarket>} markets
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @instance
                 */
                QueryAllMarketResponse.prototype.markets = $util.emptyArray;
    
                /**
                 * QueryAllMarketResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @instance
                 */
                QueryAllMarketResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllMarketResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllMarketResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.markets != null && message.markets.length)
                        for (var i = 0; i < message.markets.length; ++i)
                            $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllMarketResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllMarketResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllMarketResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.markets && message.markets.length))
                                message.markets = [];
                            message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllMarketResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllMarketResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllMarketResponse message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllMarketResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.markets != null && message.hasOwnProperty("markets")) {
                        if (!Array.isArray(message.markets))
                            return "markets: array expected";
                        for (var i = 0; i < message.markets.length; ++i) {
                            var error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
                            if (error)
                                return "markets." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllMarketResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
                 */
                QueryAllMarketResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllMarketResponse)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
                    if (object.markets) {
                        if (!Array.isArray(object.markets))
                            throw TypeError(".ununifi.pricefeed.QueryAllMarketResponse.markets: array expected");
                        message.markets = [];
                        for (var i = 0; i < object.markets.length; ++i) {
                            if (typeof object.markets[i] !== "object")
                                throw TypeError(".ununifi.pricefeed.QueryAllMarketResponse.markets: object expected");
                            message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllMarketResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllMarketResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @static
                 * @param {ununifi.pricefeed.QueryAllMarketResponse} message QueryAllMarketResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllMarketResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.markets = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.markets && message.markets.length) {
                        object.markets = [];
                        for (var j = 0; j < message.markets.length; ++j)
                            object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllMarketResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllMarketResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllMarketResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllMarketResponse;
            })();
    
            pricefeed.QueryAllOracleRequest = (function() {
    
                /**
                 * Properties of a QueryAllOracleRequest.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllOracleRequest
                 * @property {string|null} [market_id] QueryAllOracleRequest market_id
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllOracleRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllOracleRequest.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllOracleRequest.
                 * @implements IQueryAllOracleRequest
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllOracleRequest=} [properties] Properties to set
                 */
                function QueryAllOracleRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllOracleRequest market_id.
                 * @member {string} market_id
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @instance
                 */
                QueryAllOracleRequest.prototype.market_id = "";
    
                /**
                 * QueryAllOracleRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @instance
                 */
                QueryAllOracleRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllOracleRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllOracleRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market_id != null && Object.hasOwnProperty.call(message, "market_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.market_id);
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllOracleRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllOracleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllOracleRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllOracleRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market_id = reader.string();
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllOracleRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllOracleRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllOracleRequest message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllOracleRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        if (!$util.isString(message.market_id))
                            return "market_id: string expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllOracleRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
                 */
                QueryAllOracleRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllOracleRequest)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
                    if (object.market_id != null)
                        message.market_id = String(object.market_id);
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllOracleRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllOracleRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @static
                 * @param {ununifi.pricefeed.QueryAllOracleRequest} message QueryAllOracleRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllOracleRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.market_id = "";
                        object.pagination = null;
                    }
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        object.market_id = message.market_id;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllOracleRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllOracleRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllOracleRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllOracleRequest;
            })();
    
            pricefeed.QueryAllOracleResponse = (function() {
    
                /**
                 * Properties of a QueryAllOracleResponse.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllOracleResponse
                 * @property {Array.<string>|null} [oracles] QueryAllOracleResponse oracles
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllOracleResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllOracleResponse.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllOracleResponse.
                 * @implements IQueryAllOracleResponse
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllOracleResponse=} [properties] Properties to set
                 */
                function QueryAllOracleResponse(properties) {
                    this.oracles = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllOracleResponse oracles.
                 * @member {Array.<string>} oracles
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @instance
                 */
                QueryAllOracleResponse.prototype.oracles = $util.emptyArray;
    
                /**
                 * QueryAllOracleResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @instance
                 */
                QueryAllOracleResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllOracleResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllOracleResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.oracles != null && message.oracles.length)
                        for (var i = 0; i < message.oracles.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.oracles[i]);
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllOracleResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllOracleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllOracleResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllOracleResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.oracles && message.oracles.length))
                                message.oracles = [];
                            message.oracles.push(reader.string());
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllOracleResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllOracleResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllOracleResponse message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllOracleResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.oracles != null && message.hasOwnProperty("oracles")) {
                        if (!Array.isArray(message.oracles))
                            return "oracles: array expected";
                        for (var i = 0; i < message.oracles.length; ++i)
                            if (!$util.isString(message.oracles[i]))
                                return "oracles: string[] expected";
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllOracleResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
                 */
                QueryAllOracleResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllOracleResponse)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
                    if (object.oracles) {
                        if (!Array.isArray(object.oracles))
                            throw TypeError(".ununifi.pricefeed.QueryAllOracleResponse.oracles: array expected");
                        message.oracles = [];
                        for (var i = 0; i < object.oracles.length; ++i)
                            message.oracles[i] = String(object.oracles[i]);
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllOracleResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllOracleResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @static
                 * @param {ununifi.pricefeed.QueryAllOracleResponse} message QueryAllOracleResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllOracleResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.oracles = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.oracles && message.oracles.length) {
                        object.oracles = [];
                        for (var j = 0; j < message.oracles.length; ++j)
                            object.oracles[j] = message.oracles[j];
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllOracleResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllOracleResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllOracleResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllOracleResponse;
            })();
    
            pricefeed.QueryGetPriceRequest = (function() {
    
                /**
                 * Properties of a QueryGetPriceRequest.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryGetPriceRequest
                 * @property {string|null} [market_id] QueryGetPriceRequest market_id
                 */
    
                /**
                 * Constructs a new QueryGetPriceRequest.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryGetPriceRequest.
                 * @implements IQueryGetPriceRequest
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryGetPriceRequest=} [properties] Properties to set
                 */
                function QueryGetPriceRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetPriceRequest market_id.
                 * @member {string} market_id
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @instance
                 */
                QueryGetPriceRequest.prototype.market_id = "";
    
                /**
                 * Encodes the specified QueryGetPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetPriceRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market_id != null && Object.hasOwnProperty.call(message, "market_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.market_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetPriceRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetPriceRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetPriceRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetPriceRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetPriceRequest message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetPriceRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        if (!$util.isString(message.market_id))
                            return "market_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryGetPriceRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
                 */
                QueryGetPriceRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryGetPriceRequest)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
                    if (object.market_id != null)
                        message.market_id = String(object.market_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetPriceRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.QueryGetPriceRequest} message QueryGetPriceRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetPriceRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.market_id = "";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        object.market_id = message.market_id;
                    return object;
                };
    
                /**
                 * Converts this QueryGetPriceRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryGetPriceRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetPriceRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetPriceRequest;
            })();
    
            pricefeed.QueryGetPriceResponse = (function() {
    
                /**
                 * Properties of a QueryGetPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryGetPriceResponse
                 * @property {ununifi.pricefeed.ICurrentPrice|null} [price] QueryGetPriceResponse price
                 */
    
                /**
                 * Constructs a new QueryGetPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryGetPriceResponse.
                 * @implements IQueryGetPriceResponse
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryGetPriceResponse=} [properties] Properties to set
                 */
                function QueryGetPriceResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetPriceResponse price.
                 * @member {ununifi.pricefeed.ICurrentPrice|null|undefined} price
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @instance
                 */
                QueryGetPriceResponse.prototype.price = null;
    
                /**
                 * Encodes the specified QueryGetPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetPriceResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                        $root.ununifi.pricefeed.CurrentPrice.encode(message.price, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetPriceResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetPriceResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.price = $root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetPriceResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetPriceResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetPriceResponse message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetPriceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.price != null && message.hasOwnProperty("price")) {
                        var error = $root.ununifi.pricefeed.CurrentPrice.verify(message.price);
                        if (error)
                            return "price." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryGetPriceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
                 */
                QueryGetPriceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryGetPriceResponse)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
                    if (object.price != null) {
                        if (typeof object.price !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryGetPriceResponse.price: object expected");
                        message.price = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.price);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetPriceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.QueryGetPriceResponse} message QueryGetPriceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetPriceResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.price = null;
                    if (message.price != null && message.hasOwnProperty("price"))
                        object.price = $root.ununifi.pricefeed.CurrentPrice.toObject(message.price, options);
                    return object;
                };
    
                /**
                 * Converts this QueryGetPriceResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryGetPriceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetPriceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetPriceResponse;
            })();
    
            pricefeed.QueryAllPriceRequest = (function() {
    
                /**
                 * Properties of a QueryAllPriceRequest.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllPriceRequest
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllPriceRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllPriceRequest.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllPriceRequest.
                 * @implements IQueryAllPriceRequest
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllPriceRequest=} [properties] Properties to set
                 */
                function QueryAllPriceRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllPriceRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @instance
                 */
                QueryAllPriceRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPriceRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllPriceRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPriceRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllPriceRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPriceRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllPriceRequest message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllPriceRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllPriceRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
                 */
                QueryAllPriceRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllPriceRequest)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllPriceRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllPriceRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.QueryAllPriceRequest} message QueryAllPriceRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllPriceRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pagination = null;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllPriceRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllPriceRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllPriceRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllPriceRequest;
            })();
    
            pricefeed.QueryAllPriceResponse = (function() {
    
                /**
                 * Properties of a QueryAllPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllPriceResponse
                 * @property {Array.<ununifi.pricefeed.ICurrentPrice>|null} [prices] QueryAllPriceResponse prices
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllPriceResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllPriceResponse.
                 * @implements IQueryAllPriceResponse
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllPriceResponse=} [properties] Properties to set
                 */
                function QueryAllPriceResponse(properties) {
                    this.prices = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllPriceResponse prices.
                 * @member {Array.<ununifi.pricefeed.ICurrentPrice>} prices
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @instance
                 */
                QueryAllPriceResponse.prototype.prices = $util.emptyArray;
    
                /**
                 * QueryAllPriceResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @instance
                 */
                QueryAllPriceResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPriceResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.prices != null && message.prices.length)
                        for (var i = 0; i < message.prices.length; ++i)
                            $root.ununifi.pricefeed.CurrentPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllPriceResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPriceResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.prices && message.prices.length))
                                message.prices = [];
                            message.prices.push($root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllPriceResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllPriceResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllPriceResponse message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllPriceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.prices != null && message.hasOwnProperty("prices")) {
                        if (!Array.isArray(message.prices))
                            return "prices: array expected";
                        for (var i = 0; i < message.prices.length; ++i) {
                            var error = $root.ununifi.pricefeed.CurrentPrice.verify(message.prices[i]);
                            if (error)
                                return "prices." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllPriceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
                 */
                QueryAllPriceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllPriceResponse)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
                    if (object.prices) {
                        if (!Array.isArray(object.prices))
                            throw TypeError(".ununifi.pricefeed.QueryAllPriceResponse.prices: array expected");
                        message.prices = [];
                        for (var i = 0; i < object.prices.length; ++i) {
                            if (typeof object.prices[i] !== "object")
                                throw TypeError(".ununifi.pricefeed.QueryAllPriceResponse.prices: object expected");
                            message.prices[i] = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.prices[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllPriceResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllPriceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.QueryAllPriceResponse} message QueryAllPriceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllPriceResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.prices = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.prices && message.prices.length) {
                        object.prices = [];
                        for (var j = 0; j < message.prices.length; ++j)
                            object.prices[j] = $root.ununifi.pricefeed.CurrentPrice.toObject(message.prices[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllPriceResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllPriceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllPriceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllPriceResponse;
            })();
    
            pricefeed.QueryAllRawPriceRequest = (function() {
    
                /**
                 * Properties of a QueryAllRawPriceRequest.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllRawPriceRequest
                 * @property {string|null} [market_id] QueryAllRawPriceRequest market_id
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllRawPriceRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllRawPriceRequest.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllRawPriceRequest.
                 * @implements IQueryAllRawPriceRequest
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllRawPriceRequest=} [properties] Properties to set
                 */
                function QueryAllRawPriceRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllRawPriceRequest market_id.
                 * @member {string} market_id
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @instance
                 */
                QueryAllRawPriceRequest.prototype.market_id = "";
    
                /**
                 * QueryAllRawPriceRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @instance
                 */
                QueryAllRawPriceRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllRawPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRawPriceRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.market_id != null && Object.hasOwnProperty.call(message, "market_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.market_id);
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllRawPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRawPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRawPriceRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.market_id = reader.string();
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRawPriceRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllRawPriceRequest message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllRawPriceRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        if (!$util.isString(message.market_id))
                            return "market_id: string expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllRawPriceRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
                 */
                QueryAllRawPriceRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceRequest)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
                    if (object.market_id != null)
                        message.market_id = String(object.market_id);
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllRawPriceRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllRawPriceRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @static
                 * @param {ununifi.pricefeed.QueryAllRawPriceRequest} message QueryAllRawPriceRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllRawPriceRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.market_id = "";
                        object.pagination = null;
                    }
                    if (message.market_id != null && message.hasOwnProperty("market_id"))
                        object.market_id = message.market_id;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllRawPriceRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllRawPriceRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllRawPriceRequest;
            })();
    
            pricefeed.QueryAllRawPriceResponse = (function() {
    
                /**
                 * Properties of a QueryAllRawPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @interface IQueryAllRawPriceResponse
                 * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [prices] QueryAllRawPriceResponse prices
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllRawPriceResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllRawPriceResponse.
                 * @memberof ununifi.pricefeed
                 * @classdesc Represents a QueryAllRawPriceResponse.
                 * @implements IQueryAllRawPriceResponse
                 * @constructor
                 * @param {ununifi.pricefeed.IQueryAllRawPriceResponse=} [properties] Properties to set
                 */
                function QueryAllRawPriceResponse(properties) {
                    this.prices = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllRawPriceResponse prices.
                 * @member {Array.<ununifi.pricefeed.IPostedPrice>} prices
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @instance
                 */
                QueryAllRawPriceResponse.prototype.prices = $util.emptyArray;
    
                /**
                 * QueryAllRawPriceResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @instance
                 */
                QueryAllRawPriceResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllRawPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRawPriceResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.prices != null && message.prices.length)
                        for (var i = 0; i < message.prices.length; ++i)
                            $root.ununifi.pricefeed.PostedPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllRawPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllRawPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRawPriceResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.prices && message.prices.length))
                                message.prices = [];
                            message.prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllRawPriceResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllRawPriceResponse message.
                 * @function verify
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllRawPriceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.prices != null && message.hasOwnProperty("prices")) {
                        if (!Array.isArray(message.prices))
                            return "prices: array expected";
                        for (var i = 0; i < message.prices.length; ++i) {
                            var error = $root.ununifi.pricefeed.PostedPrice.verify(message.prices[i]);
                            if (error)
                                return "prices." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllRawPriceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
                 */
                QueryAllRawPriceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceResponse)
                        return object;
                    var message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
                    if (object.prices) {
                        if (!Array.isArray(object.prices))
                            throw TypeError(".ununifi.pricefeed.QueryAllRawPriceResponse.prices: array expected");
                        message.prices = [];
                        for (var i = 0; i < object.prices.length; ++i) {
                            if (typeof object.prices[i] !== "object")
                                throw TypeError(".ununifi.pricefeed.QueryAllRawPriceResponse.prices: object expected");
                            message.prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.prices[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.pricefeed.QueryAllRawPriceResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllRawPriceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @static
                 * @param {ununifi.pricefeed.QueryAllRawPriceResponse} message QueryAllRawPriceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllRawPriceResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.prices = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.prices && message.prices.length) {
                        object.prices = [];
                        for (var j = 0; j < message.prices.length; ++j)
                            object.prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.prices[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllRawPriceResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllRawPriceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllRawPriceResponse;
            })();
    
            return pricefeed;
        })();
    
        ununifi.yieldaggregator = (function() {
    
            /**
             * Namespace yieldaggregator.
             * @memberof ununifi
             * @namespace
             */
            var yieldaggregator = {};
    
            yieldaggregator.Msg = (function() {
    
                /**
                 * Constructs a new Msg service.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a Msg
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Msg(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Msg#depositToVault}.
                 * @memberof ununifi.yieldaggregator.Msg
                 * @typedef DepositToVaultCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.MsgDepositToVaultResponse} [response] MsgDepositToVaultResponse
                 */
    
                /**
                 * Calls DepositToVault.
                 * @function depositToVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgDepositToVault} request MsgDepositToVault message or plain object
                 * @param {ununifi.yieldaggregator.Msg.DepositToVaultCallback} callback Node-style callback called with the error, if any, and MsgDepositToVaultResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.depositToVault = function depositToVault(request, callback) {
                    return this.rpcCall(depositToVault, $root.ununifi.yieldaggregator.MsgDepositToVault, $root.ununifi.yieldaggregator.MsgDepositToVaultResponse, request, callback);
                }, "name", { value: "DepositToVault" });
    
                /**
                 * Calls DepositToVault.
                 * @function depositToVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgDepositToVault} request MsgDepositToVault message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.MsgDepositToVaultResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Msg#withdrawFromVault}.
                 * @memberof ununifi.yieldaggregator.Msg
                 * @typedef WithdrawFromVaultCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} [response] MsgWithdrawFromVaultResponse
                 */
    
                /**
                 * Calls WithdrawFromVault.
                 * @function withdrawFromVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} request MsgWithdrawFromVault message or plain object
                 * @param {ununifi.yieldaggregator.Msg.WithdrawFromVaultCallback} callback Node-style callback called with the error, if any, and MsgWithdrawFromVaultResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.withdrawFromVault = function withdrawFromVault(request, callback) {
                    return this.rpcCall(withdrawFromVault, $root.ununifi.yieldaggregator.MsgWithdrawFromVault, $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse, request, callback);
                }, "name", { value: "WithdrawFromVault" });
    
                /**
                 * Calls WithdrawFromVault.
                 * @function withdrawFromVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} request MsgWithdrawFromVault message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.MsgWithdrawFromVaultResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Msg#createVault}.
                 * @memberof ununifi.yieldaggregator.Msg
                 * @typedef CreateVaultCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.MsgCreateVaultResponse} [response] MsgCreateVaultResponse
                 */
    
                /**
                 * Calls CreateVault.
                 * @function createVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgCreateVault} request MsgCreateVault message or plain object
                 * @param {ununifi.yieldaggregator.Msg.CreateVaultCallback} callback Node-style callback called with the error, if any, and MsgCreateVaultResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.createVault = function createVault(request, callback) {
                    return this.rpcCall(createVault, $root.ununifi.yieldaggregator.MsgCreateVault, $root.ununifi.yieldaggregator.MsgCreateVaultResponse, request, callback);
                }, "name", { value: "CreateVault" });
    
                /**
                 * Calls CreateVault.
                 * @function createVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgCreateVault} request MsgCreateVault message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.MsgCreateVaultResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Msg#transferVaultOwnership}.
                 * @memberof ununifi.yieldaggregator.Msg
                 * @typedef TransferVaultOwnershipCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} [response] MsgTransferVaultOwnershipResponse
                 */
    
                /**
                 * Calls TransferVaultOwnership.
                 * @function transferVaultOwnership
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} request MsgTransferVaultOwnership message or plain object
                 * @param {ununifi.yieldaggregator.Msg.TransferVaultOwnershipCallback} callback Node-style callback called with the error, if any, and MsgTransferVaultOwnershipResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.transferVaultOwnership = function transferVaultOwnership(request, callback) {
                    return this.rpcCall(transferVaultOwnership, $root.ununifi.yieldaggregator.MsgTransferVaultOwnership, $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse, request, callback);
                }, "name", { value: "TransferVaultOwnership" });
    
                /**
                 * Calls TransferVaultOwnership.
                 * @function transferVaultOwnership
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} request MsgTransferVaultOwnership message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Msg#updateParams}.
                 * @memberof ununifi.yieldaggregator.Msg
                 * @typedef UpdateParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.MsgUpdateParamsResponse} [response] MsgUpdateParamsResponse
                 */
    
                /**
                 * Calls UpdateParams.
                 * @function updateParams
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgUpdateParams} request MsgUpdateParams message or plain object
                 * @param {ununifi.yieldaggregator.Msg.UpdateParamsCallback} callback Node-style callback called with the error, if any, and MsgUpdateParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.updateParams = function updateParams(request, callback) {
                    return this.rpcCall(updateParams, $root.ununifi.yieldaggregator.MsgUpdateParams, $root.ununifi.yieldaggregator.MsgUpdateParamsResponse, request, callback);
                }, "name", { value: "UpdateParams" });
    
                /**
                 * Calls UpdateParams.
                 * @function updateParams
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgUpdateParams} request MsgUpdateParams message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.MsgUpdateParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Msg#registerStrategy}.
                 * @memberof ununifi.yieldaggregator.Msg
                 * @typedef RegisterStrategyCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.MsgRegisterStrategyResponse} [response] MsgRegisterStrategyResponse
                 */
    
                /**
                 * Calls RegisterStrategy.
                 * @function registerStrategy
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} request MsgRegisterStrategy message or plain object
                 * @param {ununifi.yieldaggregator.Msg.RegisterStrategyCallback} callback Node-style callback called with the error, if any, and MsgRegisterStrategyResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.registerStrategy = function registerStrategy(request, callback) {
                    return this.rpcCall(registerStrategy, $root.ununifi.yieldaggregator.MsgRegisterStrategy, $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse, request, callback);
                }, "name", { value: "RegisterStrategy" });
    
                /**
                 * Calls RegisterStrategy.
                 * @function registerStrategy
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} request MsgRegisterStrategy message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.MsgRegisterStrategyResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Msg#deleteVault}.
                 * @memberof ununifi.yieldaggregator.Msg
                 * @typedef DeleteVaultCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.MsgDeleteVaultResponse} [response] MsgDeleteVaultResponse
                 */
    
                /**
                 * Calls DeleteVault.
                 * @function deleteVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgDeleteVault} request MsgDeleteVault message or plain object
                 * @param {ununifi.yieldaggregator.Msg.DeleteVaultCallback} callback Node-style callback called with the error, if any, and MsgDeleteVaultResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.deleteVault = function deleteVault(request, callback) {
                    return this.rpcCall(deleteVault, $root.ununifi.yieldaggregator.MsgDeleteVault, $root.ununifi.yieldaggregator.MsgDeleteVaultResponse, request, callback);
                }, "name", { value: "DeleteVault" });
    
                /**
                 * Calls DeleteVault.
                 * @function deleteVault
                 * @memberof ununifi.yieldaggregator.Msg
                 * @instance
                 * @param {ununifi.yieldaggregator.IMsgDeleteVault} request MsgDeleteVault message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.MsgDeleteVaultResponse>} Promise
                 * @variation 2
                 */
    
                return Msg;
            })();
    
            yieldaggregator.MsgDepositToVault = (function() {
    
                /**
                 * Properties of a MsgDepositToVault.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgDepositToVault
                 * @property {string|null} [sender] MsgDepositToVault sender
                 * @property {Long|null} [vault_id] MsgDepositToVault vault_id
                 * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgDepositToVault amount
                 */
    
                /**
                 * Constructs a new MsgDepositToVault.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgDepositToVault.
                 * @implements IMsgDepositToVault
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgDepositToVault=} [properties] Properties to set
                 */
                function MsgDepositToVault(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgDepositToVault sender.
                 * @member {string} sender
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @instance
                 */
                MsgDepositToVault.prototype.sender = "";
    
                /**
                 * MsgDepositToVault vault_id.
                 * @member {Long} vault_id
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @instance
                 */
                MsgDepositToVault.prototype.vault_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * MsgDepositToVault amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @instance
                 */
                MsgDepositToVault.prototype.amount = null;
    
                /**
                 * Encodes the specified MsgDepositToVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVault.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDepositToVault} message MsgDepositToVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToVault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.vault_id != null && Object.hasOwnProperty.call(message, "vault_id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.vault_id);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgDepositToVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDepositToVault} message MsgDepositToVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToVault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgDepositToVault message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgDepositToVault} MsgDepositToVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToVault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgDepositToVault();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.vault_id = reader.uint64();
                            break;
                        case 3:
                            message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgDepositToVault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgDepositToVault} MsgDepositToVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToVault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgDepositToVault message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgDepositToVault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (!$util.isInteger(message.vault_id) && !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high)))
                            return "vault_id: integer|Long expected";
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgDepositToVault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgDepositToVault} MsgDepositToVault
                 */
                MsgDepositToVault.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgDepositToVault)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgDepositToVault();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.vault_id != null)
                        if ($util.Long)
                            (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
                        else if (typeof object.vault_id === "string")
                            message.vault_id = parseInt(object.vault_id, 10);
                        else if (typeof object.vault_id === "number")
                            message.vault_id = object.vault_id;
                        else if (typeof object.vault_id === "object")
                            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ununifi.yieldaggregator.MsgDepositToVault.amount: object expected");
                        message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgDepositToVault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @static
                 * @param {ununifi.yieldaggregator.MsgDepositToVault} message MsgDepositToVault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgDepositToVault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.vault_id = options.longs === String ? "0" : 0;
                        object.amount = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (typeof message.vault_id === "number")
                            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
                        else
                            object.vault_id = options.longs === String ? $util.Long.prototype.toString.call(message.vault_id) : options.longs === Number ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true) : message.vault_id;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                    return object;
                };
    
                /**
                 * Converts this MsgDepositToVault to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgDepositToVault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgDepositToVault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgDepositToVault;
            })();
    
            yieldaggregator.MsgDepositToVaultResponse = (function() {
    
                /**
                 * Properties of a MsgDepositToVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgDepositToVaultResponse
                 */
    
                /**
                 * Constructs a new MsgDepositToVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgDepositToVaultResponse.
                 * @implements IMsgDepositToVaultResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgDepositToVaultResponse=} [properties] Properties to set
                 */
                function MsgDepositToVaultResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgDepositToVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVaultResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDepositToVaultResponse} message MsgDepositToVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToVaultResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgDepositToVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVaultResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDepositToVaultResponse} message MsgDepositToVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDepositToVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgDepositToVaultResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgDepositToVaultResponse} MsgDepositToVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToVaultResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgDepositToVaultResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgDepositToVaultResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgDepositToVaultResponse} MsgDepositToVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDepositToVaultResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgDepositToVaultResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgDepositToVaultResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgDepositToVaultResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgDepositToVaultResponse} MsgDepositToVaultResponse
                 */
                MsgDepositToVaultResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgDepositToVaultResponse)
                        return object;
                    return new $root.ununifi.yieldaggregator.MsgDepositToVaultResponse();
                };
    
                /**
                 * Creates a plain object from a MsgDepositToVaultResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.MsgDepositToVaultResponse} message MsgDepositToVaultResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgDepositToVaultResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgDepositToVaultResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgDepositToVaultResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgDepositToVaultResponse;
            })();
    
            yieldaggregator.MsgWithdrawFromVault = (function() {
    
                /**
                 * Properties of a MsgWithdrawFromVault.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgWithdrawFromVault
                 * @property {string|null} [sender] MsgWithdrawFromVault sender
                 * @property {Long|null} [vault_id] MsgWithdrawFromVault vault_id
                 * @property {string|null} [lp_token_amount] MsgWithdrawFromVault lp_token_amount
                 */
    
                /**
                 * Constructs a new MsgWithdrawFromVault.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgWithdrawFromVault.
                 * @implements IMsgWithdrawFromVault
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault=} [properties] Properties to set
                 */
                function MsgWithdrawFromVault(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgWithdrawFromVault sender.
                 * @member {string} sender
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @instance
                 */
                MsgWithdrawFromVault.prototype.sender = "";
    
                /**
                 * MsgWithdrawFromVault vault_id.
                 * @member {Long} vault_id
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @instance
                 */
                MsgWithdrawFromVault.prototype.vault_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * MsgWithdrawFromVault lp_token_amount.
                 * @member {string} lp_token_amount
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @instance
                 */
                MsgWithdrawFromVault.prototype.lp_token_amount = "";
    
                /**
                 * Encodes the specified MsgWithdrawFromVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVault.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} message MsgWithdrawFromVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromVault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.vault_id != null && Object.hasOwnProperty.call(message, "vault_id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.vault_id);
                    if (message.lp_token_amount != null && Object.hasOwnProperty.call(message, "lp_token_amount"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.lp_token_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawFromVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} message MsgWithdrawFromVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromVault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawFromVault message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgWithdrawFromVault} MsgWithdrawFromVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromVault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVault();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.vault_id = reader.uint64();
                            break;
                        case 3:
                            message.lp_token_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawFromVault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgWithdrawFromVault} MsgWithdrawFromVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromVault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawFromVault message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawFromVault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (!$util.isInteger(message.vault_id) && !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high)))
                            return "vault_id: integer|Long expected";
                    if (message.lp_token_amount != null && message.hasOwnProperty("lp_token_amount"))
                        if (!$util.isString(message.lp_token_amount))
                            return "lp_token_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawFromVault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgWithdrawFromVault} MsgWithdrawFromVault
                 */
                MsgWithdrawFromVault.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgWithdrawFromVault)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVault();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.vault_id != null)
                        if ($util.Long)
                            (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
                        else if (typeof object.vault_id === "string")
                            message.vault_id = parseInt(object.vault_id, 10);
                        else if (typeof object.vault_id === "number")
                            message.vault_id = object.vault_id;
                        else if (typeof object.vault_id === "object")
                            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
                    if (object.lp_token_amount != null)
                        message.lp_token_amount = String(object.lp_token_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawFromVault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @static
                 * @param {ununifi.yieldaggregator.MsgWithdrawFromVault} message MsgWithdrawFromVault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawFromVault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.vault_id = options.longs === String ? "0" : 0;
                        object.lp_token_amount = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (typeof message.vault_id === "number")
                            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
                        else
                            object.vault_id = options.longs === String ? $util.Long.prototype.toString.call(message.vault_id) : options.longs === Number ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true) : message.vault_id;
                    if (message.lp_token_amount != null && message.hasOwnProperty("lp_token_amount"))
                        object.lp_token_amount = message.lp_token_amount;
                    return object;
                };
    
                /**
                 * Converts this MsgWithdrawFromVault to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawFromVault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawFromVault;
            })();
    
            yieldaggregator.MsgWithdrawFromVaultResponse = (function() {
    
                /**
                 * Properties of a MsgWithdrawFromVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgWithdrawFromVaultResponse
                 */
    
                /**
                 * Constructs a new MsgWithdrawFromVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgWithdrawFromVaultResponse.
                 * @implements IMsgWithdrawFromVaultResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultResponse=} [properties] Properties to set
                 */
                function MsgWithdrawFromVaultResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgWithdrawFromVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultResponse} message MsgWithdrawFromVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromVaultResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgWithdrawFromVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultResponse} message MsgWithdrawFromVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWithdrawFromVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgWithdrawFromVaultResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} MsgWithdrawFromVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromVaultResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgWithdrawFromVaultResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} MsgWithdrawFromVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWithdrawFromVaultResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgWithdrawFromVaultResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWithdrawFromVaultResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgWithdrawFromVaultResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} MsgWithdrawFromVaultResponse
                 */
                MsgWithdrawFromVaultResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse)
                        return object;
                    return new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse();
                };
    
                /**
                 * Creates a plain object from a MsgWithdrawFromVaultResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} message MsgWithdrawFromVaultResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWithdrawFromVaultResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgWithdrawFromVaultResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWithdrawFromVaultResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgWithdrawFromVaultResponse;
            })();
    
            yieldaggregator.MsgCreateVault = (function() {
    
                /**
                 * Properties of a MsgCreateVault.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgCreateVault
                 * @property {string|null} [sender] MsgCreateVault sender
                 * @property {string|null} [denom] MsgCreateVault denom
                 * @property {string|null} [commission_rate] MsgCreateVault commission_rate
                 * @property {string|null} [withdraw_reserve_rate] MsgCreateVault withdraw_reserve_rate
                 * @property {Array.<ununifi.yieldaggregator.IStrategyWeight>|null} [strategy_weights] MsgCreateVault strategy_weights
                 * @property {cosmos.base.v1beta1.ICoin|null} [fee] MsgCreateVault fee
                 * @property {cosmos.base.v1beta1.ICoin|null} [deposit] MsgCreateVault deposit
                 */
    
                /**
                 * Constructs a new MsgCreateVault.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgCreateVault.
                 * @implements IMsgCreateVault
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgCreateVault=} [properties] Properties to set
                 */
                function MsgCreateVault(properties) {
                    this.strategy_weights = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgCreateVault sender.
                 * @member {string} sender
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 */
                MsgCreateVault.prototype.sender = "";
    
                /**
                 * MsgCreateVault denom.
                 * @member {string} denom
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 */
                MsgCreateVault.prototype.denom = "";
    
                /**
                 * MsgCreateVault commission_rate.
                 * @member {string} commission_rate
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 */
                MsgCreateVault.prototype.commission_rate = "";
    
                /**
                 * MsgCreateVault withdraw_reserve_rate.
                 * @member {string} withdraw_reserve_rate
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 */
                MsgCreateVault.prototype.withdraw_reserve_rate = "";
    
                /**
                 * MsgCreateVault strategy_weights.
                 * @member {Array.<ununifi.yieldaggregator.IStrategyWeight>} strategy_weights
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 */
                MsgCreateVault.prototype.strategy_weights = $util.emptyArray;
    
                /**
                 * MsgCreateVault fee.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 */
                MsgCreateVault.prototype.fee = null;
    
                /**
                 * MsgCreateVault deposit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 */
                MsgCreateVault.prototype.deposit = null;
    
                /**
                 * Encodes the specified MsgCreateVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVault.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgCreateVault} message MsgCreateVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateVault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
                    if (message.commission_rate != null && Object.hasOwnProperty.call(message, "commission_rate"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.commission_rate);
                    if (message.withdraw_reserve_rate != null && Object.hasOwnProperty.call(message, "withdraw_reserve_rate"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.withdraw_reserve_rate);
                    if (message.strategy_weights != null && message.strategy_weights.length)
                        for (var i = 0; i < message.strategy_weights.length; ++i)
                            $root.ununifi.yieldaggregator.StrategyWeight.encode(message.strategy_weights[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.deposit != null && Object.hasOwnProperty.call(message, "deposit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.deposit, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCreateVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgCreateVault} message MsgCreateVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateVault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCreateVault message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgCreateVault} MsgCreateVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateVault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgCreateVault();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.denom = reader.string();
                            break;
                        case 3:
                            message.commission_rate = reader.string();
                            break;
                        case 4:
                            message.withdraw_reserve_rate = reader.string();
                            break;
                        case 5:
                            if (!(message.strategy_weights && message.strategy_weights.length))
                                message.strategy_weights = [];
                            message.strategy_weights.push($root.ununifi.yieldaggregator.StrategyWeight.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCreateVault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgCreateVault} MsgCreateVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateVault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCreateVault message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCreateVault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.commission_rate != null && message.hasOwnProperty("commission_rate"))
                        if (!$util.isString(message.commission_rate))
                            return "commission_rate: string expected";
                    if (message.withdraw_reserve_rate != null && message.hasOwnProperty("withdraw_reserve_rate"))
                        if (!$util.isString(message.withdraw_reserve_rate))
                            return "withdraw_reserve_rate: string expected";
                    if (message.strategy_weights != null && message.hasOwnProperty("strategy_weights")) {
                        if (!Array.isArray(message.strategy_weights))
                            return "strategy_weights: array expected";
                        for (var i = 0; i < message.strategy_weights.length; ++i) {
                            var error = $root.ununifi.yieldaggregator.StrategyWeight.verify(message.strategy_weights[i]);
                            if (error)
                                return "strategy_weights." + error;
                        }
                    }
                    if (message.fee != null && message.hasOwnProperty("fee")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
                        if (error)
                            return "fee." + error;
                    }
                    if (message.deposit != null && message.hasOwnProperty("deposit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit);
                        if (error)
                            return "deposit." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgCreateVault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgCreateVault} MsgCreateVault
                 */
                MsgCreateVault.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgCreateVault)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgCreateVault();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.commission_rate != null)
                        message.commission_rate = String(object.commission_rate);
                    if (object.withdraw_reserve_rate != null)
                        message.withdraw_reserve_rate = String(object.withdraw_reserve_rate);
                    if (object.strategy_weights) {
                        if (!Array.isArray(object.strategy_weights))
                            throw TypeError(".ununifi.yieldaggregator.MsgCreateVault.strategy_weights: array expected");
                        message.strategy_weights = [];
                        for (var i = 0; i < object.strategy_weights.length; ++i) {
                            if (typeof object.strategy_weights[i] !== "object")
                                throw TypeError(".ununifi.yieldaggregator.MsgCreateVault.strategy_weights: object expected");
                            message.strategy_weights[i] = $root.ununifi.yieldaggregator.StrategyWeight.fromObject(object.strategy_weights[i]);
                        }
                    }
                    if (object.fee != null) {
                        if (typeof object.fee !== "object")
                            throw TypeError(".ununifi.yieldaggregator.MsgCreateVault.fee: object expected");
                        message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
                    }
                    if (object.deposit != null) {
                        if (typeof object.deposit !== "object")
                            throw TypeError(".ununifi.yieldaggregator.MsgCreateVault.deposit: object expected");
                        message.deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgCreateVault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @static
                 * @param {ununifi.yieldaggregator.MsgCreateVault} message MsgCreateVault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCreateVault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.strategy_weights = [];
                    if (options.defaults) {
                        object.sender = "";
                        object.denom = "";
                        object.commission_rate = "";
                        object.withdraw_reserve_rate = "";
                        object.fee = null;
                        object.deposit = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.commission_rate != null && message.hasOwnProperty("commission_rate"))
                        object.commission_rate = message.commission_rate;
                    if (message.withdraw_reserve_rate != null && message.hasOwnProperty("withdraw_reserve_rate"))
                        object.withdraw_reserve_rate = message.withdraw_reserve_rate;
                    if (message.strategy_weights && message.strategy_weights.length) {
                        object.strategy_weights = [];
                        for (var j = 0; j < message.strategy_weights.length; ++j)
                            object.strategy_weights[j] = $root.ununifi.yieldaggregator.StrategyWeight.toObject(message.strategy_weights[j], options);
                    }
                    if (message.fee != null && message.hasOwnProperty("fee"))
                        object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
                    if (message.deposit != null && message.hasOwnProperty("deposit"))
                        object.deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit, options);
                    return object;
                };
    
                /**
                 * Converts this MsgCreateVault to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgCreateVault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCreateVault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCreateVault;
            })();
    
            yieldaggregator.MsgCreateVaultResponse = (function() {
    
                /**
                 * Properties of a MsgCreateVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgCreateVaultResponse
                 * @property {Long|null} [id] MsgCreateVaultResponse id
                 */
    
                /**
                 * Constructs a new MsgCreateVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgCreateVaultResponse.
                 * @implements IMsgCreateVaultResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgCreateVaultResponse=} [properties] Properties to set
                 */
                function MsgCreateVaultResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgCreateVaultResponse id.
                 * @member {Long} id
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @instance
                 */
                MsgCreateVaultResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified MsgCreateVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVaultResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgCreateVaultResponse} message MsgCreateVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateVaultResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgCreateVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVaultResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgCreateVaultResponse} message MsgCreateVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgCreateVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgCreateVaultResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgCreateVaultResponse} MsgCreateVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateVaultResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgCreateVaultResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgCreateVaultResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgCreateVaultResponse} MsgCreateVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgCreateVaultResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgCreateVaultResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgCreateVaultResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a MsgCreateVaultResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgCreateVaultResponse} MsgCreateVaultResponse
                 */
                MsgCreateVaultResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgCreateVaultResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgCreateVaultResponse();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgCreateVaultResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.MsgCreateVaultResponse} message MsgCreateVaultResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgCreateVaultResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };
    
                /**
                 * Converts this MsgCreateVaultResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgCreateVaultResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgCreateVaultResponse;
            })();
    
            yieldaggregator.MsgTransferVaultOwnership = (function() {
    
                /**
                 * Properties of a MsgTransferVaultOwnership.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgTransferVaultOwnership
                 * @property {string|null} [sender] MsgTransferVaultOwnership sender
                 * @property {Long|null} [vault_id] MsgTransferVaultOwnership vault_id
                 * @property {string|null} [recipient] MsgTransferVaultOwnership recipient
                 */
    
                /**
                 * Constructs a new MsgTransferVaultOwnership.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgTransferVaultOwnership.
                 * @implements IMsgTransferVaultOwnership
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership=} [properties] Properties to set
                 */
                function MsgTransferVaultOwnership(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgTransferVaultOwnership sender.
                 * @member {string} sender
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @instance
                 */
                MsgTransferVaultOwnership.prototype.sender = "";
    
                /**
                 * MsgTransferVaultOwnership vault_id.
                 * @member {Long} vault_id
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @instance
                 */
                MsgTransferVaultOwnership.prototype.vault_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * MsgTransferVaultOwnership recipient.
                 * @member {string} recipient
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @instance
                 */
                MsgTransferVaultOwnership.prototype.recipient = "";
    
                /**
                 * Encodes the specified MsgTransferVaultOwnership message. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnership.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} message MsgTransferVaultOwnership message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTransferVaultOwnership.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.vault_id != null && Object.hasOwnProperty.call(message, "vault_id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.vault_id);
                    if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipient);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgTransferVaultOwnership message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnership.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} message MsgTransferVaultOwnership message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTransferVaultOwnership.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgTransferVaultOwnership message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnership} MsgTransferVaultOwnership
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTransferVaultOwnership.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgTransferVaultOwnership();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.vault_id = reader.uint64();
                            break;
                        case 3:
                            message.recipient = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgTransferVaultOwnership message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnership} MsgTransferVaultOwnership
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTransferVaultOwnership.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgTransferVaultOwnership message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgTransferVaultOwnership.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (!$util.isInteger(message.vault_id) && !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high)))
                            return "vault_id: integer|Long expected";
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        if (!$util.isString(message.recipient))
                            return "recipient: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgTransferVaultOwnership message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnership} MsgTransferVaultOwnership
                 */
                MsgTransferVaultOwnership.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgTransferVaultOwnership)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgTransferVaultOwnership();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.vault_id != null)
                        if ($util.Long)
                            (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
                        else if (typeof object.vault_id === "string")
                            message.vault_id = parseInt(object.vault_id, 10);
                        else if (typeof object.vault_id === "number")
                            message.vault_id = object.vault_id;
                        else if (typeof object.vault_id === "object")
                            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
                    if (object.recipient != null)
                        message.recipient = String(object.recipient);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgTransferVaultOwnership message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @static
                 * @param {ununifi.yieldaggregator.MsgTransferVaultOwnership} message MsgTransferVaultOwnership
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgTransferVaultOwnership.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.vault_id = options.longs === String ? "0" : 0;
                        object.recipient = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (typeof message.vault_id === "number")
                            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
                        else
                            object.vault_id = options.longs === String ? $util.Long.prototype.toString.call(message.vault_id) : options.longs === Number ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true) : message.vault_id;
                    if (message.recipient != null && message.hasOwnProperty("recipient"))
                        object.recipient = message.recipient;
                    return object;
                };
    
                /**
                 * Converts this MsgTransferVaultOwnership to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgTransferVaultOwnership.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgTransferVaultOwnership;
            })();
    
            yieldaggregator.MsgTransferVaultOwnershipResponse = (function() {
    
                /**
                 * Properties of a MsgTransferVaultOwnershipResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgTransferVaultOwnershipResponse
                 */
    
                /**
                 * Constructs a new MsgTransferVaultOwnershipResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgTransferVaultOwnershipResponse.
                 * @implements IMsgTransferVaultOwnershipResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnershipResponse=} [properties] Properties to set
                 */
                function MsgTransferVaultOwnershipResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgTransferVaultOwnershipResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnershipResponse} message MsgTransferVaultOwnershipResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTransferVaultOwnershipResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgTransferVaultOwnershipResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnershipResponse} message MsgTransferVaultOwnershipResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTransferVaultOwnershipResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgTransferVaultOwnershipResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} MsgTransferVaultOwnershipResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTransferVaultOwnershipResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgTransferVaultOwnershipResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} MsgTransferVaultOwnershipResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTransferVaultOwnershipResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgTransferVaultOwnershipResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgTransferVaultOwnershipResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgTransferVaultOwnershipResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} MsgTransferVaultOwnershipResponse
                 */
                MsgTransferVaultOwnershipResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse)
                        return object;
                    return new $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse();
                };
    
                /**
                 * Creates a plain object from a MsgTransferVaultOwnershipResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @static
                 * @param {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} message MsgTransferVaultOwnershipResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgTransferVaultOwnershipResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgTransferVaultOwnershipResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgTransferVaultOwnershipResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgTransferVaultOwnershipResponse;
            })();
    
            yieldaggregator.MsgUpdateParams = (function() {
    
                /**
                 * Properties of a MsgUpdateParams.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgUpdateParams
                 * @property {string|null} [sender] MsgUpdateParams sender
                 * @property {ununifi.yieldaggregator.IParams|null} [params] MsgUpdateParams params
                 */
    
                /**
                 * Constructs a new MsgUpdateParams.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgUpdateParams.
                 * @implements IMsgUpdateParams
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgUpdateParams=} [properties] Properties to set
                 */
                function MsgUpdateParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgUpdateParams sender.
                 * @member {string} sender
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @instance
                 */
                MsgUpdateParams.prototype.sender = "";
    
                /**
                 * MsgUpdateParams params.
                 * @member {ununifi.yieldaggregator.IParams|null|undefined} params
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @instance
                 */
                MsgUpdateParams.prototype.params = null;
    
                /**
                 * Encodes the specified MsgUpdateParams message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParams.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.yieldaggregator.Params.encode(message.params, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUpdateParams message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUpdateParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgUpdateParams} MsgUpdateParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgUpdateParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.params = $root.ununifi.yieldaggregator.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUpdateParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgUpdateParams} MsgUpdateParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUpdateParams message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUpdateParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.yieldaggregator.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgUpdateParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgUpdateParams} MsgUpdateParams
                 */
                MsgUpdateParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateParams)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgUpdateParams();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.yieldaggregator.MsgUpdateParams.params: object expected");
                        message.params = $root.ununifi.yieldaggregator.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgUpdateParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @static
                 * @param {ununifi.yieldaggregator.MsgUpdateParams} message MsgUpdateParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUpdateParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.params = null;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.yieldaggregator.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this MsgUpdateParams to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgUpdateParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUpdateParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUpdateParams;
            })();
    
            yieldaggregator.MsgUpdateParamsResponse = (function() {
    
                /**
                 * Properties of a MsgUpdateParamsResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgUpdateParamsResponse
                 */
    
                /**
                 * Constructs a new MsgUpdateParamsResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgUpdateParamsResponse.
                 * @implements IMsgUpdateParamsResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgUpdateParamsResponse=} [properties] Properties to set
                 */
                function MsgUpdateParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgUpdateParamsResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUpdateParamsResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUpdateParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgUpdateParamsResponse} MsgUpdateParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgUpdateParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgUpdateParamsResponse} MsgUpdateParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUpdateParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUpdateParamsResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUpdateParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgUpdateParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgUpdateParamsResponse} MsgUpdateParamsResponse
                 */
                MsgUpdateParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateParamsResponse)
                        return object;
                    return new $root.ununifi.yieldaggregator.MsgUpdateParamsResponse();
                };
    
                /**
                 * Creates a plain object from a MsgUpdateParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @static
                 * @param {ununifi.yieldaggregator.MsgUpdateParamsResponse} message MsgUpdateParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUpdateParamsResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgUpdateParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUpdateParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUpdateParamsResponse;
            })();
    
            yieldaggregator.MsgRegisterStrategy = (function() {
    
                /**
                 * Properties of a MsgRegisterStrategy.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgRegisterStrategy
                 * @property {string|null} [sender] MsgRegisterStrategy sender
                 * @property {string|null} [denom] MsgRegisterStrategy denom
                 * @property {string|null} [contract_address] MsgRegisterStrategy contract_address
                 * @property {string|null} [name] MsgRegisterStrategy name
                 * @property {string|null} [git_url] MsgRegisterStrategy git_url
                 */
    
                /**
                 * Constructs a new MsgRegisterStrategy.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgRegisterStrategy.
                 * @implements IMsgRegisterStrategy
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategy=} [properties] Properties to set
                 */
                function MsgRegisterStrategy(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgRegisterStrategy sender.
                 * @member {string} sender
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @instance
                 */
                MsgRegisterStrategy.prototype.sender = "";
    
                /**
                 * MsgRegisterStrategy denom.
                 * @member {string} denom
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @instance
                 */
                MsgRegisterStrategy.prototype.denom = "";
    
                /**
                 * MsgRegisterStrategy contract_address.
                 * @member {string} contract_address
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @instance
                 */
                MsgRegisterStrategy.prototype.contract_address = "";
    
                /**
                 * MsgRegisterStrategy name.
                 * @member {string} name
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @instance
                 */
                MsgRegisterStrategy.prototype.name = "";
    
                /**
                 * MsgRegisterStrategy git_url.
                 * @member {string} git_url
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @instance
                 */
                MsgRegisterStrategy.prototype.git_url = "";
    
                /**
                 * Encodes the specified MsgRegisterStrategy message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategy.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} message MsgRegisterStrategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterStrategy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
                    if (message.contract_address != null && Object.hasOwnProperty.call(message, "contract_address"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.contract_address);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                    if (message.git_url != null && Object.hasOwnProperty.call(message, "git_url"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.git_url);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRegisterStrategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} message MsgRegisterStrategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterStrategy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRegisterStrategy message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgRegisterStrategy} MsgRegisterStrategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterStrategy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgRegisterStrategy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.denom = reader.string();
                            break;
                        case 3:
                            message.contract_address = reader.string();
                            break;
                        case 4:
                            message.name = reader.string();
                            break;
                        case 5:
                            message.git_url = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRegisterStrategy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgRegisterStrategy} MsgRegisterStrategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterStrategy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRegisterStrategy message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRegisterStrategy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        if (!$util.isString(message.contract_address))
                            return "contract_address: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        if (!$util.isString(message.git_url))
                            return "git_url: string expected";
                    return null;
                };
    
                /**
                 * Creates a MsgRegisterStrategy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgRegisterStrategy} MsgRegisterStrategy
                 */
                MsgRegisterStrategy.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterStrategy)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgRegisterStrategy();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.contract_address != null)
                        message.contract_address = String(object.contract_address);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.git_url != null)
                        message.git_url = String(object.git_url);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgRegisterStrategy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @static
                 * @param {ununifi.yieldaggregator.MsgRegisterStrategy} message MsgRegisterStrategy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRegisterStrategy.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.denom = "";
                        object.contract_address = "";
                        object.name = "";
                        object.git_url = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        object.contract_address = message.contract_address;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        object.git_url = message.git_url;
                    return object;
                };
    
                /**
                 * Converts this MsgRegisterStrategy to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRegisterStrategy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRegisterStrategy;
            })();
    
            yieldaggregator.MsgRegisterStrategyResponse = (function() {
    
                /**
                 * Properties of a MsgRegisterStrategyResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgRegisterStrategyResponse
                 */
    
                /**
                 * Constructs a new MsgRegisterStrategyResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgRegisterStrategyResponse.
                 * @implements IMsgRegisterStrategyResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategyResponse=} [properties] Properties to set
                 */
                function MsgRegisterStrategyResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgRegisterStrategyResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategyResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategyResponse} message MsgRegisterStrategyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterStrategyResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRegisterStrategyResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategyResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgRegisterStrategyResponse} message MsgRegisterStrategyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterStrategyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRegisterStrategyResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgRegisterStrategyResponse} MsgRegisterStrategyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterStrategyResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRegisterStrategyResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgRegisterStrategyResponse} MsgRegisterStrategyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterStrategyResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRegisterStrategyResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRegisterStrategyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgRegisterStrategyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgRegisterStrategyResponse} MsgRegisterStrategyResponse
                 */
                MsgRegisterStrategyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse)
                        return object;
                    return new $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse();
                };
    
                /**
                 * Creates a plain object from a MsgRegisterStrategyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.MsgRegisterStrategyResponse} message MsgRegisterStrategyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRegisterStrategyResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgRegisterStrategyResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRegisterStrategyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRegisterStrategyResponse;
            })();
    
            yieldaggregator.MsgDeleteVault = (function() {
    
                /**
                 * Properties of a MsgDeleteVault.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgDeleteVault
                 * @property {string|null} [sender] MsgDeleteVault sender
                 * @property {Long|null} [vault_id] MsgDeleteVault vault_id
                 */
    
                /**
                 * Constructs a new MsgDeleteVault.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgDeleteVault.
                 * @implements IMsgDeleteVault
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgDeleteVault=} [properties] Properties to set
                 */
                function MsgDeleteVault(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgDeleteVault sender.
                 * @member {string} sender
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @instance
                 */
                MsgDeleteVault.prototype.sender = "";
    
                /**
                 * MsgDeleteVault vault_id.
                 * @member {Long} vault_id
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @instance
                 */
                MsgDeleteVault.prototype.vault_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified MsgDeleteVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVault.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDeleteVault} message MsgDeleteVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDeleteVault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.vault_id != null && Object.hasOwnProperty.call(message, "vault_id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.vault_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgDeleteVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDeleteVault} message MsgDeleteVault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDeleteVault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgDeleteVault message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgDeleteVault} MsgDeleteVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDeleteVault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgDeleteVault();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.vault_id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgDeleteVault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgDeleteVault} MsgDeleteVault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDeleteVault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgDeleteVault message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgDeleteVault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (!$util.isInteger(message.vault_id) && !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high)))
                            return "vault_id: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a MsgDeleteVault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgDeleteVault} MsgDeleteVault
                 */
                MsgDeleteVault.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgDeleteVault)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.MsgDeleteVault();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.vault_id != null)
                        if ($util.Long)
                            (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
                        else if (typeof object.vault_id === "string")
                            message.vault_id = parseInt(object.vault_id, 10);
                        else if (typeof object.vault_id === "number")
                            message.vault_id = object.vault_id;
                        else if (typeof object.vault_id === "object")
                            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgDeleteVault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @static
                 * @param {ununifi.yieldaggregator.MsgDeleteVault} message MsgDeleteVault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgDeleteVault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.vault_id = options.longs === String ? "0" : 0;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.vault_id != null && message.hasOwnProperty("vault_id"))
                        if (typeof message.vault_id === "number")
                            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
                        else
                            object.vault_id = options.longs === String ? $util.Long.prototype.toString.call(message.vault_id) : options.longs === Number ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true) : message.vault_id;
                    return object;
                };
    
                /**
                 * Converts this MsgDeleteVault to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgDeleteVault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgDeleteVault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgDeleteVault;
            })();
    
            yieldaggregator.MsgDeleteVaultResponse = (function() {
    
                /**
                 * Properties of a MsgDeleteVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IMsgDeleteVaultResponse
                 */
    
                /**
                 * Constructs a new MsgDeleteVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a MsgDeleteVaultResponse.
                 * @implements IMsgDeleteVaultResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IMsgDeleteVaultResponse=} [properties] Properties to set
                 */
                function MsgDeleteVaultResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgDeleteVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVaultResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDeleteVaultResponse} message MsgDeleteVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDeleteVaultResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgDeleteVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVaultResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IMsgDeleteVaultResponse} message MsgDeleteVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgDeleteVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgDeleteVaultResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.MsgDeleteVaultResponse} MsgDeleteVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDeleteVaultResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.MsgDeleteVaultResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgDeleteVaultResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.MsgDeleteVaultResponse} MsgDeleteVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgDeleteVaultResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgDeleteVaultResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgDeleteVaultResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgDeleteVaultResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.MsgDeleteVaultResponse} MsgDeleteVaultResponse
                 */
                MsgDeleteVaultResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.MsgDeleteVaultResponse)
                        return object;
                    return new $root.ununifi.yieldaggregator.MsgDeleteVaultResponse();
                };
    
                /**
                 * Creates a plain object from a MsgDeleteVaultResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.MsgDeleteVaultResponse} message MsgDeleteVaultResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgDeleteVaultResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgDeleteVaultResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgDeleteVaultResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgDeleteVaultResponse;
            })();
    
            yieldaggregator.StrategyWeight = (function() {
    
                /**
                 * Properties of a StrategyWeight.
                 * @memberof ununifi.yieldaggregator
                 * @interface IStrategyWeight
                 * @property {Long|null} [strategy_id] StrategyWeight strategy_id
                 * @property {string|null} [weight] StrategyWeight weight
                 */
    
                /**
                 * Constructs a new StrategyWeight.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a StrategyWeight.
                 * @implements IStrategyWeight
                 * @constructor
                 * @param {ununifi.yieldaggregator.IStrategyWeight=} [properties] Properties to set
                 */
                function StrategyWeight(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StrategyWeight strategy_id.
                 * @member {Long} strategy_id
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @instance
                 */
                StrategyWeight.prototype.strategy_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * StrategyWeight weight.
                 * @member {string} weight
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @instance
                 */
                StrategyWeight.prototype.weight = "";
    
                /**
                 * Encodes the specified StrategyWeight message. Does not implicitly {@link ununifi.yieldaggregator.StrategyWeight.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @static
                 * @param {ununifi.yieldaggregator.IStrategyWeight} message StrategyWeight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StrategyWeight.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.strategy_id != null && Object.hasOwnProperty.call(message, "strategy_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.strategy_id);
                    if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.weight);
                    return writer;
                };
    
                /**
                 * Encodes the specified StrategyWeight message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.StrategyWeight.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @static
                 * @param {ununifi.yieldaggregator.IStrategyWeight} message StrategyWeight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StrategyWeight.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a StrategyWeight message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.StrategyWeight} StrategyWeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StrategyWeight.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.StrategyWeight();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.strategy_id = reader.uint64();
                            break;
                        case 2:
                            message.weight = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a StrategyWeight message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.StrategyWeight} StrategyWeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StrategyWeight.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a StrategyWeight message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StrategyWeight.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.strategy_id != null && message.hasOwnProperty("strategy_id"))
                        if (!$util.isInteger(message.strategy_id) && !(message.strategy_id && $util.isInteger(message.strategy_id.low) && $util.isInteger(message.strategy_id.high)))
                            return "strategy_id: integer|Long expected";
                    if (message.weight != null && message.hasOwnProperty("weight"))
                        if (!$util.isString(message.weight))
                            return "weight: string expected";
                    return null;
                };
    
                /**
                 * Creates a StrategyWeight message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.StrategyWeight} StrategyWeight
                 */
                StrategyWeight.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.StrategyWeight)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.StrategyWeight();
                    if (object.strategy_id != null)
                        if ($util.Long)
                            (message.strategy_id = $util.Long.fromValue(object.strategy_id)).unsigned = true;
                        else if (typeof object.strategy_id === "string")
                            message.strategy_id = parseInt(object.strategy_id, 10);
                        else if (typeof object.strategy_id === "number")
                            message.strategy_id = object.strategy_id;
                        else if (typeof object.strategy_id === "object")
                            message.strategy_id = new $util.LongBits(object.strategy_id.low >>> 0, object.strategy_id.high >>> 0).toNumber(true);
                    if (object.weight != null)
                        message.weight = String(object.weight);
                    return message;
                };
    
                /**
                 * Creates a plain object from a StrategyWeight message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @static
                 * @param {ununifi.yieldaggregator.StrategyWeight} message StrategyWeight
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StrategyWeight.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.strategy_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.strategy_id = options.longs === String ? "0" : 0;
                        object.weight = "";
                    }
                    if (message.strategy_id != null && message.hasOwnProperty("strategy_id"))
                        if (typeof message.strategy_id === "number")
                            object.strategy_id = options.longs === String ? String(message.strategy_id) : message.strategy_id;
                        else
                            object.strategy_id = options.longs === String ? $util.Long.prototype.toString.call(message.strategy_id) : options.longs === Number ? new $util.LongBits(message.strategy_id.low >>> 0, message.strategy_id.high >>> 0).toNumber(true) : message.strategy_id;
                    if (message.weight != null && message.hasOwnProperty("weight"))
                        object.weight = message.weight;
                    return object;
                };
    
                /**
                 * Converts this StrategyWeight to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.StrategyWeight
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StrategyWeight.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StrategyWeight;
            })();
    
            yieldaggregator.Vault = (function() {
    
                /**
                 * Properties of a Vault.
                 * @memberof ununifi.yieldaggregator
                 * @interface IVault
                 * @property {Long|null} [id] Vault id
                 * @property {string|null} [denom] Vault denom
                 * @property {string|null} [owner] Vault owner
                 * @property {cosmos.base.v1beta1.ICoin|null} [owner_deposit] Vault owner_deposit
                 * @property {string|null} [withdraw_commission_rate] Vault withdraw_commission_rate
                 * @property {string|null} [withdraw_reserve_rate] Vault withdraw_reserve_rate
                 * @property {Array.<ununifi.yieldaggregator.IStrategyWeight>|null} [strategy_weights] Vault strategy_weights
                 */
    
                /**
                 * Constructs a new Vault.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a Vault.
                 * @implements IVault
                 * @constructor
                 * @param {ununifi.yieldaggregator.IVault=} [properties] Properties to set
                 */
                function Vault(properties) {
                    this.strategy_weights = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Vault id.
                 * @member {Long} id
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 */
                Vault.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Vault denom.
                 * @member {string} denom
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 */
                Vault.prototype.denom = "";
    
                /**
                 * Vault owner.
                 * @member {string} owner
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 */
                Vault.prototype.owner = "";
    
                /**
                 * Vault owner_deposit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} owner_deposit
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 */
                Vault.prototype.owner_deposit = null;
    
                /**
                 * Vault withdraw_commission_rate.
                 * @member {string} withdraw_commission_rate
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 */
                Vault.prototype.withdraw_commission_rate = "";
    
                /**
                 * Vault withdraw_reserve_rate.
                 * @member {string} withdraw_reserve_rate
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 */
                Vault.prototype.withdraw_reserve_rate = "";
    
                /**
                 * Vault strategy_weights.
                 * @member {Array.<ununifi.yieldaggregator.IStrategyWeight>} strategy_weights
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 */
                Vault.prototype.strategy_weights = $util.emptyArray;
    
                /**
                 * Encodes the specified Vault message. Does not implicitly {@link ununifi.yieldaggregator.Vault.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.Vault
                 * @static
                 * @param {ununifi.yieldaggregator.IVault} message Vault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Vault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.owner);
                    if (message.owner_deposit != null && Object.hasOwnProperty.call(message, "owner_deposit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.owner_deposit, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.withdraw_commission_rate != null && Object.hasOwnProperty.call(message, "withdraw_commission_rate"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.withdraw_commission_rate);
                    if (message.withdraw_reserve_rate != null && Object.hasOwnProperty.call(message, "withdraw_reserve_rate"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.withdraw_reserve_rate);
                    if (message.strategy_weights != null && message.strategy_weights.length)
                        for (var i = 0; i < message.strategy_weights.length; ++i)
                            $root.ununifi.yieldaggregator.StrategyWeight.encode(message.strategy_weights[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Vault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.Vault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.Vault
                 * @static
                 * @param {ununifi.yieldaggregator.IVault} message Vault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Vault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Vault message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.Vault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.Vault} Vault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Vault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.Vault();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        case 2:
                            message.denom = reader.string();
                            break;
                        case 3:
                            message.owner = reader.string();
                            break;
                        case 4:
                            message.owner_deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.withdraw_commission_rate = reader.string();
                            break;
                        case 6:
                            message.withdraw_reserve_rate = reader.string();
                            break;
                        case 7:
                            if (!(message.strategy_weights && message.strategy_weights.length))
                                message.strategy_weights = [];
                            message.strategy_weights.push($root.ununifi.yieldaggregator.StrategyWeight.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Vault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.Vault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.Vault} Vault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Vault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Vault message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.Vault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Vault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.owner_deposit != null && message.hasOwnProperty("owner_deposit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.owner_deposit);
                        if (error)
                            return "owner_deposit." + error;
                    }
                    if (message.withdraw_commission_rate != null && message.hasOwnProperty("withdraw_commission_rate"))
                        if (!$util.isString(message.withdraw_commission_rate))
                            return "withdraw_commission_rate: string expected";
                    if (message.withdraw_reserve_rate != null && message.hasOwnProperty("withdraw_reserve_rate"))
                        if (!$util.isString(message.withdraw_reserve_rate))
                            return "withdraw_reserve_rate: string expected";
                    if (message.strategy_weights != null && message.hasOwnProperty("strategy_weights")) {
                        if (!Array.isArray(message.strategy_weights))
                            return "strategy_weights: array expected";
                        for (var i = 0; i < message.strategy_weights.length; ++i) {
                            var error = $root.ununifi.yieldaggregator.StrategyWeight.verify(message.strategy_weights[i]);
                            if (error)
                                return "strategy_weights." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Vault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.Vault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.Vault} Vault
                 */
                Vault.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.Vault)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.Vault();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.owner_deposit != null) {
                        if (typeof object.owner_deposit !== "object")
                            throw TypeError(".ununifi.yieldaggregator.Vault.owner_deposit: object expected");
                        message.owner_deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.owner_deposit);
                    }
                    if (object.withdraw_commission_rate != null)
                        message.withdraw_commission_rate = String(object.withdraw_commission_rate);
                    if (object.withdraw_reserve_rate != null)
                        message.withdraw_reserve_rate = String(object.withdraw_reserve_rate);
                    if (object.strategy_weights) {
                        if (!Array.isArray(object.strategy_weights))
                            throw TypeError(".ununifi.yieldaggregator.Vault.strategy_weights: array expected");
                        message.strategy_weights = [];
                        for (var i = 0; i < object.strategy_weights.length; ++i) {
                            if (typeof object.strategy_weights[i] !== "object")
                                throw TypeError(".ununifi.yieldaggregator.Vault.strategy_weights: object expected");
                            message.strategy_weights[i] = $root.ununifi.yieldaggregator.StrategyWeight.fromObject(object.strategy_weights[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Vault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.Vault
                 * @static
                 * @param {ununifi.yieldaggregator.Vault} message Vault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Vault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.strategy_weights = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                        object.denom = "";
                        object.owner = "";
                        object.owner_deposit = null;
                        object.withdraw_commission_rate = "";
                        object.withdraw_reserve_rate = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.owner_deposit != null && message.hasOwnProperty("owner_deposit"))
                        object.owner_deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.owner_deposit, options);
                    if (message.withdraw_commission_rate != null && message.hasOwnProperty("withdraw_commission_rate"))
                        object.withdraw_commission_rate = message.withdraw_commission_rate;
                    if (message.withdraw_reserve_rate != null && message.hasOwnProperty("withdraw_reserve_rate"))
                        object.withdraw_reserve_rate = message.withdraw_reserve_rate;
                    if (message.strategy_weights && message.strategy_weights.length) {
                        object.strategy_weights = [];
                        for (var j = 0; j < message.strategy_weights.length; ++j)
                            object.strategy_weights[j] = $root.ununifi.yieldaggregator.StrategyWeight.toObject(message.strategy_weights[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Vault to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.Vault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Vault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Vault;
            })();
    
            yieldaggregator.Strategy = (function() {
    
                /**
                 * Properties of a Strategy.
                 * @memberof ununifi.yieldaggregator
                 * @interface IStrategy
                 * @property {string|null} [denom] Strategy denom
                 * @property {Long|null} [id] Strategy id
                 * @property {string|null} [contract_address] Strategy contract_address
                 * @property {string|null} [name] Strategy name
                 * @property {string|null} [git_url] Strategy git_url
                 */
    
                /**
                 * Constructs a new Strategy.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a Strategy.
                 * @implements IStrategy
                 * @constructor
                 * @param {ununifi.yieldaggregator.IStrategy=} [properties] Properties to set
                 */
                function Strategy(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Strategy denom.
                 * @member {string} denom
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @instance
                 */
                Strategy.prototype.denom = "";
    
                /**
                 * Strategy id.
                 * @member {Long} id
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @instance
                 */
                Strategy.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Strategy contract_address.
                 * @member {string} contract_address
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @instance
                 */
                Strategy.prototype.contract_address = "";
    
                /**
                 * Strategy name.
                 * @member {string} name
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @instance
                 */
                Strategy.prototype.name = "";
    
                /**
                 * Strategy git_url.
                 * @member {string} git_url
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @instance
                 */
                Strategy.prototype.git_url = "";
    
                /**
                 * Encodes the specified Strategy message. Does not implicitly {@link ununifi.yieldaggregator.Strategy.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @static
                 * @param {ununifi.yieldaggregator.IStrategy} message Strategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Strategy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);
                    if (message.contract_address != null && Object.hasOwnProperty.call(message, "contract_address"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.contract_address);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                    if (message.git_url != null && Object.hasOwnProperty.call(message, "git_url"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.git_url);
                    return writer;
                };
    
                /**
                 * Encodes the specified Strategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.Strategy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @static
                 * @param {ununifi.yieldaggregator.IStrategy} message Strategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Strategy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Strategy message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.Strategy} Strategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Strategy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.Strategy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.denom = reader.string();
                            break;
                        case 2:
                            message.id = reader.uint64();
                            break;
                        case 3:
                            message.contract_address = reader.string();
                            break;
                        case 4:
                            message.name = reader.string();
                            break;
                        case 5:
                            message.git_url = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Strategy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.Strategy} Strategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Strategy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Strategy message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Strategy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        if (!$util.isString(message.contract_address))
                            return "contract_address: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        if (!$util.isString(message.git_url))
                            return "git_url: string expected";
                    return null;
                };
    
                /**
                 * Creates a Strategy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.Strategy} Strategy
                 */
                Strategy.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.Strategy)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.Strategy();
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    if (object.contract_address != null)
                        message.contract_address = String(object.contract_address);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.git_url != null)
                        message.git_url = String(object.git_url);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Strategy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @static
                 * @param {ununifi.yieldaggregator.Strategy} message Strategy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Strategy.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.denom = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                        object.contract_address = "";
                        object.name = "";
                        object.git_url = "";
                    }
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        object.contract_address = message.contract_address;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        object.git_url = message.git_url;
                    return object;
                };
    
                /**
                 * Converts this Strategy to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.Strategy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Strategy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Strategy;
            })();
    
            yieldaggregator.ProposalAddStrategy = (function() {
    
                /**
                 * Properties of a ProposalAddStrategy.
                 * @memberof ununifi.yieldaggregator
                 * @interface IProposalAddStrategy
                 * @property {string|null} [title] ProposalAddStrategy title
                 * @property {string|null} [description] ProposalAddStrategy description
                 * @property {string|null} [denom] ProposalAddStrategy denom
                 * @property {string|null} [contract_address] ProposalAddStrategy contract_address
                 * @property {string|null} [name] ProposalAddStrategy name
                 * @property {string|null} [git_url] ProposalAddStrategy git_url
                 */
    
                /**
                 * Constructs a new ProposalAddStrategy.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a ProposalAddStrategy.
                 * @implements IProposalAddStrategy
                 * @constructor
                 * @param {ununifi.yieldaggregator.IProposalAddStrategy=} [properties] Properties to set
                 */
                function ProposalAddStrategy(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProposalAddStrategy title.
                 * @member {string} title
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @instance
                 */
                ProposalAddStrategy.prototype.title = "";
    
                /**
                 * ProposalAddStrategy description.
                 * @member {string} description
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @instance
                 */
                ProposalAddStrategy.prototype.description = "";
    
                /**
                 * ProposalAddStrategy denom.
                 * @member {string} denom
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @instance
                 */
                ProposalAddStrategy.prototype.denom = "";
    
                /**
                 * ProposalAddStrategy contract_address.
                 * @member {string} contract_address
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @instance
                 */
                ProposalAddStrategy.prototype.contract_address = "";
    
                /**
                 * ProposalAddStrategy name.
                 * @member {string} name
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @instance
                 */
                ProposalAddStrategy.prototype.name = "";
    
                /**
                 * ProposalAddStrategy git_url.
                 * @member {string} git_url
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @instance
                 */
                ProposalAddStrategy.prototype.git_url = "";
    
                /**
                 * Encodes the specified ProposalAddStrategy message. Does not implicitly {@link ununifi.yieldaggregator.ProposalAddStrategy.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @static
                 * @param {ununifi.yieldaggregator.IProposalAddStrategy} message ProposalAddStrategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalAddStrategy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.denom);
                    if (message.contract_address != null && Object.hasOwnProperty.call(message, "contract_address"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.contract_address);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                    if (message.git_url != null && Object.hasOwnProperty.call(message, "git_url"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.git_url);
                    return writer;
                };
    
                /**
                 * Encodes the specified ProposalAddStrategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.ProposalAddStrategy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @static
                 * @param {ununifi.yieldaggregator.IProposalAddStrategy} message ProposalAddStrategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalAddStrategy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ProposalAddStrategy message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.ProposalAddStrategy} ProposalAddStrategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalAddStrategy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.ProposalAddStrategy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.title = reader.string();
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        case 3:
                            message.denom = reader.string();
                            break;
                        case 4:
                            message.contract_address = reader.string();
                            break;
                        case 5:
                            message.name = reader.string();
                            break;
                        case 6:
                            message.git_url = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ProposalAddStrategy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.ProposalAddStrategy} ProposalAddStrategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalAddStrategy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ProposalAddStrategy message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProposalAddStrategy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        if (!$util.isString(message.contract_address))
                            return "contract_address: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        if (!$util.isString(message.git_url))
                            return "git_url: string expected";
                    return null;
                };
    
                /**
                 * Creates a ProposalAddStrategy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.ProposalAddStrategy} ProposalAddStrategy
                 */
                ProposalAddStrategy.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.ProposalAddStrategy)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.ProposalAddStrategy();
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.contract_address != null)
                        message.contract_address = String(object.contract_address);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.git_url != null)
                        message.git_url = String(object.git_url);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ProposalAddStrategy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @static
                 * @param {ununifi.yieldaggregator.ProposalAddStrategy} message ProposalAddStrategy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProposalAddStrategy.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.title = "";
                        object.description = "";
                        object.denom = "";
                        object.contract_address = "";
                        object.name = "";
                        object.git_url = "";
                    }
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        object.contract_address = message.contract_address;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        object.git_url = message.git_url;
                    return object;
                };
    
                /**
                 * Converts this ProposalAddStrategy to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.ProposalAddStrategy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProposalAddStrategy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ProposalAddStrategy;
            })();
    
            yieldaggregator.Params = (function() {
    
                /**
                 * Properties of a Params.
                 * @memberof ununifi.yieldaggregator
                 * @interface IParams
                 * @property {string|null} [commission_rate] Params commission_rate
                 * @property {cosmos.base.v1beta1.ICoin|null} [vault_creation_fee] Params vault_creation_fee
                 * @property {cosmos.base.v1beta1.ICoin|null} [vault_creation_deposit] Params vault_creation_deposit
                 * @property {string|null} [fee_collector_address] Params fee_collector_address
                 */
    
                /**
                 * Constructs a new Params.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a Params.
                 * @implements IParams
                 * @constructor
                 * @param {ununifi.yieldaggregator.IParams=} [properties] Properties to set
                 */
                function Params(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Params commission_rate.
                 * @member {string} commission_rate
                 * @memberof ununifi.yieldaggregator.Params
                 * @instance
                 */
                Params.prototype.commission_rate = "";
    
                /**
                 * Params vault_creation_fee.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} vault_creation_fee
                 * @memberof ununifi.yieldaggregator.Params
                 * @instance
                 */
                Params.prototype.vault_creation_fee = null;
    
                /**
                 * Params vault_creation_deposit.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} vault_creation_deposit
                 * @memberof ununifi.yieldaggregator.Params
                 * @instance
                 */
                Params.prototype.vault_creation_deposit = null;
    
                /**
                 * Params fee_collector_address.
                 * @member {string} fee_collector_address
                 * @memberof ununifi.yieldaggregator.Params
                 * @instance
                 */
                Params.prototype.fee_collector_address = "";
    
                /**
                 * Encodes the specified Params message. Does not implicitly {@link ununifi.yieldaggregator.Params.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.Params
                 * @static
                 * @param {ununifi.yieldaggregator.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.commission_rate != null && Object.hasOwnProperty.call(message, "commission_rate"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commission_rate);
                    if (message.vault_creation_fee != null && Object.hasOwnProperty.call(message, "vault_creation_fee"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.vault_creation_fee, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.vault_creation_deposit != null && Object.hasOwnProperty.call(message, "vault_creation_deposit"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.vault_creation_deposit, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, "fee_collector_address"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.fee_collector_address);
                    return writer;
                };
    
                /**
                 * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.Params.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.Params
                 * @static
                 * @param {ununifi.yieldaggregator.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.Params();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.commission_rate = reader.string();
                            break;
                        case 2:
                            message.vault_creation_fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.vault_creation_deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.fee_collector_address = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Params message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.Params
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Params.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.commission_rate != null && message.hasOwnProperty("commission_rate"))
                        if (!$util.isString(message.commission_rate))
                            return "commission_rate: string expected";
                    if (message.vault_creation_fee != null && message.hasOwnProperty("vault_creation_fee")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.vault_creation_fee);
                        if (error)
                            return "vault_creation_fee." + error;
                    }
                    if (message.vault_creation_deposit != null && message.hasOwnProperty("vault_creation_deposit")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.vault_creation_deposit);
                        if (error)
                            return "vault_creation_deposit." + error;
                    }
                    if (message.fee_collector_address != null && message.hasOwnProperty("fee_collector_address"))
                        if (!$util.isString(message.fee_collector_address))
                            return "fee_collector_address: string expected";
                    return null;
                };
    
                /**
                 * Creates a Params message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.Params
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.Params} Params
                 */
                Params.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.Params)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.Params();
                    if (object.commission_rate != null)
                        message.commission_rate = String(object.commission_rate);
                    if (object.vault_creation_fee != null) {
                        if (typeof object.vault_creation_fee !== "object")
                            throw TypeError(".ununifi.yieldaggregator.Params.vault_creation_fee: object expected");
                        message.vault_creation_fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.vault_creation_fee);
                    }
                    if (object.vault_creation_deposit != null) {
                        if (typeof object.vault_creation_deposit !== "object")
                            throw TypeError(".ununifi.yieldaggregator.Params.vault_creation_deposit: object expected");
                        message.vault_creation_deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.vault_creation_deposit);
                    }
                    if (object.fee_collector_address != null)
                        message.fee_collector_address = String(object.fee_collector_address);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Params message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.Params
                 * @static
                 * @param {ununifi.yieldaggregator.Params} message Params
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Params.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.commission_rate = "";
                        object.vault_creation_fee = null;
                        object.vault_creation_deposit = null;
                        object.fee_collector_address = "";
                    }
                    if (message.commission_rate != null && message.hasOwnProperty("commission_rate"))
                        object.commission_rate = message.commission_rate;
                    if (message.vault_creation_fee != null && message.hasOwnProperty("vault_creation_fee"))
                        object.vault_creation_fee = $root.cosmos.base.v1beta1.Coin.toObject(message.vault_creation_fee, options);
                    if (message.vault_creation_deposit != null && message.hasOwnProperty("vault_creation_deposit"))
                        object.vault_creation_deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.vault_creation_deposit, options);
                    if (message.fee_collector_address != null && message.hasOwnProperty("fee_collector_address"))
                        object.fee_collector_address = message.fee_collector_address;
                    return object;
                };
    
                /**
                 * Converts this Params to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.Params
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Params.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Params;
            })();
    
            yieldaggregator.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof ununifi.yieldaggregator
                 * @interface IGenesisState
                 * @property {ununifi.yieldaggregator.IParams|null} [params] GenesisState params
                 * @property {Array.<ununifi.yieldaggregator.IVault>|null} [vaults] GenesisState vaults
                 * @property {Array.<ununifi.yieldaggregator.IStrategy>|null} [strategies] GenesisState strategies
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {ununifi.yieldaggregator.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.vaults = [];
                    this.strategies = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState params.
                 * @member {ununifi.yieldaggregator.IParams|null|undefined} params
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @instance
                 */
                GenesisState.prototype.params = null;
    
                /**
                 * GenesisState vaults.
                 * @member {Array.<ununifi.yieldaggregator.IVault>} vaults
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @instance
                 */
                GenesisState.prototype.vaults = $util.emptyArray;
    
                /**
                 * GenesisState strategies.
                 * @member {Array.<ununifi.yieldaggregator.IStrategy>} strategies
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @instance
                 */
                GenesisState.prototype.strategies = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.yieldaggregator.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @static
                 * @param {ununifi.yieldaggregator.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.yieldaggregator.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.vaults != null && message.vaults.length)
                        for (var i = 0; i < message.vaults.length; ++i)
                            $root.ununifi.yieldaggregator.Vault.encode(message.vaults[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.strategies != null && message.strategies.length)
                        for (var i = 0; i < message.strategies.length; ++i)
                            $root.ununifi.yieldaggregator.Strategy.encode(message.strategies[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @static
                 * @param {ununifi.yieldaggregator.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.yieldaggregator.Params.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.vaults && message.vaults.length))
                                message.vaults = [];
                            message.vaults.push($root.ununifi.yieldaggregator.Vault.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.strategies && message.strategies.length))
                                message.strategies = [];
                            message.strategies.push($root.ununifi.yieldaggregator.Strategy.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.yieldaggregator.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.vaults != null && message.hasOwnProperty("vaults")) {
                        if (!Array.isArray(message.vaults))
                            return "vaults: array expected";
                        for (var i = 0; i < message.vaults.length; ++i) {
                            var error = $root.ununifi.yieldaggregator.Vault.verify(message.vaults[i]);
                            if (error)
                                return "vaults." + error;
                        }
                    }
                    if (message.strategies != null && message.hasOwnProperty("strategies")) {
                        if (!Array.isArray(message.strategies))
                            return "strategies: array expected";
                        for (var i = 0; i < message.strategies.length; ++i) {
                            var error = $root.ununifi.yieldaggregator.Strategy.verify(message.strategies[i]);
                            if (error)
                                return "strategies." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.GenesisState)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.GenesisState();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.yieldaggregator.GenesisState.params: object expected");
                        message.params = $root.ununifi.yieldaggregator.Params.fromObject(object.params);
                    }
                    if (object.vaults) {
                        if (!Array.isArray(object.vaults))
                            throw TypeError(".ununifi.yieldaggregator.GenesisState.vaults: array expected");
                        message.vaults = [];
                        for (var i = 0; i < object.vaults.length; ++i) {
                            if (typeof object.vaults[i] !== "object")
                                throw TypeError(".ununifi.yieldaggregator.GenesisState.vaults: object expected");
                            message.vaults[i] = $root.ununifi.yieldaggregator.Vault.fromObject(object.vaults[i]);
                        }
                    }
                    if (object.strategies) {
                        if (!Array.isArray(object.strategies))
                            throw TypeError(".ununifi.yieldaggregator.GenesisState.strategies: array expected");
                        message.strategies = [];
                        for (var i = 0; i < object.strategies.length; ++i) {
                            if (typeof object.strategies[i] !== "object")
                                throw TypeError(".ununifi.yieldaggregator.GenesisState.strategies: object expected");
                            message.strategies[i] = $root.ununifi.yieldaggregator.Strategy.fromObject(object.strategies[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @static
                 * @param {ununifi.yieldaggregator.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.vaults = [];
                        object.strategies = [];
                    }
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.yieldaggregator.Params.toObject(message.params, options);
                    if (message.vaults && message.vaults.length) {
                        object.vaults = [];
                        for (var j = 0; j < message.vaults.length; ++j)
                            object.vaults[j] = $root.ununifi.yieldaggregator.Vault.toObject(message.vaults[j], options);
                    }
                    if (message.strategies && message.strategies.length) {
                        object.strategies = [];
                        for (var j = 0; j < message.strategies.length; ++j)
                            object.strategies[j] = $root.ununifi.yieldaggregator.Strategy.toObject(message.strategies[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            yieldaggregator.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Query#params}.
                 * @memberof ununifi.yieldaggregator.Query
                 * @typedef ParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.QueryParamsResponse} [response] QueryParamsResponse
                 */
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @param {ununifi.yieldaggregator.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.params = function params(request, callback) {
                    return this.rpcCall(params, $root.ununifi.yieldaggregator.QueryParamsRequest, $root.ununifi.yieldaggregator.QueryParamsResponse, request, callback);
                }, "name", { value: "Params" });
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.QueryParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Query#vaultAll}.
                 * @memberof ununifi.yieldaggregator.Query
                 * @typedef VaultAllCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.QueryAllVaultResponse} [response] QueryAllVaultResponse
                 */
    
                /**
                 * Calls VaultAll.
                 * @function vaultAll
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} request QueryAllVaultRequest message or plain object
                 * @param {ununifi.yieldaggregator.Query.VaultAllCallback} callback Node-style callback called with the error, if any, and QueryAllVaultResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.vaultAll = function vaultAll(request, callback) {
                    return this.rpcCall(vaultAll, $root.ununifi.yieldaggregator.QueryAllVaultRequest, $root.ununifi.yieldaggregator.QueryAllVaultResponse, request, callback);
                }, "name", { value: "VaultAll" });
    
                /**
                 * Calls VaultAll.
                 * @function vaultAll
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} request QueryAllVaultRequest message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.QueryAllVaultResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Query#vault}.
                 * @memberof ununifi.yieldaggregator.Query
                 * @typedef VaultCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.QueryGetVaultResponse} [response] QueryGetVaultResponse
                 */
    
                /**
                 * Calls Vault.
                 * @function vault
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} request QueryGetVaultRequest message or plain object
                 * @param {ununifi.yieldaggregator.Query.VaultCallback} callback Node-style callback called with the error, if any, and QueryGetVaultResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.vault = function vault(request, callback) {
                    return this.rpcCall(vault, $root.ununifi.yieldaggregator.QueryGetVaultRequest, $root.ununifi.yieldaggregator.QueryGetVaultResponse, request, callback);
                }, "name", { value: "Vault" });
    
                /**
                 * Calls Vault.
                 * @function vault
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} request QueryGetVaultRequest message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.QueryGetVaultResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Query#strategyAll}.
                 * @memberof ununifi.yieldaggregator.Query
                 * @typedef StrategyAllCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.QueryAllStrategyResponse} [response] QueryAllStrategyResponse
                 */
    
                /**
                 * Calls StrategyAll.
                 * @function strategyAll
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} request QueryAllStrategyRequest message or plain object
                 * @param {ununifi.yieldaggregator.Query.StrategyAllCallback} callback Node-style callback called with the error, if any, and QueryAllStrategyResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.strategyAll = function strategyAll(request, callback) {
                    return this.rpcCall(strategyAll, $root.ununifi.yieldaggregator.QueryAllStrategyRequest, $root.ununifi.yieldaggregator.QueryAllStrategyResponse, request, callback);
                }, "name", { value: "StrategyAll" });
    
                /**
                 * Calls StrategyAll.
                 * @function strategyAll
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} request QueryAllStrategyRequest message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.QueryAllStrategyResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Query#strategy}.
                 * @memberof ununifi.yieldaggregator.Query
                 * @typedef StrategyCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.QueryGetStrategyResponse} [response] QueryGetStrategyResponse
                 */
    
                /**
                 * Calls Strategy.
                 * @function strategy
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} request QueryGetStrategyRequest message or plain object
                 * @param {ununifi.yieldaggregator.Query.StrategyCallback} callback Node-style callback called with the error, if any, and QueryGetStrategyResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.strategy = function strategy(request, callback) {
                    return this.rpcCall(strategy, $root.ununifi.yieldaggregator.QueryGetStrategyRequest, $root.ununifi.yieldaggregator.QueryGetStrategyResponse, request, callback);
                }, "name", { value: "Strategy" });
    
                /**
                 * Calls Strategy.
                 * @function strategy
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} request QueryGetStrategyRequest message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.QueryGetStrategyResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Query#estimateMintAmount}.
                 * @memberof ununifi.yieldaggregator.Query
                 * @typedef EstimateMintAmountCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} [response] QueryEstimateMintAmountResponse
                 */
    
                /**
                 * Calls EstimateMintAmount.
                 * @function estimateMintAmount
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} request QueryEstimateMintAmountRequest message or plain object
                 * @param {ununifi.yieldaggregator.Query.EstimateMintAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateMintAmountResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.estimateMintAmount = function estimateMintAmount(request, callback) {
                    return this.rpcCall(estimateMintAmount, $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest, $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse, request, callback);
                }, "name", { value: "EstimateMintAmount" });
    
                /**
                 * Calls EstimateMintAmount.
                 * @function estimateMintAmount
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} request QueryEstimateMintAmountRequest message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.QueryEstimateMintAmountResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link ununifi.yieldaggregator.Query#estimateRedeemAmount}.
                 * @memberof ununifi.yieldaggregator.Query
                 * @typedef EstimateRedeemAmountCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} [response] QueryEstimateRedeemAmountResponse
                 */
    
                /**
                 * Calls EstimateRedeemAmount.
                 * @function estimateRedeemAmount
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} request QueryEstimateRedeemAmountRequest message or plain object
                 * @param {ununifi.yieldaggregator.Query.EstimateRedeemAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateRedeemAmountResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.estimateRedeemAmount = function estimateRedeemAmount(request, callback) {
                    return this.rpcCall(estimateRedeemAmount, $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest, $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse, request, callback);
                }, "name", { value: "EstimateRedeemAmount" });
    
                /**
                 * Calls EstimateRedeemAmount.
                 * @function estimateRedeemAmount
                 * @memberof ununifi.yieldaggregator.Query
                 * @instance
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} request QueryEstimateRedeemAmountRequest message or plain object
                 * @returns {Promise<ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            yieldaggregator.QueryParamsRequest = (function() {
    
                /**
                 * Properties of a QueryParamsRequest.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryParamsRequest
                 */
    
                /**
                 * Constructs a new QueryParamsRequest.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryParamsRequest.
                 * @implements IQueryParamsRequest
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryParamsRequest=} [properties] Properties to set
                 */
                function QueryParamsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryParamsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsRequest message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryParamsRequest} QueryParamsRequest
                 */
                QueryParamsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryParamsRequest)
                        return object;
                    return new $root.ununifi.yieldaggregator.QueryParamsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @static
                 * @param {ununifi.yieldaggregator.QueryParamsRequest} message QueryParamsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryParamsRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryParamsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsRequest;
            })();
    
            yieldaggregator.QueryParamsResponse = (function() {
    
                /**
                 * Properties of a QueryParamsResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryParamsResponse
                 * @property {ununifi.yieldaggregator.IParams|null} [params] QueryParamsResponse params
                 */
    
                /**
                 * Constructs a new QueryParamsResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryParamsResponse.
                 * @implements IQueryParamsResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryParamsResponse=} [properties] Properties to set
                 */
                function QueryParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryParamsResponse params.
                 * @member {ununifi.yieldaggregator.IParams|null|undefined} params
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @instance
                 */
                QueryParamsResponse.prototype.params = null;
    
                /**
                 * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.ununifi.yieldaggregator.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.ununifi.yieldaggregator.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.ununifi.yieldaggregator.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryParamsResponse} QueryParamsResponse
                 */
                QueryParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryParamsResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryParamsResponse();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryParamsResponse.params: object expected");
                        message.params = $root.ununifi.yieldaggregator.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @static
                 * @param {ununifi.yieldaggregator.QueryParamsResponse} message QueryParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.ununifi.yieldaggregator.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this QueryParamsResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsResponse;
            })();
    
            yieldaggregator.QueryAllVaultRequest = (function() {
    
                /**
                 * Properties of a QueryAllVaultRequest.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryAllVaultRequest
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllVaultRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllVaultRequest.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryAllVaultRequest.
                 * @implements IQueryAllVaultRequest
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryAllVaultRequest=} [properties] Properties to set
                 */
                function QueryAllVaultRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllVaultRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @instance
                 */
                QueryAllVaultRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllVaultRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} message QueryAllVaultRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllVaultRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllVaultRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} message QueryAllVaultRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllVaultRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllVaultRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryAllVaultRequest} QueryAllVaultRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllVaultRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryAllVaultRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllVaultRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryAllVaultRequest} QueryAllVaultRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllVaultRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllVaultRequest message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllVaultRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllVaultRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryAllVaultRequest} QueryAllVaultRequest
                 */
                QueryAllVaultRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryAllVaultRequest)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryAllVaultRequest();
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryAllVaultRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllVaultRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @static
                 * @param {ununifi.yieldaggregator.QueryAllVaultRequest} message QueryAllVaultRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllVaultRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pagination = null;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllVaultRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllVaultRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllVaultRequest;
            })();
    
            yieldaggregator.QueryAllVaultResponse = (function() {
    
                /**
                 * Properties of a QueryAllVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryAllVaultResponse
                 * @property {Array.<ununifi.yieldaggregator.IVault>|null} [vaults] QueryAllVaultResponse vaults
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllVaultResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryAllVaultResponse.
                 * @implements IQueryAllVaultResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryAllVaultResponse=} [properties] Properties to set
                 */
                function QueryAllVaultResponse(properties) {
                    this.vaults = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllVaultResponse vaults.
                 * @member {Array.<ununifi.yieldaggregator.IVault>} vaults
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @instance
                 */
                QueryAllVaultResponse.prototype.vaults = $util.emptyArray;
    
                /**
                 * QueryAllVaultResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @instance
                 */
                QueryAllVaultResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllVaultResponse} message QueryAllVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllVaultResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vaults != null && message.vaults.length)
                        for (var i = 0; i < message.vaults.length; ++i)
                            $root.ununifi.yieldaggregator.Vault.encode(message.vaults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllVaultResponse} message QueryAllVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllVaultResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryAllVaultResponse} QueryAllVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllVaultResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryAllVaultResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vaults && message.vaults.length))
                                message.vaults = [];
                            message.vaults.push($root.ununifi.yieldaggregator.Vault.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllVaultResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryAllVaultResponse} QueryAllVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllVaultResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllVaultResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllVaultResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vaults != null && message.hasOwnProperty("vaults")) {
                        if (!Array.isArray(message.vaults))
                            return "vaults: array expected";
                        for (var i = 0; i < message.vaults.length; ++i) {
                            var error = $root.ununifi.yieldaggregator.Vault.verify(message.vaults[i]);
                            if (error)
                                return "vaults." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllVaultResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryAllVaultResponse} QueryAllVaultResponse
                 */
                QueryAllVaultResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryAllVaultResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryAllVaultResponse();
                    if (object.vaults) {
                        if (!Array.isArray(object.vaults))
                            throw TypeError(".ununifi.yieldaggregator.QueryAllVaultResponse.vaults: array expected");
                        message.vaults = [];
                        for (var i = 0; i < object.vaults.length; ++i) {
                            if (typeof object.vaults[i] !== "object")
                                throw TypeError(".ununifi.yieldaggregator.QueryAllVaultResponse.vaults: object expected");
                            message.vaults[i] = $root.ununifi.yieldaggregator.Vault.fromObject(object.vaults[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryAllVaultResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllVaultResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.QueryAllVaultResponse} message QueryAllVaultResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllVaultResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vaults = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.vaults && message.vaults.length) {
                        object.vaults = [];
                        for (var j = 0; j < message.vaults.length; ++j)
                            object.vaults[j] = $root.ununifi.yieldaggregator.Vault.toObject(message.vaults[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllVaultResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllVaultResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllVaultResponse;
            })();
    
            yieldaggregator.QueryGetVaultRequest = (function() {
    
                /**
                 * Properties of a QueryGetVaultRequest.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryGetVaultRequest
                 * @property {Long|null} [id] QueryGetVaultRequest id
                 */
    
                /**
                 * Constructs a new QueryGetVaultRequest.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryGetVaultRequest.
                 * @implements IQueryGetVaultRequest
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryGetVaultRequest=} [properties] Properties to set
                 */
                function QueryGetVaultRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetVaultRequest id.
                 * @member {Long} id
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @instance
                 */
                QueryGetVaultRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified QueryGetVaultRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} message QueryGetVaultRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetVaultRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetVaultRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} message QueryGetVaultRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetVaultRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetVaultRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryGetVaultRequest} QueryGetVaultRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetVaultRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryGetVaultRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetVaultRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryGetVaultRequest} QueryGetVaultRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetVaultRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetVaultRequest message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetVaultRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryGetVaultRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryGetVaultRequest} QueryGetVaultRequest
                 */
                QueryGetVaultRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryGetVaultRequest)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryGetVaultRequest();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetVaultRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @static
                 * @param {ununifi.yieldaggregator.QueryGetVaultRequest} message QueryGetVaultRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetVaultRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };
    
                /**
                 * Converts this QueryGetVaultRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetVaultRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetVaultRequest;
            })();
    
            yieldaggregator.QueryGetVaultResponse = (function() {
    
                /**
                 * Properties of a QueryGetVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryGetVaultResponse
                 * @property {ununifi.yieldaggregator.IVault|null} [vault] QueryGetVaultResponse vault
                 * @property {Array.<ununifi.yieldaggregator.IStrategy>|null} [strategies] QueryGetVaultResponse strategies
                 * @property {string|null} [vault_address] QueryGetVaultResponse vault_address
                 * @property {string|null} [total_bonded_amount] QueryGetVaultResponse total_bonded_amount
                 * @property {string|null} [total_unbonding_amount] QueryGetVaultResponse total_unbonding_amount
                 * @property {string|null} [total_withdrawal_balance] QueryGetVaultResponse total_withdrawal_balance
                 */
    
                /**
                 * Constructs a new QueryGetVaultResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryGetVaultResponse.
                 * @implements IQueryGetVaultResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryGetVaultResponse=} [properties] Properties to set
                 */
                function QueryGetVaultResponse(properties) {
                    this.strategies = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetVaultResponse vault.
                 * @member {ununifi.yieldaggregator.IVault|null|undefined} vault
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @instance
                 */
                QueryGetVaultResponse.prototype.vault = null;
    
                /**
                 * QueryGetVaultResponse strategies.
                 * @member {Array.<ununifi.yieldaggregator.IStrategy>} strategies
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @instance
                 */
                QueryGetVaultResponse.prototype.strategies = $util.emptyArray;
    
                /**
                 * QueryGetVaultResponse vault_address.
                 * @member {string} vault_address
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @instance
                 */
                QueryGetVaultResponse.prototype.vault_address = "";
    
                /**
                 * QueryGetVaultResponse total_bonded_amount.
                 * @member {string} total_bonded_amount
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @instance
                 */
                QueryGetVaultResponse.prototype.total_bonded_amount = "";
    
                /**
                 * QueryGetVaultResponse total_unbonding_amount.
                 * @member {string} total_unbonding_amount
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @instance
                 */
                QueryGetVaultResponse.prototype.total_unbonding_amount = "";
    
                /**
                 * QueryGetVaultResponse total_withdrawal_balance.
                 * @member {string} total_withdrawal_balance
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @instance
                 */
                QueryGetVaultResponse.prototype.total_withdrawal_balance = "";
    
                /**
                 * Encodes the specified QueryGetVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetVaultResponse} message QueryGetVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetVaultResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vault != null && Object.hasOwnProperty.call(message, "vault"))
                        $root.ununifi.yieldaggregator.Vault.encode(message.vault, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.strategies != null && message.strategies.length)
                        for (var i = 0; i < message.strategies.length; ++i)
                            $root.ununifi.yieldaggregator.Strategy.encode(message.strategies[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.vault_address != null && Object.hasOwnProperty.call(message, "vault_address"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.vault_address);
                    if (message.total_bonded_amount != null && Object.hasOwnProperty.call(message, "total_bonded_amount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.total_bonded_amount);
                    if (message.total_unbonding_amount != null && Object.hasOwnProperty.call(message, "total_unbonding_amount"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.total_unbonding_amount);
                    if (message.total_withdrawal_balance != null && Object.hasOwnProperty.call(message, "total_withdrawal_balance"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.total_withdrawal_balance);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetVaultResponse} message QueryGetVaultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetVaultResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryGetVaultResponse} QueryGetVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetVaultResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryGetVaultResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.vault = $root.ununifi.yieldaggregator.Vault.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.strategies && message.strategies.length))
                                message.strategies = [];
                            message.strategies.push($root.ununifi.yieldaggregator.Strategy.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.vault_address = reader.string();
                            break;
                        case 4:
                            message.total_bonded_amount = reader.string();
                            break;
                        case 5:
                            message.total_unbonding_amount = reader.string();
                            break;
                        case 6:
                            message.total_withdrawal_balance = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetVaultResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryGetVaultResponse} QueryGetVaultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetVaultResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetVaultResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetVaultResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vault != null && message.hasOwnProperty("vault")) {
                        var error = $root.ununifi.yieldaggregator.Vault.verify(message.vault);
                        if (error)
                            return "vault." + error;
                    }
                    if (message.strategies != null && message.hasOwnProperty("strategies")) {
                        if (!Array.isArray(message.strategies))
                            return "strategies: array expected";
                        for (var i = 0; i < message.strategies.length; ++i) {
                            var error = $root.ununifi.yieldaggregator.Strategy.verify(message.strategies[i]);
                            if (error)
                                return "strategies." + error;
                        }
                    }
                    if (message.vault_address != null && message.hasOwnProperty("vault_address"))
                        if (!$util.isString(message.vault_address))
                            return "vault_address: string expected";
                    if (message.total_bonded_amount != null && message.hasOwnProperty("total_bonded_amount"))
                        if (!$util.isString(message.total_bonded_amount))
                            return "total_bonded_amount: string expected";
                    if (message.total_unbonding_amount != null && message.hasOwnProperty("total_unbonding_amount"))
                        if (!$util.isString(message.total_unbonding_amount))
                            return "total_unbonding_amount: string expected";
                    if (message.total_withdrawal_balance != null && message.hasOwnProperty("total_withdrawal_balance"))
                        if (!$util.isString(message.total_withdrawal_balance))
                            return "total_withdrawal_balance: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryGetVaultResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryGetVaultResponse} QueryGetVaultResponse
                 */
                QueryGetVaultResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryGetVaultResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryGetVaultResponse();
                    if (object.vault != null) {
                        if (typeof object.vault !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryGetVaultResponse.vault: object expected");
                        message.vault = $root.ununifi.yieldaggregator.Vault.fromObject(object.vault);
                    }
                    if (object.strategies) {
                        if (!Array.isArray(object.strategies))
                            throw TypeError(".ununifi.yieldaggregator.QueryGetVaultResponse.strategies: array expected");
                        message.strategies = [];
                        for (var i = 0; i < object.strategies.length; ++i) {
                            if (typeof object.strategies[i] !== "object")
                                throw TypeError(".ununifi.yieldaggregator.QueryGetVaultResponse.strategies: object expected");
                            message.strategies[i] = $root.ununifi.yieldaggregator.Strategy.fromObject(object.strategies[i]);
                        }
                    }
                    if (object.vault_address != null)
                        message.vault_address = String(object.vault_address);
                    if (object.total_bonded_amount != null)
                        message.total_bonded_amount = String(object.total_bonded_amount);
                    if (object.total_unbonding_amount != null)
                        message.total_unbonding_amount = String(object.total_unbonding_amount);
                    if (object.total_withdrawal_balance != null)
                        message.total_withdrawal_balance = String(object.total_withdrawal_balance);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetVaultResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @static
                 * @param {ununifi.yieldaggregator.QueryGetVaultResponse} message QueryGetVaultResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetVaultResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.strategies = [];
                    if (options.defaults) {
                        object.vault = null;
                        object.vault_address = "";
                        object.total_bonded_amount = "";
                        object.total_unbonding_amount = "";
                        object.total_withdrawal_balance = "";
                    }
                    if (message.vault != null && message.hasOwnProperty("vault"))
                        object.vault = $root.ununifi.yieldaggregator.Vault.toObject(message.vault, options);
                    if (message.strategies && message.strategies.length) {
                        object.strategies = [];
                        for (var j = 0; j < message.strategies.length; ++j)
                            object.strategies[j] = $root.ununifi.yieldaggregator.Strategy.toObject(message.strategies[j], options);
                    }
                    if (message.vault_address != null && message.hasOwnProperty("vault_address"))
                        object.vault_address = message.vault_address;
                    if (message.total_bonded_amount != null && message.hasOwnProperty("total_bonded_amount"))
                        object.total_bonded_amount = message.total_bonded_amount;
                    if (message.total_unbonding_amount != null && message.hasOwnProperty("total_unbonding_amount"))
                        object.total_unbonding_amount = message.total_unbonding_amount;
                    if (message.total_withdrawal_balance != null && message.hasOwnProperty("total_withdrawal_balance"))
                        object.total_withdrawal_balance = message.total_withdrawal_balance;
                    return object;
                };
    
                /**
                 * Converts this QueryGetVaultResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetVaultResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetVaultResponse;
            })();
    
            yieldaggregator.QueryAllStrategyRequest = (function() {
    
                /**
                 * Properties of a QueryAllStrategyRequest.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryAllStrategyRequest
                 * @property {string|null} [denom] QueryAllStrategyRequest denom
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllStrategyRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllStrategyRequest.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryAllStrategyRequest.
                 * @implements IQueryAllStrategyRequest
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest=} [properties] Properties to set
                 */
                function QueryAllStrategyRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllStrategyRequest denom.
                 * @member {string} denom
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @instance
                 */
                QueryAllStrategyRequest.prototype.denom = "";
    
                /**
                 * QueryAllStrategyRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @instance
                 */
                QueryAllStrategyRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllStrategyRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} message QueryAllStrategyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllStrategyRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllStrategyRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} message QueryAllStrategyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllStrategyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllStrategyRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryAllStrategyRequest} QueryAllStrategyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllStrategyRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryAllStrategyRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.denom = reader.string();
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllStrategyRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryAllStrategyRequest} QueryAllStrategyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllStrategyRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllStrategyRequest message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllStrategyRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllStrategyRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryAllStrategyRequest} QueryAllStrategyRequest
                 */
                QueryAllStrategyRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryAllStrategyRequest)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryAllStrategyRequest();
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryAllStrategyRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllStrategyRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @static
                 * @param {ununifi.yieldaggregator.QueryAllStrategyRequest} message QueryAllStrategyRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllStrategyRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.denom = "";
                        object.pagination = null;
                    }
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllStrategyRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllStrategyRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllStrategyRequest;
            })();
    
            yieldaggregator.QueryAllStrategyResponse = (function() {
    
                /**
                 * Properties of a QueryAllStrategyResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryAllStrategyResponse
                 * @property {Array.<ununifi.yieldaggregator.IStrategy>|null} [strategies] QueryAllStrategyResponse strategies
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllStrategyResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllStrategyResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryAllStrategyResponse.
                 * @implements IQueryAllStrategyResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyResponse=} [properties] Properties to set
                 */
                function QueryAllStrategyResponse(properties) {
                    this.strategies = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllStrategyResponse strategies.
                 * @member {Array.<ununifi.yieldaggregator.IStrategy>} strategies
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @instance
                 */
                QueryAllStrategyResponse.prototype.strategies = $util.emptyArray;
    
                /**
                 * QueryAllStrategyResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @instance
                 */
                QueryAllStrategyResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllStrategyResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyResponse} message QueryAllStrategyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllStrategyResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.strategies != null && message.strategies.length)
                        for (var i = 0; i < message.strategies.length; ++i)
                            $root.ununifi.yieldaggregator.Strategy.encode(message.strategies[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllStrategyResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryAllStrategyResponse} message QueryAllStrategyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllStrategyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllStrategyResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryAllStrategyResponse} QueryAllStrategyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllStrategyResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryAllStrategyResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.strategies && message.strategies.length))
                                message.strategies = [];
                            message.strategies.push($root.ununifi.yieldaggregator.Strategy.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllStrategyResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryAllStrategyResponse} QueryAllStrategyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllStrategyResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllStrategyResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllStrategyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.strategies != null && message.hasOwnProperty("strategies")) {
                        if (!Array.isArray(message.strategies))
                            return "strategies: array expected";
                        for (var i = 0; i < message.strategies.length; ++i) {
                            var error = $root.ununifi.yieldaggregator.Strategy.verify(message.strategies[i]);
                            if (error)
                                return "strategies." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllStrategyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryAllStrategyResponse} QueryAllStrategyResponse
                 */
                QueryAllStrategyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryAllStrategyResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryAllStrategyResponse();
                    if (object.strategies) {
                        if (!Array.isArray(object.strategies))
                            throw TypeError(".ununifi.yieldaggregator.QueryAllStrategyResponse.strategies: array expected");
                        message.strategies = [];
                        for (var i = 0; i < object.strategies.length; ++i) {
                            if (typeof object.strategies[i] !== "object")
                                throw TypeError(".ununifi.yieldaggregator.QueryAllStrategyResponse.strategies: object expected");
                            message.strategies[i] = $root.ununifi.yieldaggregator.Strategy.fromObject(object.strategies[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryAllStrategyResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllStrategyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.QueryAllStrategyResponse} message QueryAllStrategyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllStrategyResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.strategies = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.strategies && message.strategies.length) {
                        object.strategies = [];
                        for (var j = 0; j < message.strategies.length; ++j)
                            object.strategies[j] = $root.ununifi.yieldaggregator.Strategy.toObject(message.strategies[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllStrategyResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllStrategyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllStrategyResponse;
            })();
    
            yieldaggregator.QueryGetStrategyRequest = (function() {
    
                /**
                 * Properties of a QueryGetStrategyRequest.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryGetStrategyRequest
                 * @property {string|null} [denom] QueryGetStrategyRequest denom
                 * @property {Long|null} [id] QueryGetStrategyRequest id
                 */
    
                /**
                 * Constructs a new QueryGetStrategyRequest.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryGetStrategyRequest.
                 * @implements IQueryGetStrategyRequest
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest=} [properties] Properties to set
                 */
                function QueryGetStrategyRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetStrategyRequest denom.
                 * @member {string} denom
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @instance
                 */
                QueryGetStrategyRequest.prototype.denom = "";
    
                /**
                 * QueryGetStrategyRequest id.
                 * @member {Long} id
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @instance
                 */
                QueryGetStrategyRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified QueryGetStrategyRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} message QueryGetStrategyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetStrategyRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetStrategyRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} message QueryGetStrategyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetStrategyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetStrategyRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryGetStrategyRequest} QueryGetStrategyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetStrategyRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryGetStrategyRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.denom = reader.string();
                            break;
                        case 2:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetStrategyRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryGetStrategyRequest} QueryGetStrategyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetStrategyRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetStrategyRequest message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetStrategyRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        if (!$util.isString(message.denom))
                            return "denom: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryGetStrategyRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryGetStrategyRequest} QueryGetStrategyRequest
                 */
                QueryGetStrategyRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryGetStrategyRequest)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryGetStrategyRequest();
                    if (object.denom != null)
                        message.denom = String(object.denom);
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetStrategyRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @static
                 * @param {ununifi.yieldaggregator.QueryGetStrategyRequest} message QueryGetStrategyRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetStrategyRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.denom = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    }
                    if (message.denom != null && message.hasOwnProperty("denom"))
                        object.denom = message.denom;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };
    
                /**
                 * Converts this QueryGetStrategyRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetStrategyRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetStrategyRequest;
            })();
    
            yieldaggregator.QueryGetStrategyResponse = (function() {
    
                /**
                 * Properties of a QueryGetStrategyResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryGetStrategyResponse
                 * @property {ununifi.yieldaggregator.IStrategy|null} [strategy] QueryGetStrategyResponse strategy
                 */
    
                /**
                 * Constructs a new QueryGetStrategyResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryGetStrategyResponse.
                 * @implements IQueryGetStrategyResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyResponse=} [properties] Properties to set
                 */
                function QueryGetStrategyResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetStrategyResponse strategy.
                 * @member {ununifi.yieldaggregator.IStrategy|null|undefined} strategy
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @instance
                 */
                QueryGetStrategyResponse.prototype.strategy = null;
    
                /**
                 * Encodes the specified QueryGetStrategyResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyResponse} message QueryGetStrategyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetStrategyResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.strategy != null && Object.hasOwnProperty.call(message, "strategy"))
                        $root.ununifi.yieldaggregator.Strategy.encode(message.strategy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetStrategyResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryGetStrategyResponse} message QueryGetStrategyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetStrategyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetStrategyResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryGetStrategyResponse} QueryGetStrategyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetStrategyResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryGetStrategyResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.strategy = $root.ununifi.yieldaggregator.Strategy.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetStrategyResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryGetStrategyResponse} QueryGetStrategyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetStrategyResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetStrategyResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetStrategyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.strategy != null && message.hasOwnProperty("strategy")) {
                        var error = $root.ununifi.yieldaggregator.Strategy.verify(message.strategy);
                        if (error)
                            return "strategy." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryGetStrategyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryGetStrategyResponse} QueryGetStrategyResponse
                 */
                QueryGetStrategyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryGetStrategyResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryGetStrategyResponse();
                    if (object.strategy != null) {
                        if (typeof object.strategy !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryGetStrategyResponse.strategy: object expected");
                        message.strategy = $root.ununifi.yieldaggregator.Strategy.fromObject(object.strategy);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetStrategyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @static
                 * @param {ununifi.yieldaggregator.QueryGetStrategyResponse} message QueryGetStrategyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetStrategyResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.strategy = null;
                    if (message.strategy != null && message.hasOwnProperty("strategy"))
                        object.strategy = $root.ununifi.yieldaggregator.Strategy.toObject(message.strategy, options);
                    return object;
                };
    
                /**
                 * Converts this QueryGetStrategyResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetStrategyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetStrategyResponse;
            })();
    
            yieldaggregator.QueryEstimateMintAmountRequest = (function() {
    
                /**
                 * Properties of a QueryEstimateMintAmountRequest.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryEstimateMintAmountRequest
                 * @property {Long|null} [id] QueryEstimateMintAmountRequest id
                 * @property {string|null} [deposit_amount] QueryEstimateMintAmountRequest deposit_amount
                 */
    
                /**
                 * Constructs a new QueryEstimateMintAmountRequest.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryEstimateMintAmountRequest.
                 * @implements IQueryEstimateMintAmountRequest
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest=} [properties] Properties to set
                 */
                function QueryEstimateMintAmountRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateMintAmountRequest id.
                 * @member {Long} id
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @instance
                 */
                QueryEstimateMintAmountRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * QueryEstimateMintAmountRequest deposit_amount.
                 * @member {string} deposit_amount
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @instance
                 */
                QueryEstimateMintAmountRequest.prototype.deposit_amount = "";
    
                /**
                 * Encodes the specified QueryEstimateMintAmountRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} message QueryEstimateMintAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateMintAmountRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    if (message.deposit_amount != null && Object.hasOwnProperty.call(message, "deposit_amount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.deposit_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateMintAmountRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} message QueryEstimateMintAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateMintAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateMintAmountRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} QueryEstimateMintAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateMintAmountRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        case 2:
                            message.deposit_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateMintAmountRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} QueryEstimateMintAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateMintAmountRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateMintAmountRequest message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateMintAmountRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    if (message.deposit_amount != null && message.hasOwnProperty("deposit_amount"))
                        if (!$util.isString(message.deposit_amount))
                            return "deposit_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateMintAmountRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} QueryEstimateMintAmountRequest
                 */
                QueryEstimateMintAmountRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    if (object.deposit_amount != null)
                        message.deposit_amount = String(object.deposit_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateMintAmountRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @static
                 * @param {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} message QueryEstimateMintAmountRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateMintAmountRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                        object.deposit_amount = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    if (message.deposit_amount != null && message.hasOwnProperty("deposit_amount"))
                        object.deposit_amount = message.deposit_amount;
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateMintAmountRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateMintAmountRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateMintAmountRequest;
            })();
    
            yieldaggregator.QueryEstimateMintAmountResponse = (function() {
    
                /**
                 * Properties of a QueryEstimateMintAmountResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryEstimateMintAmountResponse
                 * @property {cosmos.base.v1beta1.ICoin|null} [mint_amount] QueryEstimateMintAmountResponse mint_amount
                 */
    
                /**
                 * Constructs a new QueryEstimateMintAmountResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryEstimateMintAmountResponse.
                 * @implements IQueryEstimateMintAmountResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountResponse=} [properties] Properties to set
                 */
                function QueryEstimateMintAmountResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateMintAmountResponse mint_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} mint_amount
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @instance
                 */
                QueryEstimateMintAmountResponse.prototype.mint_amount = null;
    
                /**
                 * Encodes the specified QueryEstimateMintAmountResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountResponse} message QueryEstimateMintAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateMintAmountResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mint_amount != null && Object.hasOwnProperty.call(message, "mint_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.mint_amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateMintAmountResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountResponse} message QueryEstimateMintAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateMintAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateMintAmountResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} QueryEstimateMintAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateMintAmountResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mint_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateMintAmountResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} QueryEstimateMintAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateMintAmountResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateMintAmountResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateMintAmountResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mint_amount != null && message.hasOwnProperty("mint_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.mint_amount);
                        if (error)
                            return "mint_amount." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateMintAmountResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} QueryEstimateMintAmountResponse
                 */
                QueryEstimateMintAmountResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse();
                    if (object.mint_amount != null) {
                        if (typeof object.mint_amount !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryEstimateMintAmountResponse.mint_amount: object expected");
                        message.mint_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.mint_amount);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateMintAmountResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @static
                 * @param {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} message QueryEstimateMintAmountResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateMintAmountResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.mint_amount = null;
                    if (message.mint_amount != null && message.hasOwnProperty("mint_amount"))
                        object.mint_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.mint_amount, options);
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateMintAmountResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateMintAmountResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateMintAmountResponse;
            })();
    
            yieldaggregator.QueryEstimateRedeemAmountRequest = (function() {
    
                /**
                 * Properties of a QueryEstimateRedeemAmountRequest.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryEstimateRedeemAmountRequest
                 * @property {Long|null} [id] QueryEstimateRedeemAmountRequest id
                 * @property {string|null} [burn_amount] QueryEstimateRedeemAmountRequest burn_amount
                 */
    
                /**
                 * Constructs a new QueryEstimateRedeemAmountRequest.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryEstimateRedeemAmountRequest.
                 * @implements IQueryEstimateRedeemAmountRequest
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest=} [properties] Properties to set
                 */
                function QueryEstimateRedeemAmountRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateRedeemAmountRequest id.
                 * @member {Long} id
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @instance
                 */
                QueryEstimateRedeemAmountRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * QueryEstimateRedeemAmountRequest burn_amount.
                 * @member {string} burn_amount
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @instance
                 */
                QueryEstimateRedeemAmountRequest.prototype.burn_amount = "";
    
                /**
                 * Encodes the specified QueryEstimateRedeemAmountRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} message QueryEstimateRedeemAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemAmountRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    if (message.burn_amount != null && Object.hasOwnProperty.call(message, "burn_amount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.burn_amount);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateRedeemAmountRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} message QueryEstimateRedeemAmountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateRedeemAmountRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} QueryEstimateRedeemAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemAmountRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        case 2:
                            message.burn_amount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateRedeemAmountRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} QueryEstimateRedeemAmountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemAmountRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateRedeemAmountRequest message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateRedeemAmountRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    if (message.burn_amount != null && message.hasOwnProperty("burn_amount"))
                        if (!$util.isString(message.burn_amount))
                            return "burn_amount: string expected";
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateRedeemAmountRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} QueryEstimateRedeemAmountRequest
                 */
                QueryEstimateRedeemAmountRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    if (object.burn_amount != null)
                        message.burn_amount = String(object.burn_amount);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateRedeemAmountRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @static
                 * @param {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} message QueryEstimateRedeemAmountRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateRedeemAmountRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                        object.burn_amount = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    if (message.burn_amount != null && message.hasOwnProperty("burn_amount"))
                        object.burn_amount = message.burn_amount;
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateRedeemAmountRequest to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateRedeemAmountRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateRedeemAmountRequest;
            })();
    
            yieldaggregator.QueryEstimateRedeemAmountResponse = (function() {
    
                /**
                 * Properties of a QueryEstimateRedeemAmountResponse.
                 * @memberof ununifi.yieldaggregator
                 * @interface IQueryEstimateRedeemAmountResponse
                 * @property {cosmos.base.v1beta1.ICoin|null} [redeem_amount] QueryEstimateRedeemAmountResponse redeem_amount
                 */
    
                /**
                 * Constructs a new QueryEstimateRedeemAmountResponse.
                 * @memberof ununifi.yieldaggregator
                 * @classdesc Represents a QueryEstimateRedeemAmountResponse.
                 * @implements IQueryEstimateRedeemAmountResponse
                 * @constructor
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountResponse=} [properties] Properties to set
                 */
                function QueryEstimateRedeemAmountResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryEstimateRedeemAmountResponse redeem_amount.
                 * @member {cosmos.base.v1beta1.ICoin|null|undefined} redeem_amount
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @instance
                 */
                QueryEstimateRedeemAmountResponse.prototype.redeem_amount = null;
    
                /**
                 * Encodes the specified QueryEstimateRedeemAmountResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountResponse} message QueryEstimateRedeemAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemAmountResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.redeem_amount != null && Object.hasOwnProperty.call(message, "redeem_amount"))
                        $root.cosmos.base.v1beta1.Coin.encode(message.redeem_amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryEstimateRedeemAmountResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @static
                 * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountResponse} message QueryEstimateRedeemAmountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryEstimateRedeemAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryEstimateRedeemAmountResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} QueryEstimateRedeemAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemAmountResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.redeem_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryEstimateRedeemAmountResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} QueryEstimateRedeemAmountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryEstimateRedeemAmountResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryEstimateRedeemAmountResponse message.
                 * @function verify
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryEstimateRedeemAmountResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.redeem_amount != null && message.hasOwnProperty("redeem_amount")) {
                        var error = $root.cosmos.base.v1beta1.Coin.verify(message.redeem_amount);
                        if (error)
                            return "redeem_amount." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryEstimateRedeemAmountResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} QueryEstimateRedeemAmountResponse
                 */
                QueryEstimateRedeemAmountResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse)
                        return object;
                    var message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse();
                    if (object.redeem_amount != null) {
                        if (typeof object.redeem_amount !== "object")
                            throw TypeError(".ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse.redeem_amount: object expected");
                        message.redeem_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.redeem_amount);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryEstimateRedeemAmountResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @static
                 * @param {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} message QueryEstimateRedeemAmountResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryEstimateRedeemAmountResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.redeem_amount = null;
                    if (message.redeem_amount != null && message.hasOwnProperty("redeem_amount"))
                        object.redeem_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.redeem_amount, options);
                    return object;
                };
    
                /**
                 * Converts this QueryEstimateRedeemAmountResponse to JSON.
                 * @function toJSON
                 * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryEstimateRedeemAmountResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryEstimateRedeemAmountResponse;
            })();
    
            return yieldaggregator;
        })();
    
        return ununifi;
    })();
    
    $root.cosmos = (function() {
    
        /**
         * Namespace cosmos.
         * @exports cosmos
         * @namespace
         */
        var cosmos = {};
    
        cosmos.base = (function() {
    
            /**
             * Namespace base.
             * @memberof cosmos
             * @namespace
             */
            var base = {};
    
            base.v1beta1 = (function() {
    
                /**
                 * Namespace v1beta1.
                 * @memberof cosmos.base
                 * @namespace
                 */
                var v1beta1 = {};
    
                v1beta1.Coin = (function() {
    
                    /**
                     * Properties of a Coin.
                     * @memberof cosmos.base.v1beta1
                     * @interface ICoin
                     * @property {string|null} [denom] Coin denom
                     * @property {string|null} [amount] Coin amount
                     */
    
                    /**
                     * Constructs a new Coin.
                     * @memberof cosmos.base.v1beta1
                     * @classdesc Represents a Coin.
                     * @implements ICoin
                     * @constructor
                     * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set
                     */
                    function Coin(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Coin denom.
                     * @member {string} denom
                     * @memberof cosmos.base.v1beta1.Coin
                     * @instance
                     */
                    Coin.prototype.denom = "";
    
                    /**
                     * Coin amount.
                     * @member {string} amount
                     * @memberof cosmos.base.v1beta1.Coin
                     * @instance
                     */
                    Coin.prototype.amount = "";
    
                    /**
                     * Encodes the specified Coin message. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
                     * @function encode
                     * @memberof cosmos.base.v1beta1.Coin
                     * @static
                     * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Coin.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Coin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof cosmos.base.v1beta1.Coin
                     * @static
                     * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Coin.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Coin message from the specified reader or buffer.
                     * @function decode
                     * @memberof cosmos.base.v1beta1.Coin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cosmos.base.v1beta1.Coin} Coin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Coin.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.Coin();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.denom = reader.string();
                                break;
                            case 2:
                                message.amount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Coin message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof cosmos.base.v1beta1.Coin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cosmos.base.v1beta1.Coin} Coin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Coin.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Coin message.
                     * @function verify
                     * @memberof cosmos.base.v1beta1.Coin
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Coin.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            if (!$util.isString(message.denom))
                                return "denom: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a Coin message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof cosmos.base.v1beta1.Coin
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cosmos.base.v1beta1.Coin} Coin
                     */
                    Coin.fromObject = function fromObject(object) {
                        if (object instanceof $root.cosmos.base.v1beta1.Coin)
                            return object;
                        var message = new $root.cosmos.base.v1beta1.Coin();
                        if (object.denom != null)
                            message.denom = String(object.denom);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Coin message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof cosmos.base.v1beta1.Coin
                     * @static
                     * @param {cosmos.base.v1beta1.Coin} message Coin
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Coin.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.denom = "";
                            object.amount = "";
                        }
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            object.denom = message.denom;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this Coin to JSON.
                     * @function toJSON
                     * @memberof cosmos.base.v1beta1.Coin
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Coin.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Coin;
                })();
    
                v1beta1.DecCoin = (function() {
    
                    /**
                     * Properties of a DecCoin.
                     * @memberof cosmos.base.v1beta1
                     * @interface IDecCoin
                     * @property {string|null} [denom] DecCoin denom
                     * @property {string|null} [amount] DecCoin amount
                     */
    
                    /**
                     * Constructs a new DecCoin.
                     * @memberof cosmos.base.v1beta1
                     * @classdesc Represents a DecCoin.
                     * @implements IDecCoin
                     * @constructor
                     * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set
                     */
                    function DecCoin(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DecCoin denom.
                     * @member {string} denom
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @instance
                     */
                    DecCoin.prototype.denom = "";
    
                    /**
                     * DecCoin amount.
                     * @member {string} amount
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @instance
                     */
                    DecCoin.prototype.amount = "";
    
                    /**
                     * Encodes the specified DecCoin message. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
                     * @function encode
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @static
                     * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DecCoin.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified DecCoin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @static
                     * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DecCoin.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a DecCoin message from the specified reader or buffer.
                     * @function decode
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DecCoin.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.DecCoin();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.denom = reader.string();
                                break;
                            case 2:
                                message.amount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a DecCoin message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DecCoin.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a DecCoin message.
                     * @function verify
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DecCoin.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            if (!$util.isString(message.denom))
                                return "denom: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DecCoin message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
                     */
                    DecCoin.fromObject = function fromObject(object) {
                        if (object instanceof $root.cosmos.base.v1beta1.DecCoin)
                            return object;
                        var message = new $root.cosmos.base.v1beta1.DecCoin();
                        if (object.denom != null)
                            message.denom = String(object.denom);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DecCoin message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @static
                     * @param {cosmos.base.v1beta1.DecCoin} message DecCoin
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DecCoin.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.denom = "";
                            object.amount = "";
                        }
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            object.denom = message.denom;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this DecCoin to JSON.
                     * @function toJSON
                     * @memberof cosmos.base.v1beta1.DecCoin
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DecCoin.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DecCoin;
                })();
    
                v1beta1.IntProto = (function() {
    
                    /**
                     * Properties of an IntProto.
                     * @memberof cosmos.base.v1beta1
                     * @interface IIntProto
                     * @property {string|null} [int] IntProto int
                     */
    
                    /**
                     * Constructs a new IntProto.
                     * @memberof cosmos.base.v1beta1
                     * @classdesc Represents an IntProto.
                     * @implements IIntProto
                     * @constructor
                     * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set
                     */
                    function IntProto(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * IntProto int.
                     * @member {string} int
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @instance
                     */
                    IntProto.prototype.int = "";
    
                    /**
                     * Encodes the specified IntProto message. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
                     * @function encode
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @static
                     * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IntProto.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.int != null && Object.hasOwnProperty.call(message, "int"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.int);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified IntProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @static
                     * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IntProto.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an IntProto message from the specified reader or buffer.
                     * @function decode
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cosmos.base.v1beta1.IntProto} IntProto
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IntProto.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.IntProto();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.int = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an IntProto message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cosmos.base.v1beta1.IntProto} IntProto
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IntProto.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an IntProto message.
                     * @function verify
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IntProto.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.int != null && message.hasOwnProperty("int"))
                            if (!$util.isString(message.int))
                                return "int: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an IntProto message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cosmos.base.v1beta1.IntProto} IntProto
                     */
                    IntProto.fromObject = function fromObject(object) {
                        if (object instanceof $root.cosmos.base.v1beta1.IntProto)
                            return object;
                        var message = new $root.cosmos.base.v1beta1.IntProto();
                        if (object.int != null)
                            message.int = String(object.int);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an IntProto message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @static
                     * @param {cosmos.base.v1beta1.IntProto} message IntProto
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IntProto.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.int = "";
                        if (message.int != null && message.hasOwnProperty("int"))
                            object.int = message.int;
                        return object;
                    };
    
                    /**
                     * Converts this IntProto to JSON.
                     * @function toJSON
                     * @memberof cosmos.base.v1beta1.IntProto
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IntProto.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return IntProto;
                })();
    
                v1beta1.DecProto = (function() {
    
                    /**
                     * Properties of a DecProto.
                     * @memberof cosmos.base.v1beta1
                     * @interface IDecProto
                     * @property {string|null} [dec] DecProto dec
                     */
    
                    /**
                     * Constructs a new DecProto.
                     * @memberof cosmos.base.v1beta1
                     * @classdesc Represents a DecProto.
                     * @implements IDecProto
                     * @constructor
                     * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set
                     */
                    function DecProto(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DecProto dec.
                     * @member {string} dec
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @instance
                     */
                    DecProto.prototype.dec = "";
    
                    /**
                     * Encodes the specified DecProto message. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
                     * @function encode
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @static
                     * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DecProto.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.dec != null && Object.hasOwnProperty.call(message, "dec"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.dec);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified DecProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @static
                     * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DecProto.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a DecProto message from the specified reader or buffer.
                     * @function decode
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cosmos.base.v1beta1.DecProto} DecProto
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DecProto.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.DecProto();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.dec = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a DecProto message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cosmos.base.v1beta1.DecProto} DecProto
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DecProto.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a DecProto message.
                     * @function verify
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DecProto.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.dec != null && message.hasOwnProperty("dec"))
                            if (!$util.isString(message.dec))
                                return "dec: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DecProto message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cosmos.base.v1beta1.DecProto} DecProto
                     */
                    DecProto.fromObject = function fromObject(object) {
                        if (object instanceof $root.cosmos.base.v1beta1.DecProto)
                            return object;
                        var message = new $root.cosmos.base.v1beta1.DecProto();
                        if (object.dec != null)
                            message.dec = String(object.dec);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DecProto message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @static
                     * @param {cosmos.base.v1beta1.DecProto} message DecProto
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DecProto.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.dec = "";
                        if (message.dec != null && message.hasOwnProperty("dec"))
                            object.dec = message.dec;
                        return object;
                    };
    
                    /**
                     * Converts this DecProto to JSON.
                     * @function toJSON
                     * @memberof cosmos.base.v1beta1.DecProto
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DecProto.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DecProto;
                })();
    
                return v1beta1;
            })();
    
            base.query = (function() {
    
                /**
                 * Namespace query.
                 * @memberof cosmos.base
                 * @namespace
                 */
                var query = {};
    
                query.v1beta1 = (function() {
    
                    /**
                     * Namespace v1beta1.
                     * @memberof cosmos.base.query
                     * @namespace
                     */
                    var v1beta1 = {};
    
                    v1beta1.PageRequest = (function() {
    
                        /**
                         * Properties of a PageRequest.
                         * @memberof cosmos.base.query.v1beta1
                         * @interface IPageRequest
                         * @property {Uint8Array|null} [key] PageRequest key
                         * @property {Long|null} [offset] PageRequest offset
                         * @property {Long|null} [limit] PageRequest limit
                         * @property {boolean|null} [count_total] PageRequest count_total
                         */
    
                        /**
                         * Constructs a new PageRequest.
                         * @memberof cosmos.base.query.v1beta1
                         * @classdesc Represents a PageRequest.
                         * @implements IPageRequest
                         * @constructor
                         * @param {cosmos.base.query.v1beta1.IPageRequest=} [properties] Properties to set
                         */
                        function PageRequest(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * PageRequest key.
                         * @member {Uint8Array} key
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @instance
                         */
                        PageRequest.prototype.key = $util.newBuffer([]);
    
                        /**
                         * PageRequest offset.
                         * @member {Long} offset
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @instance
                         */
                        PageRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * PageRequest limit.
                         * @member {Long} limit
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @instance
                         */
                        PageRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * PageRequest count_total.
                         * @member {boolean} count_total
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @instance
                         */
                        PageRequest.prototype.count_total = false;
    
                        /**
                         * Encodes the specified PageRequest message. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
                         * @function encode
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @static
                         * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PageRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.offset);
                            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.limit);
                            if (message.count_total != null && Object.hasOwnProperty.call(message, "count_total"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.count_total);
                            return writer;
                        };
    
                        /**
                         * Encodes the specified PageRequest message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @static
                         * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes a PageRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PageRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.query.v1beta1.PageRequest();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.key = reader.bytes();
                                    break;
                                case 2:
                                    message.offset = reader.uint64();
                                    break;
                                case 3:
                                    message.limit = reader.uint64();
                                    break;
                                case 4:
                                    message.count_total = reader.bool();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes a PageRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PageRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies a PageRequest message.
                         * @function verify
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PageRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.key != null && message.hasOwnProperty("key"))
                                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                                    return "key: buffer expected";
                            if (message.offset != null && message.hasOwnProperty("offset"))
                                if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                                    return "offset: integer|Long expected";
                            if (message.limit != null && message.hasOwnProperty("limit"))
                                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                                    return "limit: integer|Long expected";
                            if (message.count_total != null && message.hasOwnProperty("count_total"))
                                if (typeof message.count_total !== "boolean")
                                    return "count_total: boolean expected";
                            return null;
                        };
    
                        /**
                         * Creates a PageRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
                         */
                        PageRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.cosmos.base.query.v1beta1.PageRequest)
                                return object;
                            var message = new $root.cosmos.base.query.v1beta1.PageRequest();
                            if (object.key != null)
                                if (typeof object.key === "string")
                                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                                else if (object.key.length)
                                    message.key = object.key;
                            if (object.offset != null)
                                if ($util.Long)
                                    (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
                                else if (typeof object.offset === "string")
                                    message.offset = parseInt(object.offset, 10);
                                else if (typeof object.offset === "number")
                                    message.offset = object.offset;
                                else if (typeof object.offset === "object")
                                    message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
                            if (object.limit != null)
                                if ($util.Long)
                                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                                else if (typeof object.limit === "string")
                                    message.limit = parseInt(object.limit, 10);
                                else if (typeof object.limit === "number")
                                    message.limit = object.limit;
                                else if (typeof object.limit === "object")
                                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                            if (object.count_total != null)
                                message.count_total = Boolean(object.count_total);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a PageRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @static
                         * @param {cosmos.base.query.v1beta1.PageRequest} message PageRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PageRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if (options.bytes === String)
                                    object.key = "";
                                else {
                                    object.key = [];
                                    if (options.bytes !== Array)
                                        object.key = $util.newBuffer(object.key);
                                }
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.offset = options.longs === String ? "0" : 0;
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.limit = options.longs === String ? "0" : 0;
                                object.count_total = false;
                            }
                            if (message.key != null && message.hasOwnProperty("key"))
                                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                            if (message.offset != null && message.hasOwnProperty("offset"))
                                if (typeof message.offset === "number")
                                    object.offset = options.longs === String ? String(message.offset) : message.offset;
                                else
                                    object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true) : message.offset;
                            if (message.limit != null && message.hasOwnProperty("limit"))
                                if (typeof message.limit === "number")
                                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                                else
                                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                            if (message.count_total != null && message.hasOwnProperty("count_total"))
                                object.count_total = message.count_total;
                            return object;
                        };
    
                        /**
                         * Converts this PageRequest to JSON.
                         * @function toJSON
                         * @memberof cosmos.base.query.v1beta1.PageRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PageRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return PageRequest;
                    })();
    
                    v1beta1.PageResponse = (function() {
    
                        /**
                         * Properties of a PageResponse.
                         * @memberof cosmos.base.query.v1beta1
                         * @interface IPageResponse
                         * @property {Uint8Array|null} [next_key] PageResponse next_key
                         * @property {Long|null} [total] PageResponse total
                         */
    
                        /**
                         * Constructs a new PageResponse.
                         * @memberof cosmos.base.query.v1beta1
                         * @classdesc Represents a PageResponse.
                         * @implements IPageResponse
                         * @constructor
                         * @param {cosmos.base.query.v1beta1.IPageResponse=} [properties] Properties to set
                         */
                        function PageResponse(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * PageResponse next_key.
                         * @member {Uint8Array} next_key
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @instance
                         */
                        PageResponse.prototype.next_key = $util.newBuffer([]);
    
                        /**
                         * PageResponse total.
                         * @member {Long} total
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @instance
                         */
                        PageResponse.prototype.total = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Encodes the specified PageResponse message. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
                         * @function encode
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @static
                         * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PageResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.next_key != null && Object.hasOwnProperty.call(message, "next_key"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.next_key);
                            if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.total);
                            return writer;
                        };
    
                        /**
                         * Encodes the specified PageResponse message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @static
                         * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes a PageResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PageResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.query.v1beta1.PageResponse();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.next_key = reader.bytes();
                                    break;
                                case 2:
                                    message.total = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes a PageResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PageResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies a PageResponse message.
                         * @function verify
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PageResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.next_key != null && message.hasOwnProperty("next_key"))
                                if (!(message.next_key && typeof message.next_key.length === "number" || $util.isString(message.next_key)))
                                    return "next_key: buffer expected";
                            if (message.total != null && message.hasOwnProperty("total"))
                                if (!$util.isInteger(message.total) && !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high)))
                                    return "total: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a PageResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
                         */
                        PageResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.cosmos.base.query.v1beta1.PageResponse)
                                return object;
                            var message = new $root.cosmos.base.query.v1beta1.PageResponse();
                            if (object.next_key != null)
                                if (typeof object.next_key === "string")
                                    $util.base64.decode(object.next_key, message.next_key = $util.newBuffer($util.base64.length(object.next_key)), 0);
                                else if (object.next_key.length)
                                    message.next_key = object.next_key;
                            if (object.total != null)
                                if ($util.Long)
                                    (message.total = $util.Long.fromValue(object.total)).unsigned = true;
                                else if (typeof object.total === "string")
                                    message.total = parseInt(object.total, 10);
                                else if (typeof object.total === "number")
                                    message.total = object.total;
                                else if (typeof object.total === "object")
                                    message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a PageResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @static
                         * @param {cosmos.base.query.v1beta1.PageResponse} message PageResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PageResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if (options.bytes === String)
                                    object.next_key = "";
                                else {
                                    object.next_key = [];
                                    if (options.bytes !== Array)
                                        object.next_key = $util.newBuffer(object.next_key);
                                }
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.total = options.longs === String ? "0" : 0;
                            }
                            if (message.next_key != null && message.hasOwnProperty("next_key"))
                                object.next_key = options.bytes === String ? $util.base64.encode(message.next_key, 0, message.next_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.next_key) : message.next_key;
                            if (message.total != null && message.hasOwnProperty("total"))
                                if (typeof message.total === "number")
                                    object.total = options.longs === String ? String(message.total) : message.total;
                                else
                                    object.total = options.longs === String ? $util.Long.prototype.toString.call(message.total) : options.longs === Number ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true) : message.total;
                            return object;
                        };
    
                        /**
                         * Converts this PageResponse to JSON.
                         * @function toJSON
                         * @memberof cosmos.base.query.v1beta1.PageResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PageResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return PageResponse;
                    })();
    
                    return v1beta1;
                })();
    
                return query;
            })();
    
            return base;
        })();
    
        cosmos.msg = (function() {
    
            /**
             * Namespace msg.
             * @memberof cosmos
             * @namespace
             */
            var msg = {};
    
            msg.v1 = (function() {
    
                /**
                 * Namespace v1.
                 * @memberof cosmos.msg
                 * @namespace
                 */
                var v1 = {};
    
                return v1;
            })();
    
            return msg;
        })();
    
        return cosmos;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.Any = (function() {
    
                /**
                 * Properties of an Any.
                 * @memberof google.protobuf
                 * @interface IAny
                 * @property {string|null} [type_url] Any type_url
                 * @property {Uint8Array|null} [value] Any value
                 */
    
                /**
                 * Constructs a new Any.
                 * @memberof google.protobuf
                 * @classdesc Represents an Any.
                 * @implements IAny
                 * @constructor
                 * @param {google.protobuf.IAny=} [properties] Properties to set
                 */
                function Any(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Any type_url.
                 * @member {string} type_url
                 * @memberof google.protobuf.Any
                 * @instance
                 */
                Any.prototype.type_url = "";
    
                /**
                 * Any value.
                 * @member {Uint8Array} value
                 * @memberof google.protobuf.Any
                 * @instance
                 */
                Any.prototype.value = $util.newBuffer([]);
    
                /**
                 * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny} message Any message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Any.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny} message Any message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Any.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Any message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Any} Any
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Any.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type_url = reader.string();
                            break;
                        case 2:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Any message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Any} Any
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Any.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Any message.
                 * @function verify
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Any.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type_url != null && message.hasOwnProperty("type_url"))
                        if (!$util.isString(message.type_url))
                            return "type_url: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates an Any message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Any} Any
                 */
                Any.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Any)
                        return object;
                    var message = new $root.google.protobuf.Any();
                    if (object.type_url != null)
                        message.type_url = String(object.type_url);
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from an Any message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.Any} message Any
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Any.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type_url = "";
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    }
                    if (message.type_url != null && message.hasOwnProperty("type_url"))
                        object.type_url = message.type_url;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this Any to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Any
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Any.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Any;
            })();
    
            protobuf.Timestamp = (function() {
    
                /**
                 * Properties of a Timestamp.
                 * @memberof google.protobuf
                 * @interface ITimestamp
                 * @property {Long|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */
    
                /**
                 * Constructs a new Timestamp.
                 * @memberof google.protobuf
                 * @classdesc Represents a Timestamp.
                 * @implements ITimestamp
                 * @constructor
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Timestamp seconds.
                 * @member {Long} seconds
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;
    
                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Timestamp)
                        return object;
                    var message = new $root.google.protobuf.Timestamp();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.Timestamp} message Timestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };
    
                /**
                 * Converts this Timestamp to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Timestamp;
            })();
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<number>|null} [public_dependency] FileDescriptorProto public_dependency
                 * @property {Array.<number>|null} [weak_dependency] FileDescriptorProto weak_dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 * @property {string|null} [syntax] FileDescriptorProto syntax
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.public_dependency = [];
                    this.weak_dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto public_dependency.
                 * @member {Array.<number>} public_dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.public_dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto weak_dependency.
                 * @member {Array.<number>} weak_dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.weak_dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * FileDescriptorProto syntax.
                 * @member {string} syntax
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.syntax = "";
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && Object.hasOwnProperty.call(message, "source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.public_dependency != null && message.public_dependency.length)
                        for (var i = 0; i < message.public_dependency.length; ++i)
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.public_dependency[i]);
                    if (message.weak_dependency != null && message.weak_dependency.length)
                        for (var i = 0; i < message.weak_dependency.length; ++i)
                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weak_dependency[i]);
                    if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 10:
                            if (!(message.public_dependency && message.public_dependency.length))
                                message.public_dependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.public_dependency.push(reader.int32());
                            } else
                                message.public_dependency.push(reader.int32());
                            break;
                        case 11:
                            if (!(message.weak_dependency && message.weak_dependency.length))
                                message.weak_dependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weak_dependency.push(reader.int32());
                            } else
                                message.weak_dependency.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.syntax = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.public_dependency != null && message.hasOwnProperty("public_dependency")) {
                        if (!Array.isArray(message.public_dependency))
                            return "public_dependency: array expected";
                        for (var i = 0; i < message.public_dependency.length; ++i)
                            if (!$util.isInteger(message.public_dependency[i]))
                                return "public_dependency: integer[] expected";
                    }
                    if (message.weak_dependency != null && message.hasOwnProperty("weak_dependency")) {
                        if (!Array.isArray(message.weak_dependency))
                            return "weak_dependency: array expected";
                        for (var i = 0; i < message.weak_dependency.length; ++i)
                            if (!$util.isInteger(message.weak_dependency[i]))
                                return "weak_dependency: integer[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        if (!$util.isString(message.syntax))
                            return "syntax: string expected";
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.public_dependency) {
                        if (!Array.isArray(object.public_dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.public_dependency: array expected");
                        message.public_dependency = [];
                        for (var i = 0; i < object.public_dependency.length; ++i)
                            message.public_dependency[i] = object.public_dependency[i] | 0;
                    }
                    if (object.weak_dependency) {
                        if (!Array.isArray(object.weak_dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.weak_dependency: array expected");
                        message.weak_dependency = [];
                        for (var i = 0; i < object.weak_dependency.length; ++i)
                            message.weak_dependency[i] = object.weak_dependency[i] | 0;
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    if (object.syntax != null)
                        message.syntax = String(object.syntax);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                        object.public_dependency = [];
                        object.weak_dependency = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                        object.syntax = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    if (message.public_dependency && message.public_dependency.length) {
                        object.public_dependency = [];
                        for (var j = 0; j < message.public_dependency.length; ++j)
                            object.public_dependency[j] = message.public_dependency[j];
                    }
                    if (message.weak_dependency && message.weak_dependency.length) {
                        object.weak_dependency = [];
                        for (var j = 0; j < message.weak_dependency.length; ++j)
                            object.weak_dependency[j] = message.weak_dependency[j];
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        object.syntax = message.syntax;
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneof_decl] DescriptorProto oneof_decl
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reserved_range] DescriptorProto reserved_range
                 * @property {Array.<string>|null} [reserved_name] DescriptorProto reserved_name
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    this.oneof_decl = [];
                    this.reserved_range = [];
                    this.reserved_name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto oneof_decl.
                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneof_decl
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.oneof_decl = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * DescriptorProto reserved_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reserved_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reserved_range = $util.emptyArray;
    
                /**
                 * DescriptorProto reserved_name.
                 * @member {Array.<string>} reserved_name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reserved_name = $util.emptyArray;
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.oneof_decl != null && message.oneof_decl.length)
                        for (var i = 0; i < message.oneof_decl.length; ++i)
                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneof_decl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.reserved_range != null && message.reserved_range.length)
                        for (var i = 0; i < message.reserved_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reserved_range[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.reserved_name != null && message.reserved_name.length)
                        for (var i = 0; i < message.reserved_name.length; ++i)
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reserved_name[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.oneof_decl && message.oneof_decl.length))
                                message.oneof_decl = [];
                            message.oneof_decl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.reserved_range && message.reserved_range.length))
                                message.reserved_range = [];
                            message.reserved_range.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.reserved_name && message.reserved_name.length))
                                message.reserved_name = [];
                            message.reserved_name.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.oneof_decl != null && message.hasOwnProperty("oneof_decl")) {
                        if (!Array.isArray(message.oneof_decl))
                            return "oneof_decl: array expected";
                        for (var i = 0; i < message.oneof_decl.length; ++i) {
                            var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneof_decl[i]);
                            if (error)
                                return "oneof_decl." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.reserved_range != null && message.hasOwnProperty("reserved_range")) {
                        if (!Array.isArray(message.reserved_range))
                            return "reserved_range: array expected";
                        for (var i = 0; i < message.reserved_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reserved_range[i]);
                            if (error)
                                return "reserved_range." + error;
                        }
                    }
                    if (message.reserved_name != null && message.hasOwnProperty("reserved_name")) {
                        if (!Array.isArray(message.reserved_name))
                            return "reserved_name: array expected";
                        for (var i = 0; i < message.reserved_name.length; ++i)
                            if (!$util.isString(message.reserved_name[i]))
                                return "reserved_name: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.oneof_decl) {
                        if (!Array.isArray(object.oneof_decl))
                            throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: array expected");
                        message.oneof_decl = [];
                        for (var i = 0; i < object.oneof_decl.length; ++i) {
                            if (typeof object.oneof_decl[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: object expected");
                            message.oneof_decl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneof_decl[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    if (object.reserved_range) {
                        if (!Array.isArray(object.reserved_range))
                            throw TypeError(".google.protobuf.DescriptorProto.reserved_range: array expected");
                        message.reserved_range = [];
                        for (var i = 0; i < object.reserved_range.length; ++i) {
                            if (typeof object.reserved_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.reserved_range: object expected");
                            message.reserved_range[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reserved_range[i]);
                        }
                    }
                    if (object.reserved_name) {
                        if (!Array.isArray(object.reserved_name))
                            throw TypeError(".google.protobuf.DescriptorProto.reserved_name: array expected");
                        message.reserved_name = [];
                        for (var i = 0; i < object.reserved_name.length; ++i)
                            message.reserved_name[i] = String(object.reserved_name[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                        object.oneof_decl = [];
                        object.reserved_range = [];
                        object.reserved_name = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    if (message.oneof_decl && message.oneof_decl.length) {
                        object.oneof_decl = [];
                        for (var j = 0; j < message.oneof_decl.length; ++j)
                            object.oneof_decl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneof_decl[j], options);
                    }
                    if (message.reserved_range && message.reserved_range.length) {
                        object.reserved_range = [];
                        for (var j = 0; j < message.reserved_range.length; ++j)
                            object.reserved_range[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reserved_range[j], options);
                    }
                    if (message.reserved_name && message.reserved_name.length) {
                        object.reserved_name = [];
                        for (var j = 0; j < message.reserved_name.length; ++j)
                            object.reserved_name[j] = message.reserved_name[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                DescriptorProto.ReservedRange = (function() {
    
                    /**
                     * Properties of a ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IReservedRange
                     * @property {number|null} [start] ReservedRange start
                     * @property {number|null} [end] ReservedRange end
                     */
    
                    /**
                     * Constructs a new ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents a ReservedRange.
                     * @implements IReservedRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     */
                    function ReservedRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ReservedRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.start = 0;
    
                    /**
                     * ReservedRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.end = 0;
    
                    /**
                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a ReservedRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ReservedRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     */
                    ReservedRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ReservedRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ReservedRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ReservedRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ReservedRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {number|null} [oneof_index] FieldDescriptorProto oneof_index
                 * @property {string|null} [json_name] FieldDescriptorProto json_name
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto oneof_index.
                 * @member {number} oneof_index
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.oneof_index = 0;
    
                /**
                 * FieldDescriptorProto json_name.
                 * @member {string} json_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.json_name = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && Object.hasOwnProperty.call(message, "type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && Object.hasOwnProperty.call(message, "default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.oneof_index != null && Object.hasOwnProperty.call(message, "oneof_index"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneof_index);
                    if (message.json_name != null && Object.hasOwnProperty.call(message, "json_name"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.json_name);
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 9:
                            message.oneof_index = reader.int32();
                            break;
                        case 10:
                            message.json_name = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                        if (!$util.isInteger(message.oneof_index))
                            return "oneof_index: integer expected";
                    if (message.json_name != null && message.hasOwnProperty("json_name"))
                        if (!$util.isString(message.json_name))
                            return "json_name: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.oneof_index != null)
                        message.oneof_index = object.oneof_index | 0;
                    if (object.json_name != null)
                        message.json_name = String(object.json_name);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                        object.oneof_index = 0;
                        object.json_name = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                        object.oneof_index = message.oneof_index;
                    if (message.json_name != null && message.hasOwnProperty("json_name"))
                        object.json_name = message.json_name;
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.OneofDescriptorProto = (function() {
    
                /**
                 * Properties of an OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IOneofDescriptorProto
                 * @property {string|null} [name] OneofDescriptorProto name
                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
                 */
    
                /**
                 * Constructs a new OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofDescriptorProto.
                 * @implements IOneofDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 */
                function OneofDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.name = "";
    
                /**
                 * OneofDescriptorProto options.
                 * @member {google.protobuf.IOneofOptions|null|undefined} options
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.options = null;
    
                /**
                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.OneofOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 */
                OneofDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.OneofDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this OneofDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return OneofDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 * @property {boolean|null} [client_streaming] MethodDescriptorProto client_streaming
                 * @property {boolean|null} [server_streaming] MethodDescriptorProto server_streaming
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * MethodDescriptorProto client_streaming.
                 * @member {boolean} client_streaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.client_streaming = false;
    
                /**
                 * MethodDescriptorProto server_streaming.
                 * @member {boolean} server_streaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.server_streaming = false;
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && Object.hasOwnProperty.call(message, "input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && Object.hasOwnProperty.call(message, "output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.client_streaming != null && Object.hasOwnProperty.call(message, "client_streaming"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.client_streaming);
                    if (message.server_streaming != null && Object.hasOwnProperty.call(message, "server_streaming"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.server_streaming);
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.client_streaming = reader.bool();
                            break;
                        case 6:
                            message.server_streaming = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                        if (typeof message.client_streaming !== "boolean")
                            return "client_streaming: boolean expected";
                    if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                        if (typeof message.server_streaming !== "boolean")
                            return "server_streaming: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    if (object.client_streaming != null)
                        message.client_streaming = Boolean(object.client_streaming);
                    if (object.server_streaming != null)
                        message.server_streaming = Boolean(object.server_streaming);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                        object.client_streaming = false;
                        object.server_streaming = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                        object.client_streaming = message.client_streaming;
                    if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                        object.server_streaming = message.server_streaming;
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {boolean|null} [java_string_check_utf8] FileOptions java_string_check_utf8
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {string|null} [go_package] FileOptions go_package
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {boolean|null} [deprecated] FileOptions deprecated
                 * @property {boolean|null} [cc_enable_arenas] FileOptions cc_enable_arenas
                 * @property {string|null} [objc_class_prefix] FileOptions objc_class_prefix
                 * @property {string|null} [csharp_namespace] FileOptions csharp_namespace
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions java_string_check_utf8.
                 * @member {boolean} java_string_check_utf8
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_string_check_utf8 = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions go_package.
                 * @member {string} go_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.go_package = "";
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.deprecated = false;
    
                /**
                 * FileOptions cc_enable_arenas.
                 * @member {boolean} cc_enable_arenas
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_enable_arenas = false;
    
                /**
                 * FileOptions objc_class_prefix.
                 * @member {string} objc_class_prefix
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.objc_class_prefix = "";
    
                /**
                 * FileOptions csharp_namespace.
                 * @member {string} csharp_namespace
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.csharp_namespace = "";
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && Object.hasOwnProperty.call(message, "java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, "java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && Object.hasOwnProperty.call(message, "optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, "java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.go_package != null && Object.hasOwnProperty.call(message, "go_package"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.go_package);
                    if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, "cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && Object.hasOwnProperty.call(message, "java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && Object.hasOwnProperty.call(message, "py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, "java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                    if (message.java_string_check_utf8 != null && Object.hasOwnProperty.call(message, "java_string_check_utf8"))
                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.java_string_check_utf8);
                    if (message.cc_enable_arenas != null && Object.hasOwnProperty.call(message, "cc_enable_arenas"))
                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.cc_enable_arenas);
                    if (message.objc_class_prefix != null && Object.hasOwnProperty.call(message, "objc_class_prefix"))
                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objc_class_prefix);
                    if (message.csharp_namespace != null && Object.hasOwnProperty.call(message, "csharp_namespace"))
                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharp_namespace);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 27:
                            message.java_string_check_utf8 = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 11:
                            message.go_package = reader.string();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 23:
                            message.deprecated = reader.bool();
                            break;
                        case 31:
                            message.cc_enable_arenas = reader.bool();
                            break;
                        case 36:
                            message.objc_class_prefix = reader.string();
                            break;
                        case 37:
                            message.csharp_namespace = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                        if (typeof message.java_string_check_utf8 !== "boolean")
                            return "java_string_check_utf8: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.go_package != null && message.hasOwnProperty("go_package"))
                        if (!$util.isString(message.go_package))
                            return "go_package: string expected";
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                        if (typeof message.cc_enable_arenas !== "boolean")
                            return "cc_enable_arenas: boolean expected";
                    if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                        if (!$util.isString(message.objc_class_prefix))
                            return "objc_class_prefix: string expected";
                    if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                        if (!$util.isString(message.csharp_namespace))
                            return "csharp_namespace: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    if (object.java_string_check_utf8 != null)
                        message.java_string_check_utf8 = Boolean(object.java_string_check_utf8);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.go_package != null)
                        message.go_package = String(object.go_package);
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.cc_enable_arenas != null)
                        message.cc_enable_arenas = Boolean(object.cc_enable_arenas);
                    if (object.objc_class_prefix != null)
                        message.objc_class_prefix = String(object.objc_class_prefix);
                    if (object.csharp_namespace != null)
                        message.csharp_namespace = String(object.csharp_namespace);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.go_package = "";
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                        object.deprecated = false;
                        object.java_string_check_utf8 = false;
                        object.cc_enable_arenas = false;
                        object.objc_class_prefix = "";
                        object.csharp_namespace = "";
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.go_package != null && message.hasOwnProperty("go_package"))
                        object.go_package = message.go_package;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                        object.java_string_check_utf8 = message.java_string_check_utf8;
                    if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                        object.cc_enable_arenas = message.cc_enable_arenas;
                    if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                        object.objc_class_prefix = message.objc_class_prefix;
                    if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                        object.csharp_namespace = message.csharp_namespace;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {boolean|null} [deprecated] MessageOptions deprecated
                 * @property {boolean|null} [map_entry] MessageOptions map_entry
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 * @property {Array.<string>|null} [".cosmos.msg.v1.signer"] MessageOptions .cosmos.msg.v1.signer
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    this[".cosmos.msg.v1.signer"] = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.deprecated = false;
    
                /**
                 * MessageOptions map_entry.
                 * @member {boolean} map_entry
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.map_entry = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * MessageOptions .cosmos.msg.v1.signer.
                 * @member {Array.<string>} .cosmos.msg.v1.signer
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype[".cosmos.msg.v1.signer"] = $util.emptyArray;
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, "message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, "no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.map_entry != null && Object.hasOwnProperty.call(message, "map_entry"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.map_entry);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".cosmos.msg.v1.signer"] != null && message[".cosmos.msg.v1.signer"].length)
                        for (var i = 0; i < message[".cosmos.msg.v1.signer"].length; ++i)
                            writer.uint32(/* id 11110000, wireType 2 =*/88880002).string(message[".cosmos.msg.v1.signer"][i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 7:
                            message.map_entry = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 11110000:
                            if (!(message[".cosmos.msg.v1.signer"] && message[".cosmos.msg.v1.signer"].length))
                                message[".cosmos.msg.v1.signer"] = [];
                            message[".cosmos.msg.v1.signer"].push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                        if (typeof message.map_entry !== "boolean")
                            return "map_entry: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".cosmos.msg.v1.signer"] != null && message.hasOwnProperty(".cosmos.msg.v1.signer")) {
                        if (!Array.isArray(message[".cosmos.msg.v1.signer"]))
                            return ".cosmos.msg.v1.signer: array expected";
                        for (var i = 0; i < message[".cosmos.msg.v1.signer"].length; ++i)
                            if (!$util.isString(message[".cosmos.msg.v1.signer"][i]))
                                return ".cosmos.msg.v1.signer: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.map_entry != null)
                        message.map_entry = Boolean(object.map_entry);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".cosmos.msg.v1.signer"]) {
                        if (!Array.isArray(object[".cosmos.msg.v1.signer"]))
                            throw TypeError(".google.protobuf.MessageOptions..cosmos.msg.v1.signer: array expected");
                        message[".cosmos.msg.v1.signer"] = [];
                        for (var i = 0; i < object[".cosmos.msg.v1.signer"].length; ++i)
                            message[".cosmos.msg.v1.signer"][i] = String(object[".cosmos.msg.v1.signer"][i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.uninterpreted_option = [];
                        object[".cosmos.msg.v1.signer"] = [];
                    }
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                        object.deprecated = false;
                        object.map_entry = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                        object.map_entry = message.map_entry;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".cosmos.msg.v1.signer"] && message[".cosmos.msg.v1.signer"].length) {
                        object[".cosmos.msg.v1.signer"] = [];
                        for (var j = 0; j < message[".cosmos.msg.v1.signer"].length; ++j)
                            object[".cosmos.msg.v1.signer"][j] = message[".cosmos.msg.v1.signer"][j];
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
                 * @property {boolean|null} [lazy] FieldOptions lazy
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {boolean|null} [weak] FieldOptions weak
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions jstype.
                 * @member {google.protobuf.FieldOptions.JSType} jstype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.jstype = 0;
    
                /**
                 * FieldOptions lazy.
                 * @member {boolean} lazy
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.lazy = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions weak.
                 * @member {boolean} weak
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.weak = false;
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                    if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                    if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 6:
                            message.jstype = reader.int32();
                            break;
                        case 5:
                            message.lazy = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 10:
                            message.weak = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        switch (message.jstype) {
                        default:
                            return "jstype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        if (typeof message.lazy !== "boolean")
                            return "lazy: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        if (typeof message.weak !== "boolean")
                            return "weak: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    switch (object.jstype) {
                    case "JS_NORMAL":
                    case 0:
                        message.jstype = 0;
                        break;
                    case "JS_STRING":
                    case 1:
                        message.jstype = 1;
                        break;
                    case "JS_NUMBER":
                    case 2:
                        message.jstype = 2;
                        break;
                    }
                    if (object.lazy != null)
                        message.lazy = Boolean(object.lazy);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.weak != null)
                        message.weak = Boolean(object.weak);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.lazy = false;
                        object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                        object.weak = false;
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        object.lazy = message.lazy;
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        object.weak = message.weak;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                /**
                 * JSType enum.
                 * @name google.protobuf.FieldOptions.JSType
                 * @enum {number}
                 * @property {number} JS_NORMAL=0 JS_NORMAL value
                 * @property {number} JS_STRING=1 JS_STRING value
                 * @property {number} JS_NUMBER=2 JS_NUMBER value
                 */
                FieldOptions.JSType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JS_NORMAL"] = 0;
                    values[valuesById[1] = "JS_STRING"] = 1;
                    values[valuesById[2] = "JS_NUMBER"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.OneofOptions = (function() {
    
                /**
                 * Properties of an OneofOptions.
                 * @memberof google.protobuf
                 * @interface IOneofOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] OneofOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new OneofOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofOptions.
                 * @implements IOneofOptions
                 * @constructor
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 */
                function OneofOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 */
                OneofOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofOptions message.
                 * @function verify
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 */
                OneofOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofOptions)
                        return object;
                    var message = new $root.google.protobuf.OneofOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.OneofOptions} message OneofOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this OneofOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return OneofOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {boolean|null} [allow_alias] EnumOptions allow_alias
                 * @property {boolean|null} [deprecated] EnumOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions allow_alias.
                 * @member {boolean} allow_alias
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.allow_alias = false;
    
                /**
                 * EnumOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.deprecated = false;
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allow_alias != null && Object.hasOwnProperty.call(message, "allow_alias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allow_alias);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.allow_alias = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                        if (typeof message.allow_alias !== "boolean")
                            return "allow_alias: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.allow_alias != null)
                        message.allow_alias = Boolean(object.allow_alias);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.allow_alias = false;
                        object.deprecated = false;
                    }
                    if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                        object.allow_alias = message.allow_alias;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.deprecated = false;
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {boolean|null} [deprecated] ServiceOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 * @property {boolean|null} [".cosmos.msg.v1.service"] ServiceOptions .cosmos.msg.v1.service
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.deprecated = false;
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * ServiceOptions .cosmos.msg.v1.service.
                 * @member {boolean} .cosmos.msg.v1.service
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype[".cosmos.msg.v1.service"] = false;
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".cosmos.msg.v1.service"] != null && Object.hasOwnProperty.call(message, ".cosmos.msg.v1.service"))
                        writer.uint32(/* id 11110000, wireType 0 =*/88880000).bool(message[".cosmos.msg.v1.service"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 11110000:
                            message[".cosmos.msg.v1.service"] = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".cosmos.msg.v1.service"] != null && message.hasOwnProperty(".cosmos.msg.v1.service"))
                        if (typeof message[".cosmos.msg.v1.service"] !== "boolean")
                            return ".cosmos.msg.v1.service: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".cosmos.msg.v1.service"] != null)
                        message[".cosmos.msg.v1.service"] = Boolean(object[".cosmos.msg.v1.service"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.deprecated = false;
                        object[".cosmos.msg.v1.service"] = false;
                    }
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".cosmos.msg.v1.service"] != null && message.hasOwnProperty(".cosmos.msg.v1.service"))
                        object[".cosmos.msg.v1.service"] = message[".cosmos.msg.v1.service"];
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {boolean|null} [deprecated] MethodOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.deprecated = false;
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * MethodOptions .google.api.http.
                 * @member {google.api.IHttpRule|null|undefined} .google.api.http
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype[".google.api.http"] = null;
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".google.api.http"] != null && Object.hasOwnProperty.call(message, ".google.api.http"))
                        $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 72295728:
                            message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                        var error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                        if (error)
                            return ".google.api.http." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".google.api.http"] != null) {
                        if (typeof object[".google.api.http"] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                        message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.deprecated = false;
                        object[".google.api.http"] = null;
                    }
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                        object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && Object.hasOwnProperty.call(message, "identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && Object.hasOwnProperty.call(message, "positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && Object.hasOwnProperty.call(message, "negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && Object.hasOwnProperty.call(message, "aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     * @property {string|null} [leading_comments] Location leading_comments
                     * @property {string|null} [trailing_comments] Location trailing_comments
                     * @property {Array.<string>|null} [leading_detached_comments] Location leading_detached_comments
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        this.leading_detached_comments = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Location leading_comments.
                     * @member {string} leading_comments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leading_comments = "";
    
                    /**
                     * Location trailing_comments.
                     * @member {string} trailing_comments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.trailing_comments = "";
    
                    /**
                     * Location leading_detached_comments.
                     * @member {Array.<string>} leading_detached_comments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leading_detached_comments = $util.emptyArray;
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        if (message.leading_comments != null && Object.hasOwnProperty.call(message, "leading_comments"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leading_comments);
                        if (message.trailing_comments != null && Object.hasOwnProperty.call(message, "trailing_comments"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailing_comments);
                        if (message.leading_detached_comments != null && message.leading_detached_comments.length)
                            for (var i = 0; i < message.leading_detached_comments.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leading_detached_comments[i]);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            case 3:
                                message.leading_comments = reader.string();
                                break;
                            case 4:
                                message.trailing_comments = reader.string();
                                break;
                            case 6:
                                if (!(message.leading_detached_comments && message.leading_detached_comments.length))
                                    message.leading_detached_comments = [];
                                message.leading_detached_comments.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                            if (!$util.isString(message.leading_comments))
                                return "leading_comments: string expected";
                        if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                            if (!$util.isString(message.trailing_comments))
                                return "trailing_comments: string expected";
                        if (message.leading_detached_comments != null && message.hasOwnProperty("leading_detached_comments")) {
                            if (!Array.isArray(message.leading_detached_comments))
                                return "leading_detached_comments: array expected";
                            for (var i = 0; i < message.leading_detached_comments.length; ++i)
                                if (!$util.isString(message.leading_detached_comments[i]))
                                    return "leading_detached_comments: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        if (object.leading_comments != null)
                            message.leading_comments = String(object.leading_comments);
                        if (object.trailing_comments != null)
                            message.trailing_comments = String(object.trailing_comments);
                        if (object.leading_detached_comments) {
                            if (!Array.isArray(object.leading_detached_comments))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.leading_detached_comments: array expected");
                            message.leading_detached_comments = [];
                            for (var i = 0; i < object.leading_detached_comments.length; ++i)
                                message.leading_detached_comments[i] = String(object.leading_detached_comments[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                            object.leading_detached_comments = [];
                        }
                        if (options.defaults) {
                            object.leading_comments = "";
                            object.trailing_comments = "";
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                            object.leading_comments = message.leading_comments;
                        if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                            object.trailing_comments = message.trailing_comments;
                        if (message.leading_detached_comments && message.leading_detached_comments.length) {
                            object.leading_detached_comments = [];
                            for (var j = 0; j < message.leading_detached_comments.length; ++j)
                                object.leading_detached_comments[j] = message.leading_detached_comments[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            protobuf.GeneratedCodeInfo = (function() {
    
                /**
                 * Properties of a GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @interface IGeneratedCodeInfo
                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
                 */
    
                /**
                 * Constructs a new GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a GeneratedCodeInfo.
                 * @implements IGeneratedCodeInfo
                 * @constructor
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 */
                function GeneratedCodeInfo(properties) {
                    this.annotation = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeneratedCodeInfo annotation.
                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 */
                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
    
                /**
                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.annotation != null && message.annotation.length)
                        for (var i = 0; i < message.annotation.length; ++i)
                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GeneratedCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeneratedCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.annotation != null && message.hasOwnProperty("annotation")) {
                        if (!Array.isArray(message.annotation))
                            return "annotation: array expected";
                        for (var i = 0; i < message.annotation.length; ++i) {
                            var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                            if (error)
                                return "annotation." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 */
                GeneratedCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo();
                    if (object.annotation) {
                        if (!Array.isArray(object.annotation))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                        message.annotation = [];
                        for (var i = 0; i < object.annotation.length; ++i) {
                            if (typeof object.annotation[i] !== "object")
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                            message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeneratedCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.annotation = [];
                    if (message.annotation && message.annotation.length) {
                        object.annotation = [];
                        for (var j = 0; j < message.annotation.length; ++j)
                            object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GeneratedCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                GeneratedCodeInfo.Annotation = (function() {
    
                    /**
                     * Properties of an Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @interface IAnnotation
                     * @property {Array.<number>|null} [path] Annotation path
                     * @property {string|null} [source_file] Annotation source_file
                     * @property {number|null} [begin] Annotation begin
                     * @property {number|null} [end] Annotation end
                     */
    
                    /**
                     * Constructs a new Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @classdesc Represents an Annotation.
                     * @implements IAnnotation
                     * @constructor
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     */
                    function Annotation(properties) {
                        this.path = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Annotation path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.path = $util.emptyArray;
    
                    /**
                     * Annotation source_file.
                     * @member {string} source_file
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.source_file = "";
    
                    /**
                     * Annotation begin.
                     * @member {number} begin
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.begin = 0;
    
                    /**
                     * Annotation end.
                     * @member {number} end
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.end = 0;
    
                    /**
                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.source_file != null && Object.hasOwnProperty.call(message, "source_file"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.source_file);
                        if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                message.source_file = reader.string();
                                break;
                            case 3:
                                message.begin = reader.int32();
                                break;
                            case 4:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Annotation message.
                     * @function verify
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Annotation.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.source_file != null && message.hasOwnProperty("source_file"))
                            if (!$util.isString(message.source_file))
                                return "source_file: string expected";
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            if (!$util.isInteger(message.begin))
                                return "begin: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     */
                    Annotation.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                            return object;
                        var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.source_file != null)
                            message.source_file = String(object.source_file);
                        if (object.begin != null)
                            message.begin = object.begin | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Annotation.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.path = [];
                        if (options.defaults) {
                            object.source_file = "";
                            object.begin = 0;
                            object.end = 0;
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.source_file != null && message.hasOwnProperty("source_file"))
                            object.source_file = message.source_file;
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            object.begin = message.begin;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this Annotation to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Annotation.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Annotation;
                })();
    
                return GeneratedCodeInfo;
            })();
    
            protobuf.Duration = (function() {
    
                /**
                 * Properties of a Duration.
                 * @memberof google.protobuf
                 * @interface IDuration
                 * @property {Long|null} [seconds] Duration seconds
                 * @property {number|null} [nanos] Duration nanos
                 */
    
                /**
                 * Constructs a new Duration.
                 * @memberof google.protobuf
                 * @classdesc Represents a Duration.
                 * @implements IDuration
                 * @constructor
                 * @param {google.protobuf.IDuration=} [properties] Properties to set
                 */
                function Duration(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Duration seconds.
                 * @member {Long} seconds
                 * @memberof google.protobuf.Duration
                 * @instance
                 */
                Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Duration nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Duration
                 * @instance
                 */
                Duration.prototype.nanos = 0;
    
                /**
                 * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {google.protobuf.IDuration} message Duration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {google.protobuf.IDuration} message Duration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duration.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Duration message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Duration} Duration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Duration message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Duration} Duration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duration.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Duration message.
                 * @function verify
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Duration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                /**
                 * Creates a Duration message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Duration} Duration
                 */
                Duration.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Duration)
                        return object;
                    var message = new $root.google.protobuf.Duration();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a Duration message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {google.protobuf.Duration} message Duration
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Duration.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };
    
                /**
                 * Converts this Duration to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Duration
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Duration.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Duration;
            })();
    
            return protobuf;
        })();
    
        google.api = (function() {
    
            /**
             * Namespace api.
             * @memberof google
             * @namespace
             */
            var api = {};
    
            api.Http = (function() {
    
                /**
                 * Properties of a Http.
                 * @memberof google.api
                 * @interface IHttp
                 * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
                 */
    
                /**
                 * Constructs a new Http.
                 * @memberof google.api
                 * @classdesc Represents a Http.
                 * @implements IHttp
                 * @constructor
                 * @param {google.api.IHttp=} [properties] Properties to set
                 */
                function Http(properties) {
                    this.rules = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Http rules.
                 * @member {Array.<google.api.IHttpRule>} rules
                 * @memberof google.api.Http
                 * @instance
                 */
                Http.prototype.rules = $util.emptyArray;
    
                /**
                 * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.Http
                 * @static
                 * @param {google.api.IHttp} message Http message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Http.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rules != null && message.rules.length)
                        for (var i = 0; i < message.rules.length; ++i)
                            $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.api.Http
                 * @static
                 * @param {google.api.IHttp} message Http message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Http.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Http message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.Http
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.Http} Http
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Http.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.rules && message.rules.length))
                                message.rules = [];
                            message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Http message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.api.Http
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.api.Http} Http
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Http.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Http message.
                 * @function verify
                 * @memberof google.api.Http
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Http.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rules != null && message.hasOwnProperty("rules")) {
                        if (!Array.isArray(message.rules))
                            return "rules: array expected";
                        for (var i = 0; i < message.rules.length; ++i) {
                            var error = $root.google.api.HttpRule.verify(message.rules[i]);
                            if (error)
                                return "rules." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Http message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.api.Http
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.api.Http} Http
                 */
                Http.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.api.Http)
                        return object;
                    var message = new $root.google.api.Http();
                    if (object.rules) {
                        if (!Array.isArray(object.rules))
                            throw TypeError(".google.api.Http.rules: array expected");
                        message.rules = [];
                        for (var i = 0; i < object.rules.length; ++i) {
                            if (typeof object.rules[i] !== "object")
                                throw TypeError(".google.api.Http.rules: object expected");
                            message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Http message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.api.Http
                 * @static
                 * @param {google.api.Http} message Http
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Http.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rules = [];
                    if (message.rules && message.rules.length) {
                        object.rules = [];
                        for (var j = 0; j < message.rules.length; ++j)
                            object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Http to JSON.
                 * @function toJSON
                 * @memberof google.api.Http
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Http.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Http;
            })();
    
            api.HttpRule = (function() {
    
                /**
                 * Properties of a HttpRule.
                 * @memberof google.api
                 * @interface IHttpRule
                 * @property {string|null} [get] HttpRule get
                 * @property {string|null} [put] HttpRule put
                 * @property {string|null} [post] HttpRule post
                 * @property {string|null} ["delete"] HttpRule delete
                 * @property {string|null} [patch] HttpRule patch
                 * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
                 * @property {string|null} [selector] HttpRule selector
                 * @property {string|null} [body] HttpRule body
                 * @property {Array.<google.api.IHttpRule>|null} [additional_bindings] HttpRule additional_bindings
                 */
    
                /**
                 * Constructs a new HttpRule.
                 * @memberof google.api
                 * @classdesc Represents a HttpRule.
                 * @implements IHttpRule
                 * @constructor
                 * @param {google.api.IHttpRule=} [properties] Properties to set
                 */
                function HttpRule(properties) {
                    this.additional_bindings = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * HttpRule get.
                 * @member {string|null|undefined} get
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.get = null;
    
                /**
                 * HttpRule put.
                 * @member {string|null|undefined} put
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.put = null;
    
                /**
                 * HttpRule post.
                 * @member {string|null|undefined} post
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.post = null;
    
                /**
                 * HttpRule delete.
                 * @member {string|null|undefined} delete
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype["delete"] = null;
    
                /**
                 * HttpRule patch.
                 * @member {string|null|undefined} patch
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.patch = null;
    
                /**
                 * HttpRule custom.
                 * @member {google.api.ICustomHttpPattern|null|undefined} custom
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.custom = null;
    
                /**
                 * HttpRule selector.
                 * @member {string} selector
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.selector = "";
    
                /**
                 * HttpRule body.
                 * @member {string} body
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.body = "";
    
                /**
                 * HttpRule additional_bindings.
                 * @member {Array.<google.api.IHttpRule>} additional_bindings
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.additional_bindings = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * HttpRule pattern.
                 * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                Object.defineProperty(HttpRule.prototype, "pattern", {
                    get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HttpRule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.selector != null && Object.hasOwnProperty.call(message, "selector"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                    if (message.get != null && Object.hasOwnProperty.call(message, "get"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                    if (message.put != null && Object.hasOwnProperty.call(message, "put"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                    if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                    if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                    if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                    if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                    if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
                        $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.additional_bindings != null && message.additional_bindings.length)
                        for (var i = 0; i < message.additional_bindings.length; ++i)
                            $root.google.api.HttpRule.encode(message.additional_bindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a HttpRule message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.HttpRule} HttpRule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HttpRule.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.get = reader.string();
                            break;
                        case 3:
                            message.put = reader.string();
                            break;
                        case 4:
                            message.post = reader.string();
                            break;
                        case 5:
                            message["delete"] = reader.string();
                            break;
                        case 6:
                            message.patch = reader.string();
                            break;
                        case 8:
                            message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                            break;
                        case 1:
                            message.selector = reader.string();
                            break;
                        case 7:
                            message.body = reader.string();
                            break;
                        case 11:
                            if (!(message.additional_bindings && message.additional_bindings.length))
                                message.additional_bindings = [];
                            message.additional_bindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a HttpRule message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.api.HttpRule} HttpRule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HttpRule.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a HttpRule message.
                 * @function verify
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HttpRule.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.get != null && message.hasOwnProperty("get")) {
                        properties.pattern = 1;
                        if (!$util.isString(message.get))
                            return "get: string expected";
                    }
                    if (message.put != null && message.hasOwnProperty("put")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message.put))
                            return "put: string expected";
                    }
                    if (message.post != null && message.hasOwnProperty("post")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message.post))
                            return "post: string expected";
                    }
                    if (message["delete"] != null && message.hasOwnProperty("delete")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message["delete"]))
                            return "delete: string expected";
                    }
                    if (message.patch != null && message.hasOwnProperty("patch")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message.patch))
                            return "patch: string expected";
                    }
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        {
                            var error = $root.google.api.CustomHttpPattern.verify(message.custom);
                            if (error)
                                return "custom." + error;
                        }
                    }
                    if (message.selector != null && message.hasOwnProperty("selector"))
                        if (!$util.isString(message.selector))
                            return "selector: string expected";
                    if (message.body != null && message.hasOwnProperty("body"))
                        if (!$util.isString(message.body))
                            return "body: string expected";
                    if (message.additional_bindings != null && message.hasOwnProperty("additional_bindings")) {
                        if (!Array.isArray(message.additional_bindings))
                            return "additional_bindings: array expected";
                        for (var i = 0; i < message.additional_bindings.length; ++i) {
                            var error = $root.google.api.HttpRule.verify(message.additional_bindings[i]);
                            if (error)
                                return "additional_bindings." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.api.HttpRule} HttpRule
                 */
                HttpRule.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.api.HttpRule)
                        return object;
                    var message = new $root.google.api.HttpRule();
                    if (object.get != null)
                        message.get = String(object.get);
                    if (object.put != null)
                        message.put = String(object.put);
                    if (object.post != null)
                        message.post = String(object.post);
                    if (object["delete"] != null)
                        message["delete"] = String(object["delete"]);
                    if (object.patch != null)
                        message.patch = String(object.patch);
                    if (object.custom != null) {
                        if (typeof object.custom !== "object")
                            throw TypeError(".google.api.HttpRule.custom: object expected");
                        message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                    }
                    if (object.selector != null)
                        message.selector = String(object.selector);
                    if (object.body != null)
                        message.body = String(object.body);
                    if (object.additional_bindings) {
                        if (!Array.isArray(object.additional_bindings))
                            throw TypeError(".google.api.HttpRule.additional_bindings: array expected");
                        message.additional_bindings = [];
                        for (var i = 0; i < object.additional_bindings.length; ++i) {
                            if (typeof object.additional_bindings[i] !== "object")
                                throw TypeError(".google.api.HttpRule.additional_bindings: object expected");
                            message.additional_bindings[i] = $root.google.api.HttpRule.fromObject(object.additional_bindings[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {google.api.HttpRule} message HttpRule
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HttpRule.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.additional_bindings = [];
                    if (options.defaults) {
                        object.selector = "";
                        object.body = "";
                    }
                    if (message.selector != null && message.hasOwnProperty("selector"))
                        object.selector = message.selector;
                    if (message.get != null && message.hasOwnProperty("get")) {
                        object.get = message.get;
                        if (options.oneofs)
                            object.pattern = "get";
                    }
                    if (message.put != null && message.hasOwnProperty("put")) {
                        object.put = message.put;
                        if (options.oneofs)
                            object.pattern = "put";
                    }
                    if (message.post != null && message.hasOwnProperty("post")) {
                        object.post = message.post;
                        if (options.oneofs)
                            object.pattern = "post";
                    }
                    if (message["delete"] != null && message.hasOwnProperty("delete")) {
                        object["delete"] = message["delete"];
                        if (options.oneofs)
                            object.pattern = "delete";
                    }
                    if (message.patch != null && message.hasOwnProperty("patch")) {
                        object.patch = message.patch;
                        if (options.oneofs)
                            object.pattern = "patch";
                    }
                    if (message.body != null && message.hasOwnProperty("body"))
                        object.body = message.body;
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                        if (options.oneofs)
                            object.pattern = "custom";
                    }
                    if (message.additional_bindings && message.additional_bindings.length) {
                        object.additional_bindings = [];
                        for (var j = 0; j < message.additional_bindings.length; ++j)
                            object.additional_bindings[j] = $root.google.api.HttpRule.toObject(message.additional_bindings[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this HttpRule to JSON.
                 * @function toJSON
                 * @memberof google.api.HttpRule
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HttpRule.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return HttpRule;
            })();
    
            api.CustomHttpPattern = (function() {
    
                /**
                 * Properties of a CustomHttpPattern.
                 * @memberof google.api
                 * @interface ICustomHttpPattern
                 * @property {string|null} [kind] CustomHttpPattern kind
                 * @property {string|null} [path] CustomHttpPattern path
                 */
    
                /**
                 * Constructs a new CustomHttpPattern.
                 * @memberof google.api
                 * @classdesc Represents a CustomHttpPattern.
                 * @implements ICustomHttpPattern
                 * @constructor
                 * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
                 */
                function CustomHttpPattern(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CustomHttpPattern kind.
                 * @member {string} kind
                 * @memberof google.api.CustomHttpPattern
                 * @instance
                 */
                CustomHttpPattern.prototype.kind = "";
    
                /**
                 * CustomHttpPattern path.
                 * @member {string} path
                 * @memberof google.api.CustomHttpPattern
                 * @instance
                 */
                CustomHttpPattern.prototype.path = "";
    
                /**
                 * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomHttpPattern.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                    return writer;
                };
    
                /**
                 * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CustomHttpPattern message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.CustomHttpPattern} CustomHttpPattern
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomHttpPattern.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.kind = reader.string();
                            break;
                        case 2:
                            message.path = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.api.CustomHttpPattern} CustomHttpPattern
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CustomHttpPattern message.
                 * @function verify
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CustomHttpPattern.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        if (!$util.isString(message.kind))
                            return "kind: string expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    return null;
                };
    
                /**
                 * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.api.CustomHttpPattern} CustomHttpPattern
                 */
                CustomHttpPattern.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.api.CustomHttpPattern)
                        return object;
                    var message = new $root.google.api.CustomHttpPattern();
                    if (object.kind != null)
                        message.kind = String(object.kind);
                    if (object.path != null)
                        message.path = String(object.path);
                    return message;
                };
    
                /**
                 * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {google.api.CustomHttpPattern} message CustomHttpPattern
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CustomHttpPattern.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.kind = "";
                        object.path = "";
                    }
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        object.kind = message.kind;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    return object;
                };
    
                /**
                 * Converts this CustomHttpPattern to JSON.
                 * @function toJSON
                 * @memberof google.api.CustomHttpPattern
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CustomHttpPattern.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CustomHttpPattern;
            })();
    
            return api;
        })();
    
        return google;
    })();
    
    $root.nftvault = (function() {
    
        /**
         * Namespace nftvault.
         * @exports nftvault
         * @namespace
         */
        var nftvault = {};
    
        nftvault.eventhook = (function() {
    
            /**
             * Namespace eventhook.
             * @memberof nftvault
             * @namespace
             */
            var eventhook = {};
    
            eventhook.Msg = (function() {
    
                /**
                 * Constructs a new Msg service.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a Msg
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Msg(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;
    
                /**
                 * Callback as used by {@link nftvault.eventhook.Msg#registerHook}.
                 * @memberof nftvault.eventhook.Msg
                 * @typedef RegisterHookCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nftvault.eventhook.MsgRegisterHookResponse} [response] MsgRegisterHookResponse
                 */
    
                /**
                 * Calls RegisterHook.
                 * @function registerHook
                 * @memberof nftvault.eventhook.Msg
                 * @instance
                 * @param {nftvault.eventhook.IMsgRegisterHook} request MsgRegisterHook message or plain object
                 * @param {nftvault.eventhook.Msg.RegisterHookCallback} callback Node-style callback called with the error, if any, and MsgRegisterHookResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.registerHook = function registerHook(request, callback) {
                    return this.rpcCall(registerHook, $root.nftvault.eventhook.MsgRegisterHook, $root.nftvault.eventhook.MsgRegisterHookResponse, request, callback);
                }, "name", { value: "RegisterHook" });
    
                /**
                 * Calls RegisterHook.
                 * @function registerHook
                 * @memberof nftvault.eventhook.Msg
                 * @instance
                 * @param {nftvault.eventhook.IMsgRegisterHook} request MsgRegisterHook message or plain object
                 * @returns {Promise<nftvault.eventhook.MsgRegisterHookResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nftvault.eventhook.Msg#unregisterHook}.
                 * @memberof nftvault.eventhook.Msg
                 * @typedef UnregisterHookCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nftvault.eventhook.MsgUnregisterHookResponse} [response] MsgUnregisterHookResponse
                 */
    
                /**
                 * Calls UnregisterHook.
                 * @function unregisterHook
                 * @memberof nftvault.eventhook.Msg
                 * @instance
                 * @param {nftvault.eventhook.IMsgUnregisterHook} request MsgUnregisterHook message or plain object
                 * @param {nftvault.eventhook.Msg.UnregisterHookCallback} callback Node-style callback called with the error, if any, and MsgUnregisterHookResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Msg.prototype.unregisterHook = function unregisterHook(request, callback) {
                    return this.rpcCall(unregisterHook, $root.nftvault.eventhook.MsgUnregisterHook, $root.nftvault.eventhook.MsgUnregisterHookResponse, request, callback);
                }, "name", { value: "UnregisterHook" });
    
                /**
                 * Calls UnregisterHook.
                 * @function unregisterHook
                 * @memberof nftvault.eventhook.Msg
                 * @instance
                 * @param {nftvault.eventhook.IMsgUnregisterHook} request MsgUnregisterHook message or plain object
                 * @returns {Promise<nftvault.eventhook.MsgUnregisterHookResponse>} Promise
                 * @variation 2
                 */
    
                return Msg;
            })();
    
            eventhook.MsgRegisterHook = (function() {
    
                /**
                 * Properties of a MsgRegisterHook.
                 * @memberof nftvault.eventhook
                 * @interface IMsgRegisterHook
                 * @property {string|null} [sender] MsgRegisterHook sender
                 * @property {string|null} [name] MsgRegisterHook name
                 * @property {string|null} [contract_address] MsgRegisterHook contract_address
                 * @property {string|null} [git_url] MsgRegisterHook git_url
                 * @property {string|null} [event_type] MsgRegisterHook event_type
                 * @property {Array.<nftvault.eventhook.IKeyValuePair>|null} [event_attributes] MsgRegisterHook event_attributes
                 */
    
                /**
                 * Constructs a new MsgRegisterHook.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a MsgRegisterHook.
                 * @implements IMsgRegisterHook
                 * @constructor
                 * @param {nftvault.eventhook.IMsgRegisterHook=} [properties] Properties to set
                 */
                function MsgRegisterHook(properties) {
                    this.event_attributes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgRegisterHook sender.
                 * @member {string} sender
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @instance
                 */
                MsgRegisterHook.prototype.sender = "";
    
                /**
                 * MsgRegisterHook name.
                 * @member {string} name
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @instance
                 */
                MsgRegisterHook.prototype.name = "";
    
                /**
                 * MsgRegisterHook contract_address.
                 * @member {string} contract_address
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @instance
                 */
                MsgRegisterHook.prototype.contract_address = "";
    
                /**
                 * MsgRegisterHook git_url.
                 * @member {string} git_url
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @instance
                 */
                MsgRegisterHook.prototype.git_url = "";
    
                /**
                 * MsgRegisterHook event_type.
                 * @member {string} event_type
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @instance
                 */
                MsgRegisterHook.prototype.event_type = "";
    
                /**
                 * MsgRegisterHook event_attributes.
                 * @member {Array.<nftvault.eventhook.IKeyValuePair>} event_attributes
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @instance
                 */
                MsgRegisterHook.prototype.event_attributes = $util.emptyArray;
    
                /**
                 * Encodes the specified MsgRegisterHook message. Does not implicitly {@link nftvault.eventhook.MsgRegisterHook.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @static
                 * @param {nftvault.eventhook.IMsgRegisterHook} message MsgRegisterHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterHook.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.contract_address != null && Object.hasOwnProperty.call(message, "contract_address"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.contract_address);
                    if (message.git_url != null && Object.hasOwnProperty.call(message, "git_url"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.git_url);
                    if (message.event_type != null && Object.hasOwnProperty.call(message, "event_type"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.event_type);
                    if (message.event_attributes != null && message.event_attributes.length)
                        for (var i = 0; i < message.event_attributes.length; ++i)
                            $root.nftvault.eventhook.KeyValuePair.encode(message.event_attributes[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRegisterHook message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgRegisterHook.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @static
                 * @param {nftvault.eventhook.IMsgRegisterHook} message MsgRegisterHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterHook.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRegisterHook message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.MsgRegisterHook} MsgRegisterHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterHook.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.MsgRegisterHook();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.contract_address = reader.string();
                            break;
                        case 4:
                            message.git_url = reader.string();
                            break;
                        case 5:
                            message.event_type = reader.string();
                            break;
                        case 6:
                            if (!(message.event_attributes && message.event_attributes.length))
                                message.event_attributes = [];
                            message.event_attributes.push($root.nftvault.eventhook.KeyValuePair.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRegisterHook message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.MsgRegisterHook} MsgRegisterHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterHook.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRegisterHook message.
                 * @function verify
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRegisterHook.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        if (!$util.isString(message.contract_address))
                            return "contract_address: string expected";
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        if (!$util.isString(message.git_url))
                            return "git_url: string expected";
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        if (!$util.isString(message.event_type))
                            return "event_type: string expected";
                    if (message.event_attributes != null && message.hasOwnProperty("event_attributes")) {
                        if (!Array.isArray(message.event_attributes))
                            return "event_attributes: array expected";
                        for (var i = 0; i < message.event_attributes.length; ++i) {
                            var error = $root.nftvault.eventhook.KeyValuePair.verify(message.event_attributes[i]);
                            if (error)
                                return "event_attributes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MsgRegisterHook message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.MsgRegisterHook} MsgRegisterHook
                 */
                MsgRegisterHook.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.MsgRegisterHook)
                        return object;
                    var message = new $root.nftvault.eventhook.MsgRegisterHook();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.contract_address != null)
                        message.contract_address = String(object.contract_address);
                    if (object.git_url != null)
                        message.git_url = String(object.git_url);
                    if (object.event_type != null)
                        message.event_type = String(object.event_type);
                    if (object.event_attributes) {
                        if (!Array.isArray(object.event_attributes))
                            throw TypeError(".nftvault.eventhook.MsgRegisterHook.event_attributes: array expected");
                        message.event_attributes = [];
                        for (var i = 0; i < object.event_attributes.length; ++i) {
                            if (typeof object.event_attributes[i] !== "object")
                                throw TypeError(".nftvault.eventhook.MsgRegisterHook.event_attributes: object expected");
                            message.event_attributes[i] = $root.nftvault.eventhook.KeyValuePair.fromObject(object.event_attributes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgRegisterHook message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @static
                 * @param {nftvault.eventhook.MsgRegisterHook} message MsgRegisterHook
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRegisterHook.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.event_attributes = [];
                    if (options.defaults) {
                        object.sender = "";
                        object.name = "";
                        object.contract_address = "";
                        object.git_url = "";
                        object.event_type = "";
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        object.contract_address = message.contract_address;
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        object.git_url = message.git_url;
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        object.event_type = message.event_type;
                    if (message.event_attributes && message.event_attributes.length) {
                        object.event_attributes = [];
                        for (var j = 0; j < message.event_attributes.length; ++j)
                            object.event_attributes[j] = $root.nftvault.eventhook.KeyValuePair.toObject(message.event_attributes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MsgRegisterHook to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.MsgRegisterHook
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRegisterHook.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRegisterHook;
            })();
    
            eventhook.MsgRegisterHookResponse = (function() {
    
                /**
                 * Properties of a MsgRegisterHookResponse.
                 * @memberof nftvault.eventhook
                 * @interface IMsgRegisterHookResponse
                 * @property {Long|null} [id] MsgRegisterHookResponse id
                 */
    
                /**
                 * Constructs a new MsgRegisterHookResponse.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a MsgRegisterHookResponse.
                 * @implements IMsgRegisterHookResponse
                 * @constructor
                 * @param {nftvault.eventhook.IMsgRegisterHookResponse=} [properties] Properties to set
                 */
                function MsgRegisterHookResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgRegisterHookResponse id.
                 * @member {Long} id
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @instance
                 */
                MsgRegisterHookResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified MsgRegisterHookResponse message. Does not implicitly {@link nftvault.eventhook.MsgRegisterHookResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @static
                 * @param {nftvault.eventhook.IMsgRegisterHookResponse} message MsgRegisterHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterHookResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgRegisterHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgRegisterHookResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @static
                 * @param {nftvault.eventhook.IMsgRegisterHookResponse} message MsgRegisterHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgRegisterHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgRegisterHookResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.MsgRegisterHookResponse} MsgRegisterHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterHookResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.MsgRegisterHookResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgRegisterHookResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.MsgRegisterHookResponse} MsgRegisterHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgRegisterHookResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgRegisterHookResponse message.
                 * @function verify
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgRegisterHookResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a MsgRegisterHookResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.MsgRegisterHookResponse} MsgRegisterHookResponse
                 */
                MsgRegisterHookResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.MsgRegisterHookResponse)
                        return object;
                    var message = new $root.nftvault.eventhook.MsgRegisterHookResponse();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgRegisterHookResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @static
                 * @param {nftvault.eventhook.MsgRegisterHookResponse} message MsgRegisterHookResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgRegisterHookResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };
    
                /**
                 * Converts this MsgRegisterHookResponse to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.MsgRegisterHookResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgRegisterHookResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgRegisterHookResponse;
            })();
    
            eventhook.MsgUnregisterHook = (function() {
    
                /**
                 * Properties of a MsgUnregisterHook.
                 * @memberof nftvault.eventhook
                 * @interface IMsgUnregisterHook
                 * @property {string|null} [sender] MsgUnregisterHook sender
                 * @property {string|null} [event_type] MsgUnregisterHook event_type
                 * @property {Long|null} [id] MsgUnregisterHook id
                 */
    
                /**
                 * Constructs a new MsgUnregisterHook.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a MsgUnregisterHook.
                 * @implements IMsgUnregisterHook
                 * @constructor
                 * @param {nftvault.eventhook.IMsgUnregisterHook=} [properties] Properties to set
                 */
                function MsgUnregisterHook(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MsgUnregisterHook sender.
                 * @member {string} sender
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @instance
                 */
                MsgUnregisterHook.prototype.sender = "";
    
                /**
                 * MsgUnregisterHook event_type.
                 * @member {string} event_type
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @instance
                 */
                MsgUnregisterHook.prototype.event_type = "";
    
                /**
                 * MsgUnregisterHook id.
                 * @member {Long} id
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @instance
                 */
                MsgUnregisterHook.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified MsgUnregisterHook message. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHook.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @static
                 * @param {nftvault.eventhook.IMsgUnregisterHook} message MsgUnregisterHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUnregisterHook.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if (message.event_type != null && Object.hasOwnProperty.call(message, "event_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.event_type);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUnregisterHook message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHook.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @static
                 * @param {nftvault.eventhook.IMsgUnregisterHook} message MsgUnregisterHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUnregisterHook.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUnregisterHook message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.MsgUnregisterHook} MsgUnregisterHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUnregisterHook.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.MsgUnregisterHook();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sender = reader.string();
                            break;
                        case 2:
                            message.event_type = reader.string();
                            break;
                        case 3:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUnregisterHook message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.MsgUnregisterHook} MsgUnregisterHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUnregisterHook.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUnregisterHook message.
                 * @function verify
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUnregisterHook.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        if (!$util.isString(message.sender))
                            return "sender: string expected";
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        if (!$util.isString(message.event_type))
                            return "event_type: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a MsgUnregisterHook message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.MsgUnregisterHook} MsgUnregisterHook
                 */
                MsgUnregisterHook.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.MsgUnregisterHook)
                        return object;
                    var message = new $root.nftvault.eventhook.MsgUnregisterHook();
                    if (object.sender != null)
                        message.sender = String(object.sender);
                    if (object.event_type != null)
                        message.event_type = String(object.event_type);
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MsgUnregisterHook message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @static
                 * @param {nftvault.eventhook.MsgUnregisterHook} message MsgUnregisterHook
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUnregisterHook.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sender = "";
                        object.event_type = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    }
                    if (message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        object.event_type = message.event_type;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };
    
                /**
                 * Converts this MsgUnregisterHook to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.MsgUnregisterHook
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUnregisterHook.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUnregisterHook;
            })();
    
            eventhook.MsgUnregisterHookResponse = (function() {
    
                /**
                 * Properties of a MsgUnregisterHookResponse.
                 * @memberof nftvault.eventhook
                 * @interface IMsgUnregisterHookResponse
                 */
    
                /**
                 * Constructs a new MsgUnregisterHookResponse.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a MsgUnregisterHookResponse.
                 * @implements IMsgUnregisterHookResponse
                 * @constructor
                 * @param {nftvault.eventhook.IMsgUnregisterHookResponse=} [properties] Properties to set
                 */
                function MsgUnregisterHookResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified MsgUnregisterHookResponse message. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHookResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @static
                 * @param {nftvault.eventhook.IMsgUnregisterHookResponse} message MsgUnregisterHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUnregisterHookResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MsgUnregisterHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHookResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @static
                 * @param {nftvault.eventhook.IMsgUnregisterHookResponse} message MsgUnregisterHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgUnregisterHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MsgUnregisterHookResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.MsgUnregisterHookResponse} MsgUnregisterHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUnregisterHookResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.MsgUnregisterHookResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MsgUnregisterHookResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.MsgUnregisterHookResponse} MsgUnregisterHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgUnregisterHookResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MsgUnregisterHookResponse message.
                 * @function verify
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgUnregisterHookResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MsgUnregisterHookResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.MsgUnregisterHookResponse} MsgUnregisterHookResponse
                 */
                MsgUnregisterHookResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.MsgUnregisterHookResponse)
                        return object;
                    return new $root.nftvault.eventhook.MsgUnregisterHookResponse();
                };
    
                /**
                 * Creates a plain object from a MsgUnregisterHookResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @static
                 * @param {nftvault.eventhook.MsgUnregisterHookResponse} message MsgUnregisterHookResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgUnregisterHookResponse.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MsgUnregisterHookResponse to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.MsgUnregisterHookResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgUnregisterHookResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MsgUnregisterHookResponse;
            })();
    
            eventhook.Hook = (function() {
    
                /**
                 * Properties of a Hook.
                 * @memberof nftvault.eventhook
                 * @interface IHook
                 * @property {Long|null} [id] Hook id
                 * @property {string|null} [name] Hook name
                 * @property {string|null} [contract_address] Hook contract_address
                 * @property {string|null} [git_url] Hook git_url
                 * @property {string|null} [event_type] Hook event_type
                 * @property {Array.<nftvault.eventhook.IKeyValuePair>|null} [event_attributes] Hook event_attributes
                 */
    
                /**
                 * Constructs a new Hook.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a Hook.
                 * @implements IHook
                 * @constructor
                 * @param {nftvault.eventhook.IHook=} [properties] Properties to set
                 */
                function Hook(properties) {
                    this.event_attributes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Hook id.
                 * @member {Long} id
                 * @memberof nftvault.eventhook.Hook
                 * @instance
                 */
                Hook.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Hook name.
                 * @member {string} name
                 * @memberof nftvault.eventhook.Hook
                 * @instance
                 */
                Hook.prototype.name = "";
    
                /**
                 * Hook contract_address.
                 * @member {string} contract_address
                 * @memberof nftvault.eventhook.Hook
                 * @instance
                 */
                Hook.prototype.contract_address = "";
    
                /**
                 * Hook git_url.
                 * @member {string} git_url
                 * @memberof nftvault.eventhook.Hook
                 * @instance
                 */
                Hook.prototype.git_url = "";
    
                /**
                 * Hook event_type.
                 * @member {string} event_type
                 * @memberof nftvault.eventhook.Hook
                 * @instance
                 */
                Hook.prototype.event_type = "";
    
                /**
                 * Hook event_attributes.
                 * @member {Array.<nftvault.eventhook.IKeyValuePair>} event_attributes
                 * @memberof nftvault.eventhook.Hook
                 * @instance
                 */
                Hook.prototype.event_attributes = $util.emptyArray;
    
                /**
                 * Encodes the specified Hook message. Does not implicitly {@link nftvault.eventhook.Hook.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.Hook
                 * @static
                 * @param {nftvault.eventhook.IHook} message Hook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hook.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.contract_address != null && Object.hasOwnProperty.call(message, "contract_address"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.contract_address);
                    if (message.git_url != null && Object.hasOwnProperty.call(message, "git_url"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.git_url);
                    if (message.event_type != null && Object.hasOwnProperty.call(message, "event_type"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.event_type);
                    if (message.event_attributes != null && message.event_attributes.length)
                        for (var i = 0; i < message.event_attributes.length; ++i)
                            $root.nftvault.eventhook.KeyValuePair.encode(message.event_attributes[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Hook message, length delimited. Does not implicitly {@link nftvault.eventhook.Hook.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.Hook
                 * @static
                 * @param {nftvault.eventhook.IHook} message Hook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hook.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Hook message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.Hook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.Hook} Hook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hook.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.Hook();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.contract_address = reader.string();
                            break;
                        case 4:
                            message.git_url = reader.string();
                            break;
                        case 5:
                            message.event_type = reader.string();
                            break;
                        case 6:
                            if (!(message.event_attributes && message.event_attributes.length))
                                message.event_attributes = [];
                            message.event_attributes.push($root.nftvault.eventhook.KeyValuePair.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Hook message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.Hook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.Hook} Hook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hook.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Hook message.
                 * @function verify
                 * @memberof nftvault.eventhook.Hook
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Hook.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        if (!$util.isString(message.contract_address))
                            return "contract_address: string expected";
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        if (!$util.isString(message.git_url))
                            return "git_url: string expected";
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        if (!$util.isString(message.event_type))
                            return "event_type: string expected";
                    if (message.event_attributes != null && message.hasOwnProperty("event_attributes")) {
                        if (!Array.isArray(message.event_attributes))
                            return "event_attributes: array expected";
                        for (var i = 0; i < message.event_attributes.length; ++i) {
                            var error = $root.nftvault.eventhook.KeyValuePair.verify(message.event_attributes[i]);
                            if (error)
                                return "event_attributes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Hook message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.Hook
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.Hook} Hook
                 */
                Hook.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.Hook)
                        return object;
                    var message = new $root.nftvault.eventhook.Hook();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.contract_address != null)
                        message.contract_address = String(object.contract_address);
                    if (object.git_url != null)
                        message.git_url = String(object.git_url);
                    if (object.event_type != null)
                        message.event_type = String(object.event_type);
                    if (object.event_attributes) {
                        if (!Array.isArray(object.event_attributes))
                            throw TypeError(".nftvault.eventhook.Hook.event_attributes: array expected");
                        message.event_attributes = [];
                        for (var i = 0; i < object.event_attributes.length; ++i) {
                            if (typeof object.event_attributes[i] !== "object")
                                throw TypeError(".nftvault.eventhook.Hook.event_attributes: object expected");
                            message.event_attributes[i] = $root.nftvault.eventhook.KeyValuePair.fromObject(object.event_attributes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Hook message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.Hook
                 * @static
                 * @param {nftvault.eventhook.Hook} message Hook
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Hook.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.event_attributes = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                        object.name = "";
                        object.contract_address = "";
                        object.git_url = "";
                        object.event_type = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                        object.contract_address = message.contract_address;
                    if (message.git_url != null && message.hasOwnProperty("git_url"))
                        object.git_url = message.git_url;
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        object.event_type = message.event_type;
                    if (message.event_attributes && message.event_attributes.length) {
                        object.event_attributes = [];
                        for (var j = 0; j < message.event_attributes.length; ++j)
                            object.event_attributes[j] = $root.nftvault.eventhook.KeyValuePair.toObject(message.event_attributes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Hook to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.Hook
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Hook.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Hook;
            })();
    
            eventhook.KeyValuePair = (function() {
    
                /**
                 * Properties of a KeyValuePair.
                 * @memberof nftvault.eventhook
                 * @interface IKeyValuePair
                 * @property {string|null} [key] KeyValuePair key
                 * @property {string|null} [value] KeyValuePair value
                 */
    
                /**
                 * Constructs a new KeyValuePair.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a KeyValuePair.
                 * @implements IKeyValuePair
                 * @constructor
                 * @param {nftvault.eventhook.IKeyValuePair=} [properties] Properties to set
                 */
                function KeyValuePair(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * KeyValuePair key.
                 * @member {string} key
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @instance
                 */
                KeyValuePair.prototype.key = "";
    
                /**
                 * KeyValuePair value.
                 * @member {string} value
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @instance
                 */
                KeyValuePair.prototype.value = "";
    
                /**
                 * Encodes the specified KeyValuePair message. Does not implicitly {@link nftvault.eventhook.KeyValuePair.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @static
                 * @param {nftvault.eventhook.IKeyValuePair} message KeyValuePair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyValuePair.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified KeyValuePair message, length delimited. Does not implicitly {@link nftvault.eventhook.KeyValuePair.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @static
                 * @param {nftvault.eventhook.IKeyValuePair} message KeyValuePair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyValuePair.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a KeyValuePair message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.KeyValuePair} KeyValuePair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyValuePair.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.KeyValuePair();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a KeyValuePair message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.KeyValuePair} KeyValuePair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyValuePair.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a KeyValuePair message.
                 * @function verify
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KeyValuePair.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };
    
                /**
                 * Creates a KeyValuePair message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.KeyValuePair} KeyValuePair
                 */
                KeyValuePair.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.KeyValuePair)
                        return object;
                    var message = new $root.nftvault.eventhook.KeyValuePair();
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a KeyValuePair message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @static
                 * @param {nftvault.eventhook.KeyValuePair} message KeyValuePair
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeyValuePair.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.key = "";
                        object.value = "";
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this KeyValuePair to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.KeyValuePair
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KeyValuePair.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return KeyValuePair;
            })();
    
            eventhook.GenesisState = (function() {
    
                /**
                 * Properties of a GenesisState.
                 * @memberof nftvault.eventhook
                 * @interface IGenesisState
                 * @property {nftvault.eventhook.IParams|null} [params] GenesisState params
                 * @property {Array.<nftvault.eventhook.IHook>|null} [hooks] GenesisState hooks
                 */
    
                /**
                 * Constructs a new GenesisState.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a GenesisState.
                 * @implements IGenesisState
                 * @constructor
                 * @param {nftvault.eventhook.IGenesisState=} [properties] Properties to set
                 */
                function GenesisState(properties) {
                    this.hooks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GenesisState params.
                 * @member {nftvault.eventhook.IParams|null|undefined} params
                 * @memberof nftvault.eventhook.GenesisState
                 * @instance
                 */
                GenesisState.prototype.params = null;
    
                /**
                 * GenesisState hooks.
                 * @member {Array.<nftvault.eventhook.IHook>} hooks
                 * @memberof nftvault.eventhook.GenesisState
                 * @instance
                 */
                GenesisState.prototype.hooks = $util.emptyArray;
    
                /**
                 * Encodes the specified GenesisState message. Does not implicitly {@link nftvault.eventhook.GenesisState.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.GenesisState
                 * @static
                 * @param {nftvault.eventhook.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.nftvault.eventhook.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.hooks != null && message.hooks.length)
                        for (var i = 0; i < message.hooks.length; ++i)
                            $root.nftvault.eventhook.Hook.encode(message.hooks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link nftvault.eventhook.GenesisState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.GenesisState
                 * @static
                 * @param {nftvault.eventhook.IGenesisState} message GenesisState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.GenesisState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.nftvault.eventhook.Params.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.hooks && message.hooks.length))
                                message.hooks = [];
                            message.hooks.push($root.nftvault.eventhook.Hook.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GenesisState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.GenesisState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.GenesisState} GenesisState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GenesisState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GenesisState message.
                 * @function verify
                 * @memberof nftvault.eventhook.GenesisState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GenesisState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.nftvault.eventhook.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.hooks != null && message.hasOwnProperty("hooks")) {
                        if (!Array.isArray(message.hooks))
                            return "hooks: array expected";
                        for (var i = 0; i < message.hooks.length; ++i) {
                            var error = $root.nftvault.eventhook.Hook.verify(message.hooks[i]);
                            if (error)
                                return "hooks." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.GenesisState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.GenesisState} GenesisState
                 */
                GenesisState.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.GenesisState)
                        return object;
                    var message = new $root.nftvault.eventhook.GenesisState();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".nftvault.eventhook.GenesisState.params: object expected");
                        message.params = $root.nftvault.eventhook.Params.fromObject(object.params);
                    }
                    if (object.hooks) {
                        if (!Array.isArray(object.hooks))
                            throw TypeError(".nftvault.eventhook.GenesisState.hooks: array expected");
                        message.hooks = [];
                        for (var i = 0; i < object.hooks.length; ++i) {
                            if (typeof object.hooks[i] !== "object")
                                throw TypeError(".nftvault.eventhook.GenesisState.hooks: object expected");
                            message.hooks[i] = $root.nftvault.eventhook.Hook.fromObject(object.hooks[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.GenesisState
                 * @static
                 * @param {nftvault.eventhook.GenesisState} message GenesisState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GenesisState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.hooks = [];
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.nftvault.eventhook.Params.toObject(message.params, options);
                    if (message.hooks && message.hooks.length) {
                        object.hooks = [];
                        for (var j = 0; j < message.hooks.length; ++j)
                            object.hooks[j] = $root.nftvault.eventhook.Hook.toObject(message.hooks[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GenesisState to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.GenesisState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GenesisState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GenesisState;
            })();
    
            eventhook.Params = (function() {
    
                /**
                 * Properties of a Params.
                 * @memberof nftvault.eventhook
                 * @interface IParams
                 */
    
                /**
                 * Constructs a new Params.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a Params.
                 * @implements IParams
                 * @constructor
                 * @param {nftvault.eventhook.IParams=} [properties] Properties to set
                 */
                function Params(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified Params message. Does not implicitly {@link nftvault.eventhook.Params.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.Params
                 * @static
                 * @param {nftvault.eventhook.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Params message, length delimited. Does not implicitly {@link nftvault.eventhook.Params.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.Params
                 * @static
                 * @param {nftvault.eventhook.IParams} message Params message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Params.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.Params();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Params message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.Params
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.Params} Params
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Params.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Params message.
                 * @function verify
                 * @memberof nftvault.eventhook.Params
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Params.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a Params message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.Params
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.Params} Params
                 */
                Params.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.Params)
                        return object;
                    return new $root.nftvault.eventhook.Params();
                };
    
                /**
                 * Creates a plain object from a Params message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.Params
                 * @static
                 * @param {nftvault.eventhook.Params} message Params
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Params.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Params to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.Params
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Params.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Params;
            })();
    
            eventhook.Query = (function() {
    
                /**
                 * Constructs a new Query service.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a Query
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Query(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;
    
                /**
                 * Callback as used by {@link nftvault.eventhook.Query#params}.
                 * @memberof nftvault.eventhook.Query
                 * @typedef ParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nftvault.eventhook.QueryParamsResponse} [response] QueryParamsResponse
                 */
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof nftvault.eventhook.Query
                 * @instance
                 * @param {nftvault.eventhook.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @param {nftvault.eventhook.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.params = function params(request, callback) {
                    return this.rpcCall(params, $root.nftvault.eventhook.QueryParamsRequest, $root.nftvault.eventhook.QueryParamsResponse, request, callback);
                }, "name", { value: "Params" });
    
                /**
                 * Calls Params.
                 * @function params
                 * @memberof nftvault.eventhook.Query
                 * @instance
                 * @param {nftvault.eventhook.IQueryParamsRequest} request QueryParamsRequest message or plain object
                 * @returns {Promise<nftvault.eventhook.QueryParamsResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nftvault.eventhook.Query#hookAll}.
                 * @memberof nftvault.eventhook.Query
                 * @typedef HookAllCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nftvault.eventhook.QueryAllHookResponse} [response] QueryAllHookResponse
                 */
    
                /**
                 * Calls HookAll.
                 * @function hookAll
                 * @memberof nftvault.eventhook.Query
                 * @instance
                 * @param {nftvault.eventhook.IQueryAllHookRequest} request QueryAllHookRequest message or plain object
                 * @param {nftvault.eventhook.Query.HookAllCallback} callback Node-style callback called with the error, if any, and QueryAllHookResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.hookAll = function hookAll(request, callback) {
                    return this.rpcCall(hookAll, $root.nftvault.eventhook.QueryAllHookRequest, $root.nftvault.eventhook.QueryAllHookResponse, request, callback);
                }, "name", { value: "HookAll" });
    
                /**
                 * Calls HookAll.
                 * @function hookAll
                 * @memberof nftvault.eventhook.Query
                 * @instance
                 * @param {nftvault.eventhook.IQueryAllHookRequest} request QueryAllHookRequest message or plain object
                 * @returns {Promise<nftvault.eventhook.QueryAllHookResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nftvault.eventhook.Query#hook}.
                 * @memberof nftvault.eventhook.Query
                 * @typedef HookCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nftvault.eventhook.QueryGetHookResponse} [response] QueryGetHookResponse
                 */
    
                /**
                 * Calls Hook.
                 * @function hook
                 * @memberof nftvault.eventhook.Query
                 * @instance
                 * @param {nftvault.eventhook.IQueryGetHookRequest} request QueryGetHookRequest message or plain object
                 * @param {nftvault.eventhook.Query.HookCallback} callback Node-style callback called with the error, if any, and QueryGetHookResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(Query.prototype.hook = function hook(request, callback) {
                    return this.rpcCall(hook, $root.nftvault.eventhook.QueryGetHookRequest, $root.nftvault.eventhook.QueryGetHookResponse, request, callback);
                }, "name", { value: "Hook" });
    
                /**
                 * Calls Hook.
                 * @function hook
                 * @memberof nftvault.eventhook.Query
                 * @instance
                 * @param {nftvault.eventhook.IQueryGetHookRequest} request QueryGetHookRequest message or plain object
                 * @returns {Promise<nftvault.eventhook.QueryGetHookResponse>} Promise
                 * @variation 2
                 */
    
                return Query;
            })();
    
            eventhook.QueryParamsRequest = (function() {
    
                /**
                 * Properties of a QueryParamsRequest.
                 * @memberof nftvault.eventhook
                 * @interface IQueryParamsRequest
                 */
    
                /**
                 * Constructs a new QueryParamsRequest.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a QueryParamsRequest.
                 * @implements IQueryParamsRequest
                 * @constructor
                 * @param {nftvault.eventhook.IQueryParamsRequest=} [properties] Properties to set
                 */
                function QueryParamsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Encodes the specified QueryParamsRequest message. Does not implicitly {@link nftvault.eventhook.QueryParamsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @static
                 * @param {nftvault.eventhook.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryParamsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @static
                 * @param {nftvault.eventhook.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.QueryParamsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.QueryParamsRequest} QueryParamsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsRequest message.
                 * @function verify
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.QueryParamsRequest} QueryParamsRequest
                 */
                QueryParamsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.QueryParamsRequest)
                        return object;
                    return new $root.nftvault.eventhook.QueryParamsRequest();
                };
    
                /**
                 * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @static
                 * @param {nftvault.eventhook.QueryParamsRequest} message QueryParamsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsRequest.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this QueryParamsRequest to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.QueryParamsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsRequest;
            })();
    
            eventhook.QueryParamsResponse = (function() {
    
                /**
                 * Properties of a QueryParamsResponse.
                 * @memberof nftvault.eventhook
                 * @interface IQueryParamsResponse
                 * @property {nftvault.eventhook.IParams|null} [params] QueryParamsResponse params
                 */
    
                /**
                 * Constructs a new QueryParamsResponse.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a QueryParamsResponse.
                 * @implements IQueryParamsResponse
                 * @constructor
                 * @param {nftvault.eventhook.IQueryParamsResponse=} [properties] Properties to set
                 */
                function QueryParamsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryParamsResponse params.
                 * @member {nftvault.eventhook.IParams|null|undefined} params
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @instance
                 */
                QueryParamsResponse.prototype.params = null;
    
                /**
                 * Encodes the specified QueryParamsResponse message. Does not implicitly {@link nftvault.eventhook.QueryParamsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @static
                 * @param {nftvault.eventhook.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                        $root.nftvault.eventhook.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryParamsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @static
                 * @param {nftvault.eventhook.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.QueryParamsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.params = $root.nftvault.eventhook.Params.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.QueryParamsResponse} QueryParamsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryParamsResponse message.
                 * @function verify
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryParamsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.nftvault.eventhook.Params.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.QueryParamsResponse} QueryParamsResponse
                 */
                QueryParamsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.QueryParamsResponse)
                        return object;
                    var message = new $root.nftvault.eventhook.QueryParamsResponse();
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".nftvault.eventhook.QueryParamsResponse.params: object expected");
                        message.params = $root.nftvault.eventhook.Params.fromObject(object.params);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @static
                 * @param {nftvault.eventhook.QueryParamsResponse} message QueryParamsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryParamsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.params = null;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.nftvault.eventhook.Params.toObject(message.params, options);
                    return object;
                };
    
                /**
                 * Converts this QueryParamsResponse to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.QueryParamsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryParamsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryParamsResponse;
            })();
    
            eventhook.QueryAllHookRequest = (function() {
    
                /**
                 * Properties of a QueryAllHookRequest.
                 * @memberof nftvault.eventhook
                 * @interface IQueryAllHookRequest
                 * @property {string|null} [event_type] QueryAllHookRequest event_type
                 * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllHookRequest pagination
                 */
    
                /**
                 * Constructs a new QueryAllHookRequest.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a QueryAllHookRequest.
                 * @implements IQueryAllHookRequest
                 * @constructor
                 * @param {nftvault.eventhook.IQueryAllHookRequest=} [properties] Properties to set
                 */
                function QueryAllHookRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllHookRequest event_type.
                 * @member {string} event_type
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @instance
                 */
                QueryAllHookRequest.prototype.event_type = "";
    
                /**
                 * QueryAllHookRequest pagination.
                 * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @instance
                 */
                QueryAllHookRequest.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllHookRequest message. Does not implicitly {@link nftvault.eventhook.QueryAllHookRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @static
                 * @param {nftvault.eventhook.IQueryAllHookRequest} message QueryAllHookRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllHookRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.event_type != null && Object.hasOwnProperty.call(message, "event_type"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_type);
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllHookRequest message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryAllHookRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @static
                 * @param {nftvault.eventhook.IQueryAllHookRequest} message QueryAllHookRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllHookRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllHookRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.QueryAllHookRequest} QueryAllHookRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllHookRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.QueryAllHookRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.event_type = reader.string();
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllHookRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.QueryAllHookRequest} QueryAllHookRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllHookRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllHookRequest message.
                 * @function verify
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllHookRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        if (!$util.isString(message.event_type))
                            return "event_type: string expected";
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllHookRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.QueryAllHookRequest} QueryAllHookRequest
                 */
                QueryAllHookRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.QueryAllHookRequest)
                        return object;
                    var message = new $root.nftvault.eventhook.QueryAllHookRequest();
                    if (object.event_type != null)
                        message.event_type = String(object.event_type);
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".nftvault.eventhook.QueryAllHookRequest.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllHookRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @static
                 * @param {nftvault.eventhook.QueryAllHookRequest} message QueryAllHookRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllHookRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.event_type = "";
                        object.pagination = null;
                    }
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        object.event_type = message.event_type;
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllHookRequest to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.QueryAllHookRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllHookRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllHookRequest;
            })();
    
            eventhook.QueryAllHookResponse = (function() {
    
                /**
                 * Properties of a QueryAllHookResponse.
                 * @memberof nftvault.eventhook
                 * @interface IQueryAllHookResponse
                 * @property {Array.<nftvault.eventhook.IHook>|null} [hooks] QueryAllHookResponse hooks
                 * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllHookResponse pagination
                 */
    
                /**
                 * Constructs a new QueryAllHookResponse.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a QueryAllHookResponse.
                 * @implements IQueryAllHookResponse
                 * @constructor
                 * @param {nftvault.eventhook.IQueryAllHookResponse=} [properties] Properties to set
                 */
                function QueryAllHookResponse(properties) {
                    this.hooks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryAllHookResponse hooks.
                 * @member {Array.<nftvault.eventhook.IHook>} hooks
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @instance
                 */
                QueryAllHookResponse.prototype.hooks = $util.emptyArray;
    
                /**
                 * QueryAllHookResponse pagination.
                 * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @instance
                 */
                QueryAllHookResponse.prototype.pagination = null;
    
                /**
                 * Encodes the specified QueryAllHookResponse message. Does not implicitly {@link nftvault.eventhook.QueryAllHookResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @static
                 * @param {nftvault.eventhook.IQueryAllHookResponse} message QueryAllHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllHookResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hooks != null && message.hooks.length)
                        for (var i = 0; i < message.hooks.length; ++i)
                            $root.nftvault.eventhook.Hook.encode(message.hooks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pagination != null && Object.hasOwnProperty.call(message, "pagination"))
                        $root.cosmos.base.query.v1beta1.PageResponse.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryAllHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryAllHookResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @static
                 * @param {nftvault.eventhook.IQueryAllHookResponse} message QueryAllHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryAllHookResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.QueryAllHookResponse} QueryAllHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllHookResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.QueryAllHookResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.hooks && message.hooks.length))
                                message.hooks = [];
                            message.hooks.push($root.nftvault.eventhook.Hook.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryAllHookResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.QueryAllHookResponse} QueryAllHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllHookResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryAllHookResponse message.
                 * @function verify
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllHookResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hooks != null && message.hasOwnProperty("hooks")) {
                        if (!Array.isArray(message.hooks))
                            return "hooks: array expected";
                        for (var i = 0; i < message.hooks.length; ++i) {
                            var error = $root.nftvault.eventhook.Hook.verify(message.hooks[i]);
                            if (error)
                                return "hooks." + error;
                        }
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination")) {
                        var error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
                        if (error)
                            return "pagination." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryAllHookResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.QueryAllHookResponse} QueryAllHookResponse
                 */
                QueryAllHookResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.QueryAllHookResponse)
                        return object;
                    var message = new $root.nftvault.eventhook.QueryAllHookResponse();
                    if (object.hooks) {
                        if (!Array.isArray(object.hooks))
                            throw TypeError(".nftvault.eventhook.QueryAllHookResponse.hooks: array expected");
                        message.hooks = [];
                        for (var i = 0; i < object.hooks.length; ++i) {
                            if (typeof object.hooks[i] !== "object")
                                throw TypeError(".nftvault.eventhook.QueryAllHookResponse.hooks: object expected");
                            message.hooks[i] = $root.nftvault.eventhook.Hook.fromObject(object.hooks[i]);
                        }
                    }
                    if (object.pagination != null) {
                        if (typeof object.pagination !== "object")
                            throw TypeError(".nftvault.eventhook.QueryAllHookResponse.pagination: object expected");
                        message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryAllHookResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @static
                 * @param {nftvault.eventhook.QueryAllHookResponse} message QueryAllHookResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllHookResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.hooks = [];
                    if (options.defaults)
                        object.pagination = null;
                    if (message.hooks && message.hooks.length) {
                        object.hooks = [];
                        for (var j = 0; j < message.hooks.length; ++j)
                            object.hooks[j] = $root.nftvault.eventhook.Hook.toObject(message.hooks[j], options);
                    }
                    if (message.pagination != null && message.hasOwnProperty("pagination"))
                        object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
                    return object;
                };
    
                /**
                 * Converts this QueryAllHookResponse to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.QueryAllHookResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllHookResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryAllHookResponse;
            })();
    
            eventhook.QueryGetHookRequest = (function() {
    
                /**
                 * Properties of a QueryGetHookRequest.
                 * @memberof nftvault.eventhook
                 * @interface IQueryGetHookRequest
                 * @property {string|null} [event_type] QueryGetHookRequest event_type
                 * @property {Long|null} [id] QueryGetHookRequest id
                 */
    
                /**
                 * Constructs a new QueryGetHookRequest.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a QueryGetHookRequest.
                 * @implements IQueryGetHookRequest
                 * @constructor
                 * @param {nftvault.eventhook.IQueryGetHookRequest=} [properties] Properties to set
                 */
                function QueryGetHookRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetHookRequest event_type.
                 * @member {string} event_type
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @instance
                 */
                QueryGetHookRequest.prototype.event_type = "";
    
                /**
                 * QueryGetHookRequest id.
                 * @member {Long} id
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @instance
                 */
                QueryGetHookRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Encodes the specified QueryGetHookRequest message. Does not implicitly {@link nftvault.eventhook.QueryGetHookRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @static
                 * @param {nftvault.eventhook.IQueryGetHookRequest} message QueryGetHookRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetHookRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.event_type != null && Object.hasOwnProperty.call(message, "event_type"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_type);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetHookRequest message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryGetHookRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @static
                 * @param {nftvault.eventhook.IQueryGetHookRequest} message QueryGetHookRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetHookRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetHookRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.QueryGetHookRequest} QueryGetHookRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetHookRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.QueryGetHookRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.event_type = reader.string();
                            break;
                        case 2:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetHookRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.QueryGetHookRequest} QueryGetHookRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetHookRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetHookRequest message.
                 * @function verify
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetHookRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        if (!$util.isString(message.event_type))
                            return "event_type: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a QueryGetHookRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.QueryGetHookRequest} QueryGetHookRequest
                 */
                QueryGetHookRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.QueryGetHookRequest)
                        return object;
                    var message = new $root.nftvault.eventhook.QueryGetHookRequest();
                    if (object.event_type != null)
                        message.event_type = String(object.event_type);
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetHookRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @static
                 * @param {nftvault.eventhook.QueryGetHookRequest} message QueryGetHookRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetHookRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.event_type = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    }
                    if (message.event_type != null && message.hasOwnProperty("event_type"))
                        object.event_type = message.event_type;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };
    
                /**
                 * Converts this QueryGetHookRequest to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.QueryGetHookRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetHookRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetHookRequest;
            })();
    
            eventhook.QueryGetHookResponse = (function() {
    
                /**
                 * Properties of a QueryGetHookResponse.
                 * @memberof nftvault.eventhook
                 * @interface IQueryGetHookResponse
                 * @property {nftvault.eventhook.IHook|null} [hook] QueryGetHookResponse hook
                 */
    
                /**
                 * Constructs a new QueryGetHookResponse.
                 * @memberof nftvault.eventhook
                 * @classdesc Represents a QueryGetHookResponse.
                 * @implements IQueryGetHookResponse
                 * @constructor
                 * @param {nftvault.eventhook.IQueryGetHookResponse=} [properties] Properties to set
                 */
                function QueryGetHookResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QueryGetHookResponse hook.
                 * @member {nftvault.eventhook.IHook|null|undefined} hook
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @instance
                 */
                QueryGetHookResponse.prototype.hook = null;
    
                /**
                 * Encodes the specified QueryGetHookResponse message. Does not implicitly {@link nftvault.eventhook.QueryGetHookResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @static
                 * @param {nftvault.eventhook.IQueryGetHookResponse} message QueryGetHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetHookResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hook != null && Object.hasOwnProperty.call(message, "hook"))
                        $root.nftvault.eventhook.Hook.encode(message.hook, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified QueryGetHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryGetHookResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @static
                 * @param {nftvault.eventhook.IQueryGetHookResponse} message QueryGetHookResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryGetHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QueryGetHookResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nftvault.eventhook.QueryGetHookResponse} QueryGetHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetHookResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nftvault.eventhook.QueryGetHookResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.hook = $root.nftvault.eventhook.Hook.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QueryGetHookResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {nftvault.eventhook.QueryGetHookResponse} QueryGetHookResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryGetHookResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QueryGetHookResponse message.
                 * @function verify
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryGetHookResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hook != null && message.hasOwnProperty("hook")) {
                        var error = $root.nftvault.eventhook.Hook.verify(message.hook);
                        if (error)
                            return "hook." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a QueryGetHookResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {nftvault.eventhook.QueryGetHookResponse} QueryGetHookResponse
                 */
                QueryGetHookResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.nftvault.eventhook.QueryGetHookResponse)
                        return object;
                    var message = new $root.nftvault.eventhook.QueryGetHookResponse();
                    if (object.hook != null) {
                        if (typeof object.hook !== "object")
                            throw TypeError(".nftvault.eventhook.QueryGetHookResponse.hook: object expected");
                        message.hook = $root.nftvault.eventhook.Hook.fromObject(object.hook);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a QueryGetHookResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @static
                 * @param {nftvault.eventhook.QueryGetHookResponse} message QueryGetHookResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryGetHookResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.hook = null;
                    if (message.hook != null && message.hasOwnProperty("hook"))
                        object.hook = $root.nftvault.eventhook.Hook.toObject(message.hook, options);
                    return object;
                };
    
                /**
                 * Converts this QueryGetHookResponse to JSON.
                 * @function toJSON
                 * @memberof nftvault.eventhook.QueryGetHookResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryGetHookResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QueryGetHookResponse;
            })();
    
            return eventhook;
        })();
    
        return nftvault;
    })();

    return $root;
});
