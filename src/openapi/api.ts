/* tslint:disable */
/* eslint-disable */
/**
 * UnUniFi - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AddressPositions200Response
 */
export interface AddressPositions200Response {
  /**
   *
   * @type {Array<AddressPositions200ResponsePositionsInner>}
   * @memberof AddressPositions200Response
   */
  positions?: Array<AddressPositions200ResponsePositionsInner>;
}
/**
 *
 * @export
 * @interface AddressPositions200ResponsePositionsInner
 */
export interface AddressPositions200ResponsePositionsInner {
  /**
   *
   * @type {AllPositions200ResponsePositionsInner}
   * @memberof AddressPositions200ResponsePositionsInner
   */
  position?: AllPositions200ResponsePositionsInner;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof AddressPositions200ResponsePositionsInner
   */
  valuation_profit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof AddressPositions200ResponsePositionsInner
   */
  remaining_margin_value?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof AddressPositions200ResponsePositionsInner
   */
  effective_margin?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof AddressPositions200ResponsePositionsInner
   */
  margin_maintenance_rate?: string;
}
/**
 *
 * @export
 * @interface AllPendingPaymentPositions200Response
 */
export interface AllPendingPaymentPositions200Response {
  /**
   *
   * @type {Array<AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner>}
   * @memberof AllPendingPaymentPositions200Response
   */
  pending_payment_positions?: Array<AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner>;
}
/**
 *
 * @export
 * @interface AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner
 */
export interface AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner {
  /**
   *
   * @type {string}
   * @memberof AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner
   */
  id?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner
   */
  refundable_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner
   */
  created_height?: string;
}
/**
 *
 * @export
 * @interface AllPositions200Response
 */
export interface AllPositions200Response {
  /**
   *
   * @type {Array<AllPositions200ResponsePositionsInner>}
   * @memberof AllPositions200Response
   */
  positions?: Array<AllPositions200ResponsePositionsInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof AllPositions200Response
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface AllPositions200ResponsePagination
 */
export interface AllPositions200ResponsePagination {
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePagination
   */
  next_key?: string;
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePagination
   */
  total?: string;
}
/**
 *
 * @export
 * @interface AllPositions200ResponsePositionsInner
 */
export interface AllPositions200ResponsePositionsInner {
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePositionsInner
   */
  id?: string;
  /**
   *
   * @type {DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner}
   * @memberof AllPositions200ResponsePositionsInner
   */
  market?: DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner;
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePositionsInner
   */
  opener_address?: string;
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePositionsInner
   */
  opened_at?: string;
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePositionsInner
   */
  opened_height?: string;
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePositionsInner
   */
  opened_base_rate?: string;
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePositionsInner
   */
  opened_quote_rate?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof AllPositions200ResponsePositionsInner
   */
  remaining_margin?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof AllPositions200ResponsePositionsInner
   */
  levied_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {boolean}
   * @memberof AllPositions200ResponsePositionsInner
   */
  levied_amount_negative?: boolean;
  /**
   *
   * @type {string}
   * @memberof AllPositions200ResponsePositionsInner
   */
  last_levied_at?: string;
  /**
   *
   * @type {EstimateDLPTokenAmountDefaultResponseDetailsInner}
   * @memberof AllPositions200ResponsePositionsInner
   */
  position_instance?: EstimateDLPTokenAmountDefaultResponseDetailsInner;
}
/**
 * QueryTranchesResponse is response type for the Query/Tranches RPC method.
 * @export
 * @interface AllTranches200Response
 */
export interface AllTranches200Response {
  /**
   *
   * @type {Array<AllTranches200ResponseTranchesInner>}
   * @memberof AllTranches200Response
   */
  tranches?: Array<AllTranches200ResponseTranchesInner>;
}
/**
 *
 * @export
 * @interface AllTranches200ResponseTranchesInner
 */
export interface AllTranches200ResponseTranchesInner {
  /**
   *
   * @type {string}
   * @memberof AllTranches200ResponseTranchesInner
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AllTranches200ResponseTranchesInner
   */
  strategy_contract?: string;
  /**
   *
   * @type {string}
   * @memberof AllTranches200ResponseTranchesInner
   */
  start_time?: string;
  /**
   *
   * @type {string}
   * @memberof AllTranches200ResponseTranchesInner
   */
  maturity?: string;
  /**
   *
   * @type {string}
   * @memberof AllTranches200ResponseTranchesInner
   */
  swap_fee?: string;
  /**
   *
   * @type {string}
   * @memberof AllTranches200ResponseTranchesInner
   */
  exit_fee?: string;
  /**
   *
   * @type {SumOfAllLPTokensSentOut}
   * @memberof AllTranches200ResponseTranchesInner
   */
  total_shares?: SumOfAllLPTokensSentOut;
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof AllTranches200ResponseTranchesInner
   */
  pool_assets?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface AvailableAssetsInPool200Response
 */
export interface AvailableAssetsInPool200Response {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof AvailableAssetsInPool200Response
   */
  available_assets?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface BorrowInfo
 */
export interface BorrowInfo {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof BorrowInfo
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof BorrowInfo
   */
  last_repaid_at?: string;
}
/**
 *
 * @export
 * @interface ClassAuthorityMetadata200Response
 */
export interface ClassAuthorityMetadata200Response {
  /**
   *
   * @type {ClassAuthorityMetadata200ResponseAuthorityMetadata}
   * @memberof ClassAuthorityMetadata200Response
   */
  authority_metadata?: ClassAuthorityMetadata200ResponseAuthorityMetadata;
}
/**
 * ClassAuthorityMetadata specifies metadata for addresses that have specific capabilities over a nft factory class. Right now there is only one Admin permission, but is planned to be extended to the future.
 * @export
 * @interface ClassAuthorityMetadata200ResponseAuthorityMetadata
 */
export interface ClassAuthorityMetadata200ResponseAuthorityMetadata {
  /**
   *
   * @type {string}
   * @memberof ClassAuthorityMetadata200ResponseAuthorityMetadata
   */
  Admin?: string;
}
/**
 *
 * @export
 * @interface ClassesFromCreator200Response
 */
export interface ClassesFromCreator200Response {
  /**
   *
   * @type {Array<string>}
   * @memberof ClassesFromCreator200Response
   */
  classes?: Array<string>;
}
/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
  /**
   * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  key?: string;
  /**
   * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  offset?: string;
  /**
   * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  limit?: string;
  /**
   * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @type {boolean}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  count_total?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
  /**
   *
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageResponse
   */
  next_key?: string;
  /**
   *
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageResponse
   */
  total?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
  /**
   *
   * @type {string}
   * @memberof CosmosBaseV1beta1Coin
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof CosmosBaseV1beta1Coin
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface DLPTokenRates200Response
 */
export interface DLPTokenRates200Response {
  /**
   *
   * @type {string}
   * @memberof DLPTokenRates200Response
   */
  symbol?: string;
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof DLPTokenRates200Response
   */
  rates?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface DenomInfos200Response
 */
export interface DenomInfos200Response {
  /**
   *
   * @type {Array<DenomInfos200ResponseInfoInner>}
   * @memberof DenomInfos200Response
   */
  info?: Array<DenomInfos200ResponseInfoInner>;
}
/**
 *
 * @export
 * @interface DenomInfos200ResponseInfoInner
 */
export interface DenomInfos200ResponseInfoInner {
  /**
   *
   * @type {string}
   * @memberof DenomInfos200ResponseInfoInner
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof DenomInfos200ResponseInfoInner
   */
  symbol?: string;
  /**
   *
   * @type {Array<DenomInfos200ResponseInfoInnerChannelsInner>}
   * @memberof DenomInfos200ResponseInfoInner
   */
  channels?: Array<DenomInfos200ResponseInfoInnerChannelsInner>;
}
/**
 *
 * @export
 * @interface DenomInfos200ResponseInfoInnerChannelsInner
 */
export interface DenomInfos200ResponseInfoInnerChannelsInner {
  /**
   *
   * @type {string}
   * @memberof DenomInfos200ResponseInfoInnerChannelsInner
   */
  send_chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof DenomInfos200ResponseInfoInnerChannelsInner
   */
  recv_chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof DenomInfos200ResponseInfoInnerChannelsInner
   */
  channel_id?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface DerivativesParams200Response
 */
export interface DerivativesParams200Response {
  /**
   *
   * @type {DerivativesParams200ResponseParams}
   * @memberof DerivativesParams200Response
   */
  params?: DerivativesParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface DerivativesParams200ResponseParams
 */
export interface DerivativesParams200ResponseParams {
  /**
   *
   * @type {DerivativesParams200ResponseParamsPoolParams}
   * @memberof DerivativesParams200ResponseParams
   */
  pool_params?: DerivativesParams200ResponseParamsPoolParams;
  /**
   *
   * @type {DerivativesParams200ResponseParamsPerpetualFutures}
   * @memberof DerivativesParams200ResponseParams
   */
  perpetual_futures?: DerivativesParams200ResponseParamsPerpetualFutures;
  /**
   *
   * @type {DerivativesParams200ResponseParamsPerpetualOptions}
   * @memberof DerivativesParams200ResponseParams
   */
  perpetual_options?: DerivativesParams200ResponseParamsPerpetualOptions;
}
/**
 *
 * @export
 * @interface DerivativesParams200ResponseParamsPerpetualFutures
 */
export interface DerivativesParams200ResponseParamsPerpetualFutures {
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualFutures
   */
  commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualFutures
   */
  margin_maintenance_rate?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualFutures
   */
  imaginary_funding_rate_proportional_coefficient?: string;
  /**
   *
   * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
   * @memberof DerivativesParams200ResponseParamsPerpetualFutures
   */
  markets?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
  /**
   *
   * @type {number}
   * @memberof DerivativesParams200ResponseParamsPerpetualFutures
   */
  max_leverage?: number;
}
/**
 *
 * @export
 * @interface DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner
 */
export interface DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner {
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner
   */
  base_denom?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner
   */
  quote_denom?: string;
}
/**
 *
 * @export
 * @interface DerivativesParams200ResponseParamsPerpetualOptions
 */
export interface DerivativesParams200ResponseParamsPerpetualOptions {
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualOptions
   */
  premium_commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualOptions
   */
  strike_commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualOptions
   */
  margin_maintenance_rate?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPerpetualOptions
   */
  imaginary_funding_rate_proportional_coefficient?: string;
  /**
   *
   * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
   * @memberof DerivativesParams200ResponseParamsPerpetualOptions
   */
  markets?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
}
/**
 *
 * @export
 * @interface DerivativesParams200ResponseParamsPoolParams
 */
export interface DerivativesParams200ResponseParamsPoolParams {
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  base_lpt_mint_fee?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  base_lpt_redeem_fee?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  borrowing_fee_rate_per_hour?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  report_liquidation_reward_rate?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  report_levy_period_reward_rate?: string;
  /**
   *
   * @type {Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  accepted_assets_conf?: Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParams
   */
  levy_period_required_seconds?: string;
}
/**
 *
 * @export
 * @interface DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner
 */
export interface DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner {
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner
   */
  target_weight?: string;
}
/**
 *
 * @export
 * @interface EcosystemIncentiveParams200Response
 */
export interface EcosystemIncentiveParams200Response {
  /**
   *
   * @type {EcosystemIncentiveParams200ResponseParams}
   * @memberof EcosystemIncentiveParams200Response
   */
  params?: EcosystemIncentiveParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface EcosystemIncentiveParams200ResponseParams
 */
export interface EcosystemIncentiveParams200ResponseParams {
  /**
   *
   * @type {Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>}
   * @memberof EcosystemIncentiveParams200ResponseParams
   */
  reward_params?: Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>;
}
/**
 *
 * @export
 * @interface EcosystemIncentiveParamsDefaultResponse
 */
export interface EcosystemIncentiveParamsDefaultResponse {
  /**
   *
   * @type {string}
   * @memberof EcosystemIncentiveParamsDefaultResponse
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof EcosystemIncentiveParamsDefaultResponse
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof EcosystemIncentiveParamsDefaultResponse
   */
  message?: string;
  /**
   *
   * @type {Array<EcosystemIncentiveParamsDefaultResponseDetailsInner>}
   * @memberof EcosystemIncentiveParamsDefaultResponse
   */
  details?: Array<EcosystemIncentiveParamsDefaultResponseDetailsInner>;
}
/**
 *
 * @export
 * @interface EcosystemIncentiveParamsDefaultResponseDetailsInner
 */
export interface EcosystemIncentiveParamsDefaultResponseDetailsInner {
  /**
   *
   * @type {string}
   * @memberof EcosystemIncentiveParamsDefaultResponseDetailsInner
   */
  type_url?: string;
  /**
   *
   * @type {string}
   * @memberof EcosystemIncentiveParamsDefaultResponseDetailsInner
   */
  value?: string;
}
/**
 *
 * @export
 * @interface EcosystemRewards200Response
 */
export interface EcosystemRewards200Response {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof EcosystemRewards200Response
   */
  rewards?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface EstimateDLPTokenAmount200Response
 */
export interface EstimateDLPTokenAmount200Response {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateDLPTokenAmount200Response
   */
  estimated_dlp_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateDLPTokenAmount200Response
   */
  deposit_fee?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface EstimateDLPTokenAmount200ResponseEstimatedDlpAmount
 */
export interface EstimateDLPTokenAmount200ResponseEstimatedDlpAmount {
  /**
   *
   * @type {string}
   * @memberof EstimateDLPTokenAmount200ResponseEstimatedDlpAmount
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof EstimateDLPTokenAmount200ResponseEstimatedDlpAmount
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface EstimateDLPTokenAmountDefaultResponse
 */
export interface EstimateDLPTokenAmountDefaultResponse {
  /**
   *
   * @type {string}
   * @memberof EstimateDLPTokenAmountDefaultResponse
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof EstimateDLPTokenAmountDefaultResponse
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof EstimateDLPTokenAmountDefaultResponse
   */
  message?: string;
  /**
   *
   * @type {Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>}
   * @memberof EstimateDLPTokenAmountDefaultResponse
   */
  details?: Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface EstimateDLPTokenAmountDefaultResponseDetailsInner
 */
export interface EstimateDLPTokenAmountDefaultResponseDetailsInner {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof EstimateDLPTokenAmountDefaultResponseDetailsInner
   */
  type_url?: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   * @type {string}
   * @memberof EstimateDLPTokenAmountDefaultResponseDetailsInner
   */
  value?: string;
}
/**
 *
 * @export
 * @interface EstimateMintAmount200Response
 */
export interface EstimateMintAmount200Response {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateMintAmount200Response
   */
  mint_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface EstimateMintLiquidityPoolToken200Response
 */
export interface EstimateMintLiquidityPoolToken200Response {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof EstimateMintLiquidityPoolToken200Response
   */
  required_amount?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface EstimateMintPtYtPair200Response
 */
export interface EstimateMintPtYtPair200Response {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateMintPtYtPair200Response
   */
  pt_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateMintPtYtPair200Response
   */
  yt_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface EstimateRedeemAmount200Response
 */
export interface EstimateRedeemAmount200Response {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateRedeemAmount200Response
   */
  share_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof EstimateRedeemAmount200Response
   */
  fee?: string;
  /**
   *
   * @type {string}
   * @memberof EstimateRedeemAmount200Response
   */
  redeem_amount?: string;
  /**
   *
   * @type {string}
   * @memberof EstimateRedeemAmount200Response
   */
  total_amount?: string;
  /**
   *
   * @type {string}
   * @memberof EstimateRedeemAmount200Response
   */
  symbol?: string;
}
/**
 *
 * @export
 * @interface EstimateRedeemLiquidityPoolToken200Response
 */
export interface EstimateRedeemLiquidityPoolToken200Response {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof EstimateRedeemLiquidityPoolToken200Response
   */
  redeem_amount?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface EstimateRedeemTokenAmount200Response
 */
export interface EstimateRedeemTokenAmount200Response {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateRedeemTokenAmount200Response
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateRedeemTokenAmount200Response
   */
  fee?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface EstimateRedeemYt200Response
 */
export interface EstimateRedeemYt200Response {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof EstimateRedeemYt200Response
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof GoogleProtobufAny
   */
  type_url?: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   * @type {string}
   * @memberof GoogleProtobufAny
   */
  value?: string;
}
/**
 *
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
  /**
   *
   * @type {string}
   * @memberof GrpcGatewayRuntimeError
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof GrpcGatewayRuntimeError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof GrpcGatewayRuntimeError
   */
  message?: string;
  /**
   *
   * @type {Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>}
   * @memberof GrpcGatewayRuntimeError
   */
  details?: Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>;
}
/**
 *
 * @export
 * @interface IntermediaryAccountInfo200Response
 */
export interface IntermediaryAccountInfo200Response {
  /**
   *
   * @type {Array<IntermediaryAccountInfo200ResponseAddrsInner>}
   * @memberof IntermediaryAccountInfo200Response
   */
  addrs?: Array<IntermediaryAccountInfo200ResponseAddrsInner>;
}
/**
 *
 * @export
 * @interface IntermediaryAccountInfo200ResponseAddrsInner
 */
export interface IntermediaryAccountInfo200ResponseAddrsInner {
  /**
   *
   * @type {string}
   * @memberof IntermediaryAccountInfo200ResponseAddrsInner
   */
  chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof IntermediaryAccountInfo200ResponseAddrsInner
   */
  address?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface IrsParams200Response
 */
export interface IrsParams200Response {
  /**
   *
   * @type {IrsParams200ResponseParams}
   * @memberof IrsParams200Response
   */
  params?: IrsParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface IrsParams200ResponseParams
 */
export interface IrsParams200ResponseParams {
  /**
   *
   * @type {string}
   * @memberof IrsParams200ResponseParams
   */
  authority?: string;
  /**
   *
   * @type {string}
   * @memberof IrsParams200ResponseParams
   */
  trade_fee_rate?: string;
}
/**
 *
 * @export
 * @interface Liquidation200Response
 */
export interface Liquidation200Response {
  /**
   *
   * @type {Liquidation200ResponseLiquidations}
   * @memberof Liquidation200Response
   */
  liquidations?: Liquidation200ResponseLiquidations;
}
/**
 *
 * @export
 * @interface Liquidation200ResponseLiquidations
 */
export interface Liquidation200ResponseLiquidations {
  /**
   *
   * @type {Liquidation200ResponseLiquidationsLiquidation}
   * @memberof Liquidation200ResponseLiquidations
   */
  liquidation?: Liquidation200ResponseLiquidationsLiquidation;
  /**
   *
   * @type {Array<Liquidation200ResponseLiquidationsLiquidation>}
   * @memberof Liquidation200ResponseLiquidations
   */
  next_liquidation?: Array<Liquidation200ResponseLiquidationsLiquidation>;
}
/**
 *
 * @export
 * @interface Liquidation200ResponseLiquidationsLiquidation
 */
export interface Liquidation200ResponseLiquidationsLiquidation {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof Liquidation200ResponseLiquidationsLiquidation
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof Liquidation200ResponseLiquidationsLiquidation
   */
  liquidation_date?: string;
}
/**
 *
 * @export
 * @interface LiquidityProviderTokenNominalAPY200Response
 */
export interface LiquidityProviderTokenNominalAPY200Response {
  /**
   *
   * @type {string}
   * @memberof LiquidityProviderTokenNominalAPY200Response
   */
  apy?: string;
}
/**
 *
 * @export
 * @interface ListedClasses200Response
 */
export interface ListedClasses200Response {
  /**
   *
   * @type {Array<ListedClasses200ResponseClassesInner>}
   * @memberof ListedClasses200Response
   */
  classes?: Array<ListedClasses200ResponseClassesInner>;
}
/**
 *
 * @export
 * @interface ListedClasses200ResponseClassesInner
 */
export interface ListedClasses200ResponseClassesInner {
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInner
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInner
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInner
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInner
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInner
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInner
   */
  urihash?: string;
  /**
   *
   * @type {Array<ListedClasses200ResponseClassesInnerNftsInner>}
   * @memberof ListedClasses200ResponseClassesInner
   */
  nfts?: Array<ListedClasses200ResponseClassesInnerNftsInner>;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInner
   */
  nft_count?: string;
}
/**
 *
 * @export
 * @interface ListedClasses200ResponseClassesInnerNftsInner
 */
export interface ListedClasses200ResponseClassesInnerNftsInner {
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInnerNftsInner
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInnerNftsInner
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClasses200ResponseClassesInnerNftsInner
   */
  uri_hash?: string;
}
/**
 *
 * @export
 * @interface ListedNft200Response
 */
export interface ListedNft200Response {
  /**
   *
   * @type {ListedNfts200ResponseListingsInnerListing}
   * @memberof ListedNft200Response
   */
  listing?: ListedNfts200ResponseListingsInnerListing;
}
/**
 *
 * @export
 * @interface ListedNfts200Response
 */
export interface ListedNfts200Response {
  /**
   *
   * @type {Array<ListedNfts200ResponseListingsInner>}
   * @memberof ListedNfts200Response
   */
  listings?: Array<ListedNfts200ResponseListingsInner>;
}
/**
 *
 * @export
 * @interface ListedNfts200ResponseListingsInner
 */
export interface ListedNfts200ResponseListingsInner {
  /**
   *
   * @type {ListedNfts200ResponseListingsInnerListing}
   * @memberof ListedNfts200ResponseListingsInner
   */
  listing?: ListedNfts200ResponseListingsInnerListing;
  /**
   *
   * @type {ListedClasses200ResponseClassesInnerNftsInner}
   * @memberof ListedNfts200ResponseListingsInner
   */
  nft_info?: ListedClasses200ResponseClassesInnerNftsInner;
}
/**
 *
 * @export
 * @interface ListedNfts200ResponseListingsInnerListing
 */
export interface ListedNfts200ResponseListingsInnerListing {
  /**
   *
   * @type {NftBids200ResponseBidsInnerIdNftId}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  nft_id?: NftBids200ResponseBidsInnerIdNftId;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  state?: ListedNfts200ResponseListingsInnerListingStateEnum;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  bid_denom?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  min_deposit_rate?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  min_bid_period?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  started_at?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  liquidated_at?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  full_payment_end_at?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  successful_bid_end_at?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  collected_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {boolean}
   * @memberof ListedNfts200ResponseListingsInnerListing
   */
  collected_amount_negative?: boolean;
}

export const ListedNfts200ResponseListingsInnerListingStateEnum = {
  Unknown: 'UNKNOWN',
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type ListedNfts200ResponseListingsInnerListingStateEnum =
  (typeof ListedNfts200ResponseListingsInnerListingStateEnum)[keyof typeof ListedNfts200ResponseListingsInnerListingStateEnum];

/**
 *
 * @export
 * @interface Loan200Response
 */
export interface Loan200Response {
  /**
   *
   * @type {NftBids200ResponseBidsInnerIdNftId}
   * @memberof Loan200Response
   */
  nft_id?: NftBids200ResponseBidsInnerIdNftId;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof Loan200Response
   */
  borrowing_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof Loan200Response
   */
  borrowing_limit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof Loan200Response
   */
  total_deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface MarketAll200Response
 */
export interface MarketAll200Response {
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof MarketAll200Response
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof MarketAll200Response
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface MarketAll200ResponseMarketsInner
 */
export interface MarketAll200ResponseMarketsInner {
  /**
   *
   * @type {string}
   * @memberof MarketAll200ResponseMarketsInner
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof MarketAll200ResponseMarketsInner
   */
  base_asset?: string;
  /**
   *
   * @type {string}
   * @memberof MarketAll200ResponseMarketsInner
   */
  quote_asset?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MarketAll200ResponseMarketsInner
   */
  oracles?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof MarketAll200ResponseMarketsInner
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface NftBackedLoanParams200Response
 */
export interface NftBackedLoanParams200Response {
  /**
   *
   * @type {NftBackedLoanParams200ResponseParams}
   * @memberof NftBackedLoanParams200Response
   */
  params?: NftBackedLoanParams200ResponseParams;
}
/**
 *
 * @export
 * @interface NftBackedLoanParams200ResponseParams
 */
export interface NftBackedLoanParams200ResponseParams {
  /**
   *
   * @type {string}
   * @memberof NftBackedLoanParams200ResponseParams
   */
  min_staking_for_listing?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof NftBackedLoanParams200ResponseParams
   */
  bid_tokens?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof NftBackedLoanParams200ResponseParams
   */
  nft_listing_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof NftBackedLoanParams200ResponseParams
   */
  bid_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof NftBackedLoanParams200ResponseParams
   */
  nft_listing_full_payment_period?: string;
  /**
   *
   * @type {string}
   * @memberof NftBackedLoanParams200ResponseParams
   */
  nft_listing_nft_delivery_period?: string;
  /**
   *
   * @type {string}
   * @memberof NftBackedLoanParams200ResponseParams
   */
  nft_listing_commission_rate?: string;
}
/**
 *
 * @export
 * @interface NftBids200Response
 */
export interface NftBids200Response {
  /**
   *
   * @type {Array<NftBids200ResponseBidsInner>}
   * @memberof NftBids200Response
   */
  bids?: Array<NftBids200ResponseBidsInner>;
}
/**
 *
 * @export
 * @interface NftBids200ResponseBidsInner
 */
export interface NftBids200ResponseBidsInner {
  /**
   *
   * @type {NftBids200ResponseBidsInnerId}
   * @memberof NftBids200ResponseBidsInner
   */
  id?: NftBids200ResponseBidsInnerId;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof NftBids200ResponseBidsInner
   */
  price?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof NftBids200ResponseBidsInner
   */
  deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof NftBids200ResponseBidsInner
   */
  paid_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof NftBids200ResponseBidsInner
   */
  expiry?: string;
  /**
   *
   * @type {string}
   * @memberof NftBids200ResponseBidsInner
   */
  interest_rate?: string;
  /**
   *
   * @type {boolean}
   * @memberof NftBids200ResponseBidsInner
   */
  automatic_payment?: boolean;
  /**
   *
   * @type {string}
   * @memberof NftBids200ResponseBidsInner
   */
  created_at?: string;
  /**
   *
   * @type {BorrowInfo}
   * @memberof NftBids200ResponseBidsInner
   */
  loan?: BorrowInfo;
}
/**
 *
 * @export
 * @interface NftBids200ResponseBidsInnerId
 */
export interface NftBids200ResponseBidsInnerId {
  /**
   *
   * @type {NftBids200ResponseBidsInnerIdNftId}
   * @memberof NftBids200ResponseBidsInnerId
   */
  nft_id?: NftBids200ResponseBidsInnerIdNftId;
  /**
   *
   * @type {string}
   * @memberof NftBids200ResponseBidsInnerId
   */
  bidder?: string;
}
/**
 *
 * @export
 * @interface NftBids200ResponseBidsInnerIdNftId
 */
export interface NftBids200ResponseBidsInnerIdNftId {
  /**
   *
   * @type {string}
   * @memberof NftBids200ResponseBidsInnerIdNftId
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof NftBids200ResponseBidsInnerIdNftId
   */
  token_id?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface NftFactoryParams200Response
 */
export interface NftFactoryParams200Response {
  /**
   *
   * @type {NftFactoryParams200ResponseParams}
   * @memberof NftFactoryParams200Response
   */
  params?: NftFactoryParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface NftFactoryParams200ResponseParams
 */
export interface NftFactoryParams200ResponseParams {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof NftFactoryParams200ResponseParams
   */
  class_creation_fee?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
  /**
   *
   * @type {string}
   * @memberof NftFactoryParams200ResponseParams
   */
  fee_collector_address?: string;
}
/**
 *
 * @export
 * @interface OracleAll200Response
 */
export interface OracleAll200Response {
  /**
   *
   * @type {Array<string>}
   * @memberof OracleAll200Response
   */
  oracles?: Array<string>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof OracleAll200Response
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface PendingPaymentPosition200Response
 */
export interface PendingPaymentPosition200Response {
  /**
   *
   * @type {AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner}
   * @memberof PendingPaymentPosition200Response
   */
  pending_payment_position?: AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner;
}
/**
 *
 * @export
 * @interface PerpetualFutures200Response
 */
export interface PerpetualFutures200Response {
  /**
   *
   * @type {string}
   * @memberof PerpetualFutures200Response
   */
  metrics_quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof PerpetualFutures200Response
   */
  long_positions?: string;
  /**
   *
   * @type {string}
   * @memberof PerpetualFutures200Response
   */
  short_positions?: string;
}
/**
 *
 * @export
 * @interface PerpetualFuturesMarket200Response
 */
export interface PerpetualFuturesMarket200Response {
  /**
   *
   * @type {string}
   * @memberof PerpetualFuturesMarket200Response
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof PerpetualFuturesMarket200Response
   */
  metrics_quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof PerpetualFuturesMarket200Response
   */
  long_positions?: string;
  /**
   *
   * @type {string}
   * @memberof PerpetualFuturesMarket200Response
   */
  short_positions?: string;
}
/**
 *
 * @export
 * @interface PerpetualFuturesPositionSize200Response
 */
export interface PerpetualFuturesPositionSize200Response {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof PerpetualFuturesPositionSize200Response
   */
  total_position_size_usd?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface Pool200Response
 */
export interface Pool200Response {
  /**
   *
   * @type {string}
   * @memberof Pool200Response
   */
  metrics_quote_ticker?: string;
  /**
   *
   * @type {Pool200ResponsePoolMarketCap}
   * @memberof Pool200Response
   */
  pool_market_cap?: Pool200ResponsePoolMarketCap;
}
/**
 *
 * @export
 * @interface Pool200ResponsePoolMarketCap
 */
export interface Pool200ResponsePoolMarketCap {
  /**
   *
   * @type {string}
   * @memberof Pool200ResponsePoolMarketCap
   */
  quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof Pool200ResponsePoolMarketCap
   */
  total?: string;
  /**
   *
   * @type {Array<Pool200ResponsePoolMarketCapAssetInfoInner>}
   * @memberof Pool200ResponsePoolMarketCap
   */
  asset_info?: Array<Pool200ResponsePoolMarketCapAssetInfoInner>;
}
/**
 *
 * @export
 * @interface Pool200ResponsePoolMarketCapAssetInfoInner
 */
export interface Pool200ResponsePoolMarketCapAssetInfoInner {
  /**
   *
   * @type {string}
   * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
   */
  reserved?: string;
}
/**
 *
 * @export
 * @interface Position200Response
 */
export interface Position200Response {
  /**
   *
   * @type {AllPositions200ResponsePositionsInner}
   * @memberof Position200Response
   */
  position?: AllPositions200ResponsePositionsInner;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof Position200Response
   */
  valuation_profit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof Position200Response
   */
  margin_maintenance_rate?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof Position200Response
   */
  effective_margin?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface Price200Response
 */
export interface Price200Response {
  /**
   *
   * @type {Price200ResponsePrice}
   * @memberof Price200Response
   */
  price?: Price200ResponsePrice;
}
/**
 *
 * @export
 * @interface Price200ResponsePrice
 */
export interface Price200ResponsePrice {
  /**
   *
   * @type {string}
   * @memberof Price200ResponsePrice
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof Price200ResponsePrice
   */
  price?: string;
}
/**
 *
 * @export
 * @interface PriceAll200Response
 */
export interface PriceAll200Response {
  /**
   *
   * @type {Array<Price200ResponsePrice>}
   * @memberof PriceAll200Response
   */
  prices?: Array<Price200ResponsePrice>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof PriceAll200Response
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface PricefeedParams200Response
 */
export interface PricefeedParams200Response {
  /**
   *
   * @type {PricefeedParams200ResponseParams}
   * @memberof PricefeedParams200Response
   */
  params?: PricefeedParams200ResponseParams;
}
/**
 *
 * @export
 * @interface PricefeedParams200ResponseParams
 */
export interface PricefeedParams200ResponseParams {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof PricefeedParams200ResponseParams
   */
  deposit_for_posting?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof PricefeedParams200ResponseParams
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
}
/**
 *
 * @export
 * @interface RawPriceAll200Response
 */
export interface RawPriceAll200Response {
  /**
   *
   * @type {Array<RawPriceAll200ResponsePricesInner>}
   * @memberof RawPriceAll200Response
   */
  prices?: Array<RawPriceAll200ResponsePricesInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof RawPriceAll200Response
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface RawPriceAll200ResponsePricesInner
 */
export interface RawPriceAll200ResponsePricesInner {
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  oracle_address?: string;
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  expiry?: string;
}
/**
 *
 * @export
 * @interface RecipientAddressWithNftId200Response
 */
export interface RecipientAddressWithNftId200Response {
  /**
   *
   * @type {string}
   * @memberof RecipientAddressWithNftId200Response
   */
  address?: string;
}
/**
 *
 * @export
 * @interface RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
 */
export interface RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1 {
  /**
   *
   * @type {string}
   * @memberof RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
   */
  module_name?: string;
  /**
   *
   * @type {Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>}
   * @memberof RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
   */
  reward_rate?: Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>;
}
/**
 *
 * @export
 * @interface RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
 */
export interface RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1 {
  /**
   * STAKERS type reward will be distributed for the stakers of GUU token. FRONTEND_DEVELOPERS type reward will be disributed for the creators of frontend of UnUniFi\'s services. COMMUNITY_POOL type reward will be distributed for the community pool.
   * @type {string}
   * @memberof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
   */
  reward_type?: RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum;
  /**
   *
   * @type {string}
   * @memberof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
   */
  rate?: string;
}

export const RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum = {
  Unknown: 'UNKNOWN',
  Stakers: 'STAKERS',
  FrontendDevelopers: 'FRONTEND_DEVELOPERS',
  CommunityPool: 'COMMUNITY_POOL',
} as const;

export type RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum =
  (typeof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum)[keyof typeof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum];

/**
 *
 * @export
 * @interface Strategy200Response
 */
export interface Strategy200Response {
  /**
   *
   * @type {StrategyAll200ResponseStrategiesInner}
   * @memberof Strategy200Response
   */
  strategy?: StrategyAll200ResponseStrategiesInner;
}
/**
 *
 * @export
 * @interface StrategyAll200Response
 */
export interface StrategyAll200Response {
  /**
   *
   * @type {Array<StrategyAll200ResponseStrategiesInner>}
   * @memberof StrategyAll200Response
   */
  strategies?: Array<StrategyAll200ResponseStrategiesInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof StrategyAll200Response
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface StrategyAll200ResponseStrategiesInner
 */
export interface StrategyAll200ResponseStrategiesInner {
  /**
   *
   * @type {StrategyAll200ResponseStrategiesInnerStrategy}
   * @memberof StrategyAll200ResponseStrategiesInner
   */
  strategy?: StrategyAll200ResponseStrategiesInnerStrategy;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInner
   */
  deposit_fee_rate?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInner
   */
  withdraw_fee_rate?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInner
   */
  performance_fee_rate?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInner
   */
  symbol?: string;
}
/**
 *
 * @export
 * @interface StrategyAll200ResponseStrategiesInnerStrategy
 */
export interface StrategyAll200ResponseStrategiesInnerStrategy {
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInnerStrategy
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInnerStrategy
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInnerStrategy
   */
  contract_address?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInnerStrategy
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInnerStrategy
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof StrategyAll200ResponseStrategiesInnerStrategy
   */
  git_url?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface SumOfAllLPTokensSentOut
 */
export interface SumOfAllLPTokensSentOut {
  /**
   *
   * @type {string}
   * @memberof SumOfAllLPTokensSentOut
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof SumOfAllLPTokensSentOut
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface SymbolInfos200Response
 */
export interface SymbolInfos200Response {
  /**
   *
   * @type {Array<SymbolInfos200ResponseInfoInner>}
   * @memberof SymbolInfos200Response
   */
  info?: Array<SymbolInfos200ResponseInfoInner>;
}
/**
 *
 * @export
 * @interface SymbolInfos200ResponseInfoInner
 */
export interface SymbolInfos200ResponseInfoInner {
  /**
   *
   * @type {string}
   * @memberof SymbolInfos200ResponseInfoInner
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof SymbolInfos200ResponseInfoInner
   */
  native_chain_id?: string;
  /**
   *
   * @type {Array<DenomInfos200ResponseInfoInnerChannelsInner>}
   * @memberof SymbolInfos200ResponseInfoInner
   */
  channels?: Array<DenomInfos200ResponseInfoInnerChannelsInner>;
}
/**
 * QueryTranchResponse is response type for the Query/Tranch RPC method.
 * @export
 * @interface Tranche200Response
 */
export interface Tranche200Response {
  /**
   *
   * @type {AllTranches200ResponseTranchesInner}
   * @memberof Tranche200Response
   */
  tranche?: AllTranches200ResponseTranchesInner;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesMarket
 */
export interface UnunifiDerivativesMarket {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesMarket
   */
  base_denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesMarket
   */
  quote_denom?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesParams
 */
export interface UnunifiDerivativesParams {
  /**
   *
   * @type {DerivativesParams200ResponseParamsPoolParams}
   * @memberof UnunifiDerivativesParams
   */
  pool_params?: DerivativesParams200ResponseParamsPoolParams;
  /**
   *
   * @type {DerivativesParams200ResponseParamsPerpetualFutures}
   * @memberof UnunifiDerivativesParams
   */
  perpetual_futures?: DerivativesParams200ResponseParamsPerpetualFutures;
  /**
   *
   * @type {DerivativesParams200ResponseParamsPerpetualOptions}
   * @memberof UnunifiDerivativesParams
   */
  perpetual_options?: DerivativesParams200ResponseParamsPerpetualOptions;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPendingPaymentPosition
 */
export interface UnunifiDerivativesPendingPaymentPosition {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPendingPaymentPosition
   */
  id?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesPendingPaymentPosition
   */
  refundable_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPendingPaymentPosition
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPendingPaymentPosition
   */
  created_height?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPerpetualFuturesParams
 */
export interface UnunifiDerivativesPerpetualFuturesParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPerpetualFuturesParams
   */
  commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPerpetualFuturesParams
   */
  margin_maintenance_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPerpetualFuturesParams
   */
  imaginary_funding_rate_proportional_coefficient?: string;
  /**
   *
   * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
   * @memberof UnunifiDerivativesPerpetualFuturesParams
   */
  markets?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
  /**
   *
   * @type {number}
   * @memberof UnunifiDerivativesPerpetualFuturesParams
   */
  max_leverage?: number;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPerpetualOptionsParams
 */
export interface UnunifiDerivativesPerpetualOptionsParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPerpetualOptionsParams
   */
  premium_commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPerpetualOptionsParams
   */
  strike_commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPerpetualOptionsParams
   */
  margin_maintenance_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPerpetualOptionsParams
   */
  imaginary_funding_rate_proportional_coefficient?: string;
  /**
   *
   * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
   * @memberof UnunifiDerivativesPerpetualOptionsParams
   */
  markets?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPoolAssetConf
 */
export interface UnunifiDerivativesPoolAssetConf {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolAssetConf
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolAssetConf
   */
  target_weight?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPoolMarketCap
 */
export interface UnunifiDerivativesPoolMarketCap {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolMarketCap
   */
  quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolMarketCap
   */
  total?: string;
  /**
   *
   * @type {Array<Pool200ResponsePoolMarketCapAssetInfoInner>}
   * @memberof UnunifiDerivativesPoolMarketCap
   */
  asset_info?: Array<Pool200ResponsePoolMarketCapAssetInfoInner>;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPoolMarketCapAssetInfo
 */
export interface UnunifiDerivativesPoolMarketCapAssetInfo {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
   */
  reserved?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPoolParams
 */
export interface UnunifiDerivativesPoolParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolParams
   */
  quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolParams
   */
  base_lpt_mint_fee?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolParams
   */
  base_lpt_redeem_fee?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolParams
   */
  borrowing_fee_rate_per_hour?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolParams
   */
  report_liquidation_reward_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolParams
   */
  report_levy_period_reward_rate?: string;
  /**
   *
   * @type {Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>}
   * @memberof UnunifiDerivativesPoolParams
   */
  accepted_assets_conf?: Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPoolParams
   */
  levy_period_required_seconds?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesPosition
 */
export interface UnunifiDerivativesPosition {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPosition
   */
  id?: string;
  /**
   *
   * @type {DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner}
   * @memberof UnunifiDerivativesPosition
   */
  market?: DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPosition
   */
  opener_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPosition
   */
  opened_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPosition
   */
  opened_height?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPosition
   */
  opened_base_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPosition
   */
  opened_quote_rate?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesPosition
   */
  remaining_margin?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesPosition
   */
  levied_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiDerivativesPosition
   */
  levied_amount_negative?: boolean;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesPosition
   */
  last_levied_at?: string;
  /**
   *
   * @type {EstimateDLPTokenAmountDefaultResponseDetailsInner}
   * @memberof UnunifiDerivativesPosition
   */
  position_instance?: EstimateDLPTokenAmountDefaultResponseDetailsInner;
}
/**
 *
 * @export
 * @enum {string}
 */

export const UnunifiDerivativesPositionType = {
  PositionUnknown: 'POSITION_UNKNOWN',
  Long: 'LONG',
  Short: 'SHORT',
} as const;

export type UnunifiDerivativesPositionType = (typeof UnunifiDerivativesPositionType)[keyof typeof UnunifiDerivativesPositionType];

/**
 *
 * @export
 * @interface UnunifiDerivativesQueriedPosition
 */
export interface UnunifiDerivativesQueriedPosition {
  /**
   *
   * @type {AllPositions200ResponsePositionsInner}
   * @memberof UnunifiDerivativesQueriedPosition
   */
  position?: AllPositions200ResponsePositionsInner;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueriedPosition
   */
  valuation_profit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueriedPosition
   */
  remaining_margin_value?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueriedPosition
   */
  effective_margin?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueriedPosition
   */
  margin_maintenance_rate?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryAddressPositionsResponse
 */
export interface UnunifiDerivativesQueryAddressPositionsResponse {
  /**
   *
   * @type {Array<AddressPositions200ResponsePositionsInner>}
   * @memberof UnunifiDerivativesQueryAddressPositionsResponse
   */
  positions?: Array<AddressPositions200ResponsePositionsInner>;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryAllPendingPaymentPositionsResponse
 */
export interface UnunifiDerivativesQueryAllPendingPaymentPositionsResponse {
  /**
   *
   * @type {Array<AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner>}
   * @memberof UnunifiDerivativesQueryAllPendingPaymentPositionsResponse
   */
  pending_payment_positions?: Array<AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner>;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryAllPositionsResponse
 */
export interface UnunifiDerivativesQueryAllPositionsResponse {
  /**
   *
   * @type {Array<AllPositions200ResponsePositionsInner>}
   * @memberof UnunifiDerivativesQueryAllPositionsResponse
   */
  positions?: Array<AllPositions200ResponsePositionsInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof UnunifiDerivativesQueryAllPositionsResponse
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryAvailableAssetsInPoolResponse
 */
export interface UnunifiDerivativesQueryAvailableAssetsInPoolResponse {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiDerivativesQueryAvailableAssetsInPoolResponse
   */
  available_assets?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryDLPTokenRateResponse
 */
export interface UnunifiDerivativesQueryDLPTokenRateResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryDLPTokenRateResponse
   */
  symbol?: string;
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiDerivativesQueryDLPTokenRateResponse
   */
  rates?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryEstimateDLPTokenAmountResponse
 */
export interface UnunifiDerivativesQueryEstimateDLPTokenAmountResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueryEstimateDLPTokenAmountResponse
   */
  estimated_dlp_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueryEstimateDLPTokenAmountResponse
   */
  deposit_fee?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse
 */
export interface UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse
   */
  fee?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryLiquidityProviderTokenNominalAPYResponse
 */
export interface UnunifiDerivativesQueryLiquidityProviderTokenNominalAPYResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryLiquidityProviderTokenNominalAPYResponse
   */
  apy?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryLiquidityProviderTokenRealAPYResponse
 */
export interface UnunifiDerivativesQueryLiquidityProviderTokenRealAPYResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryLiquidityProviderTokenRealAPYResponse
   */
  apy?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface UnunifiDerivativesQueryParamsResponse
 */
export interface UnunifiDerivativesQueryParamsResponse {
  /**
   *
   * @type {DerivativesParams200ResponseParams}
   * @memberof UnunifiDerivativesQueryParamsResponse
   */
  params?: DerivativesParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryPendingPaymentPositionResponse
 */
export interface UnunifiDerivativesQueryPendingPaymentPositionResponse {
  /**
   *
   * @type {AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner}
   * @memberof UnunifiDerivativesQueryPendingPaymentPositionResponse
   */
  pending_payment_position?: AllPendingPaymentPositions200ResponsePendingPaymentPositionsInner;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryPerpetualFuturesMarketResponse
 */
export interface UnunifiDerivativesQueryPerpetualFuturesMarketResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
   */
  metrics_quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
   */
  long_positions?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
   */
  short_positions?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryPerpetualFuturesPositionSizeResponse
 */
export interface UnunifiDerivativesQueryPerpetualFuturesPositionSizeResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesPositionSizeResponse
   */
  total_position_size_usd?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryPerpetualFuturesResponse
 */
export interface UnunifiDerivativesQueryPerpetualFuturesResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
   */
  metrics_quote_ticker?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
   */
  long_positions?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
   */
  short_positions?: string;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryPoolResponse
 */
export interface UnunifiDerivativesQueryPoolResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPoolResponse
   */
  metrics_quote_ticker?: string;
  /**
   *
   * @type {Pool200ResponsePoolMarketCap}
   * @memberof UnunifiDerivativesQueryPoolResponse
   */
  pool_market_cap?: Pool200ResponsePoolMarketCap;
}
/**
 *
 * @export
 * @interface UnunifiDerivativesQueryPositionResponse
 */
export interface UnunifiDerivativesQueryPositionResponse {
  /**
   *
   * @type {AllPositions200ResponsePositionsInner}
   * @memberof UnunifiDerivativesQueryPositionResponse
   */
  position?: AllPositions200ResponsePositionsInner;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueryPositionResponse
   */
  valuation_profit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiDerivativesQueryPositionResponse
   */
  margin_maintenance_rate?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiDerivativesQueryPositionResponse
   */
  effective_margin?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * Params defines the parameters for the module.
 * @export
 * @interface UnunifiEcosystemincentiveParams
 */
export interface UnunifiEcosystemincentiveParams {
  /**
   *
   * @type {Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>}
   * @memberof UnunifiEcosystemincentiveParams
   */
  reward_params?: Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftbackedloanModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryEcosystemRewardsResponse
 */
export interface UnunifiEcosystemincentiveQueryEcosystemRewardsResponse {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiEcosystemincentiveQueryEcosystemRewardsResponse
   */
  rewards?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryParamsResponse
 */
export interface UnunifiEcosystemincentiveQueryParamsResponse {
  /**
   *
   * @type {EcosystemIncentiveParams200ResponseParams}
   * @memberof UnunifiEcosystemincentiveQueryParamsResponse
   */
  params?: EcosystemIncentiveParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryRecipientAddressWithNftIdResponse
 */
export interface UnunifiEcosystemincentiveQueryRecipientAddressWithNftIdResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveQueryRecipientAddressWithNftIdResponse
   */
  address?: string;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveRewardParams
 */
export interface UnunifiEcosystemincentiveRewardParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveRewardParams
   */
  module_name?: string;
  /**
   *
   * @type {Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>}
   * @memberof UnunifiEcosystemincentiveRewardParams
   */
  reward_rate?: Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveRewardRate
 */
export interface UnunifiEcosystemincentiveRewardRate {
  /**
   * STAKERS type reward will be distributed for the stakers of GUU token. FRONTEND_DEVELOPERS type reward will be disributed for the creators of frontend of UnUniFi\'s services. COMMUNITY_POOL type reward will be distributed for the community pool.
   * @type {string}
   * @memberof UnunifiEcosystemincentiveRewardRate
   */
  reward_type?: UnunifiEcosystemincentiveRewardRateRewardTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveRewardRate
   */
  rate?: string;
}

export const UnunifiEcosystemincentiveRewardRateRewardTypeEnum = {
  Unknown: 'UNKNOWN',
  Stakers: 'STAKERS',
  FrontendDevelopers: 'FRONTEND_DEVELOPERS',
  CommunityPool: 'COMMUNITY_POOL',
} as const;

export type UnunifiEcosystemincentiveRewardRateRewardTypeEnum =
  (typeof UnunifiEcosystemincentiveRewardRateRewardTypeEnum)[keyof typeof UnunifiEcosystemincentiveRewardRateRewardTypeEnum];

/**
 * STAKERS type reward will be distributed for the stakers of GUU token. FRONTEND_DEVELOPERS type reward will be disributed for the creators of frontend of UnUniFi\'s services. COMMUNITY_POOL type reward will be distributed for the community pool.
 * @export
 * @enum {string}
 */

export const UnunifiEcosystemincentiveRewardType = {
  Unknown: 'UNKNOWN',
  Stakers: 'STAKERS',
  FrontendDevelopers: 'FRONTEND_DEVELOPERS',
  CommunityPool: 'COMMUNITY_POOL',
} as const;

export type UnunifiEcosystemincentiveRewardType =
  (typeof UnunifiEcosystemincentiveRewardType)[keyof typeof UnunifiEcosystemincentiveRewardType];

/**
 *
 * @export
 * @interface UnunifiIrsInterestRateSwapVault
 */
export interface UnunifiIrsInterestRateSwapVault {
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsInterestRateSwapVault
   */
  strategy_contract?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsInterestRateSwapVault
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsInterestRateSwapVault
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsInterestRateSwapVault
   */
  max_maturity?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsInterestRateSwapVault
   */
  cycle?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsInterestRateSwapVault
   */
  last_tranche_time?: string;
}
/**
 *
 * @export
 * @interface UnunifiIrsParams
 */
export interface UnunifiIrsParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsParams
   */
  authority?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsParams
   */
  trade_fee_rate?: string;
}
/**
 *
 * @export
 * @interface UnunifiIrsQueryEstimateMintLiquidityPoolTokenResponse
 */
export interface UnunifiIrsQueryEstimateMintLiquidityPoolTokenResponse {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiIrsQueryEstimateMintLiquidityPoolTokenResponse
   */
  required_amount?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface UnunifiIrsQueryEstimateMintPtYtPairResponse
 */
export interface UnunifiIrsQueryEstimateMintPtYtPairResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiIrsQueryEstimateMintPtYtPairResponse
   */
  pt_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiIrsQueryEstimateMintPtYtPairResponse
   */
  yt_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface UnunifiIrsQueryEstimateRedeemLiquidityPoolTokenResponse
 */
export interface UnunifiIrsQueryEstimateRedeemLiquidityPoolTokenResponse {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiIrsQueryEstimateRedeemLiquidityPoolTokenResponse
   */
  redeem_amount?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface UnunifiIrsQueryEstimateRedeemYtResponse
 */
export interface UnunifiIrsQueryEstimateRedeemYtResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiIrsQueryEstimateRedeemYtResponse
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface UnunifiIrsQueryEstimateSwapInPoolResponse
 */
export interface UnunifiIrsQueryEstimateSwapInPoolResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiIrsQueryEstimateSwapInPoolResponse
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface UnunifiIrsQueryParamsResponse
 */
export interface UnunifiIrsQueryParamsResponse {
  /**
   *
   * @type {IrsParams200ResponseParams}
   * @memberof UnunifiIrsQueryParamsResponse
   */
  params?: IrsParams200ResponseParams;
}
/**
 * QueryTranchResponse is response type for the Query/Tranch RPC method.
 * @export
 * @interface UnunifiIrsQueryTrancheResponse
 */
export interface UnunifiIrsQueryTrancheResponse {
  /**
   *
   * @type {AllTranches200ResponseTranchesInner}
   * @memberof UnunifiIrsQueryTrancheResponse
   */
  tranche?: AllTranches200ResponseTranchesInner;
}
/**
 * QueryTranchesResponse is response type for the Query/Tranches RPC method.
 * @export
 * @interface UnunifiIrsQueryTranchesResponse
 */
export interface UnunifiIrsQueryTranchesResponse {
  /**
   *
   * @type {Array<AllTranches200ResponseTranchesInner>}
   * @memberof UnunifiIrsQueryTranchesResponse
   */
  tranches?: Array<AllTranches200ResponseTranchesInner>;
}
/**
 * QueryVaultResponse is response type for the Query/Vault RPC method.
 * @export
 * @interface UnunifiIrsQueryVaultByContractResponse
 */
export interface UnunifiIrsQueryVaultByContractResponse {
  /**
   *
   * @type {VaultByContract200ResponseVault}
   * @memberof UnunifiIrsQueryVaultByContractResponse
   */
  vault?: VaultByContract200ResponseVault;
}
/**
 * QueryVaultDetailsResponse is response type for the Query/VaultDetails RPC method.
 * @export
 * @interface UnunifiIrsQueryVaultDetailsResponse
 */
export interface UnunifiIrsQueryVaultDetailsResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsQueryVaultDetailsResponse
   */
  liquidity_pool?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsQueryVaultDetailsResponse
   */
  fy_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsQueryVaultDetailsResponse
   */
  lvy_rate?: string;
}
/**
 * QueryVaultsResponse is response type for the Query/Vaults RPC method.
 * @export
 * @interface UnunifiIrsQueryVaultsResponse
 */
export interface UnunifiIrsQueryVaultsResponse {
  /**
   *
   * @type {Array<VaultByContract200ResponseVault>}
   * @memberof UnunifiIrsQueryVaultsResponse
   */
  vaults?: Array<VaultByContract200ResponseVault>;
}
/**
 *
 * @export
 * @interface UnunifiIrsTranchePool
 */
export interface UnunifiIrsTranchePool {
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsTranchePool
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsTranchePool
   */
  strategy_contract?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsTranchePool
   */
  start_time?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsTranchePool
   */
  maturity?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsTranchePool
   */
  swap_fee?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIrsTranchePool
   */
  exit_fee?: string;
  /**
   *
   * @type {SumOfAllLPTokensSentOut}
   * @memberof UnunifiIrsTranchePool
   */
  total_shares?: SumOfAllLPTokensSentOut;
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiIrsTranchePool
   */
  pool_assets?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanBid
 */
export interface UnunifiNftbackedloanBid {
  /**
   *
   * @type {NftBids200ResponseBidsInnerId}
   * @memberof UnunifiNftbackedloanBid
   */
  id?: NftBids200ResponseBidsInnerId;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanBid
   */
  price?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanBid
   */
  deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanBid
   */
  paid_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanBid
   */
  expiry?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanBid
   */
  interest_rate?: string;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiNftbackedloanBid
   */
  automatic_payment?: boolean;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanBid
   */
  created_at?: string;
  /**
   *
   * @type {BorrowInfo}
   * @memberof UnunifiNftbackedloanBid
   */
  loan?: BorrowInfo;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanBidId
 */
export interface UnunifiNftbackedloanBidId {
  /**
   *
   * @type {NftBids200ResponseBidsInnerIdNftId}
   * @memberof UnunifiNftbackedloanBidId
   */
  nft_id?: NftBids200ResponseBidsInnerIdNftId;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanBidId
   */
  bidder?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanLiquidation
 */
export interface UnunifiNftbackedloanLiquidation {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanLiquidation
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanLiquidation
   */
  liquidation_date?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanLiquidations
 */
export interface UnunifiNftbackedloanLiquidations {
  /**
   *
   * @type {Liquidation200ResponseLiquidationsLiquidation}
   * @memberof UnunifiNftbackedloanLiquidations
   */
  liquidation?: Liquidation200ResponseLiquidationsLiquidation;
  /**
   *
   * @type {Array<Liquidation200ResponseLiquidationsLiquidation>}
   * @memberof UnunifiNftbackedloanLiquidations
   */
  next_liquidation?: Array<Liquidation200ResponseLiquidationsLiquidation>;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanListedNftDetail
 */
export interface UnunifiNftbackedloanListedNftDetail {
  /**
   *
   * @type {ListedNfts200ResponseListingsInnerListing}
   * @memberof UnunifiNftbackedloanListedNftDetail
   */
  listing?: ListedNfts200ResponseListingsInnerListing;
  /**
   *
   * @type {ListedClasses200ResponseClassesInnerNftsInner}
   * @memberof UnunifiNftbackedloanListedNftDetail
   */
  nft_info?: ListedClasses200ResponseClassesInnerNftsInner;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanListing
 */
export interface UnunifiNftbackedloanListing {
  /**
   *
   * @type {NftBids200ResponseBidsInnerIdNftId}
   * @memberof UnunifiNftbackedloanListing
   */
  nft_id?: NftBids200ResponseBidsInnerIdNftId;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  state?: UnunifiNftbackedloanListingStateEnum;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  bid_denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  min_deposit_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  min_bid_period?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  started_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  liquidated_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  full_payment_end_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanListing
   */
  successful_bid_end_at?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanListing
   */
  collected_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiNftbackedloanListing
   */
  collected_amount_negative?: boolean;
}

export const UnunifiNftbackedloanListingStateEnum = {
  Unknown: 'UNKNOWN',
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type UnunifiNftbackedloanListingStateEnum =
  (typeof UnunifiNftbackedloanListingStateEnum)[keyof typeof UnunifiNftbackedloanListingStateEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const UnunifiNftbackedloanListingState = {
  Unknown: 'UNKNOWN',
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type UnunifiNftbackedloanListingState = (typeof UnunifiNftbackedloanListingState)[keyof typeof UnunifiNftbackedloanListingState];

/**
 *
 * @export
 * @interface UnunifiNftbackedloanLoan
 */
export interface UnunifiNftbackedloanLoan {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanLoan
   */
  amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanLoan
   */
  last_repaid_at?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanNftId
 */
export interface UnunifiNftbackedloanNftId {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanNftId
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanNftId
   */
  token_id?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanNftInfo
 */
export interface UnunifiNftbackedloanNftInfo {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanNftInfo
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanNftInfo
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanNftInfo
   */
  uri_hash?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanParams
 */
export interface UnunifiNftbackedloanParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanParams
   */
  min_staking_for_listing?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiNftbackedloanParams
   */
  bid_tokens?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanParams
   */
  nft_listing_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanParams
   */
  bid_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanParams
   */
  nft_listing_full_payment_period?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanParams
   */
  nft_listing_nft_delivery_period?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanParams
   */
  nft_listing_commission_rate?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryBidderBidsResponse
 */
export interface UnunifiNftbackedloanQueryBidderBidsResponse {
  /**
   *
   * @type {Array<NftBids200ResponseBidsInner>}
   * @memberof UnunifiNftbackedloanQueryBidderBidsResponse
   */
  bids?: Array<NftBids200ResponseBidsInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryLiquidationResponse
 */
export interface UnunifiNftbackedloanQueryLiquidationResponse {
  /**
   *
   * @type {Liquidation200ResponseLiquidations}
   * @memberof UnunifiNftbackedloanQueryLiquidationResponse
   */
  liquidations?: Liquidation200ResponseLiquidations;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryListedClassResponse
 */
export interface UnunifiNftbackedloanQueryListedClassResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  urihash?: string;
  /**
   *
   * @type {Array<ListedClasses200ResponseClassesInnerNftsInner>}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  nfts?: Array<ListedClasses200ResponseClassesInnerNftsInner>;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftbackedloanQueryListedClassResponse
   */
  nft_count?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryListedClassesResponse
 */
export interface UnunifiNftbackedloanQueryListedClassesResponse {
  /**
   *
   * @type {Array<ListedClasses200ResponseClassesInner>}
   * @memberof UnunifiNftbackedloanQueryListedClassesResponse
   */
  classes?: Array<ListedClasses200ResponseClassesInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryListedNftResponse
 */
export interface UnunifiNftbackedloanQueryListedNftResponse {
  /**
   *
   * @type {ListedNfts200ResponseListingsInnerListing}
   * @memberof UnunifiNftbackedloanQueryListedNftResponse
   */
  listing?: ListedNfts200ResponseListingsInnerListing;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryListedNftsResponse
 */
export interface UnunifiNftbackedloanQueryListedNftsResponse {
  /**
   *
   * @type {Array<ListedNfts200ResponseListingsInner>}
   * @memberof UnunifiNftbackedloanQueryListedNftsResponse
   */
  listings?: Array<ListedNfts200ResponseListingsInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryLoanResponse
 */
export interface UnunifiNftbackedloanQueryLoanResponse {
  /**
   *
   * @type {NftBids200ResponseBidsInnerIdNftId}
   * @memberof UnunifiNftbackedloanQueryLoanResponse
   */
  nft_id?: NftBids200ResponseBidsInnerIdNftId;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanQueryLoanResponse
   */
  borrowing_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanQueryLoanResponse
   */
  borrowing_limit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiNftbackedloanQueryLoanResponse
   */
  total_deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryNftBidsResponse
 */
export interface UnunifiNftbackedloanQueryNftBidsResponse {
  /**
   *
   * @type {Array<NftBids200ResponseBidsInner>}
   * @memberof UnunifiNftbackedloanQueryNftBidsResponse
   */
  bids?: Array<NftBids200ResponseBidsInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryParamsResponse
 */
export interface UnunifiNftbackedloanQueryParamsResponse {
  /**
   *
   * @type {NftBackedLoanParams200ResponseParams}
   * @memberof UnunifiNftbackedloanQueryParamsResponse
   */
  params?: NftBackedLoanParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiNftbackedloanQueryRewardsResponse
 */
export interface UnunifiNftbackedloanQueryRewardsResponse {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiNftbackedloanQueryRewardsResponse
   */
  rewards?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * ClassAuthorityMetadata specifies metadata for addresses that have specific capabilities over a nft factory class. Right now there is only one Admin permission, but is planned to be extended to the future.
 * @export
 * @interface UnunifiNftfactoryClassAuthorityMetadata
 */
export interface UnunifiNftfactoryClassAuthorityMetadata {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftfactoryClassAuthorityMetadata
   */
  Admin?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftfactoryParams
 */
export interface UnunifiNftfactoryParams {
  /**
   *
   * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
   * @memberof UnunifiNftfactoryParams
   */
  class_creation_fee?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftfactoryParams
   */
  fee_collector_address?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftfactoryQueryClassAuthorityMetadataResponse
 */
export interface UnunifiNftfactoryQueryClassAuthorityMetadataResponse {
  /**
   *
   * @type {ClassAuthorityMetadata200ResponseAuthorityMetadata}
   * @memberof UnunifiNftfactoryQueryClassAuthorityMetadataResponse
   */
  authority_metadata?: ClassAuthorityMetadata200ResponseAuthorityMetadata;
}
/**
 *
 * @export
 * @interface UnunifiNftfactoryQueryClassesFromCreatorResponse
 */
export interface UnunifiNftfactoryQueryClassesFromCreatorResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiNftfactoryQueryClassesFromCreatorResponse
   */
  classes?: Array<string>;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface UnunifiNftfactoryQueryParamsResponse
 */
export interface UnunifiNftfactoryQueryParamsResponse {
  /**
   *
   * @type {NftFactoryParams200ResponseParams}
   * @memberof UnunifiNftfactoryQueryParamsResponse
   */
  params?: NftFactoryParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedCurrentPrice
 */
export interface UnunifiPricefeedCurrentPrice {
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedCurrentPrice
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedCurrentPrice
   */
  price?: string;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedMarket
 */
export interface UnunifiPricefeedMarket {
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedMarket
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedMarket
   */
  base_asset?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedMarket
   */
  quote_asset?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiPricefeedMarket
   */
  oracles?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiPricefeedMarket
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedParams
 */
export interface UnunifiPricefeedParams {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiPricefeedParams
   */
  deposit_for_posting?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof UnunifiPricefeedParams
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedPostedPrice
 */
export interface UnunifiPricefeedPostedPrice {
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  oracle_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  expiry?: string;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllMarketResponse
 */
export interface UnunifiPricefeedQueryAllMarketResponse {
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof UnunifiPricefeedQueryAllMarketResponse
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllMarketResponse
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllOracleResponse
 */
export interface UnunifiPricefeedQueryAllOracleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiPricefeedQueryAllOracleResponse
   */
  oracles?: Array<string>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllOracleResponse
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllPriceResponse
 */
export interface UnunifiPricefeedQueryAllPriceResponse {
  /**
   *
   * @type {Array<Price200ResponsePrice>}
   * @memberof UnunifiPricefeedQueryAllPriceResponse
   */
  prices?: Array<Price200ResponsePrice>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllPriceResponse
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllRawPriceResponse
 */
export interface UnunifiPricefeedQueryAllRawPriceResponse {
  /**
   *
   * @type {Array<RawPriceAll200ResponsePricesInner>}
   * @memberof UnunifiPricefeedQueryAllRawPriceResponse
   */
  prices?: Array<RawPriceAll200ResponsePricesInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllRawPriceResponse
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryGetPriceResponse
 */
export interface UnunifiPricefeedQueryGetPriceResponse {
  /**
   *
   * @type {Price200ResponsePrice}
   * @memberof UnunifiPricefeedQueryGetPriceResponse
   */
  price?: Price200ResponsePrice;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryParamsResponse
 */
export interface UnunifiPricefeedQueryParamsResponse {
  /**
   *
   * @type {PricefeedParams200ResponseParams}
   * @memberof UnunifiPricefeedQueryParamsResponse
   */
  params?: PricefeedParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorChainAddress
 */
export interface UnunifiYieldaggregatorChainAddress {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorChainAddress
   */
  chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorChainAddress
   */
  address?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorDenomInfo
 */
export interface UnunifiYieldaggregatorDenomInfo {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorDenomInfo
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorDenomInfo
   */
  symbol?: string;
  /**
   *
   * @type {Array<DenomInfos200ResponseInfoInnerChannelsInner>}
   * @memberof UnunifiYieldaggregatorDenomInfo
   */
  channels?: Array<DenomInfos200ResponseInfoInnerChannelsInner>;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorParams
 */
export interface UnunifiYieldaggregatorParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorParams
   */
  commission_rate?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiYieldaggregatorParams
   */
  vault_creation_fee?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiYieldaggregatorParams
   */
  vault_creation_deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorParams
   */
  fee_collector_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorParams
   */
  ibc_transfer_timeout_nanos?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryAllStrategyResponse
 */
export interface UnunifiYieldaggregatorQueryAllStrategyResponse {
  /**
   *
   * @type {Array<StrategyAll200ResponseStrategiesInner>}
   * @memberof UnunifiYieldaggregatorQueryAllStrategyResponse
   */
  strategies?: Array<StrategyAll200ResponseStrategiesInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof UnunifiYieldaggregatorQueryAllStrategyResponse
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryAllVaultByShareHolderResponse
 */
export interface UnunifiYieldaggregatorQueryAllVaultByShareHolderResponse {
  /**
   *
   * @type {Array<VaultAll200ResponseVaultsInner>}
   * @memberof UnunifiYieldaggregatorQueryAllVaultByShareHolderResponse
   */
  vaults?: Array<VaultAll200ResponseVaultsInner>;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryAllVaultResponse
 */
export interface UnunifiYieldaggregatorQueryAllVaultResponse {
  /**
   *
   * @type {Array<VaultAll200ResponseVaultsInner>}
   * @memberof UnunifiYieldaggregatorQueryAllVaultResponse
   */
  vaults?: Array<VaultAll200ResponseVaultsInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof UnunifiYieldaggregatorQueryAllVaultResponse
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryDenomInfosResponse
 */
export interface UnunifiYieldaggregatorQueryDenomInfosResponse {
  /**
   *
   * @type {Array<DenomInfos200ResponseInfoInner>}
   * @memberof UnunifiYieldaggregatorQueryDenomInfosResponse
   */
  info?: Array<DenomInfos200ResponseInfoInner>;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryEstimateMintAmountResponse
 */
export interface UnunifiYieldaggregatorQueryEstimateMintAmountResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiYieldaggregatorQueryEstimateMintAmountResponse
   */
  mint_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
 */
export interface UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse {
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
   */
  share_amount?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
   */
  fee?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
   */
  redeem_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
   */
  total_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
   */
  symbol?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryGetStrategyResponse
 */
export interface UnunifiYieldaggregatorQueryGetStrategyResponse {
  /**
   *
   * @type {StrategyAll200ResponseStrategiesInner}
   * @memberof UnunifiYieldaggregatorQueryGetStrategyResponse
   */
  strategy?: StrategyAll200ResponseStrategiesInner;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryGetVaultResponse
 */
export interface UnunifiYieldaggregatorQueryGetVaultResponse {
  /**
   *
   * @type {VaultAll200ResponseVaultsInnerVault}
   * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
   */
  vault?: VaultAll200ResponseVaultsInnerVault;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
   */
  total_bonded_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
   */
  total_unbonding_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
   */
  withdraw_reserve?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
   */
  total_pending_deposit?: string;
  /**
   *
   * @type {Array<StrategyAll200ResponseStrategiesInnerStrategy>}
   * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
   */
  strategies?: Array<StrategyAll200ResponseStrategiesInnerStrategy>;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQueryIntermediaryAccountInfoResponse
 */
export interface UnunifiYieldaggregatorQueryIntermediaryAccountInfoResponse {
  /**
   *
   * @type {Array<IntermediaryAccountInfo200ResponseAddrsInner>}
   * @memberof UnunifiYieldaggregatorQueryIntermediaryAccountInfoResponse
   */
  addrs?: Array<IntermediaryAccountInfo200ResponseAddrsInner>;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface UnunifiYieldaggregatorQueryParamsResponse
 */
export interface UnunifiYieldaggregatorQueryParamsResponse {
  /**
   *
   * @type {YieldAggregatorParams200ResponseParams}
   * @memberof UnunifiYieldaggregatorQueryParamsResponse
   */
  params?: YieldAggregatorParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorQuerySymbolInfosResponse
 */
export interface UnunifiYieldaggregatorQuerySymbolInfosResponse {
  /**
   *
   * @type {Array<SymbolInfos200ResponseInfoInner>}
   * @memberof UnunifiYieldaggregatorQuerySymbolInfosResponse
   */
  info?: Array<SymbolInfos200ResponseInfoInner>;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorStrategy
 */
export interface UnunifiYieldaggregatorStrategy {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategy
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategy
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategy
   */
  contract_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategy
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategy
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategy
   */
  git_url?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorStrategyContainer
 */
export interface UnunifiYieldaggregatorStrategyContainer {
  /**
   *
   * @type {StrategyAll200ResponseStrategiesInnerStrategy}
   * @memberof UnunifiYieldaggregatorStrategyContainer
   */
  strategy?: StrategyAll200ResponseStrategiesInnerStrategy;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategyContainer
   */
  deposit_fee_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategyContainer
   */
  withdraw_fee_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategyContainer
   */
  performance_fee_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategyContainer
   */
  symbol?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorStrategyWeight
 */
export interface UnunifiYieldaggregatorStrategyWeight {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategyWeight
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategyWeight
   */
  strategy_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorStrategyWeight
   */
  weight?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorSymbolInfo
 */
export interface UnunifiYieldaggregatorSymbolInfo {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorSymbolInfo
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorSymbolInfo
   */
  native_chain_id?: string;
  /**
   *
   * @type {Array<DenomInfos200ResponseInfoInnerChannelsInner>}
   * @memberof UnunifiYieldaggregatorSymbolInfo
   */
  channels?: Array<DenomInfos200ResponseInfoInnerChannelsInner>;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorTransferChannel
 */
export interface UnunifiYieldaggregatorTransferChannel {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorTransferChannel
   */
  send_chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorTransferChannel
   */
  recv_chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorTransferChannel
   */
  channel_id?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorVault
 */
export interface UnunifiYieldaggregatorVault {
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  owner?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof UnunifiYieldaggregatorVault
   */
  owner_deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  withdraw_commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  withdraw_reserve_rate?: string;
  /**
   *
   * @type {Array<VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner>}
   * @memberof UnunifiYieldaggregatorVault
   */
  strategy_weights?: Array<VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner>;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVault
   */
  fee_collector_address?: string;
}
/**
 *
 * @export
 * @interface UnunifiYieldaggregatorVaultContainer
 */
export interface UnunifiYieldaggregatorVaultContainer {
  /**
   *
   * @type {VaultAll200ResponseVaultsInnerVault}
   * @memberof UnunifiYieldaggregatorVaultContainer
   */
  vault?: VaultAll200ResponseVaultsInnerVault;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVaultContainer
   */
  total_bonded_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVaultContainer
   */
  total_unbonding_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVaultContainer
   */
  withdraw_reserve?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiYieldaggregatorVaultContainer
   */
  total_pending_deposit?: string;
}
/**
 *
 * @export
 * @interface Vault200Response
 */
export interface Vault200Response {
  /**
   *
   * @type {VaultAll200ResponseVaultsInnerVault}
   * @memberof Vault200Response
   */
  vault?: VaultAll200ResponseVaultsInnerVault;
  /**
   *
   * @type {string}
   * @memberof Vault200Response
   */
  total_bonded_amount?: string;
  /**
   *
   * @type {string}
   * @memberof Vault200Response
   */
  total_unbonding_amount?: string;
  /**
   *
   * @type {string}
   * @memberof Vault200Response
   */
  withdraw_reserve?: string;
  /**
   *
   * @type {string}
   * @memberof Vault200Response
   */
  total_pending_deposit?: string;
  /**
   *
   * @type {Array<StrategyAll200ResponseStrategiesInnerStrategy>}
   * @memberof Vault200Response
   */
  strategies?: Array<StrategyAll200ResponseStrategiesInnerStrategy>;
}
/**
 *
 * @export
 * @interface VaultAll200Response
 */
export interface VaultAll200Response {
  /**
   *
   * @type {Array<VaultAll200ResponseVaultsInner>}
   * @memberof VaultAll200Response
   */
  vaults?: Array<VaultAll200ResponseVaultsInner>;
  /**
   *
   * @type {AllPositions200ResponsePagination}
   * @memberof VaultAll200Response
   */
  pagination?: AllPositions200ResponsePagination;
}
/**
 *
 * @export
 * @interface VaultAll200ResponseVaultsInner
 */
export interface VaultAll200ResponseVaultsInner {
  /**
   *
   * @type {VaultAll200ResponseVaultsInnerVault}
   * @memberof VaultAll200ResponseVaultsInner
   */
  vault?: VaultAll200ResponseVaultsInnerVault;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInner
   */
  total_bonded_amount?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInner
   */
  total_unbonding_amount?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInner
   */
  withdraw_reserve?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInner
   */
  total_pending_deposit?: string;
}
/**
 *
 * @export
 * @interface VaultAll200ResponseVaultsInnerVault
 */
export interface VaultAll200ResponseVaultsInnerVault {
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  owner?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  owner_deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  withdraw_commission_rate?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  withdraw_reserve_rate?: string;
  /**
   *
   * @type {Array<VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner>}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  strategy_weights?: Array<VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner>;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVault
   */
  fee_collector_address?: string;
}
/**
 *
 * @export
 * @interface VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner
 */
export interface VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner {
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner
   */
  strategy_id?: string;
  /**
   *
   * @type {string}
   * @memberof VaultAll200ResponseVaultsInnerVaultStrategyWeightsInner
   */
  weight?: string;
}
/**
 *
 * @export
 * @interface VaultAllByShareHolder200Response
 */
export interface VaultAllByShareHolder200Response {
  /**
   *
   * @type {Array<VaultAll200ResponseVaultsInner>}
   * @memberof VaultAllByShareHolder200Response
   */
  vaults?: Array<VaultAll200ResponseVaultsInner>;
}
/**
 * QueryVaultResponse is response type for the Query/Vault RPC method.
 * @export
 * @interface VaultByContract200Response
 */
export interface VaultByContract200Response {
  /**
   *
   * @type {VaultByContract200ResponseVault}
   * @memberof VaultByContract200Response
   */
  vault?: VaultByContract200ResponseVault;
}
/**
 *
 * @export
 * @interface VaultByContract200ResponseVault
 */
export interface VaultByContract200ResponseVault {
  /**
   *
   * @type {string}
   * @memberof VaultByContract200ResponseVault
   */
  strategy_contract?: string;
  /**
   *
   * @type {string}
   * @memberof VaultByContract200ResponseVault
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof VaultByContract200ResponseVault
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof VaultByContract200ResponseVault
   */
  max_maturity?: string;
  /**
   *
   * @type {string}
   * @memberof VaultByContract200ResponseVault
   */
  cycle?: string;
  /**
   *
   * @type {string}
   * @memberof VaultByContract200ResponseVault
   */
  last_tranche_time?: string;
}
/**
 * QueryVaultDetailsResponse is response type for the Query/VaultDetails RPC method.
 * @export
 * @interface VaultDetails200Response
 */
export interface VaultDetails200Response {
  /**
   *
   * @type {string}
   * @memberof VaultDetails200Response
   */
  liquidity_pool?: string;
  /**
   *
   * @type {string}
   * @memberof VaultDetails200Response
   */
  fy_rate?: string;
  /**
   *
   * @type {string}
   * @memberof VaultDetails200Response
   */
  lvy_rate?: string;
}
/**
 * QueryVaultsResponse is response type for the Query/Vaults RPC method.
 * @export
 * @interface Vaults200Response
 */
export interface Vaults200Response {
  /**
   *
   * @type {Array<VaultByContract200ResponseVault>}
   * @memberof Vaults200Response
   */
  vaults?: Array<VaultByContract200ResponseVault>;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface YieldAggregatorParams200Response
 */
export interface YieldAggregatorParams200Response {
  /**
   *
   * @type {YieldAggregatorParams200ResponseParams}
   * @memberof YieldAggregatorParams200Response
   */
  params?: YieldAggregatorParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface YieldAggregatorParams200ResponseParams
 */
export interface YieldAggregatorParams200ResponseParams {
  /**
   *
   * @type {string}
   * @memberof YieldAggregatorParams200ResponseParams
   */
  commission_rate?: string;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof YieldAggregatorParams200ResponseParams
   */
  vault_creation_fee?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
   * @memberof YieldAggregatorParams200ResponseParams
   */
  vault_creation_deposit?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
  /**
   *
   * @type {string}
   * @memberof YieldAggregatorParams200ResponseParams
   */
  fee_collector_address?: string;
  /**
   *
   * @type {string}
   * @memberof YieldAggregatorParams200ResponseParams
   */
  ibc_transfer_timeout_nanos?: string;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addressPositions: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('addressPositions', 'address', address);
      const localVarPath = `/ununifi/derivatives/{address}/positions`.replace(`{${'address'}}`, encodeURIComponent(String(address)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allPendingPaymentPositions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/pending-payment-positions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allPositions: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/positions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Tranches by Strategy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allTranches: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/all-tranches`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    availableAssetsInPool: async (denom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/pools/available-assets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (denom !== undefined) {
        localVarQueryParameter['denom'] = denom;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bidderBids: async (bidder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'bidder' is not null or undefined
      assertParamExists('bidderBids', 'bidder', bidder);
      const localVarPath = `/ununifi/nftbackedloan/bids/{bidder}`.replace(`{${'bidder'}}`, encodeURIComponent(String(bidder)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} creator
     * @param {string} subclass
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classAuthorityMetadata: async (creator: string, subclass: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'creator' is not null or undefined
      assertParamExists('classAuthorityMetadata', 'creator', creator);
      // verify required parameter 'subclass' is not null or undefined
      assertParamExists('classAuthorityMetadata', 'subclass', subclass);
      const localVarPath = `/ununifi/nftfactory/class/factory/{creator}/{subclass}/authority-metadata`
        .replace(`{${'creator'}}`, encodeURIComponent(String(creator)))
        .replace(`{${'subclass'}}`, encodeURIComponent(String(subclass)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} creator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classesFromCreator: async (creator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'creator' is not null or undefined
      assertParamExists('classesFromCreator', 'creator', creator);
      const localVarPath = `/ununifi/nftfactory/classes-from-creator/{creator}`.replace(
        `{${'creator'}}`,
        encodeURIComponent(String(creator)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dLPTokenRates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/pools/dlp`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    denomInfos: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/yieldaggregator/denom-infos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    derivativesParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ecosystemIncentiveParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/ecosystemincentive/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} address
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ecosystemRewards: async (address: string, denom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('ecosystemRewards', 'address', address);
      const localVarPath = `/ununifi/ecosystemincentive/rewards/{address}`.replace(`{${'address'}}`, encodeURIComponent(String(address)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (denom !== undefined) {
        localVarQueryParameter['denom'] = denom;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [mintDenom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateDLPTokenAmount: async (mintDenom?: string, amount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/estimate-dlp-token-amount`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mintDenom !== undefined) {
        localVarQueryParameter['mint_denom'] = mintDenom;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {string} [depositAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateMintAmount: async (id: string, depositAmount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('estimateMintAmount', 'id', id);
      const localVarPath = `/ununifi/yieldaggregator/vaults/{id}/estimate-mint-amount`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (depositAmount !== undefined) {
        localVarQueryParameter['deposit_amount'] = depositAmount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Estimate tokens to mint liquidity pool token
     * @param {string} [poolId]
     * @param {string} [desiredAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateMintLiquidityPoolToken: async (
      poolId?: string,
      desiredAmount?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/estimate-mint-liquidity-pool-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (poolId !== undefined) {
        localVarQueryParameter['pool_id'] = poolId;
      }

      if (desiredAmount !== undefined) {
        localVarQueryParameter['desired_amount'] = desiredAmount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Estimate mint amount of PT&YT pair
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateMintPtYtPair: async (
      poolId?: string,
      denom?: string,
      amount?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/estimate-mint-pt-yt-pair`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (poolId !== undefined) {
        localVarQueryParameter['pool_id'] = poolId;
      }

      if (denom !== undefined) {
        localVarQueryParameter['denom'] = denom;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {string} [burnAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemAmount: async (id: string, burnAmount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('estimateRedeemAmount', 'id', id);
      const localVarPath = `/ununifi/yieldaggregator/vaults/{id}/estimate-redeem-amount`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (burnAmount !== undefined) {
        localVarQueryParameter['burn_amount'] = burnAmount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Estimate redeem amount of liquidity pool token
     * @param {string} [poolId]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemLiquidityPoolToken: async (poolId?: string, amount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/estimate-redeem-liquidity-pool-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (poolId !== undefined) {
        localVarQueryParameter['pool_id'] = poolId;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [redeemDenom]
     * @param {string} [lptAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemTokenAmount: async (redeemDenom?: string, lptAmount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/estimate-redeem-amount`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (redeemDenom !== undefined) {
        localVarQueryParameter['redeem_denom'] = redeemDenom;
      }

      if (lptAmount !== undefined) {
        localVarQueryParameter['lpt_amount'] = lptAmount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Estimate redeem amount of YT after maturity
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemYt: async (poolId?: string, denom?: string, amount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/estimate-redeem-yt`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (poolId !== undefined) {
        localVarQueryParameter['pool_id'] = poolId;
      }

      if (denom !== undefined) {
        localVarQueryParameter['denom'] = denom;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Estimate swap amount of UT/PT (in the pool)
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateSwapInPool: async (
      poolId?: string,
      denom?: string,
      amount?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/estimate-swap-in-pool`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (poolId !== undefined) {
        localVarQueryParameter['pool_id'] = poolId;
      }

      if (denom !== undefined) {
        localVarQueryParameter['denom'] = denom;
      }

      if (amount !== undefined) {
        localVarQueryParameter['amount'] = amount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    intermediaryAccountInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/yieldaggregator/intermediary-account-info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    irsParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liquidation: async (classId?: string, tokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/liquidation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (classId !== undefined) {
        localVarQueryParameter['class_id'] = classId;
      }

      if (tokenId !== undefined) {
        localVarQueryParameter['token_id'] = tokenId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [beforeHeight]
     * @param {string} [afterHeight]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liquidityProviderTokenNominalAPY: async (
      beforeHeight?: string,
      afterHeight?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/liquidity-providers/nominal-apy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (beforeHeight !== undefined) {
        localVarQueryParameter['before_height'] = beforeHeight;
      }

      if (afterHeight !== undefined) {
        localVarQueryParameter['after_height'] = afterHeight;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [beforeHeight]
     * @param {string} [afterHeight]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liquidityProviderTokenRealAPY: async (
      beforeHeight?: string,
      afterHeight?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/liquidity-providers/real-apy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (beforeHeight !== undefined) {
        localVarQueryParameter['before_height'] = beforeHeight;
      }

      if (afterHeight !== undefined) {
        localVarQueryParameter['after_height'] = afterHeight;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [classId]
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClass: async (classId?: string, nftLimit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/listed-classes/class`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (classId !== undefined) {
        localVarQueryParameter['class_id'] = classId;
      }

      if (nftLimit !== undefined) {
        localVarQueryParameter['nft_limit'] = nftLimit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClasses: async (nftLimit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/listed-classes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (nftLimit !== undefined) {
        localVarQueryParameter['nft_limit'] = nftLimit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedNft: async (classId?: string, tokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/listed-nfts/nft`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (classId !== undefined) {
        localVarQueryParameter['class_id'] = classId;
      }

      if (tokenId !== undefined) {
        localVarQueryParameter['token_id'] = tokenId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [owner]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedNfts: async (owner?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/listed-nfts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loan: async (classId?: string, tokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/loans`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (classId !== undefined) {
        localVarQueryParameter['class_id'] = classId;
      }

      if (tokenId !== undefined) {
        localVarQueryParameter['token_id'] = tokenId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketAll: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/pricefeed/markets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftBackedLoanParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftBids: async (classId?: string, tokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftbackedloan/bids`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (classId !== undefined) {
        localVarQueryParameter['class_id'] = classId;
      }

      if (tokenId !== undefined) {
        localVarQueryParameter['token_id'] = tokenId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftFactoryParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftfactory/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oracleAll: async (
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'marketId' is not null or undefined
      assertParamExists('oracleAll', 'marketId', marketId);
      const localVarPath = `/ununifi/pricefeed/markets/{market_id}/oracles`.replace(
        `{${'market_id'}}`,
        encodeURIComponent(String(marketId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} positionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pendingPaymentPosition: async (positionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'positionId' is not null or undefined
      assertParamExists('pendingPaymentPosition', 'positionId', positionId);
      const localVarPath = `/ununifi/derivatives/pending-payment-positions/{position_id}`.replace(
        `{${'position_id'}}`,
        encodeURIComponent(String(positionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualFutures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/perpetual-futures`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [baseDenom]
     * @param {string} [quoteDenom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualFuturesMarket: async (baseDenom?: string, quoteDenom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/perpetual-futures/market`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (baseDenom !== undefined) {
        localVarQueryParameter['base_denom'] = baseDenom;
      }

      if (quoteDenom !== undefined) {
        localVarQueryParameter['quote_denom'] = quoteDenom;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PerpetualFuturesPositionSizePositionTypeEnum} positionType
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualFuturesPositionSize: async (
      positionType: PerpetualFuturesPositionSizePositionTypeEnum,
      address: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'positionType' is not null or undefined
      assertParamExists('perpetualFuturesPositionSize', 'positionType', positionType);
      // verify required parameter 'address' is not null or undefined
      assertParamExists('perpetualFuturesPositionSize', 'address', address);
      const localVarPath = `/ununifi/derivatives/positions/perpetual-futures/{position_type}/{address}`
        .replace(`{${'position_type'}}`, encodeURIComponent(String(positionType)))
        .replace(`{${'address'}}`, encodeURIComponent(String(address)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/perpetual-options`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [baseDenom]
     * @param {string} [quoteDenom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualOptionsMarket: async (baseDenom?: string, quoteDenom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/perpetual-options/market`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (baseDenom !== undefined) {
        localVarQueryParameter['base_denom'] = baseDenom;
      }

      if (quoteDenom !== undefined) {
        localVarQueryParameter['quote_denom'] = quoteDenom;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pool: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/derivatives/pool`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} positionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    position: async (positionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'positionId' is not null or undefined
      assertParamExists('position', 'positionId', positionId);
      const localVarPath = `/ununifi/derivatives/positions/{position_id}`.replace(
        `{${'position_id'}}`,
        encodeURIComponent(String(positionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} marketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price: async (marketId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'marketId' is not null or undefined
      assertParamExists('price', 'marketId', marketId);
      const localVarPath = `/ununifi/pricefeed/markets/{market_id}/price`.replace(`{${'market_id'}}`, encodeURIComponent(String(marketId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    priceAll: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/pricefeed/prices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricefeedParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/pricefeed/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rawPriceAll: async (
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'marketId' is not null or undefined
      assertParamExists('rawPriceAll', 'marketId', marketId);
      const localVarPath = `/ununifi/pricefeed/markets/{market_id}/raw_prices`.replace(
        `{${'market_id'}}`,
        encodeURIComponent(String(marketId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipientAddressWithNftId: async (classId?: string, tokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/ecosystemincentive/recipients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (classId !== undefined) {
        localVarQueryParameter['class_id'] = classId;
      }

      if (tokenId !== undefined) {
        localVarQueryParameter['token_id'] = tokenId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rewards: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('rewards', 'address', address);
      const localVarPath = `/ununifi/nftbackedloan/rewards/{address}`.replace(`{${'address'}}`, encodeURIComponent(String(address)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    strategy: async (id: string, denom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('strategy', 'id', id);
      const localVarPath = `/ununifi/yieldaggregator/strategies/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (denom !== undefined) {
        localVarQueryParameter['denom'] = denom;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [denom]
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    strategyAll: async (
      denom?: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/yieldaggregator/strategies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (denom !== undefined) {
        localVarQueryParameter['denom'] = denom;
      }

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    symbolInfos: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/yieldaggregator/symbol-infos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Tranche by id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tranche: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('tranche', 'id', id);
      const localVarPath = `/ununifi/irs/tranche/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Tranches by Strategy
     * @param {string} strategyContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tranches: async (strategyContract: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'strategyContract' is not null or undefined
      assertParamExists('tranches', 'strategyContract', strategyContract);
      const localVarPath = `/ununifi/irs/tranches/{strategy_contract}`.replace(
        `{${'strategy_contract'}}`,
        encodeURIComponent(String(strategyContract)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vault: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vault', 'id', id);
      const localVarPath = `/ununifi/yieldaggregator/vaults/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultAll: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/yieldaggregator/vaults`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} shareHolder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultAllByShareHolder: async (shareHolder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shareHolder' is not null or undefined
      assertParamExists('vaultAllByShareHolder', 'shareHolder', shareHolder);
      const localVarPath = `/ununifi/yieldaggregator/vaults/share-holders/{share_holder}`.replace(
        `{${'share_holder'}}`,
        encodeURIComponent(String(shareHolder)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Vault queries a single InterestRateSwapVault
     * @param {string} strategyContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultByContract: async (strategyContract: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'strategyContract' is not null or undefined
      assertParamExists('vaultByContract', 'strategyContract', strategyContract);
      const localVarPath = `/ununifi/irs/vault/{strategy_contract}`.replace(
        `{${'strategy_contract'}}`,
        encodeURIComponent(String(strategyContract)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary VaultDetails queries the details of the vault
     * @param {string} strategyContract
     * @param {string} maturity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultDetails: async (strategyContract: string, maturity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'strategyContract' is not null or undefined
      assertParamExists('vaultDetails', 'strategyContract', strategyContract);
      // verify required parameter 'maturity' is not null or undefined
      assertParamExists('vaultDetails', 'maturity', maturity);
      const localVarPath = `/ununifi/irs/vault/{strategy_contract}/maturities/{maturity}`
        .replace(`{${'strategy_contract'}}`, encodeURIComponent(String(strategyContract)))
        .replace(`{${'maturity'}}`, encodeURIComponent(String(maturity)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Vaults queries the InterestRateSwapVaults
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaults: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/irs/vaults`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    yieldAggregatorParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/yieldaggregator/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addressPositions(
      address: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressPositions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addressPositions(address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async allPendingPaymentPositions(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllPendingPaymentPositions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.allPendingPaymentPositions(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async allPositions(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllPositions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.allPositions(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Tranches by Strategy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async allTranches(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTranches200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.allTranches(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async availableAssetsInPool(
      denom?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableAssetsInPool200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.availableAssetsInPool(denom, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bidderBids(
      bidder: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftBids200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bidderBids(bidder, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} creator
     * @param {string} subclass
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classAuthorityMetadata(
      creator: string,
      subclass: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassAuthorityMetadata200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.classAuthorityMetadata(creator, subclass, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} creator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classesFromCreator(
      creator: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesFromCreator200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.classesFromCreator(creator, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dLPTokenRates(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DLPTokenRates200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dLPTokenRates(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async denomInfos(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DenomInfos200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.denomInfos(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async derivativesParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DerivativesParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.derivativesParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ecosystemIncentiveParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EcosystemIncentiveParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ecosystemIncentiveParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} address
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ecosystemRewards(
      address: string,
      denom?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EcosystemRewards200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ecosystemRewards(address, denom, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [mintDenom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateDLPTokenAmount(
      mintDenom?: string,
      amount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateDLPTokenAmount200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateDLPTokenAmount(mintDenom, amount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} id
     * @param {string} [depositAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateMintAmount(
      id: string,
      depositAmount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateMintAmount200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateMintAmount(id, depositAmount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Estimate tokens to mint liquidity pool token
     * @param {string} [poolId]
     * @param {string} [desiredAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateMintLiquidityPoolToken(
      poolId?: string,
      desiredAmount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateMintLiquidityPoolToken200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateMintLiquidityPoolToken(poolId, desiredAmount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Estimate mint amount of PT&YT pair
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateMintPtYtPair(
      poolId?: string,
      denom?: string,
      amount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateMintPtYtPair200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateMintPtYtPair(poolId, denom, amount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} id
     * @param {string} [burnAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateRedeemAmount(
      id: string,
      burnAmount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateRedeemAmount200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateRedeemAmount(id, burnAmount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Estimate redeem amount of liquidity pool token
     * @param {string} [poolId]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateRedeemLiquidityPoolToken(
      poolId?: string,
      amount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateRedeemLiquidityPoolToken200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateRedeemLiquidityPoolToken(poolId, amount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [redeemDenom]
     * @param {string} [lptAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateRedeemTokenAmount(
      redeemDenom?: string,
      lptAmount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateRedeemTokenAmount200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateRedeemTokenAmount(redeemDenom, lptAmount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Estimate redeem amount of YT after maturity
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateRedeemYt(
      poolId?: string,
      denom?: string,
      amount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateRedeemYt200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateRedeemYt(poolId, denom, amount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Estimate swap amount of UT/PT (in the pool)
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateSwapInPool(
      poolId?: string,
      denom?: string,
      amount?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateRedeemYt200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.estimateSwapInPool(poolId, denom, amount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async intermediaryAccountInfo(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntermediaryAccountInfo200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.intermediaryAccountInfo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async irsParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IrsParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.irsParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async liquidation(
      classId?: string,
      tokenId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Liquidation200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.liquidation(classId, tokenId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [beforeHeight]
     * @param {string} [afterHeight]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async liquidityProviderTokenNominalAPY(
      beforeHeight?: string,
      afterHeight?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProviderTokenNominalAPY200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProviderTokenNominalAPY(beforeHeight, afterHeight, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [beforeHeight]
     * @param {string} [afterHeight]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async liquidityProviderTokenRealAPY(
      beforeHeight?: string,
      afterHeight?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProviderTokenNominalAPY200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProviderTokenRealAPY(beforeHeight, afterHeight, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [classId]
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listedClass(
      classId?: string,
      nftLimit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedClasses200ResponseClassesInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listedClass(classId, nftLimit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listedClasses(
      nftLimit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedClasses200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listedClasses(nftLimit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listedNft(
      classId?: string,
      tokenId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedNft200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listedNft(classId, tokenId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [owner]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listedNfts(
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedNfts200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listedNfts(owner, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loan(
      classId?: string,
      tokenId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loan200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loan(classId, tokenId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async marketAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.marketAll(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nftBackedLoanParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftBackedLoanParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nftBackedLoanParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nftBids(
      classId?: string,
      tokenId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftBids200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nftBids(classId, tokenId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nftFactoryParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftFactoryParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nftFactoryParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oracleAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OracleAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oracleAll(
        marketId,
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} positionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pendingPaymentPosition(
      positionId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingPaymentPosition200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pendingPaymentPosition(positionId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async perpetualFutures(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerpetualFutures200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualFutures(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [baseDenom]
     * @param {string} [quoteDenom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async perpetualFuturesMarket(
      baseDenom?: string,
      quoteDenom?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerpetualFuturesMarket200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualFuturesMarket(baseDenom, quoteDenom, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {PerpetualFuturesPositionSizePositionTypeEnum} positionType
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async perpetualFuturesPositionSize(
      positionType: PerpetualFuturesPositionSizePositionTypeEnum,
      address: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerpetualFuturesPositionSize200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualFuturesPositionSize(positionType, address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async perpetualOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualOptions(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [baseDenom]
     * @param {string} [quoteDenom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async perpetualOptionsMarket(
      baseDenom?: string,
      quoteDenom?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualOptionsMarket(baseDenom, quoteDenom, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pool(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pool(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} positionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async position(
      positionId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.position(positionId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} marketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async price(
      marketId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.price(marketId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async priceAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.priceAll(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pricefeedParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricefeedParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pricefeedParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rawPriceAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawPriceAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rawPriceAll(
        marketId,
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recipientAddressWithNftId(
      classId?: string,
      tokenId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipientAddressWithNftId200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.recipientAddressWithNftId(classId, tokenId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rewards(
      address: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EcosystemRewards200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rewards(address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} id
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async strategy(
      id: string,
      denom?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Strategy200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.strategy(id, denom, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [denom]
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async strategyAll(
      denom?: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.strategyAll(
        denom,
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async symbolInfos(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SymbolInfos200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.symbolInfos(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Tranche by id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tranche(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tranche200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tranche(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Tranches by Strategy
     * @param {string} strategyContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tranches(
      strategyContract: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTranches200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tranches(strategyContract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vault(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vault(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vaultAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vaultAll(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} shareHolder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vaultAllByShareHolder(
      shareHolder: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAllByShareHolder200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vaultAllByShareHolder(shareHolder, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Vault queries a single InterestRateSwapVault
     * @param {string} strategyContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vaultByContract(
      strategyContract: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultByContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vaultByContract(strategyContract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary VaultDetails queries the details of the vault
     * @param {string} strategyContract
     * @param {string} maturity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vaultDetails(
      strategyContract: string,
      maturity: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultDetails200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vaultDetails(strategyContract, maturity, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Vaults queries the InterestRateSwapVaults
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vaults(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vaults200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vaults(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async yieldAggregatorParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<YieldAggregatorParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.yieldAggregatorParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = QueryApiFp(configuration);
  return {
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addressPositions(address: string, options?: any): AxiosPromise<AddressPositions200Response> {
      return localVarFp.addressPositions(address, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allPendingPaymentPositions(options?: any): AxiosPromise<AllPendingPaymentPositions200Response> {
      return localVarFp.allPendingPaymentPositions(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allPositions(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<AllPositions200Response> {
      return localVarFp
        .allPositions(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Tranches by Strategy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allTranches(options?: any): AxiosPromise<AllTranches200Response> {
      return localVarFp.allTranches(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    availableAssetsInPool(denom?: string, options?: any): AxiosPromise<AvailableAssetsInPool200Response> {
      return localVarFp.availableAssetsInPool(denom, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bidderBids(bidder: string, options?: any): AxiosPromise<NftBids200Response> {
      return localVarFp.bidderBids(bidder, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} creator
     * @param {string} subclass
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classAuthorityMetadata(creator: string, subclass: string, options?: any): AxiosPromise<ClassAuthorityMetadata200Response> {
      return localVarFp.classAuthorityMetadata(creator, subclass, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} creator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classesFromCreator(creator: string, options?: any): AxiosPromise<ClassesFromCreator200Response> {
      return localVarFp.classesFromCreator(creator, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dLPTokenRates(options?: any): AxiosPromise<DLPTokenRates200Response> {
      return localVarFp.dLPTokenRates(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    denomInfos(options?: any): AxiosPromise<DenomInfos200Response> {
      return localVarFp.denomInfos(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    derivativesParams(options?: any): AxiosPromise<DerivativesParams200Response> {
      return localVarFp.derivativesParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ecosystemIncentiveParams(options?: any): AxiosPromise<EcosystemIncentiveParams200Response> {
      return localVarFp.ecosystemIncentiveParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} address
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ecosystemRewards(address: string, denom?: string, options?: any): AxiosPromise<EcosystemRewards200Response> {
      return localVarFp.ecosystemRewards(address, denom, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [mintDenom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateDLPTokenAmount(mintDenom?: string, amount?: string, options?: any): AxiosPromise<EstimateDLPTokenAmount200Response> {
      return localVarFp.estimateDLPTokenAmount(mintDenom, amount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {string} [depositAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateMintAmount(id: string, depositAmount?: string, options?: any): AxiosPromise<EstimateMintAmount200Response> {
      return localVarFp.estimateMintAmount(id, depositAmount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Estimate tokens to mint liquidity pool token
     * @param {string} [poolId]
     * @param {string} [desiredAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateMintLiquidityPoolToken(
      poolId?: string,
      desiredAmount?: string,
      options?: any,
    ): AxiosPromise<EstimateMintLiquidityPoolToken200Response> {
      return localVarFp.estimateMintLiquidityPoolToken(poolId, desiredAmount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Estimate mint amount of PT&YT pair
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateMintPtYtPair(poolId?: string, denom?: string, amount?: string, options?: any): AxiosPromise<EstimateMintPtYtPair200Response> {
      return localVarFp.estimateMintPtYtPair(poolId, denom, amount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {string} [burnAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemAmount(id: string, burnAmount?: string, options?: any): AxiosPromise<EstimateRedeemAmount200Response> {
      return localVarFp.estimateRedeemAmount(id, burnAmount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Estimate redeem amount of liquidity pool token
     * @param {string} [poolId]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemLiquidityPoolToken(
      poolId?: string,
      amount?: string,
      options?: any,
    ): AxiosPromise<EstimateRedeemLiquidityPoolToken200Response> {
      return localVarFp.estimateRedeemLiquidityPoolToken(poolId, amount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [redeemDenom]
     * @param {string} [lptAmount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemTokenAmount(redeemDenom?: string, lptAmount?: string, options?: any): AxiosPromise<EstimateRedeemTokenAmount200Response> {
      return localVarFp.estimateRedeemTokenAmount(redeemDenom, lptAmount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Estimate redeem amount of YT after maturity
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateRedeemYt(poolId?: string, denom?: string, amount?: string, options?: any): AxiosPromise<EstimateRedeemYt200Response> {
      return localVarFp.estimateRedeemYt(poolId, denom, amount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Estimate swap amount of UT/PT (in the pool)
     * @param {string} [poolId]
     * @param {string} [denom]
     * @param {string} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateSwapInPool(poolId?: string, denom?: string, amount?: string, options?: any): AxiosPromise<EstimateRedeemYt200Response> {
      return localVarFp.estimateSwapInPool(poolId, denom, amount, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    intermediaryAccountInfo(options?: any): AxiosPromise<IntermediaryAccountInfo200Response> {
      return localVarFp.intermediaryAccountInfo(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    irsParams(options?: any): AxiosPromise<IrsParams200Response> {
      return localVarFp.irsParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liquidation(classId?: string, tokenId?: string, options?: any): AxiosPromise<Liquidation200Response> {
      return localVarFp.liquidation(classId, tokenId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [beforeHeight]
     * @param {string} [afterHeight]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liquidityProviderTokenNominalAPY(
      beforeHeight?: string,
      afterHeight?: string,
      options?: any,
    ): AxiosPromise<LiquidityProviderTokenNominalAPY200Response> {
      return localVarFp.liquidityProviderTokenNominalAPY(beforeHeight, afterHeight, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [beforeHeight]
     * @param {string} [afterHeight]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liquidityProviderTokenRealAPY(
      beforeHeight?: string,
      afterHeight?: string,
      options?: any,
    ): AxiosPromise<LiquidityProviderTokenNominalAPY200Response> {
      return localVarFp.liquidityProviderTokenRealAPY(beforeHeight, afterHeight, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [classId]
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClass(classId?: string, nftLimit?: number, options?: any): AxiosPromise<ListedClasses200ResponseClassesInner> {
      return localVarFp.listedClass(classId, nftLimit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClasses(nftLimit?: number, options?: any): AxiosPromise<ListedClasses200Response> {
      return localVarFp.listedClasses(nftLimit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedNft(classId?: string, tokenId?: string, options?: any): AxiosPromise<ListedNft200Response> {
      return localVarFp.listedNft(classId, tokenId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [owner]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedNfts(owner?: string, options?: any): AxiosPromise<ListedNfts200Response> {
      return localVarFp.listedNfts(owner, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loan(classId?: string, tokenId?: string, options?: any): AxiosPromise<Loan200Response> {
      return localVarFp.loan(classId, tokenId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<MarketAll200Response> {
      return localVarFp
        .marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftBackedLoanParams(options?: any): AxiosPromise<NftBackedLoanParams200Response> {
      return localVarFp.nftBackedLoanParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftBids(classId?: string, tokenId?: string, options?: any): AxiosPromise<NftBids200Response> {
      return localVarFp.nftBids(classId, tokenId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftFactoryParams(options?: any): AxiosPromise<NftFactoryParams200Response> {
      return localVarFp.nftFactoryParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oracleAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<OracleAll200Response> {
      return localVarFp
        .oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} positionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pendingPaymentPosition(positionId: string, options?: any): AxiosPromise<PendingPaymentPosition200Response> {
      return localVarFp.pendingPaymentPosition(positionId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualFutures(options?: any): AxiosPromise<PerpetualFutures200Response> {
      return localVarFp.perpetualFutures(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [baseDenom]
     * @param {string} [quoteDenom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualFuturesMarket(baseDenom?: string, quoteDenom?: string, options?: any): AxiosPromise<PerpetualFuturesMarket200Response> {
      return localVarFp.perpetualFuturesMarket(baseDenom, quoteDenom, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PerpetualFuturesPositionSizePositionTypeEnum} positionType
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualFuturesPositionSize(
      positionType: PerpetualFuturesPositionSizePositionTypeEnum,
      address: string,
      options?: any,
    ): AxiosPromise<PerpetualFuturesPositionSize200Response> {
      return localVarFp.perpetualFuturesPositionSize(positionType, address, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualOptions(options?: any): AxiosPromise<object> {
      return localVarFp.perpetualOptions(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [baseDenom]
     * @param {string} [quoteDenom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    perpetualOptionsMarket(baseDenom?: string, quoteDenom?: string, options?: any): AxiosPromise<object> {
      return localVarFp.perpetualOptionsMarket(baseDenom, quoteDenom, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pool(options?: any): AxiosPromise<Pool200Response> {
      return localVarFp.pool(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} positionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    position(positionId: string, options?: any): AxiosPromise<Position200Response> {
      return localVarFp.position(positionId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} marketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price(marketId: string, options?: any): AxiosPromise<Price200Response> {
      return localVarFp.price(marketId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    priceAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<PriceAll200Response> {
      return localVarFp
        .priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricefeedParams(options?: any): AxiosPromise<PricefeedParams200Response> {
      return localVarFp.pricefeedParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rawPriceAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<RawPriceAll200Response> {
      return localVarFp
        .rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [classId]
     * @param {string} [tokenId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipientAddressWithNftId(classId?: string, tokenId?: string, options?: any): AxiosPromise<RecipientAddressWithNftId200Response> {
      return localVarFp.recipientAddressWithNftId(classId, tokenId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rewards(address: string, options?: any): AxiosPromise<EcosystemRewards200Response> {
      return localVarFp.rewards(address, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {string} [denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    strategy(id: string, denom?: string, options?: any): AxiosPromise<Strategy200Response> {
      return localVarFp.strategy(id, denom, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [denom]
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    strategyAll(
      denom?: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<StrategyAll200Response> {
      return localVarFp
        .strategyAll(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    symbolInfos(options?: any): AxiosPromise<SymbolInfos200Response> {
      return localVarFp.symbolInfos(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Tranche by id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tranche(id: string, options?: any): AxiosPromise<Tranche200Response> {
      return localVarFp.tranche(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Tranches by Strategy
     * @param {string} strategyContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tranches(strategyContract: string, options?: any): AxiosPromise<AllTranches200Response> {
      return localVarFp.tranches(strategyContract, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vault(id: string, options?: any): AxiosPromise<Vault200Response> {
      return localVarFp.vault(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<VaultAll200Response> {
      return localVarFp
        .vaultAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} shareHolder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultAllByShareHolder(shareHolder: string, options?: any): AxiosPromise<VaultAllByShareHolder200Response> {
      return localVarFp.vaultAllByShareHolder(shareHolder, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Vault queries a single InterestRateSwapVault
     * @param {string} strategyContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultByContract(strategyContract: string, options?: any): AxiosPromise<VaultByContract200Response> {
      return localVarFp.vaultByContract(strategyContract, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary VaultDetails queries the details of the vault
     * @param {string} strategyContract
     * @param {string} maturity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaultDetails(strategyContract: string, maturity: string, options?: any): AxiosPromise<VaultDetails200Response> {
      return localVarFp.vaultDetails(strategyContract, maturity, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Vaults queries the InterestRateSwapVaults
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vaults(options?: any): AxiosPromise<Vaults200Response> {
      return localVarFp.vaults(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    yieldAggregatorParams(options?: any): AxiosPromise<YieldAggregatorParams200Response> {
      return localVarFp.yieldAggregatorParams(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
  /**
   *
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public addressPositions(address: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .addressPositions(address, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public allPendingPaymentPositions(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .allPendingPaymentPositions(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public allPositions(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .allPositions(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Tranches by Strategy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public allTranches(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .allTranches(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [denom]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public availableAssetsInPool(denom?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .availableAssetsInPool(denom, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} bidder
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public bidderBids(bidder: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .bidderBids(bidder, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} creator
   * @param {string} subclass
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public classAuthorityMetadata(creator: string, subclass: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .classAuthorityMetadata(creator, subclass, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} creator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public classesFromCreator(creator: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .classesFromCreator(creator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public dLPTokenRates(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .dLPTokenRates(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public denomInfos(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .denomInfos(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Parameters queries the parameters of the module.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public derivativesParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .derivativesParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Parameters queries the parameters of the module.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public ecosystemIncentiveParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .ecosystemIncentiveParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} address
   * @param {string} [denom]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public ecosystemRewards(address: string, denom?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .ecosystemRewards(address, denom, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [mintDenom]
   * @param {string} [amount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateDLPTokenAmount(mintDenom?: string, amount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateDLPTokenAmount(mintDenom, amount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {string} [depositAmount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateMintAmount(id: string, depositAmount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateMintAmount(id, depositAmount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Estimate tokens to mint liquidity pool token
   * @param {string} [poolId]
   * @param {string} [desiredAmount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateMintLiquidityPoolToken(poolId?: string, desiredAmount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateMintLiquidityPoolToken(poolId, desiredAmount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Estimate mint amount of PT&YT pair
   * @param {string} [poolId]
   * @param {string} [denom]
   * @param {string} [amount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateMintPtYtPair(poolId?: string, denom?: string, amount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateMintPtYtPair(poolId, denom, amount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {string} [burnAmount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateRedeemAmount(id: string, burnAmount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateRedeemAmount(id, burnAmount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Estimate redeem amount of liquidity pool token
   * @param {string} [poolId]
   * @param {string} [amount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateRedeemLiquidityPoolToken(poolId?: string, amount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateRedeemLiquidityPoolToken(poolId, amount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [redeemDenom]
   * @param {string} [lptAmount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateRedeemTokenAmount(redeemDenom?: string, lptAmount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateRedeemTokenAmount(redeemDenom, lptAmount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Estimate redeem amount of YT after maturity
   * @param {string} [poolId]
   * @param {string} [denom]
   * @param {string} [amount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateRedeemYt(poolId?: string, denom?: string, amount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateRedeemYt(poolId, denom, amount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Estimate swap amount of UT/PT (in the pool)
   * @param {string} [poolId]
   * @param {string} [denom]
   * @param {string} [amount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public estimateSwapInPool(poolId?: string, denom?: string, amount?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .estimateSwapInPool(poolId, denom, amount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public intermediaryAccountInfo(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .intermediaryAccountInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Parameters queries the parameters of the module.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public irsParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .irsParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [classId]
   * @param {string} [tokenId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public liquidation(classId?: string, tokenId?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .liquidation(classId, tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [beforeHeight]
   * @param {string} [afterHeight]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public liquidityProviderTokenNominalAPY(beforeHeight?: string, afterHeight?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .liquidityProviderTokenNominalAPY(beforeHeight, afterHeight, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [beforeHeight]
   * @param {string} [afterHeight]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public liquidityProviderTokenRealAPY(beforeHeight?: string, afterHeight?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .liquidityProviderTokenRealAPY(beforeHeight, afterHeight, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [classId]
   * @param {number} [nftLimit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public listedClass(classId?: string, nftLimit?: number, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .listedClass(classId, nftLimit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [nftLimit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public listedClasses(nftLimit?: number, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .listedClasses(nftLimit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [classId]
   * @param {string} [tokenId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public listedNft(classId?: string, tokenId?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .listedNft(classId, tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [owner]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public listedNfts(owner?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .listedNfts(owner, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [classId]
   * @param {string} [tokenId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public loan(classId?: string, tokenId?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .loan(classId, tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary this line is used by starport scaffolding # 2
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public marketAll(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nftBackedLoanParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nftBackedLoanParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [classId]
   * @param {string} [tokenId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nftBids(classId?: string, tokenId?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nftBids(classId, tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nftFactoryParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nftFactoryParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} marketId
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public oracleAll(
    marketId: string,
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} positionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public pendingPaymentPosition(positionId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .pendingPaymentPosition(positionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public perpetualFutures(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .perpetualFutures(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [baseDenom]
   * @param {string} [quoteDenom]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public perpetualFuturesMarket(baseDenom?: string, quoteDenom?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .perpetualFuturesMarket(baseDenom, quoteDenom, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PerpetualFuturesPositionSizePositionTypeEnum} positionType
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public perpetualFuturesPositionSize(
    positionType: PerpetualFuturesPositionSizePositionTypeEnum,
    address: string,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .perpetualFuturesPositionSize(positionType, address, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public perpetualOptions(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .perpetualOptions(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [baseDenom]
   * @param {string} [quoteDenom]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public perpetualOptionsMarket(baseDenom?: string, quoteDenom?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .perpetualOptionsMarket(baseDenom, quoteDenom, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary this line is used by starport scaffolding # 2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public pool(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .pool(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} positionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public position(positionId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .position(positionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} marketId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public price(marketId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .price(marketId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public priceAll(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public pricefeedParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .pricefeedParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} marketId
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public rawPriceAll(
    marketId: string,
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [classId]
   * @param {string} [tokenId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public recipientAddressWithNftId(classId?: string, tokenId?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .recipientAddressWithNftId(classId, tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public rewards(address: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .rewards(address, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {string} [denom]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public strategy(id: string, denom?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .strategy(id, denom, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [denom]
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public strategyAll(
    denom?: string,
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .strategyAll(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public symbolInfos(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .symbolInfos(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Tranche by id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public tranche(id: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .tranche(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Tranches by Strategy
   * @param {string} strategyContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public tranches(strategyContract: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .tranches(strategyContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public vault(id: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .vault(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary this line is used by starport scaffolding # 2
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public vaultAll(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .vaultAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} shareHolder
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public vaultAllByShareHolder(shareHolder: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .vaultAllByShareHolder(shareHolder, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Vault queries a single InterestRateSwapVault
   * @param {string} strategyContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public vaultByContract(strategyContract: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .vaultByContract(strategyContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary VaultDetails queries the details of the vault
   * @param {string} strategyContract
   * @param {string} maturity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public vaultDetails(strategyContract: string, maturity: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .vaultDetails(strategyContract, maturity, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Vaults queries the InterestRateSwapVaults
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public vaults(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .vaults(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Parameters queries the parameters of the module.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public yieldAggregatorParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .yieldAggregatorParams(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const PerpetualFuturesPositionSizePositionTypeEnum = {
  PositionUnknown: 'POSITION_UNKNOWN',
  Long: 'LONG',
  Short: 'SHORT',
} as const;
export type PerpetualFuturesPositionSizePositionTypeEnum =
  (typeof PerpetualFuturesPositionSizePositionTypeEnum)[keyof typeof PerpetualFuturesPositionSizePositionTypeEnum];
