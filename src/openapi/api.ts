/* tslint:disable */
/* eslint-disable */
/**
 * UnUniFi - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddressPositions200Response
 */
export interface AddressPositions200Response {
    /**
     * 
     * @type {Array<AddressPositions200ResponsePositionsInner>}
     * @memberof AddressPositions200Response
     */
    'positions'?: Array<AddressPositions200ResponsePositionsInner>;
}
/**
 * 
 * @export
 * @interface AddressPositions200ResponsePositionsInner
 */
export interface AddressPositions200ResponsePositionsInner {
    /**
     * 
     * @type {Position200ResponsePosition}
     * @memberof AddressPositions200ResponsePositionsInner
     */
    'position'?: Position200ResponsePosition;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof AddressPositions200ResponsePositionsInner
     */
    'valuation_profit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof AddressPositions200ResponsePositionsInner
     */
    'remaining_margin_value'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof AddressPositions200ResponsePositionsInner
     */
    'effective_margin'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof AddressPositions200ResponsePositionsInner
     */
    'margin_maintenance_rate'?: string;
}
/**
 * 
 * @export
 * @interface AllPositions200Response
 */
export interface AllPositions200Response {
    /**
     * 
     * @type {Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>}
     * @memberof AllPositions200Response
     */
    'positions'?: Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof AllPositions200Response
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface AllPositions200ResponsePagination
 */
export interface AllPositions200ResponsePagination {
    /**
     * 
     * @type {string}
     * @memberof AllPositions200ResponsePagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllPositions200ResponsePagination
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface AllRewards200Response
 */
export interface AllRewards200Response {
    /**
     * 
     * @type {AllRewards200ResponseRewards}
     * @memberof AllRewards200Response
     */
    'rewards'?: AllRewards200ResponseRewards;
}
/**
 * 
 * @export
 * @interface AllRewards200ResponseRewards
 */
export interface AllRewards200ResponseRewards {
    /**
     * 
     * @type {string}
     * @memberof AllRewards200ResponseRewards
     */
    'address'?: string;
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof AllRewards200ResponseRewards
     */
    'rewards'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * 
 * @export
 * @interface AvailableAssetInPoolByDenom200Response
 */
export interface AvailableAssetInPoolByDenom200Response {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof AvailableAssetInPoolByDenom200Response
     */
    'available_asset'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface AvailableAssetsInPool200Response
 */
export interface AvailableAssetsInPool200Response {
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof AvailableAssetsInPool200Response
     */
    'available_assets'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * 
 * @export
 * @interface BelongingRecipientContainerIdsByAddr200Response
 */
export interface BelongingRecipientContainerIdsByAddr200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof BelongingRecipientContainerIdsByAddr200Response
     */
    'recipient_container_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BelongingRecipientContainerIdsByAddrDefaultResponse
 */
export interface BelongingRecipientContainerIdsByAddrDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof BelongingRecipientContainerIdsByAddrDefaultResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof BelongingRecipientContainerIdsByAddrDefaultResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof BelongingRecipientContainerIdsByAddrDefaultResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<BelongingRecipientContainerIdsByAddrDefaultResponseDetailsInner>}
     * @memberof BelongingRecipientContainerIdsByAddrDefaultResponse
     */
    'details'?: Array<BelongingRecipientContainerIdsByAddrDefaultResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface BelongingRecipientContainerIdsByAddrDefaultResponseDetailsInner
 */
export interface BelongingRecipientContainerIdsByAddrDefaultResponseDetailsInner {
    /**
     * 
     * @type {string}
     * @memberof BelongingRecipientContainerIdsByAddrDefaultResponseDetailsInner
     */
    'type_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof BelongingRecipientContainerIdsByAddrDefaultResponseDetailsInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BidderBids200Response
 */
export interface BidderBids200Response {
    /**
     * 
     * @type {Array<BidderBids200ResponseBidsInner>}
     * @memberof BidderBids200Response
     */
    'bids'?: Array<BidderBids200ResponseBidsInner>;
}
/**
 * 
 * @export
 * @interface BidderBids200ResponseBidsInner
 */
export interface BidderBids200ResponseBidsInner {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof BidderBids200ResponseBidsInner
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof BidderBids200ResponseBidsInner
     */
    'bidder'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof BidderBids200ResponseBidsInner
     */
    'bid_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof BidderBids200ResponseBidsInner
     */
    'deposit_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof BidderBids200ResponseBidsInner
     */
    'paid_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof BidderBids200ResponseBidsInner
     */
    'bidding_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof BidderBids200ResponseBidsInner
     */
    'deposit_lending_rate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BidderBids200ResponseBidsInner
     */
    'automatic_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BidderBids200ResponseBidsInner
     */
    'bid_time'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof BidderBids200ResponseBidsInner
     */
    'interest_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {Array<ListerBorrowingBidderInfoInner>}
     * @memberof BidderBids200ResponseBidsInner
     */
    'borrowings'?: Array<ListerBorrowingBidderInfoInner>;
    /**
     * 
     * @type {TodoRemoveNftIdBidderThenUseIt}
     * @memberof BidderBids200ResponseBidsInner
     */
    'id'?: TodoRemoveNftIdBidderThenUseIt;
}
/**
 * 
 * @export
 * @interface BidderBids200ResponseBidsInnerNftId
 */
export interface BidderBids200ResponseBidsInnerNftId {
    /**
     * 
     * @type {string}
     * @memberof BidderBids200ResponseBidsInnerNftId
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BidderBids200ResponseBidsInnerNftId
     */
    'nft_id'?: string;
}
/**
 * 
 * @export
 * @interface ClassAttributes200Response
 */
export interface ClassAttributes200Response {
    /**
     * 
     * @type {ClassAttributes200ResponseClassAttributes}
     * @memberof ClassAttributes200Response
     */
    'class_attributes'?: ClassAttributes200ResponseClassAttributes;
}
/**
 * 
 * @export
 * @interface ClassAttributes200ResponseClassAttributes
 */
export interface ClassAttributes200ResponseClassAttributes {
    /**
     * 
     * @type {string}
     * @memberof ClassAttributes200ResponseClassAttributes
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassAttributes200ResponseClassAttributes
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassAttributes200ResponseClassAttributes
     */
    'base_token_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassAttributes200ResponseClassAttributes
     */
    'minting_permission'?: ClassAttributes200ResponseClassAttributesMintingPermissionEnum;
    /**
     * 
     * @type {string}
     * @memberof ClassAttributes200ResponseClassAttributes
     */
    'token_supply_cap'?: string;
}

export const ClassAttributes200ResponseClassAttributesMintingPermissionEnum = {
    OnlyOwner: 'OnlyOwner',
    Anyone: 'Anyone'
} as const;

export type ClassAttributes200ResponseClassAttributesMintingPermissionEnum = typeof ClassAttributes200ResponseClassAttributesMintingPermissionEnum[keyof typeof ClassAttributes200ResponseClassAttributesMintingPermissionEnum];

/**
 * 
 * @export
 * @interface ClassIdsByName200Response
 */
export interface ClassIdsByName200Response {
    /**
     * 
     * @type {ClassIdsByName200ResponseClassNameIdList}
     * @memberof ClassIdsByName200Response
     */
    'class_name_id_list'?: ClassIdsByName200ResponseClassNameIdList;
}
/**
 * 
 * @export
 * @interface ClassIdsByName200ResponseClassNameIdList
 */
export interface ClassIdsByName200ResponseClassNameIdList {
    /**
     * 
     * @type {string}
     * @memberof ClassIdsByName200ResponseClassNameIdList
     */
    'class_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassIdsByName200ResponseClassNameIdList
     */
    'class_id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClassIdsByOwner200Response
 */
export interface ClassIdsByOwner200Response {
    /**
     * 
     * @type {ClassIdsByOwner200ResponseOwningClassIdList}
     * @memberof ClassIdsByOwner200Response
     */
    'owning_class_id_list'?: ClassIdsByOwner200ResponseOwningClassIdList;
}
/**
 * 
 * @export
 * @interface ClassIdsByOwner200ResponseOwningClassIdList
 */
export interface ClassIdsByOwner200ResponseOwningClassIdList {
    /**
     * 
     * @type {string}
     * @memberof ClassIdsByOwner200ResponseOwningClassIdList
     */
    'owner'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassIdsByOwner200ResponseOwningClassIdList
     */
    'class_id'?: Array<string>;
}
/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
    /**
     * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'key'?: string;
    /**
     * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'offset'?: string;
    /**
     * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'limit'?: string;
    /**
     * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'count_total'?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    'total'?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface DLPTokenRates200Response
 */
export interface DLPTokenRates200Response {
    /**
     * 
     * @type {string}
     * @memberof DLPTokenRates200Response
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof DLPTokenRates200Response
     */
    'rates'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface DerivativesParams200Response
 */
export interface DerivativesParams200Response {
    /**
     * 
     * @type {DerivativesParams200ResponseParams}
     * @memberof DerivativesParams200Response
     */
    'params'?: DerivativesParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface DerivativesParams200ResponseParams
 */
export interface DerivativesParams200ResponseParams {
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPoolParams}
     * @memberof DerivativesParams200ResponseParams
     */
    'pool_params'?: DerivativesParams200ResponseParamsPoolParams;
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPerpetualFutures}
     * @memberof DerivativesParams200ResponseParams
     */
    'perpetual_futures'?: DerivativesParams200ResponseParamsPerpetualFutures;
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPerpetualOptions}
     * @memberof DerivativesParams200ResponseParams
     */
    'perpetual_options'?: DerivativesParams200ResponseParamsPerpetualOptions;
}
/**
 * 
 * @export
 * @interface DerivativesParams200ResponseParamsPerpetualFutures
 */
export interface DerivativesParams200ResponseParamsPerpetualFutures {
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualFutures
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualFutures
     */
    'margin_maintenance_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualFutures
     */
    'imaginary_funding_rate_proportional_coefficient'?: string;
    /**
     * 
     * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
     * @memberof DerivativesParams200ResponseParamsPerpetualFutures
     */
    'markets'?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
    /**
     * 
     * @type {number}
     * @memberof DerivativesParams200ResponseParamsPerpetualFutures
     */
    'max_leverage'?: number;
}
/**
 * 
 * @export
 * @interface DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner
 */
export interface DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner {
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner
     */
    'base_denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner
     */
    'quote_denom'?: string;
}
/**
 * 
 * @export
 * @interface DerivativesParams200ResponseParamsPerpetualOptions
 */
export interface DerivativesParams200ResponseParamsPerpetualOptions {
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualOptions
     */
    'premium_commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualOptions
     */
    'strike_commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualOptions
     */
    'margin_maintenance_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPerpetualOptions
     */
    'imaginary_funding_rate_proportional_coefficient'?: string;
    /**
     * 
     * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
     * @memberof DerivativesParams200ResponseParamsPerpetualOptions
     */
    'markets'?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
}
/**
 * 
 * @export
 * @interface DerivativesParams200ResponseParamsPoolParams
 */
export interface DerivativesParams200ResponseParamsPoolParams {
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParams
     */
    'quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParams
     */
    'base_lpt_mint_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParams
     */
    'base_lpt_redeem_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParams
     */
    'borrowing_fee_rate_per_hour'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParams
     */
    'report_liquidation_reward_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParams
     */
    'report_levy_period_reward_rate'?: string;
    /**
     * 
     * @type {Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>}
     * @memberof DerivativesParams200ResponseParamsPoolParams
     */
    'accepted_assets_conf'?: Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>;
}
/**
 * 
 * @export
 * @interface DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner
 */
export interface DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner {
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner
     */
    'target_weight'?: string;
}
/**
 * 
 * @export
 * @interface EcosystemIncentiveParams200Response
 */
export interface EcosystemIncentiveParams200Response {
    /**
     * 
     * @type {EcosystemIncentiveParams200ResponseParams}
     * @memberof EcosystemIncentiveParams200Response
     */
    'params'?: EcosystemIncentiveParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface EcosystemIncentiveParams200ResponseParams
 */
export interface EcosystemIncentiveParams200ResponseParams {
    /**
     * 
     * @type {Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>}
     * @memberof EcosystemIncentiveParams200ResponseParams
     */
    'reward_params'?: Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>;
}
/**
 * 
 * @export
 * @interface EstimateDLPTokenAmount200Response
 */
export interface EstimateDLPTokenAmount200Response {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof EstimateDLPTokenAmount200Response
     */
    'estimated_dlp_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof EstimateDLPTokenAmount200Response
     */
    'deposit_fee'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface EstimateDLPTokenAmount200ResponseEstimatedDlpAmount
 */
export interface EstimateDLPTokenAmount200ResponseEstimatedDlpAmount {
    /**
     * 
     * @type {string}
     * @memberof EstimateDLPTokenAmount200ResponseEstimatedDlpAmount
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateDLPTokenAmount200ResponseEstimatedDlpAmount
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface EstimateDLPTokenAmountDefaultResponse
 */
export interface EstimateDLPTokenAmountDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof EstimateDLPTokenAmountDefaultResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof EstimateDLPTokenAmountDefaultResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof EstimateDLPTokenAmountDefaultResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>}
     * @memberof EstimateDLPTokenAmountDefaultResponse
     */
    'details'?: Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface EstimateDLPTokenAmountDefaultResponseDetailsInner
 */
export interface EstimateDLPTokenAmountDefaultResponseDetailsInner {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof EstimateDLPTokenAmountDefaultResponseDetailsInner
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof EstimateDLPTokenAmountDefaultResponseDetailsInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface EstimateMintAmount200Response
 */
export interface EstimateMintAmount200Response {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof EstimateMintAmount200Response
     */
    'mint_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface EstimateRedeemAmount200Response
 */
export interface EstimateRedeemAmount200Response {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof EstimateRedeemAmount200Response
     */
    'redeem_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface EstimateRedeemTokenAmount200Response
 */
export interface EstimateRedeemTokenAmount200Response {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof EstimateRedeemTokenAmount200Response
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof EstimateRedeemTokenAmount200Response
     */
    'fee'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    'message'?: string;
    /**
     * 
     * @type {Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>}
     * @memberof GrpcGatewayRuntimeError
     */
    'details'?: Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface Liquidation200Response
 */
export interface Liquidation200Response {
    /**
     * 
     * @type {Liquidation200ResponseLiquidations}
     * @memberof Liquidation200Response
     */
    'liquidations'?: Liquidation200ResponseLiquidations;
}
/**
 * 
 * @export
 * @interface Liquidation200ResponseLiquidations
 */
export interface Liquidation200ResponseLiquidations {
    /**
     * 
     * @type {Liquidation200ResponseLiquidationsLiquidation}
     * @memberof Liquidation200ResponseLiquidations
     */
    'liquidation'?: Liquidation200ResponseLiquidationsLiquidation;
    /**
     * 
     * @type {Array<Liquidation200ResponseLiquidationsLiquidation>}
     * @memberof Liquidation200ResponseLiquidations
     */
    'next_liquidation'?: Array<Liquidation200ResponseLiquidationsLiquidation>;
}
/**
 * 
 * @export
 * @interface Liquidation200ResponseLiquidationsLiquidation
 */
export interface Liquidation200ResponseLiquidationsLiquidation {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof Liquidation200ResponseLiquidationsLiquidation
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof Liquidation200ResponseLiquidationsLiquidation
     */
    'liquidation_date'?: string;
}
/**
 * 
 * @export
 * @interface LiquidityProviderTokenNominalAPY200Response
 */
export interface LiquidityProviderTokenNominalAPY200Response {
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderTokenNominalAPY200Response
     */
    'apy'?: string;
}
/**
 * 
 * @export
 * @interface ListedClass200Response
 */
export interface ListedClass200Response {
    /**
     * 
     * @type {string}
     * @memberof ListedClass200Response
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200Response
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200Response
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200Response
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200Response
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200Response
     */
    'urihash'?: string;
    /**
     * 
     * @type {Array<ListedClass200ResponseNftsInner>}
     * @memberof ListedClass200Response
     */
    'nfts'?: Array<ListedClass200ResponseNftsInner>;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200Response
     */
    'nft_count'?: string;
}
/**
 * 
 * @export
 * @interface ListedClass200ResponseNftsInner
 */
export interface ListedClass200ResponseNftsInner {
    /**
     * 
     * @type {string}
     * @memberof ListedClass200ResponseNftsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200ResponseNftsInner
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedClass200ResponseNftsInner
     */
    'uri_hash'?: string;
}
/**
 * 
 * @export
 * @interface ListedClasses200Response
 */
export interface ListedClasses200Response {
    /**
     * 
     * @type {Array<ListedClass200Response>}
     * @memberof ListedClasses200Response
     */
    'classes'?: Array<ListedClass200Response>;
}
/**
 * 
 * @export
 * @interface ListedNfts200Response
 */
export interface ListedNfts200Response {
    /**
     * 
     * @type {Array<ListedNfts200ResponseListingsInner>}
     * @memberof ListedNfts200Response
     */
    'listings'?: Array<ListedNfts200ResponseListingsInner>;
}
/**
 * 
 * @export
 * @interface ListedNfts200ResponseListingsInner
 */
export interface ListedNfts200ResponseListingsInner {
    /**
     * 
     * @type {ListedNfts200ResponseListingsInnerListing}
     * @memberof ListedNfts200ResponseListingsInner
     */
    'listing'?: ListedNfts200ResponseListingsInnerListing;
    /**
     * 
     * @type {ListedClass200ResponseNftsInner}
     * @memberof ListedNfts200ResponseListingsInner
     */
    'nft_info'?: ListedClass200ResponseNftsInner;
}
/**
 * 
 * @export
 * @interface ListedNfts200ResponseListingsInnerListing
 */
export interface ListedNfts200ResponseListingsInnerListing {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'listing_type'?: ListedNfts200ResponseListingsInnerListingListingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'state'?: ListedNfts200ResponseListingsInnerListingStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'bid_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'minimum_deposit_rate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'automatic_refinancing'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'started_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'end_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'full_payment_end_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'successful_bid_end_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'auto_relisted_count'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'collected_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof ListedNfts200ResponseListingsInnerListing
     */
    'minimum_bidding_period'?: string;
}

export const ListedNfts200ResponseListingsInnerListingListingTypeEnum = {
    DirectAssetBorrow: 'DIRECT_ASSET_BORROW',
    SyntheticAssetCreation: 'SYNTHETIC_ASSET_CREATION',
    LateShipping: 'LATE_SHIPPING'
} as const;

export type ListedNfts200ResponseListingsInnerListingListingTypeEnum = typeof ListedNfts200ResponseListingsInnerListingListingTypeEnum[keyof typeof ListedNfts200ResponseListingsInnerListingListingTypeEnum];
export const ListedNfts200ResponseListingsInnerListingStateEnum = {
    Listing: 'LISTING',
    Bidding: 'BIDDING',
    SellingDecision: 'SELLING_DECISION',
    EndListing: 'END_LISTING',
    SuccessfulBid: 'SUCCESSFUL_BID'
} as const;

export type ListedNfts200ResponseListingsInnerListingStateEnum = typeof ListedNfts200ResponseListingsInnerListingStateEnum[keyof typeof ListedNfts200ResponseListingsInnerListingStateEnum];

/**
 * 
 * @export
 * @interface ListerBorrowingBidderInfoInner
 */
export interface ListerBorrowingBidderInfoInner {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof ListerBorrowingBidderInfoInner
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof ListerBorrowingBidderInfoInner
     */
    'paid_interest_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof ListerBorrowingBidderInfoInner
     */
    'start_at'?: string;
}
/**
 * 
 * @export
 * @interface Loan200Response
 */
export interface Loan200Response {
    /**
     * 
     * @type {Loans200ResponseLoansInner}
     * @memberof Loan200Response
     */
    'loan'?: Loans200ResponseLoansInner;
    /**
     * 
     * @type {string}
     * @memberof Loan200Response
     */
    'borrowing_limit'?: string;
}
/**
 * 
 * @export
 * @interface Loans200Response
 */
export interface Loans200Response {
    /**
     * 
     * @type {Array<Loans200ResponseLoansInner>}
     * @memberof Loans200Response
     */
    'loans'?: Array<Loans200ResponseLoansInner>;
}
/**
 * 
 * @export
 * @interface Loans200ResponseLoansInner
 */
export interface Loans200ResponseLoansInner {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof Loans200ResponseLoansInner
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof Loans200ResponseLoansInner
     */
    'loan'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface MarketAll200Response
 */
export interface MarketAll200Response {
    /**
     * 
     * @type {Array<MarketAll200ResponseMarketsInner>}
     * @memberof MarketAll200Response
     */
    'markets'?: Array<MarketAll200ResponseMarketsInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof MarketAll200Response
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface MarketAll200ResponseMarketsInner
 */
export interface MarketAll200ResponseMarketsInner {
    /**
     * 
     * @type {string}
     * @memberof MarketAll200ResponseMarketsInner
     */
    'market_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MarketAll200ResponseMarketsInner
     */
    'base_asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof MarketAll200ResponseMarketsInner
     */
    'quote_asset'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MarketAll200ResponseMarketsInner
     */
    'oracles'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MarketAll200ResponseMarketsInner
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface NFTMinter200Response
 */
export interface NFTMinter200Response {
    /**
     * 
     * @type {string}
     * @memberof NFTMinter200Response
     */
    'minter'?: string;
}
/**
 * 
 * @export
 * @interface NftBackedLoanParams200Response
 */
export interface NftBackedLoanParams200Response {
    /**
     * 
     * @type {NftBackedLoanParams200ResponseParams}
     * @memberof NftBackedLoanParams200Response
     */
    'params'?: NftBackedLoanParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface NftBackedLoanParams200ResponseParams
 */
export interface NftBackedLoanParams200ResponseParams {
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'min_staking_for_listing'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'default_bid_active_rank'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'bid_tokens'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'auto_relisting_count_if_no_bid'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_delay_seconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_period_initial'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_cancel_required_seconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_cancel_fee_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_gap_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'bid_cancel_required_seconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'bid_token_disburse_seconds_after_cancel'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_full_payment_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_nft_delivery_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_creator_share_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'market_administrator'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_commission_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_extend_seconds'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof NftBackedLoanParams200ResponseParams
     */
    'nft_listing_period_extend_fee_per_hour'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface NftFactoryParams200Response
 */
export interface NftFactoryParams200Response {
    /**
     * 
     * @type {NftFactoryParams200ResponseParams}
     * @memberof NftFactoryParams200Response
     */
    'params'?: NftFactoryParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface NftFactoryParams200ResponseParams
 */
export interface NftFactoryParams200ResponseParams {
    /**
     * 
     * @type {string}
     * @memberof NftFactoryParams200ResponseParams
     */
    'MaxNFTSupplyCap'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftFactoryParams200ResponseParams
     */
    'MinClassNameLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftFactoryParams200ResponseParams
     */
    'MaxClassNameLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftFactoryParams200ResponseParams
     */
    'MinUriLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftFactoryParams200ResponseParams
     */
    'MaxUriLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftFactoryParams200ResponseParams
     */
    'MaxSymbolLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftFactoryParams200ResponseParams
     */
    'MaxDescriptionLen'?: string;
}
/**
 * 
 * @export
 * @interface NftListing200Response
 */
export interface NftListing200Response {
    /**
     * 
     * @type {ListedNfts200ResponseListingsInnerListing}
     * @memberof NftListing200Response
     */
    'listing'?: ListedNfts200ResponseListingsInnerListing;
}
/**
 * 
 * @export
 * @interface OracleAll200Response
 */
export interface OracleAll200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof OracleAll200Response
     */
    'oracles'?: Array<string>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof OracleAll200Response
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface PaymentStatus200Response
 */
export interface PaymentStatus200Response {
    /**
     * 
     * @type {PaymentStatus200ResponsePaymentStatus}
     * @memberof PaymentStatus200Response
     */
    'paymentStatus'?: PaymentStatus200ResponsePaymentStatus;
}
/**
 * 
 * @export
 * @interface PaymentStatus200ResponsePaymentStatus
 */
export interface PaymentStatus200ResponsePaymentStatus {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'bidder'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'automatic_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'paid_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'bid_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'state'?: PaymentStatus200ResponsePaymentStatusStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentStatus200ResponsePaymentStatus
     */
    'all_paid'?: boolean;
}

export const PaymentStatus200ResponsePaymentStatusStateEnum = {
    Listing: 'LISTING',
    Bidding: 'BIDDING',
    SellingDecision: 'SELLING_DECISION',
    EndListing: 'END_LISTING',
    SuccessfulBid: 'SUCCESSFUL_BID'
} as const;

export type PaymentStatus200ResponsePaymentStatusStateEnum = typeof PaymentStatus200ResponsePaymentStatusStateEnum[keyof typeof PaymentStatus200ResponsePaymentStatusStateEnum];

/**
 * 
 * @export
 * @interface PerpetualFutures200Response
 */
export interface PerpetualFutures200Response {
    /**
     * 
     * @type {string}
     * @memberof PerpetualFutures200Response
     */
    'metrics_quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerpetualFutures200Response
     */
    'volume_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerpetualFutures200Response
     */
    'fees_24hours'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof PerpetualFutures200Response
     */
    'long_positions'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof PerpetualFutures200Response
     */
    'short_positions'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface PerpetualFuturesMarket200Response
 */
export interface PerpetualFuturesMarket200Response {
    /**
     * 
     * @type {string}
     * @memberof PerpetualFuturesMarket200Response
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerpetualFuturesMarket200Response
     */
    'metrics_quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerpetualFuturesMarket200Response
     */
    'volume_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerpetualFuturesMarket200Response
     */
    'fees_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerpetualFuturesMarket200Response
     */
    'long_positions'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerpetualFuturesMarket200Response
     */
    'short_positions'?: string;
}
/**
 * 
 * @export
 * @interface PerpetualFuturesPositionSize200Response
 */
export interface PerpetualFuturesPositionSize200Response {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof PerpetualFuturesPositionSize200Response
     */
    'total_position_size_usd'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface Pool200Response
 */
export interface Pool200Response {
    /**
     * 
     * @type {string}
     * @memberof Pool200Response
     */
    'metrics_quote_ticker'?: string;
    /**
     * 
     * @type {Pool200ResponsePoolMarketCap}
     * @memberof Pool200Response
     */
    'pool_market_cap'?: Pool200ResponsePoolMarketCap;
    /**
     * 
     * @type {string}
     * @memberof Pool200Response
     */
    'volume_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool200Response
     */
    'fees_24hours'?: string;
}
/**
 * 
 * @export
 * @interface Pool200ResponsePoolMarketCap
 */
export interface Pool200ResponsePoolMarketCap {
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePoolMarketCap
     */
    'quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePoolMarketCap
     */
    'total'?: string;
    /**
     * 
     * @type {Array<Pool200ResponsePoolMarketCapAssetInfoInner>}
     * @memberof Pool200ResponsePoolMarketCap
     */
    'asset_info'?: Array<Pool200ResponsePoolMarketCapAssetInfoInner>;
}
/**
 * 
 * @export
 * @interface Pool200ResponsePoolMarketCapAssetInfoInner
 */
export interface Pool200ResponsePoolMarketCapAssetInfoInner {
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePoolMarketCapAssetInfoInner
     */
    'reserved'?: string;
}
/**
 * 
 * @export
 * @interface Position200Response
 */
export interface Position200Response {
    /**
     * 
     * @type {Position200ResponsePosition}
     * @memberof Position200Response
     */
    'position'?: Position200ResponsePosition;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof Position200Response
     */
    'valuation_profit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof Position200Response
     */
    'margin_maintenance_rate'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof Position200Response
     */
    'effective_margin'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface Position200ResponsePosition
 */
export interface Position200ResponsePosition {
    /**
     * 
     * @type {string}
     * @memberof Position200ResponsePosition
     */
    'id'?: string;
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner}
     * @memberof Position200ResponsePosition
     */
    'market'?: DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner;
    /**
     * 
     * @type {string}
     * @memberof Position200ResponsePosition
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position200ResponsePosition
     */
    'opened_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position200ResponsePosition
     */
    'opened_height'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position200ResponsePosition
     */
    'opened_base_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position200ResponsePosition
     */
    'opened_quote_rate'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof Position200ResponsePosition
     */
    'remaining_margin'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof Position200ResponsePosition
     */
    'last_levied_at'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmountDefaultResponseDetailsInner}
     * @memberof Position200ResponsePosition
     */
    'position_instance'?: EstimateDLPTokenAmountDefaultResponseDetailsInner;
}
/**
 * 
 * @export
 * @interface Price200Response
 */
export interface Price200Response {
    /**
     * 
     * @type {Price200ResponsePrice}
     * @memberof Price200Response
     */
    'price'?: Price200ResponsePrice;
}
/**
 * 
 * @export
 * @interface Price200ResponsePrice
 */
export interface Price200ResponsePrice {
    /**
     * 
     * @type {string}
     * @memberof Price200ResponsePrice
     */
    'market_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price200ResponsePrice
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface PriceAll200Response
 */
export interface PriceAll200Response {
    /**
     * 
     * @type {Array<Price200ResponsePrice>}
     * @memberof PriceAll200Response
     */
    'prices'?: Array<Price200ResponsePrice>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof PriceAll200Response
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface PricefeedParams200Response
 */
export interface PricefeedParams200Response {
    /**
     * 
     * @type {PricefeedParams200ResponseParams}
     * @memberof PricefeedParams200Response
     */
    'params'?: PricefeedParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface PricefeedParams200ResponseParams
 */
export interface PricefeedParams200ResponseParams {
    /**
     * 
     * @type {Array<MarketAll200ResponseMarketsInner>}
     * @memberof PricefeedParams200ResponseParams
     */
    'markets'?: Array<MarketAll200ResponseMarketsInner>;
}
/**
 * 
 * @export
 * @interface RawPriceAll200Response
 */
export interface RawPriceAll200Response {
    /**
     * 
     * @type {Array<RawPriceAll200ResponsePricesInner>}
     * @memberof RawPriceAll200Response
     */
    'prices'?: Array<RawPriceAll200ResponsePricesInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof RawPriceAll200Response
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface RawPriceAll200ResponsePricesInner
 */
export interface RawPriceAll200ResponsePricesInner {
    /**
     * 
     * @type {string}
     * @memberof RawPriceAll200ResponsePricesInner
     */
    'market_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RawPriceAll200ResponsePricesInner
     */
    'oracle_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof RawPriceAll200ResponsePricesInner
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof RawPriceAll200ResponsePricesInner
     */
    'expiry'?: string;
}
/**
 * 
 * @export
 * @interface RecipientContainer200Response
 */
export interface RecipientContainer200Response {
    /**
     * 
     * @type {RecipientContainer200ResponseRecipientContainer}
     * @memberof RecipientContainer200Response
     */
    'recipient_container'?: RecipientContainer200ResponseRecipientContainer;
}
/**
 * 
 * @export
 * @interface RecipientContainer200ResponseRecipientContainer
 */
export interface RecipientContainer200ResponseRecipientContainer {
    /**
     * 
     * @type {string}
     * @memberof RecipientContainer200ResponseRecipientContainer
     */
    'id'?: string;
    /**
     * 
     * @type {Array<RecipientContainer200ResponseRecipientContainerWeightedAddressesInner>}
     * @memberof RecipientContainer200ResponseRecipientContainer
     */
    'weighted_addresses'?: Array<RecipientContainer200ResponseRecipientContainerWeightedAddressesInner>;
}
/**
 * 
 * @export
 * @interface RecipientContainer200ResponseRecipientContainerWeightedAddressesInner
 */
export interface RecipientContainer200ResponseRecipientContainerWeightedAddressesInner {
    /**
     * 
     * @type {string}
     * @memberof RecipientContainer200ResponseRecipientContainerWeightedAddressesInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipientContainer200ResponseRecipientContainerWeightedAddressesInner
     */
    'weight'?: string;
}
/**
 * 
 * @export
 * @interface RecordedRecipientContainerId200Response
 */
export interface RecordedRecipientContainerId200Response {
    /**
     * 
     * @type {string}
     * @memberof RecordedRecipientContainerId200Response
     */
    'recipient_container_id'?: string;
}
/**
 * 
 * @export
 * @interface Reward200Response
 */
export interface Reward200Response {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof Reward200Response
     */
    'reward'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
 */
export interface RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1 {
    /**
     * 
     * @type {string}
     * @memberof RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
     */
    'module_name'?: string;
    /**
     * 
     * @type {Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>}
     * @memberof RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
     */
    'reward_rate'?: Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>;
}
/**
 * 
 * @export
 * @interface RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
 */
export interface RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1 {
    /**
     * NFTMARKET_FRONTEND type reward will be disributed for the creators of frontend of UnUniFi\'s services.
     * @type {string}
     * @memberof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
     */
    'reward_type'?: RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
     */
    'rate'?: string;
}

export const RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum = {
    Unknown: 'UNKNOWN',
    Stakers: 'STAKERS',
    FrontendDevelopers: 'FRONTEND_DEVELOPERS'
} as const;

export type RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum = typeof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum[keyof typeof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum];

/**
 * 
 * @export
 * @interface Rewards200Response
 */
export interface Rewards200Response {
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof Rewards200Response
     */
    'rewards'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * 
 * @export
 * @interface Strategy200Response
 */
export interface Strategy200Response {
    /**
     * 
     * @type {StrategyAll200ResponseStrategiesInner}
     * @memberof Strategy200Response
     */
    'strategy'?: StrategyAll200ResponseStrategiesInner;
}
/**
 * 
 * @export
 * @interface StrategyAll200Response
 */
export interface StrategyAll200Response {
    /**
     * 
     * @type {Array<StrategyAll200ResponseStrategiesInner>}
     * @memberof StrategyAll200Response
     */
    'strategies'?: Array<StrategyAll200ResponseStrategiesInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof StrategyAll200Response
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface StrategyAll200ResponseStrategiesInner
 */
export interface StrategyAll200ResponseStrategiesInner {
    /**
     * 
     * @type {string}
     * @memberof StrategyAll200ResponseStrategiesInner
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyAll200ResponseStrategiesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyAll200ResponseStrategiesInner
     */
    'contract_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyAll200ResponseStrategiesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyAll200ResponseStrategiesInner
     */
    'git_url'?: string;
}
/**
 * 
 * @export
 * @interface TodoRemoveNftIdBidderThenUseIt
 */
export interface TodoRemoveNftIdBidderThenUseIt {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof TodoRemoveNftIdBidderThenUseIt
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof TodoRemoveNftIdBidderThenUseIt
     */
    'bidder'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesMarket
 */
export interface UnunifiDerivativesMarket {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesMarket
     */
    'base_denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesMarket
     */
    'quote_denom'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesParams
 */
export interface UnunifiDerivativesParams {
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPoolParams}
     * @memberof UnunifiDerivativesParams
     */
    'pool_params'?: DerivativesParams200ResponseParamsPoolParams;
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPerpetualFutures}
     * @memberof UnunifiDerivativesParams
     */
    'perpetual_futures'?: DerivativesParams200ResponseParamsPerpetualFutures;
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPerpetualOptions}
     * @memberof UnunifiDerivativesParams
     */
    'perpetual_options'?: DerivativesParams200ResponseParamsPerpetualOptions;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesPerpetualFuturesParams
 */
export interface UnunifiDerivativesPerpetualFuturesParams {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPerpetualFuturesParams
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPerpetualFuturesParams
     */
    'margin_maintenance_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPerpetualFuturesParams
     */
    'imaginary_funding_rate_proportional_coefficient'?: string;
    /**
     * 
     * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
     * @memberof UnunifiDerivativesPerpetualFuturesParams
     */
    'markets'?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
    /**
     * 
     * @type {number}
     * @memberof UnunifiDerivativesPerpetualFuturesParams
     */
    'max_leverage'?: number;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesPerpetualOptionsParams
 */
export interface UnunifiDerivativesPerpetualOptionsParams {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPerpetualOptionsParams
     */
    'premium_commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPerpetualOptionsParams
     */
    'strike_commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPerpetualOptionsParams
     */
    'margin_maintenance_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPerpetualOptionsParams
     */
    'imaginary_funding_rate_proportional_coefficient'?: string;
    /**
     * 
     * @type {Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>}
     * @memberof UnunifiDerivativesPerpetualOptionsParams
     */
    'markets'?: Array<DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner>;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesPoolAssetConf
 */
export interface UnunifiDerivativesPoolAssetConf {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolAssetConf
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolAssetConf
     */
    'target_weight'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesPoolMarketCap
 */
export interface UnunifiDerivativesPoolMarketCap {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolMarketCap
     */
    'quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolMarketCap
     */
    'total'?: string;
    /**
     * 
     * @type {Array<Pool200ResponsePoolMarketCapAssetInfoInner>}
     * @memberof UnunifiDerivativesPoolMarketCap
     */
    'asset_info'?: Array<Pool200ResponsePoolMarketCapAssetInfoInner>;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesPoolMarketCapAssetInfo
 */
export interface UnunifiDerivativesPoolMarketCapAssetInfo {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolMarketCapAssetInfo
     */
    'reserved'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesPoolParams
 */
export interface UnunifiDerivativesPoolParams {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolParams
     */
    'quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolParams
     */
    'base_lpt_mint_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolParams
     */
    'base_lpt_redeem_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolParams
     */
    'borrowing_fee_rate_per_hour'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolParams
     */
    'report_liquidation_reward_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPoolParams
     */
    'report_levy_period_reward_rate'?: string;
    /**
     * 
     * @type {Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>}
     * @memberof UnunifiDerivativesPoolParams
     */
    'accepted_assets_conf'?: Array<DerivativesParams200ResponseParamsPoolParamsAcceptedAssetsConfInner>;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesPosition
 */
export interface UnunifiDerivativesPosition {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPosition
     */
    'id'?: string;
    /**
     * 
     * @type {DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner}
     * @memberof UnunifiDerivativesPosition
     */
    'market'?: DerivativesParams200ResponseParamsPerpetualFuturesMarketsInner;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPosition
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPosition
     */
    'opened_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPosition
     */
    'opened_height'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPosition
     */
    'opened_base_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPosition
     */
    'opened_quote_rate'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesPosition
     */
    'remaining_margin'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesPosition
     */
    'last_levied_at'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmountDefaultResponseDetailsInner}
     * @memberof UnunifiDerivativesPosition
     */
    'position_instance'?: EstimateDLPTokenAmountDefaultResponseDetailsInner;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UnunifiDerivativesPositionType = {
    PositionUnknown: 'POSITION_UNKNOWN',
    Long: 'LONG',
    Short: 'SHORT'
} as const;

export type UnunifiDerivativesPositionType = typeof UnunifiDerivativesPositionType[keyof typeof UnunifiDerivativesPositionType];


/**
 * 
 * @export
 * @interface UnunifiDerivativesQueriedPosition
 */
export interface UnunifiDerivativesQueriedPosition {
    /**
     * 
     * @type {Position200ResponsePosition}
     * @memberof UnunifiDerivativesQueriedPosition
     */
    'position'?: Position200ResponsePosition;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueriedPosition
     */
    'valuation_profit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueriedPosition
     */
    'remaining_margin_value'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueriedPosition
     */
    'effective_margin'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueriedPosition
     */
    'margin_maintenance_rate'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryAddressPositionsResponse
 */
export interface UnunifiDerivativesQueryAddressPositionsResponse {
    /**
     * 
     * @type {Array<AddressPositions200ResponsePositionsInner>}
     * @memberof UnunifiDerivativesQueryAddressPositionsResponse
     */
    'positions'?: Array<AddressPositions200ResponsePositionsInner>;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryAllPositionsResponse
 */
export interface UnunifiDerivativesQueryAllPositionsResponse {
    /**
     * 
     * @type {Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>}
     * @memberof UnunifiDerivativesQueryAllPositionsResponse
     */
    'positions'?: Array<EstimateDLPTokenAmountDefaultResponseDetailsInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof UnunifiDerivativesQueryAllPositionsResponse
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryAvailableAssetInPoolByDenomResponse
 */
export interface UnunifiDerivativesQueryAvailableAssetInPoolByDenomResponse {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryAvailableAssetInPoolByDenomResponse
     */
    'available_asset'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryAvailableAssetsInPoolResponse
 */
export interface UnunifiDerivativesQueryAvailableAssetsInPoolResponse {
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof UnunifiDerivativesQueryAvailableAssetsInPoolResponse
     */
    'available_assets'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryDLPTokenRateResponse
 */
export interface UnunifiDerivativesQueryDLPTokenRateResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryDLPTokenRateResponse
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof UnunifiDerivativesQueryDLPTokenRateResponse
     */
    'rates'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryEstimateDLPTokenAmountResponse
 */
export interface UnunifiDerivativesQueryEstimateDLPTokenAmountResponse {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryEstimateDLPTokenAmountResponse
     */
    'estimated_dlp_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryEstimateDLPTokenAmountResponse
     */
    'deposit_fee'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse
 */
export interface UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryEstimateRedeemTokenAmountResponse
     */
    'fee'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryLiquidityProviderTokenNominalAPYResponse
 */
export interface UnunifiDerivativesQueryLiquidityProviderTokenNominalAPYResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryLiquidityProviderTokenNominalAPYResponse
     */
    'apy'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryLiquidityProviderTokenRealAPYResponse
 */
export interface UnunifiDerivativesQueryLiquidityProviderTokenRealAPYResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryLiquidityProviderTokenRealAPYResponse
     */
    'apy'?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface UnunifiDerivativesQueryParamsResponse
 */
export interface UnunifiDerivativesQueryParamsResponse {
    /**
     * 
     * @type {DerivativesParams200ResponseParams}
     * @memberof UnunifiDerivativesQueryParamsResponse
     */
    'params'?: DerivativesParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryPerpetualFuturesMarketResponse
 */
export interface UnunifiDerivativesQueryPerpetualFuturesMarketResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
     */
    'metrics_quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
     */
    'volume_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
     */
    'fees_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
     */
    'long_positions'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesMarketResponse
     */
    'short_positions'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryPerpetualFuturesPositionSizeResponse
 */
export interface UnunifiDerivativesQueryPerpetualFuturesPositionSizeResponse {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesPositionSizeResponse
     */
    'total_position_size_usd'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryPerpetualFuturesResponse
 */
export interface UnunifiDerivativesQueryPerpetualFuturesResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
     */
    'metrics_quote_ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
     */
    'volume_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
     */
    'fees_24hours'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
     */
    'long_positions'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryPerpetualFuturesResponse
     */
    'short_positions'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryPoolResponse
 */
export interface UnunifiDerivativesQueryPoolResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPoolResponse
     */
    'metrics_quote_ticker'?: string;
    /**
     * 
     * @type {Pool200ResponsePoolMarketCap}
     * @memberof UnunifiDerivativesQueryPoolResponse
     */
    'pool_market_cap'?: Pool200ResponsePoolMarketCap;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPoolResponse
     */
    'volume_24hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPoolResponse
     */
    'fees_24hours'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiDerivativesQueryPositionResponse
 */
export interface UnunifiDerivativesQueryPositionResponse {
    /**
     * 
     * @type {Position200ResponsePosition}
     * @memberof UnunifiDerivativesQueryPositionResponse
     */
    'position'?: Position200ResponsePosition;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryPositionResponse
     */
    'valuation_profit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiDerivativesQueryPositionResponse
     */
    'margin_maintenance_rate'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiDerivativesQueryPositionResponse
     */
    'effective_margin'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * Params defines the parameters for the module.
 * @export
 * @interface UnunifiEcosystemincentiveParams
 */
export interface UnunifiEcosystemincentiveParams {
    /**
     * 
     * @type {Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>}
     * @memberof UnunifiEcosystemincentiveParams
     */
    'reward_params'?: Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveQueryAllRewardsResponse
 */
export interface UnunifiEcosystemincentiveQueryAllRewardsResponse {
    /**
     * 
     * @type {AllRewards200ResponseRewards}
     * @memberof UnunifiEcosystemincentiveQueryAllRewardsResponse
     */
    'rewards'?: AllRewards200ResponseRewards;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveQueryBelongingRecipientContainerIdsByAddrResponse
 */
export interface UnunifiEcosystemincentiveQueryBelongingRecipientContainerIdsByAddrResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof UnunifiEcosystemincentiveQueryBelongingRecipientContainerIdsByAddrResponse
     */
    'recipient_container_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveQueryParamsResponse
 */
export interface UnunifiEcosystemincentiveQueryParamsResponse {
    /**
     * 
     * @type {EcosystemIncentiveParams200ResponseParams}
     * @memberof UnunifiEcosystemincentiveQueryParamsResponse
     */
    'params'?: EcosystemIncentiveParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveQueryRecipientContainerResponse
 */
export interface UnunifiEcosystemincentiveQueryRecipientContainerResponse {
    /**
     * 
     * @type {RecipientContainer200ResponseRecipientContainer}
     * @memberof UnunifiEcosystemincentiveQueryRecipientContainerResponse
     */
    'recipient_container'?: RecipientContainer200ResponseRecipientContainer;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveQueryRecordedRecipientContainerIdResponse
 */
export interface UnunifiEcosystemincentiveQueryRecordedRecipientContainerIdResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiEcosystemincentiveQueryRecordedRecipientContainerIdResponse
     */
    'recipient_container_id'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveQueryRewardResponse
 */
export interface UnunifiEcosystemincentiveQueryRewardResponse {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiEcosystemincentiveQueryRewardResponse
     */
    'reward'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveRecipientContainer
 */
export interface UnunifiEcosystemincentiveRecipientContainer {
    /**
     * 
     * @type {string}
     * @memberof UnunifiEcosystemincentiveRecipientContainer
     */
    'id'?: string;
    /**
     * 
     * @type {Array<RecipientContainer200ResponseRecipientContainerWeightedAddressesInner>}
     * @memberof UnunifiEcosystemincentiveRecipientContainer
     */
    'weighted_addresses'?: Array<RecipientContainer200ResponseRecipientContainerWeightedAddressesInner>;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveRewardParams
 */
export interface UnunifiEcosystemincentiveRewardParams {
    /**
     * 
     * @type {string}
     * @memberof UnunifiEcosystemincentiveRewardParams
     */
    'module_name'?: string;
    /**
     * 
     * @type {Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>}
     * @memberof UnunifiEcosystemincentiveRewardParams
     */
    'reward_rate'?: Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>;
}
/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveRewardRate
 */
export interface UnunifiEcosystemincentiveRewardRate {
    /**
     * NFTMARKET_FRONTEND type reward will be disributed for the creators of frontend of UnUniFi\'s services.
     * @type {string}
     * @memberof UnunifiEcosystemincentiveRewardRate
     */
    'reward_type'?: UnunifiEcosystemincentiveRewardRateRewardTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UnunifiEcosystemincentiveRewardRate
     */
    'rate'?: string;
}

export const UnunifiEcosystemincentiveRewardRateRewardTypeEnum = {
    Unknown: 'UNKNOWN',
    Stakers: 'STAKERS',
    FrontendDevelopers: 'FRONTEND_DEVELOPERS'
} as const;

export type UnunifiEcosystemincentiveRewardRateRewardTypeEnum = typeof UnunifiEcosystemincentiveRewardRateRewardTypeEnum[keyof typeof UnunifiEcosystemincentiveRewardRateRewardTypeEnum];

/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveRewardStore
 */
export interface UnunifiEcosystemincentiveRewardStore {
    /**
     * 
     * @type {string}
     * @memberof UnunifiEcosystemincentiveRewardStore
     */
    'address'?: string;
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof UnunifiEcosystemincentiveRewardStore
     */
    'rewards'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * NFTMARKET_FRONTEND type reward will be disributed for the creators of frontend of UnUniFi\'s services.
 * @export
 * @enum {string}
 */

export const UnunifiEcosystemincentiveRewardType = {
    Unknown: 'UNKNOWN',
    Stakers: 'STAKERS',
    FrontendDevelopers: 'FRONTEND_DEVELOPERS'
} as const;

export type UnunifiEcosystemincentiveRewardType = typeof UnunifiEcosystemincentiveRewardType[keyof typeof UnunifiEcosystemincentiveRewardType];


/**
 * 
 * @export
 * @interface UnunifiEcosystemincentiveWeightedAddress
 */
export interface UnunifiEcosystemincentiveWeightedAddress {
    /**
     * 
     * @type {string}
     * @memberof UnunifiEcosystemincentiveWeightedAddress
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiEcosystemincentiveWeightedAddress
     */
    'weight'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanBidId
 */
export interface UnunifiNftbackedloanBidId {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof UnunifiNftbackedloanBidId
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanBidId
     */
    'bidder'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanBorrowing
 */
export interface UnunifiNftbackedloanBorrowing {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanBorrowing
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanBorrowing
     */
    'paid_interest_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanBorrowing
     */
    'start_at'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanLiquidation
 */
export interface UnunifiNftbackedloanLiquidation {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanLiquidation
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanLiquidation
     */
    'liquidation_date'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanLiquidations
 */
export interface UnunifiNftbackedloanLiquidations {
    /**
     * 
     * @type {Liquidation200ResponseLiquidationsLiquidation}
     * @memberof UnunifiNftbackedloanLiquidations
     */
    'liquidation'?: Liquidation200ResponseLiquidationsLiquidation;
    /**
     * 
     * @type {Array<Liquidation200ResponseLiquidationsLiquidation>}
     * @memberof UnunifiNftbackedloanLiquidations
     */
    'next_liquidation'?: Array<Liquidation200ResponseLiquidationsLiquidation>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UnunifiNftbackedloanListingState = {
    Listing: 'LISTING',
    Bidding: 'BIDDING',
    SellingDecision: 'SELLING_DECISION',
    EndListing: 'END_LISTING',
    SuccessfulBid: 'SUCCESSFUL_BID'
} as const;

export type UnunifiNftbackedloanListingState = typeof UnunifiNftbackedloanListingState[keyof typeof UnunifiNftbackedloanListingState];


/**
 * 
 * @export
 * @enum {string}
 */

export const UnunifiNftbackedloanListingType = {
    DirectAssetBorrow: 'DIRECT_ASSET_BORROW',
    SyntheticAssetCreation: 'SYNTHETIC_ASSET_CREATION',
    LateShipping: 'LATE_SHIPPING'
} as const;

export type UnunifiNftbackedloanListingType = typeof UnunifiNftbackedloanListingType[keyof typeof UnunifiNftbackedloanListingType];


/**
 * 
 * @export
 * @interface UnunifiNftbackedloanLoan
 */
export interface UnunifiNftbackedloanLoan {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof UnunifiNftbackedloanLoan
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanLoan
     */
    'loan'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanNftBid
 */
export interface UnunifiNftbackedloanNftBid {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'bidder'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'bid_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'deposit_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'paid_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'bidding_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'deposit_lending_rate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'automatic_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'bid_time'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'interest_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {Array<ListerBorrowingBidderInfoInner>}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'borrowings'?: Array<ListerBorrowingBidderInfoInner>;
    /**
     * 
     * @type {TodoRemoveNftIdBidderThenUseIt}
     * @memberof UnunifiNftbackedloanNftBid
     */
    'id'?: TodoRemoveNftIdBidderThenUseIt;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanNftIdentifier
 */
export interface UnunifiNftbackedloanNftIdentifier {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftIdentifier
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftIdentifier
     */
    'nft_id'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanNftInfo
 */
export interface UnunifiNftbackedloanNftInfo {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftInfo
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftInfo
     */
    'uri_hash'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanNftListing
 */
export interface UnunifiNftbackedloanNftListing {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'listing_type'?: UnunifiNftbackedloanNftListingListingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'state'?: UnunifiNftbackedloanNftListingStateEnum;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'bid_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'minimum_deposit_rate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'automatic_refinancing'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'started_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'end_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'full_payment_end_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'successful_bid_end_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'auto_relisted_count'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'collected_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanNftListing
     */
    'minimum_bidding_period'?: string;
}

export const UnunifiNftbackedloanNftListingListingTypeEnum = {
    DirectAssetBorrow: 'DIRECT_ASSET_BORROW',
    SyntheticAssetCreation: 'SYNTHETIC_ASSET_CREATION',
    LateShipping: 'LATE_SHIPPING'
} as const;

export type UnunifiNftbackedloanNftListingListingTypeEnum = typeof UnunifiNftbackedloanNftListingListingTypeEnum[keyof typeof UnunifiNftbackedloanNftListingListingTypeEnum];
export const UnunifiNftbackedloanNftListingStateEnum = {
    Listing: 'LISTING',
    Bidding: 'BIDDING',
    SellingDecision: 'SELLING_DECISION',
    EndListing: 'END_LISTING',
    SuccessfulBid: 'SUCCESSFUL_BID'
} as const;

export type UnunifiNftbackedloanNftListingStateEnum = typeof UnunifiNftbackedloanNftListingStateEnum[keyof typeof UnunifiNftbackedloanNftListingStateEnum];

/**
 * 
 * @export
 * @interface UnunifiNftbackedloanNftListingDetail
 */
export interface UnunifiNftbackedloanNftListingDetail {
    /**
     * 
     * @type {ListedNfts200ResponseListingsInnerListing}
     * @memberof UnunifiNftbackedloanNftListingDetail
     */
    'listing'?: ListedNfts200ResponseListingsInnerListing;
    /**
     * 
     * @type {ListedClass200ResponseNftsInner}
     * @memberof UnunifiNftbackedloanNftListingDetail
     */
    'nft_info'?: ListedClass200ResponseNftsInner;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanParams
 */
export interface UnunifiNftbackedloanParams {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'min_staking_for_listing'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'default_bid_active_rank'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UnunifiNftbackedloanParams
     */
    'bid_tokens'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'auto_relisting_count_if_no_bid'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_delay_seconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_period_initial'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_cancel_required_seconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_cancel_fee_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_gap_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'bid_cancel_required_seconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'bid_token_disburse_seconds_after_cancel'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_full_payment_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_nft_delivery_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_creator_share_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'market_administrator'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_commission_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_extend_seconds'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanParams
     */
    'nft_listing_period_extend_fee_per_hour'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanPaymentStatus
 */
export interface UnunifiNftbackedloanPaymentStatus {
    /**
     * 
     * @type {BidderBids200ResponseBidsInnerNftId}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'nft_id'?: BidderBids200ResponseBidsInnerNftId;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'bidder'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {boolean}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'automatic_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'paid_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'bid_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'state'?: UnunifiNftbackedloanPaymentStatusStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UnunifiNftbackedloanPaymentStatus
     */
    'all_paid'?: boolean;
}

export const UnunifiNftbackedloanPaymentStatusStateEnum = {
    Listing: 'LISTING',
    Bidding: 'BIDDING',
    SellingDecision: 'SELLING_DECISION',
    EndListing: 'END_LISTING',
    SuccessfulBid: 'SUCCESSFUL_BID'
} as const;

export type UnunifiNftbackedloanPaymentStatusStateEnum = typeof UnunifiNftbackedloanPaymentStatusStateEnum[keyof typeof UnunifiNftbackedloanPaymentStatusStateEnum];

/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryBidderBidsResponse
 */
export interface UnunifiNftbackedloanQueryBidderBidsResponse {
    /**
     * 
     * @type {Array<BidderBids200ResponseBidsInner>}
     * @memberof UnunifiNftbackedloanQueryBidderBidsResponse
     */
    'bids'?: Array<BidderBids200ResponseBidsInner>;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryLiquidationResponse
 */
export interface UnunifiNftbackedloanQueryLiquidationResponse {
    /**
     * 
     * @type {Liquidation200ResponseLiquidations}
     * @memberof UnunifiNftbackedloanQueryLiquidationResponse
     */
    'liquidations'?: Liquidation200ResponseLiquidations;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryListedClassResponse
 */
export interface UnunifiNftbackedloanQueryListedClassResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'urihash'?: string;
    /**
     * 
     * @type {Array<ListedClass200ResponseNftsInner>}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'nfts'?: Array<ListedClass200ResponseNftsInner>;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryListedClassResponse
     */
    'nft_count'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryListedClassesResponse
 */
export interface UnunifiNftbackedloanQueryListedClassesResponse {
    /**
     * 
     * @type {Array<ListedClass200Response>}
     * @memberof UnunifiNftbackedloanQueryListedClassesResponse
     */
    'classes'?: Array<ListedClass200Response>;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryListedNftsResponse
 */
export interface UnunifiNftbackedloanQueryListedNftsResponse {
    /**
     * 
     * @type {Array<ListedNfts200ResponseListingsInner>}
     * @memberof UnunifiNftbackedloanQueryListedNftsResponse
     */
    'listings'?: Array<ListedNfts200ResponseListingsInner>;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryLoanResponse
 */
export interface UnunifiNftbackedloanQueryLoanResponse {
    /**
     * 
     * @type {Loans200ResponseLoansInner}
     * @memberof UnunifiNftbackedloanQueryLoanResponse
     */
    'loan'?: Loans200ResponseLoansInner;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftbackedloanQueryLoanResponse
     */
    'borrowing_limit'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryLoansResponse
 */
export interface UnunifiNftbackedloanQueryLoansResponse {
    /**
     * 
     * @type {Array<Loans200ResponseLoansInner>}
     * @memberof UnunifiNftbackedloanQueryLoansResponse
     */
    'loans'?: Array<Loans200ResponseLoansInner>;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryNftBidsResponse
 */
export interface UnunifiNftbackedloanQueryNftBidsResponse {
    /**
     * 
     * @type {Array<BidderBids200ResponseBidsInner>}
     * @memberof UnunifiNftbackedloanQueryNftBidsResponse
     */
    'bids'?: Array<BidderBids200ResponseBidsInner>;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryNftListingResponse
 */
export interface UnunifiNftbackedloanQueryNftListingResponse {
    /**
     * 
     * @type {ListedNfts200ResponseListingsInnerListing}
     * @memberof UnunifiNftbackedloanQueryNftListingResponse
     */
    'listing'?: ListedNfts200ResponseListingsInnerListing;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryParamsResponse
 */
export interface UnunifiNftbackedloanQueryParamsResponse {
    /**
     * 
     * @type {NftBackedLoanParams200ResponseParams}
     * @memberof UnunifiNftbackedloanQueryParamsResponse
     */
    'params'?: NftBackedLoanParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryPaymentStatusResponse
 */
export interface UnunifiNftbackedloanQueryPaymentStatusResponse {
    /**
     * 
     * @type {PaymentStatus200ResponsePaymentStatus}
     * @memberof UnunifiNftbackedloanQueryPaymentStatusResponse
     */
    'paymentStatus'?: PaymentStatus200ResponsePaymentStatus;
}
/**
 * 
 * @export
 * @interface UnunifiNftbackedloanQueryRewardsResponse
 */
export interface UnunifiNftbackedloanQueryRewardsResponse {
    /**
     * 
     * @type {Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>}
     * @memberof UnunifiNftbackedloanQueryRewardsResponse
     */
    'rewards'?: Array<EstimateDLPTokenAmount200ResponseEstimatedDlpAmount>;
}
/**
 * 
 * @export
 * @interface UnunifiNftfactoryClassAttributes
 */
export interface UnunifiNftfactoryClassAttributes {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryClassAttributes
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryClassAttributes
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryClassAttributes
     */
    'base_token_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryClassAttributes
     */
    'minting_permission'?: UnunifiNftfactoryClassAttributesMintingPermissionEnum;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryClassAttributes
     */
    'token_supply_cap'?: string;
}

export const UnunifiNftfactoryClassAttributesMintingPermissionEnum = {
    OnlyOwner: 'OnlyOwner',
    Anyone: 'Anyone'
} as const;

export type UnunifiNftfactoryClassAttributesMintingPermissionEnum = typeof UnunifiNftfactoryClassAttributesMintingPermissionEnum[keyof typeof UnunifiNftfactoryClassAttributesMintingPermissionEnum];

/**
 * 
 * @export
 * @interface UnunifiNftfactoryClassNameIdList
 */
export interface UnunifiNftfactoryClassNameIdList {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryClassNameIdList
     */
    'class_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UnunifiNftfactoryClassNameIdList
     */
    'class_id'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UnunifiNftfactoryMintingPermission = {
    OnlyOwner: 'OnlyOwner',
    Anyone: 'Anyone'
} as const;

export type UnunifiNftfactoryMintingPermission = typeof UnunifiNftfactoryMintingPermission[keyof typeof UnunifiNftfactoryMintingPermission];


/**
 * 
 * @export
 * @interface UnunifiNftfactoryOwningClassIdList
 */
export interface UnunifiNftfactoryOwningClassIdList {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryOwningClassIdList
     */
    'owner'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UnunifiNftfactoryOwningClassIdList
     */
    'class_id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UnunifiNftfactoryParams
 */
export interface UnunifiNftfactoryParams {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryParams
     */
    'MaxNFTSupplyCap'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryParams
     */
    'MinClassNameLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryParams
     */
    'MaxClassNameLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryParams
     */
    'MinUriLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryParams
     */
    'MaxUriLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryParams
     */
    'MaxSymbolLen'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryParams
     */
    'MaxDescriptionLen'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftfactoryQueryClassAttributesResponse
 */
export interface UnunifiNftfactoryQueryClassAttributesResponse {
    /**
     * 
     * @type {ClassAttributes200ResponseClassAttributes}
     * @memberof UnunifiNftfactoryQueryClassAttributesResponse
     */
    'class_attributes'?: ClassAttributes200ResponseClassAttributes;
}
/**
 * 
 * @export
 * @interface UnunifiNftfactoryQueryClassIdsByNameResponse
 */
export interface UnunifiNftfactoryQueryClassIdsByNameResponse {
    /**
     * 
     * @type {ClassIdsByName200ResponseClassNameIdList}
     * @memberof UnunifiNftfactoryQueryClassIdsByNameResponse
     */
    'class_name_id_list'?: ClassIdsByName200ResponseClassNameIdList;
}
/**
 * 
 * @export
 * @interface UnunifiNftfactoryQueryClassIdsByOwnerResponse
 */
export interface UnunifiNftfactoryQueryClassIdsByOwnerResponse {
    /**
     * 
     * @type {ClassIdsByOwner200ResponseOwningClassIdList}
     * @memberof UnunifiNftfactoryQueryClassIdsByOwnerResponse
     */
    'owning_class_id_list'?: ClassIdsByOwner200ResponseOwningClassIdList;
}
/**
 * 
 * @export
 * @interface UnunifiNftfactoryQueryNFTMinterResponse
 */
export interface UnunifiNftfactoryQueryNFTMinterResponse {
    /**
     * 
     * @type {string}
     * @memberof UnunifiNftfactoryQueryNFTMinterResponse
     */
    'minter'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiNftfactoryQueryParamsResponse
 */
export interface UnunifiNftfactoryQueryParamsResponse {
    /**
     * 
     * @type {NftFactoryParams200ResponseParams}
     * @memberof UnunifiNftfactoryQueryParamsResponse
     */
    'params'?: NftFactoryParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedCurrentPrice
 */
export interface UnunifiPricefeedCurrentPrice {
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedCurrentPrice
     */
    'market_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedCurrentPrice
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedMarket
 */
export interface UnunifiPricefeedMarket {
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedMarket
     */
    'market_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedMarket
     */
    'base_asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedMarket
     */
    'quote_asset'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UnunifiPricefeedMarket
     */
    'oracles'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UnunifiPricefeedMarket
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedParams
 */
export interface UnunifiPricefeedParams {
    /**
     * 
     * @type {Array<MarketAll200ResponseMarketsInner>}
     * @memberof UnunifiPricefeedParams
     */
    'markets'?: Array<MarketAll200ResponseMarketsInner>;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedPostedPrice
 */
export interface UnunifiPricefeedPostedPrice {
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedPostedPrice
     */
    'market_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedPostedPrice
     */
    'oracle_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedPostedPrice
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiPricefeedPostedPrice
     */
    'expiry'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedQueryAllMarketResponse
 */
export interface UnunifiPricefeedQueryAllMarketResponse {
    /**
     * 
     * @type {Array<MarketAll200ResponseMarketsInner>}
     * @memberof UnunifiPricefeedQueryAllMarketResponse
     */
    'markets'?: Array<MarketAll200ResponseMarketsInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof UnunifiPricefeedQueryAllMarketResponse
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedQueryAllOracleResponse
 */
export interface UnunifiPricefeedQueryAllOracleResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof UnunifiPricefeedQueryAllOracleResponse
     */
    'oracles'?: Array<string>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof UnunifiPricefeedQueryAllOracleResponse
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedQueryAllPriceResponse
 */
export interface UnunifiPricefeedQueryAllPriceResponse {
    /**
     * 
     * @type {Array<Price200ResponsePrice>}
     * @memberof UnunifiPricefeedQueryAllPriceResponse
     */
    'prices'?: Array<Price200ResponsePrice>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof UnunifiPricefeedQueryAllPriceResponse
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedQueryAllRawPriceResponse
 */
export interface UnunifiPricefeedQueryAllRawPriceResponse {
    /**
     * 
     * @type {Array<RawPriceAll200ResponsePricesInner>}
     * @memberof UnunifiPricefeedQueryAllRawPriceResponse
     */
    'prices'?: Array<RawPriceAll200ResponsePricesInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof UnunifiPricefeedQueryAllRawPriceResponse
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedQueryGetPriceResponse
 */
export interface UnunifiPricefeedQueryGetPriceResponse {
    /**
     * 
     * @type {Price200ResponsePrice}
     * @memberof UnunifiPricefeedQueryGetPriceResponse
     */
    'price'?: Price200ResponsePrice;
}
/**
 * 
 * @export
 * @interface UnunifiPricefeedQueryParamsResponse
 */
export interface UnunifiPricefeedQueryParamsResponse {
    /**
     * 
     * @type {PricefeedParams200ResponseParams}
     * @memberof UnunifiPricefeedQueryParamsResponse
     */
    'params'?: PricefeedParams200ResponseParams;
}
/**
 * Params defines the parameters for the module.
 * @export
 * @interface UnunifiYieldaggregatorParams
 */
export interface UnunifiYieldaggregatorParams {
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorParams
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiYieldaggregatorParams
     */
    'vault_creation_fee'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiYieldaggregatorParams
     */
    'vault_creation_deposit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorQueryAllStrategyResponse
 */
export interface UnunifiYieldaggregatorQueryAllStrategyResponse {
    /**
     * 
     * @type {Array<StrategyAll200ResponseStrategiesInner>}
     * @memberof UnunifiYieldaggregatorQueryAllStrategyResponse
     */
    'strategies'?: Array<StrategyAll200ResponseStrategiesInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof UnunifiYieldaggregatorQueryAllStrategyResponse
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorQueryAllVaultResponse
 */
export interface UnunifiYieldaggregatorQueryAllVaultResponse {
    /**
     * 
     * @type {Array<VaultAll200ResponseVaultsInner>}
     * @memberof UnunifiYieldaggregatorQueryAllVaultResponse
     */
    'vaults'?: Array<VaultAll200ResponseVaultsInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof UnunifiYieldaggregatorQueryAllVaultResponse
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorQueryEstimateMintAmountResponse
 */
export interface UnunifiYieldaggregatorQueryEstimateMintAmountResponse {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiYieldaggregatorQueryEstimateMintAmountResponse
     */
    'mint_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
 */
export interface UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse {
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiYieldaggregatorQueryEstimateRedeemAmountResponse
     */
    'redeem_amount'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorQueryGetStrategyResponse
 */
export interface UnunifiYieldaggregatorQueryGetStrategyResponse {
    /**
     * 
     * @type {StrategyAll200ResponseStrategiesInner}
     * @memberof UnunifiYieldaggregatorQueryGetStrategyResponse
     */
    'strategy'?: StrategyAll200ResponseStrategiesInner;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorQueryGetVaultResponse
 */
export interface UnunifiYieldaggregatorQueryGetVaultResponse {
    /**
     * 
     * @type {VaultAll200ResponseVaultsInner}
     * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
     */
    'vault'?: VaultAll200ResponseVaultsInner;
    /**
     * 
     * @type {Array<StrategyAll200ResponseStrategiesInner>}
     * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
     */
    'strategies'?: Array<StrategyAll200ResponseStrategiesInner>;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
     */
    'vault_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
     */
    'total_bonded_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
     */
    'total_unbonding_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorQueryGetVaultResponse
     */
    'total_withdrawal_balance'?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface UnunifiYieldaggregatorQueryParamsResponse
 */
export interface UnunifiYieldaggregatorQueryParamsResponse {
    /**
     * 
     * @type {YieldAggregatorParams200ResponseParams}
     * @memberof UnunifiYieldaggregatorQueryParamsResponse
     */
    'params'?: YieldAggregatorParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorStrategy
 */
export interface UnunifiYieldaggregatorStrategy {
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorStrategy
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorStrategy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorStrategy
     */
    'contract_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorStrategy
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorStrategy
     */
    'git_url'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorStrategyWeight
 */
export interface UnunifiYieldaggregatorStrategyWeight {
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorStrategyWeight
     */
    'strategy_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorStrategyWeight
     */
    'weight'?: string;
}
/**
 * 
 * @export
 * @interface UnunifiYieldaggregatorVault
 */
export interface UnunifiYieldaggregatorVault {
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorVault
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorVault
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorVault
     */
    'owner'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof UnunifiYieldaggregatorVault
     */
    'owner_deposit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorVault
     */
    'withdraw_commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnunifiYieldaggregatorVault
     */
    'withdraw_reserve_rate'?: string;
    /**
     * 
     * @type {Array<VaultAll200ResponseVaultsInnerStrategyWeightsInner>}
     * @memberof UnunifiYieldaggregatorVault
     */
    'strategy_weights'?: Array<VaultAll200ResponseVaultsInnerStrategyWeightsInner>;
}
/**
 * 
 * @export
 * @interface Vault200Response
 */
export interface Vault200Response {
    /**
     * 
     * @type {VaultAll200ResponseVaultsInner}
     * @memberof Vault200Response
     */
    'vault'?: VaultAll200ResponseVaultsInner;
    /**
     * 
     * @type {Array<StrategyAll200ResponseStrategiesInner>}
     * @memberof Vault200Response
     */
    'strategies'?: Array<StrategyAll200ResponseStrategiesInner>;
    /**
     * 
     * @type {string}
     * @memberof Vault200Response
     */
    'vault_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault200Response
     */
    'total_bonded_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault200Response
     */
    'total_unbonding_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault200Response
     */
    'total_withdrawal_balance'?: string;
}
/**
 * 
 * @export
 * @interface VaultAll200Response
 */
export interface VaultAll200Response {
    /**
     * 
     * @type {Array<VaultAll200ResponseVaultsInner>}
     * @memberof VaultAll200Response
     */
    'vaults'?: Array<VaultAll200ResponseVaultsInner>;
    /**
     * 
     * @type {AllPositions200ResponsePagination}
     * @memberof VaultAll200Response
     */
    'pagination'?: AllPositions200ResponsePagination;
}
/**
 * 
 * @export
 * @interface VaultAll200ResponseVaultsInner
 */
export interface VaultAll200ResponseVaultsInner {
    /**
     * 
     * @type {string}
     * @memberof VaultAll200ResponseVaultsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAll200ResponseVaultsInner
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAll200ResponseVaultsInner
     */
    'owner'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof VaultAll200ResponseVaultsInner
     */
    'owner_deposit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {string}
     * @memberof VaultAll200ResponseVaultsInner
     */
    'withdraw_commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAll200ResponseVaultsInner
     */
    'withdraw_reserve_rate'?: string;
    /**
     * 
     * @type {Array<VaultAll200ResponseVaultsInnerStrategyWeightsInner>}
     * @memberof VaultAll200ResponseVaultsInner
     */
    'strategy_weights'?: Array<VaultAll200ResponseVaultsInnerStrategyWeightsInner>;
}
/**
 * 
 * @export
 * @interface VaultAll200ResponseVaultsInnerStrategyWeightsInner
 */
export interface VaultAll200ResponseVaultsInnerStrategyWeightsInner {
    /**
     * 
     * @type {string}
     * @memberof VaultAll200ResponseVaultsInnerStrategyWeightsInner
     */
    'strategy_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAll200ResponseVaultsInnerStrategyWeightsInner
     */
    'weight'?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface YieldAggregatorParams200Response
 */
export interface YieldAggregatorParams200Response {
    /**
     * 
     * @type {YieldAggregatorParams200ResponseParams}
     * @memberof YieldAggregatorParams200Response
     */
    'params'?: YieldAggregatorParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface YieldAggregatorParams200ResponseParams
 */
export interface YieldAggregatorParams200ResponseParams {
    /**
     * 
     * @type {string}
     * @memberof YieldAggregatorParams200ResponseParams
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof YieldAggregatorParams200ResponseParams
     */
    'vault_creation_fee'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
    /**
     * 
     * @type {EstimateDLPTokenAmount200ResponseEstimatedDlpAmount}
     * @memberof YieldAggregatorParams200ResponseParams
     */
    'vault_creation_deposit'?: EstimateDLPTokenAmount200ResponseEstimatedDlpAmount;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressPositions: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressPositions', 'address', address)
            const localVarPath = `/ununifi/derivatives/{address}/positions`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allPositions: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allRewards: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('allRewards', 'address', address)
            const localVarPath = `/ununifi/ecosystemincentive/rewards/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} denom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssetInPoolByDenom: async (denom: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('availableAssetInPoolByDenom', 'denom', denom)
            const localVarPath = `/ununifi/derivatives/pools/available-asset/{denom}`
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssetsInPool: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/pools/available-assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        belongingRecipientContainerIdsByAddr: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('belongingRecipientContainerIdsByAddr', 'address', address)
            const localVarPath = `/ununifi/ecosystemincentive/belonging-recipient-containers/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bidder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bidderBids: async (bidder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bidder' is not null or undefined
            assertParamExists('bidderBids', 'bidder', bidder)
            const localVarPath = `/ununifi/nftbackedloan/bidder_bids/{bidder}`
                .replace(`{${"bidder"}}`, encodeURIComponent(String(bidder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cDPsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/nftbackedloan/cdps_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classAttributes: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('classAttributes', 'classId', classId)
            const localVarPath = `/ununifi/nftfactory/class_owner/{class_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} className 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classIdsByName: async (className: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'className' is not null or undefined
            assertParamExists('classIdsByName', 'className', className)
            const localVarPath = `/ununifi/nftfactory/class_ids_by_name/{class_name}`
                .replace(`{${"class_name"}}`, encodeURIComponent(String(className)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classIdsByOwner: async (owner: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('classIdsByOwner', 'owner', owner)
            const localVarPath = `/ununifi/nftfactory/class_ids_by_owner/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dLPTokenRates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/pools/dlp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ecosystemIncentiveParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/ecosystemincentive/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mintDenom 
         * @param {string} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateDLPTokenAmount: async (mintDenom: string, amount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintDenom' is not null or undefined
            assertParamExists('estimateDLPTokenAmount', 'mintDenom', mintDenom)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('estimateDLPTokenAmount', 'amount', amount)
            const localVarPath = `/ununifi/derivatives/estimate-dlp-token-amount/{mint_denom}/{amount}`
                .replace(`{${"mint_denom"}}`, encodeURIComponent(String(mintDenom)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [depositAmount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateMintAmount: async (id: string, depositAmount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('estimateMintAmount', 'id', id)
            const localVarPath = `/ununifi/yieldaggregator/vaults/{id}/estimate-mint-amount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (depositAmount !== undefined) {
                localVarQueryParameter['deposit_amount'] = depositAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [burnAmount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRedeemAmount: async (id: string, burnAmount?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('estimateRedeemAmount', 'id', id)
            const localVarPath = `/ununifi/yieldaggregator/vaults/{id}/estimate-redeem-amount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (burnAmount !== undefined) {
                localVarQueryParameter['burn_amount'] = burnAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redeemDenom 
         * @param {string} lptAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRedeemTokenAmount: async (redeemDenom: string, lptAmount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redeemDenom' is not null or undefined
            assertParamExists('estimateRedeemTokenAmount', 'redeemDenom', redeemDenom)
            // verify required parameter 'lptAmount' is not null or undefined
            assertParamExists('estimateRedeemTokenAmount', 'lptAmount', lptAmount)
            const localVarPath = `/ununifi/derivatives/estimate-redeem-amount/{redeem_denom}/{lpt_amount}`
                .replace(`{${"redeem_denom"}}`, encodeURIComponent(String(redeemDenom)))
                .replace(`{${"lpt_amount"}}`, encodeURIComponent(String(lptAmount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidation: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('liquidation', 'classId', classId)
            // verify required parameter 'nftId' is not null or undefined
            assertParamExists('liquidation', 'nftId', nftId)
            const localVarPath = `/ununifi/nftbackedloan/liquidation/{class_id}/{nft_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_id"}}`, encodeURIComponent(String(nftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [beforeHeight] 
         * @param {string} [afterHeight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviderTokenNominalAPY: async (beforeHeight?: string, afterHeight?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/liquidity-providers/nominal-apy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (beforeHeight !== undefined) {
                localVarQueryParameter['before_height'] = beforeHeight;
            }

            if (afterHeight !== undefined) {
                localVarQueryParameter['after_height'] = afterHeight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [beforeHeight] 
         * @param {string} [afterHeight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviderTokenRealAPY: async (beforeHeight?: string, afterHeight?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/liquidity-providers/real-apy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (beforeHeight !== undefined) {
                localVarQueryParameter['before_height'] = beforeHeight;
            }

            if (afterHeight !== undefined) {
                localVarQueryParameter['after_height'] = afterHeight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {number} nftLimit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listedClass: async (classId: string, nftLimit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('listedClass', 'classId', classId)
            // verify required parameter 'nftLimit' is not null or undefined
            assertParamExists('listedClass', 'nftLimit', nftLimit)
            const localVarPath = `/ununifi/nftbackedloan/listed_class/{class_id}/{nft_limit}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_limit"}}`, encodeURIComponent(String(nftLimit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [nftLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listedClasses: async (nftLimit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/nftbackedloan/listed_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nftLimit !== undefined) {
                localVarQueryParameter['nft_limit'] = nftLimit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listedNfts: async (owner?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/nftbackedloan/listed_nfts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loan: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('loan', 'classId', classId)
            // verify required parameter 'nftId' is not null or undefined
            assertParamExists('loan', 'nftId', nftId)
            const localVarPath = `/ununifi/nftbackedloan/loans/{class_id}/{nft_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_id"}}`, encodeURIComponent(String(nftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loans: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/nftbackedloan/loans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/pricefeed/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFTMinter: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('nFTMinter', 'classId', classId)
            // verify required parameter 'nftId' is not null or undefined
            assertParamExists('nFTMinter', 'nftId', nftId)
            const localVarPath = `/ununifi/nftfactory/nft_minter/{class_id}/{nft_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_id"}}`, encodeURIComponent(String(nftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftBackedLoanParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/nftbackedloan/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftBids: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('nftBids', 'classId', classId)
            // verify required parameter 'nftId' is not null or undefined
            assertParamExists('nftBids', 'nftId', nftId)
            const localVarPath = `/ununifi/nftbackedloan/nft_bids/{class_id}/{nft_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_id"}}`, encodeURIComponent(String(nftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftFactoryParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/nftfactory/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftListing: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('nftListing', 'classId', classId)
            // verify required parameter 'nftId' is not null or undefined
            assertParamExists('nftListing', 'nftId', nftId)
            const localVarPath = `/ununifi/nftbackedloan/nft_listing/{class_id}/{nft_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_id"}}`, encodeURIComponent(String(nftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oracleAll: async (marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('oracleAll', 'marketId', marketId)
            const localVarPath = `/ununifi/pricefeed/markets/{market_id}/oracles`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {string} bidder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentStatus: async (classId: string, nftId: string, bidder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('paymentStatus', 'classId', classId)
            // verify required parameter 'nftId' is not null or undefined
            assertParamExists('paymentStatus', 'nftId', nftId)
            // verify required parameter 'bidder' is not null or undefined
            assertParamExists('paymentStatus', 'bidder', bidder)
            const localVarPath = `/ununifi/nftbackedloan/payment_status/{class_id}/{nft_id}/{bidder}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_id"}}`, encodeURIComponent(String(nftId)))
                .replace(`{${"bidder"}}`, encodeURIComponent(String(bidder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualFutures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/perpetual-futures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} baseDenom 
         * @param {string} quoteDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualFuturesMarket: async (baseDenom: string, quoteDenom: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseDenom' is not null or undefined
            assertParamExists('perpetualFuturesMarket', 'baseDenom', baseDenom)
            // verify required parameter 'quoteDenom' is not null or undefined
            assertParamExists('perpetualFuturesMarket', 'quoteDenom', quoteDenom)
            const localVarPath = `/ununifi/derivatives/perpetual-futures/{base_denom}/{quote_denom}`
                .replace(`{${"base_denom"}}`, encodeURIComponent(String(baseDenom)))
                .replace(`{${"quote_denom"}}`, encodeURIComponent(String(quoteDenom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'POSITION_UNKNOWN' | 'LONG' | 'SHORT'} positionType 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualFuturesPositionSize: async (positionType: 'POSITION_UNKNOWN' | 'LONG' | 'SHORT', address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionType' is not null or undefined
            assertParamExists('perpetualFuturesPositionSize', 'positionType', positionType)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('perpetualFuturesPositionSize', 'address', address)
            const localVarPath = `/ununifi/derivatives/positions/perpetual-futures/{position_type}/{address}`
                .replace(`{${"position_type"}}`, encodeURIComponent(String(positionType)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/perpetual-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} baseDenom 
         * @param {string} quoteDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualOptionsMarket: async (baseDenom: string, quoteDenom: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseDenom' is not null or undefined
            assertParamExists('perpetualOptionsMarket', 'baseDenom', baseDenom)
            // verify required parameter 'quoteDenom' is not null or undefined
            assertParamExists('perpetualOptionsMarket', 'quoteDenom', quoteDenom)
            const localVarPath = `/ununifi/derivatives/perpetual-options/{base_denom}/{quote_denom}`
                .replace(`{${"base_denom"}}`, encodeURIComponent(String(baseDenom)))
                .replace(`{${"quote_denom"}}`, encodeURIComponent(String(quoteDenom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/derivatives/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} positionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        position: async (positionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionId' is not null or undefined
            assertParamExists('position', 'positionId', positionId)
            const localVarPath = `/ununifi/derivatives/positions/{position_id}`
                .replace(`{${"position_id"}}`, encodeURIComponent(String(positionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price: async (marketId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('price', 'marketId', marketId)
            const localVarPath = `/ununifi/pricefeed/markets/{market_id}/price`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/pricefeed/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricefeedParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/pricefeed/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawPriceAll: async (marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('rawPriceAll', 'marketId', marketId)
            const localVarPath = `/ununifi/pricefeed/markets/{market_id}/raw_prices`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipientContainer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recipientContainer', 'id', id)
            const localVarPath = `/ununifi/ecosystemincentive/recipient-containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordedRecipientContainerId: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('recordedRecipientContainerId', 'classId', classId)
            // verify required parameter 'nftId' is not null or undefined
            assertParamExists('recordedRecipientContainerId', 'nftId', nftId)
            const localVarPath = `/ununifi/ecosystemincentive/recorded-recipient-containers/{class_id}/{nft_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"nft_id"}}`, encodeURIComponent(String(nftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {string} denom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reward: async (address: string, denom: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('reward', 'address', address)
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('reward', 'denom', denom)
            const localVarPath = `/ununifi/ecosystemincentive/rewards/{address}/{denom}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewards: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('rewards', 'address', address)
            const localVarPath = `/ununifi/nftbackedloan/rewards/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [denom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        strategy: async (id: string, denom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('strategy', 'id', id)
            const localVarPath = `/ununifi/yieldaggregator/strategies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (denom !== undefined) {
                localVarQueryParameter['denom'] = denom;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [denom] 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        strategyAll: async (denom?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/yieldaggregator/strategies/query-param`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (denom !== undefined) {
                localVarQueryParameter['denom'] = denom;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vault', 'id', id)
            const localVarPath = `/ununifi/yieldaggregator/vaults/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/yieldaggregator/vaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yieldAggregatorParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ununifi/yieldaggregator/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressPositions(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressPositions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressPositions(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allPositions(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllPositions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allPositions(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allRewards(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllRewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allRewards(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} denom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableAssetInPoolByDenom(denom: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableAssetInPoolByDenom200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableAssetInPoolByDenom(denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableAssetsInPool(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableAssetsInPool200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableAssetsInPool(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async belongingRecipientContainerIdsByAddr(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BelongingRecipientContainerIdsByAddr200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.belongingRecipientContainerIdsByAddr(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bidder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bidderBids(bidder: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidderBids200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bidderBids(bidder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cDPsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cDPsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classAttributes(classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassAttributes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classAttributes(classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} className 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classIdsByName(className: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassIdsByName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classIdsByName(className, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} owner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classIdsByOwner(owner: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassIdsByOwner200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classIdsByOwner(owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dLPTokenRates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DLPTokenRates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dLPTokenRates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async derivativesParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DerivativesParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.derivativesParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ecosystemIncentiveParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EcosystemIncentiveParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ecosystemIncentiveParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} mintDenom 
         * @param {string} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateDLPTokenAmount(mintDenom: string, amount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateDLPTokenAmount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateDLPTokenAmount(mintDenom, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [depositAmount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateMintAmount(id: string, depositAmount?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateMintAmount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateMintAmount(id, depositAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [burnAmount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateRedeemAmount(id: string, burnAmount?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateRedeemAmount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateRedeemAmount(id, burnAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} redeemDenom 
         * @param {string} lptAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateRedeemTokenAmount(redeemDenom: string, lptAmount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateRedeemTokenAmount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateRedeemTokenAmount(redeemDenom, lptAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidation(classId: string, nftId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Liquidation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidation(classId, nftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [beforeHeight] 
         * @param {string} [afterHeight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProviderTokenNominalAPY(beforeHeight?: string, afterHeight?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProviderTokenNominalAPY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProviderTokenNominalAPY(beforeHeight, afterHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [beforeHeight] 
         * @param {string} [afterHeight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProviderTokenRealAPY(beforeHeight?: string, afterHeight?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProviderTokenNominalAPY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProviderTokenRealAPY(beforeHeight, afterHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {number} nftLimit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listedClass(classId: string, nftLimit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedClass200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listedClass(classId, nftLimit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [nftLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listedClasses(nftLimit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedClasses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listedClasses(nftLimit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listedNfts(owner?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedNfts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listedNfts(owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loan(classId: string, nftId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loan200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loan(classId, nftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loans(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loans200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loans(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nFTMinter(classId: string, nftId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NFTMinter200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nFTMinter(classId, nftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftBackedLoanParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftBackedLoanParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftBackedLoanParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftBids(classId: string, nftId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidderBids200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftBids(classId, nftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftFactoryParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftFactoryParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftFactoryParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftListing(classId: string, nftId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftListing200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftListing(classId, nftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OracleAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {string} bidder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentStatus(classId: string, nftId: string, bidder: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentStatus(classId, nftId, bidder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async perpetualFutures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerpetualFutures200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualFutures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} baseDenom 
         * @param {string} quoteDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async perpetualFuturesMarket(baseDenom: string, quoteDenom: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerpetualFuturesMarket200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualFuturesMarket(baseDenom, quoteDenom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'POSITION_UNKNOWN' | 'LONG' | 'SHORT'} positionType 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async perpetualFuturesPositionSize(positionType: 'POSITION_UNKNOWN' | 'LONG' | 'SHORT', address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerpetualFuturesPositionSize200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualFuturesPositionSize(positionType, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async perpetualOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} baseDenom 
         * @param {string} quoteDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async perpetualOptionsMarket(baseDenom: string, quoteDenom: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.perpetualOptionsMarket(baseDenom, quoteDenom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pool(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pool(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} positionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async position(positionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.position(positionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async price(marketId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.price(marketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricefeedParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricefeedParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricefeedParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawPriceAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recipientContainer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipientContainer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recipientContainer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordedRecipientContainerId(classId: string, nftId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordedRecipientContainerId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordedRecipientContainerId(classId, nftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {string} denom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reward(address: string, denom: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reward200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reward(address, denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewards(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewards(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [denom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async strategy(id: string, denom?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Strategy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.strategy(id, denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [denom] 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async strategyAll(denom?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.strategyAll(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vault(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vault(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vaultAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vaultAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async yieldAggregatorParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<YieldAggregatorParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.yieldAggregatorParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressPositions(address: string, options?: any): AxiosPromise<AddressPositions200Response> {
            return localVarFp.addressPositions(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allPositions(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<AllPositions200Response> {
            return localVarFp.allPositions(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allRewards(address: string, options?: any): AxiosPromise<AllRewards200Response> {
            return localVarFp.allRewards(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} denom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssetInPoolByDenom(denom: string, options?: any): AxiosPromise<AvailableAssetInPoolByDenom200Response> {
            return localVarFp.availableAssetInPoolByDenom(denom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssetsInPool(options?: any): AxiosPromise<AvailableAssetsInPool200Response> {
            return localVarFp.availableAssetsInPool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        belongingRecipientContainerIdsByAddr(address: string, options?: any): AxiosPromise<BelongingRecipientContainerIdsByAddr200Response> {
            return localVarFp.belongingRecipientContainerIdsByAddr(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bidder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bidderBids(bidder: string, options?: any): AxiosPromise<BidderBids200Response> {
            return localVarFp.bidderBids(bidder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cDPsList(options?: any): AxiosPromise<object> {
            return localVarFp.cDPsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classAttributes(classId: string, options?: any): AxiosPromise<ClassAttributes200Response> {
            return localVarFp.classAttributes(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} className 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classIdsByName(className: string, options?: any): AxiosPromise<ClassIdsByName200Response> {
            return localVarFp.classIdsByName(className, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} owner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classIdsByOwner(owner: string, options?: any): AxiosPromise<ClassIdsByOwner200Response> {
            return localVarFp.classIdsByOwner(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dLPTokenRates(options?: any): AxiosPromise<DLPTokenRates200Response> {
            return localVarFp.dLPTokenRates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesParams(options?: any): AxiosPromise<DerivativesParams200Response> {
            return localVarFp.derivativesParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ecosystemIncentiveParams(options?: any): AxiosPromise<EcosystemIncentiveParams200Response> {
            return localVarFp.ecosystemIncentiveParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} mintDenom 
         * @param {string} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateDLPTokenAmount(mintDenom: string, amount: string, options?: any): AxiosPromise<EstimateDLPTokenAmount200Response> {
            return localVarFp.estimateDLPTokenAmount(mintDenom, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [depositAmount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateMintAmount(id: string, depositAmount?: string, options?: any): AxiosPromise<EstimateMintAmount200Response> {
            return localVarFp.estimateMintAmount(id, depositAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [burnAmount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRedeemAmount(id: string, burnAmount?: string, options?: any): AxiosPromise<EstimateRedeemAmount200Response> {
            return localVarFp.estimateRedeemAmount(id, burnAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redeemDenom 
         * @param {string} lptAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRedeemTokenAmount(redeemDenom: string, lptAmount: string, options?: any): AxiosPromise<EstimateRedeemTokenAmount200Response> {
            return localVarFp.estimateRedeemTokenAmount(redeemDenom, lptAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidation(classId: string, nftId: string, options?: any): AxiosPromise<Liquidation200Response> {
            return localVarFp.liquidation(classId, nftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [beforeHeight] 
         * @param {string} [afterHeight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviderTokenNominalAPY(beforeHeight?: string, afterHeight?: string, options?: any): AxiosPromise<LiquidityProviderTokenNominalAPY200Response> {
            return localVarFp.liquidityProviderTokenNominalAPY(beforeHeight, afterHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [beforeHeight] 
         * @param {string} [afterHeight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviderTokenRealAPY(beforeHeight?: string, afterHeight?: string, options?: any): AxiosPromise<LiquidityProviderTokenNominalAPY200Response> {
            return localVarFp.liquidityProviderTokenRealAPY(beforeHeight, afterHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {number} nftLimit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listedClass(classId: string, nftLimit: number, options?: any): AxiosPromise<ListedClass200Response> {
            return localVarFp.listedClass(classId, nftLimit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [nftLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listedClasses(nftLimit?: number, options?: any): AxiosPromise<ListedClasses200Response> {
            return localVarFp.listedClasses(nftLimit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listedNfts(owner?: string, options?: any): AxiosPromise<ListedNfts200Response> {
            return localVarFp.listedNfts(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loan(classId: string, nftId: string, options?: any): AxiosPromise<Loan200Response> {
            return localVarFp.loan(classId, nftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loans(options?: any): AxiosPromise<Loans200Response> {
            return localVarFp.loans(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<MarketAll200Response> {
            return localVarFp.marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFTMinter(classId: string, nftId: string, options?: any): AxiosPromise<NFTMinter200Response> {
            return localVarFp.nFTMinter(classId, nftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftBackedLoanParams(options?: any): AxiosPromise<NftBackedLoanParams200Response> {
            return localVarFp.nftBackedLoanParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftBids(classId: string, nftId: string, options?: any): AxiosPromise<BidderBids200Response> {
            return localVarFp.nftBids(classId, nftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftFactoryParams(options?: any): AxiosPromise<NftFactoryParams200Response> {
            return localVarFp.nftFactoryParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftListing(classId: string, nftId: string, options?: any): AxiosPromise<NftListing200Response> {
            return localVarFp.nftListing(classId, nftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<OracleAll200Response> {
            return localVarFp.oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {string} bidder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentStatus(classId: string, nftId: string, bidder: string, options?: any): AxiosPromise<PaymentStatus200Response> {
            return localVarFp.paymentStatus(classId, nftId, bidder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualFutures(options?: any): AxiosPromise<PerpetualFutures200Response> {
            return localVarFp.perpetualFutures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} baseDenom 
         * @param {string} quoteDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualFuturesMarket(baseDenom: string, quoteDenom: string, options?: any): AxiosPromise<PerpetualFuturesMarket200Response> {
            return localVarFp.perpetualFuturesMarket(baseDenom, quoteDenom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'POSITION_UNKNOWN' | 'LONG' | 'SHORT'} positionType 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualFuturesPositionSize(positionType: 'POSITION_UNKNOWN' | 'LONG' | 'SHORT', address: string, options?: any): AxiosPromise<PerpetualFuturesPositionSize200Response> {
            return localVarFp.perpetualFuturesPositionSize(positionType, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualOptions(options?: any): AxiosPromise<object> {
            return localVarFp.perpetualOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} baseDenom 
         * @param {string} quoteDenom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perpetualOptionsMarket(baseDenom: string, quoteDenom: string, options?: any): AxiosPromise<object> {
            return localVarFp.perpetualOptionsMarket(baseDenom, quoteDenom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(options?: any): AxiosPromise<Pool200Response> {
            return localVarFp.pool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} positionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        position(positionId: string, options?: any): AxiosPromise<Position200Response> {
            return localVarFp.position(positionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price(marketId: string, options?: any): AxiosPromise<Price200Response> {
            return localVarFp.price(marketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<PriceAll200Response> {
            return localVarFp.priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricefeedParams(options?: any): AxiosPromise<PricefeedParams200Response> {
            return localVarFp.pricefeedParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<RawPriceAll200Response> {
            return localVarFp.rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipientContainer(id: string, options?: any): AxiosPromise<RecipientContainer200Response> {
            return localVarFp.recipientContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} classId 
         * @param {string} nftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordedRecipientContainerId(classId: string, nftId: string, options?: any): AxiosPromise<RecordedRecipientContainerId200Response> {
            return localVarFp.recordedRecipientContainerId(classId, nftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {string} denom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reward(address: string, denom: string, options?: any): AxiosPromise<Reward200Response> {
            return localVarFp.reward(address, denom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewards(address: string, options?: any): AxiosPromise<Rewards200Response> {
            return localVarFp.rewards(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [denom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        strategy(id: string, denom?: string, options?: any): AxiosPromise<Strategy200Response> {
            return localVarFp.strategy(id, denom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [denom] 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        strategyAll(denom?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<StrategyAll200Response> {
            return localVarFp.strategyAll(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault(id: string, options?: any): AxiosPromise<Vault200Response> {
            return localVarFp.vault(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<VaultAll200Response> {
            return localVarFp.vaultAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parameters queries the parameters of the module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yieldAggregatorParams(options?: any): AxiosPromise<YieldAggregatorParams200Response> {
            return localVarFp.yieldAggregatorParams(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public addressPositions(address: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).addressPositions(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allPositions(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).allPositions(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allRewards(address: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).allRewards(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} denom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public availableAssetInPoolByDenom(denom: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).availableAssetInPoolByDenom(denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public availableAssetsInPool(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).availableAssetsInPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public belongingRecipientContainerIdsByAddr(address: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).belongingRecipientContainerIdsByAddr(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bidder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public bidderBids(bidder: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).bidderBids(bidder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public cDPsList(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).cDPsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public classAttributes(classId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).classAttributes(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} className 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public classIdsByName(className: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).classIdsByName(className, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} owner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public classIdsByOwner(owner: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).classIdsByOwner(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public dLPTokenRates(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).dLPTokenRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public derivativesParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).derivativesParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public ecosystemIncentiveParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).ecosystemIncentiveParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} mintDenom 
     * @param {string} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public estimateDLPTokenAmount(mintDenom: string, amount: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).estimateDLPTokenAmount(mintDenom, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [depositAmount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public estimateMintAmount(id: string, depositAmount?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).estimateMintAmount(id, depositAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [burnAmount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public estimateRedeemAmount(id: string, burnAmount?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).estimateRedeemAmount(id, burnAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redeemDenom 
     * @param {string} lptAmount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public estimateRedeemTokenAmount(redeemDenom: string, lptAmount: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).estimateRedeemTokenAmount(redeemDenom, lptAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {string} nftId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidation(classId: string, nftId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).liquidation(classId, nftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [beforeHeight] 
     * @param {string} [afterHeight] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityProviderTokenNominalAPY(beforeHeight?: string, afterHeight?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).liquidityProviderTokenNominalAPY(beforeHeight, afterHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [beforeHeight] 
     * @param {string} [afterHeight] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public liquidityProviderTokenRealAPY(beforeHeight?: string, afterHeight?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).liquidityProviderTokenRealAPY(beforeHeight, afterHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {number} nftLimit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public listedClass(classId: string, nftLimit: number, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).listedClass(classId, nftLimit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [nftLimit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public listedClasses(nftLimit?: number, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).listedClasses(nftLimit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public listedNfts(owner?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).listedNfts(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {string} nftId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public loan(classId: string, nftId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).loan(classId, nftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public loans(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).loans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {string} nftId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nFTMinter(classId: string, nftId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nFTMinter(classId, nftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nftBackedLoanParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nftBackedLoanParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {string} nftId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nftBids(classId: string, nftId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nftBids(classId, nftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nftFactoryParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nftFactoryParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {string} nftId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nftListing(classId: string, nftId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nftListing(classId, nftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {string} nftId 
     * @param {string} bidder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public paymentStatus(classId: string, nftId: string, bidder: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).paymentStatus(classId, nftId, bidder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public perpetualFutures(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).perpetualFutures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} baseDenom 
     * @param {string} quoteDenom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public perpetualFuturesMarket(baseDenom: string, quoteDenom: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).perpetualFuturesMarket(baseDenom, quoteDenom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'POSITION_UNKNOWN' | 'LONG' | 'SHORT'} positionType 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public perpetualFuturesPositionSize(positionType: 'POSITION_UNKNOWN' | 'LONG' | 'SHORT', address: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).perpetualFuturesPositionSize(positionType, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public perpetualOptions(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).perpetualOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} baseDenom 
     * @param {string} quoteDenom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public perpetualOptionsMarket(baseDenom: string, quoteDenom: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).perpetualOptionsMarket(baseDenom, quoteDenom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public pool(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).pool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} positionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public position(positionId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).position(positionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public price(marketId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).price(marketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public pricefeedParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).pricefeedParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public recipientContainer(id: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).recipientContainer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} classId 
     * @param {string} nftId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public recordedRecipientContainerId(classId: string, nftId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).recordedRecipientContainerId(classId, nftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {string} denom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public reward(address: string, denom: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).reward(address, denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public rewards(address: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).rewards(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [denom] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public strategy(id: string, denom?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).strategy(id, denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [denom] 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public strategyAll(denom?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).strategyAll(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public vault(id: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).vault(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public vaultAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).vaultAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public yieldAggregatorParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).yieldAggregatorParams(options).then((request) => request(this.axios, this.basePath));
    }
}


