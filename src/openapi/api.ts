/* tslint:disable */
/* eslint-disable */
/**
 * UnUniFi - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AccountAll200Response
 */
export interface AccountAll200Response {
  /**
   *
   * @type {Array<AuctionAll200ResponseAuctionsInner>}
   * @memberof AccountAll200Response
   */
  accounts?: Array<AuctionAll200ResponseAuctionsInner>;
}
/**
 *
 * @export
 * @interface AllRewards200Response
 */
export interface AllRewards200Response {
  /**
   *
   * @type {AllRewards200ResponseRewards}
   * @memberof AllRewards200Response
   */
  rewards?: AllRewards200ResponseRewards;
}
/**
 *
 * @export
 * @interface AllRewards200ResponseRewards
 */
export interface AllRewards200ResponseRewards {
  /**
   *
   * @type {string}
   * @memberof AllRewards200ResponseRewards
   */
  subject_addr?: string;
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInnerCdpCollateral>}
   * @memberof AllRewards200ResponseRewards
   */
  rewards?: Array<CdpAll200ResponseCdpInnerCdpCollateral>;
}
/**
 *
 * @export
 * @interface Auction200Response
 */
export interface Auction200Response {
  /**
   *
   * @type {AuctionAll200ResponseAuctionsInner}
   * @memberof Auction200Response
   */
  auction?: AuctionAll200ResponseAuctionsInner;
}
/**
 *
 * @export
 * @interface AuctionAll200Response
 */
export interface AuctionAll200Response {
  /**
   *
   * @type {Array<AuctionAll200ResponseAuctionsInner>}
   * @memberof AuctionAll200Response
   */
  auctions?: Array<AuctionAll200ResponseAuctionsInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof AuctionAll200Response
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface AuctionAll200ResponseAuctionsInner
 */
export interface AuctionAll200ResponseAuctionsInner {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof AuctionAll200ResponseAuctionsInner
   */
  type_url?: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   * @type {string}
   * @memberof AuctionAll200ResponseAuctionsInner
   */
  value?: string;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface AuctionAll200ResponsePagination
 */
export interface AuctionAll200ResponsePagination {
  /**
   *
   * @type {string}
   * @memberof AuctionAll200ResponsePagination
   */
  next_key?: string;
  /**
   *
   * @type {string}
   * @memberof AuctionAll200ResponsePagination
   */
  total?: string;
}
/**
 *
 * @export
 * @interface AuctionAllDefaultResponse
 */
export interface AuctionAllDefaultResponse {
  /**
   *
   * @type {string}
   * @memberof AuctionAllDefaultResponse
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof AuctionAllDefaultResponse
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof AuctionAllDefaultResponse
   */
  message?: string;
  /**
   *
   * @type {Array<AuctionAll200ResponseAuctionsInner>}
   * @memberof AuctionAllDefaultResponse
   */
  details?: Array<AuctionAll200ResponseAuctionsInner>;
}
/**
 *
 * @export
 * @interface AuctionParams200Response
 */
export interface AuctionParams200Response {
  /**
   *
   * @type {AuctionParams200ResponseParams}
   * @memberof AuctionParams200Response
   */
  params?: AuctionParams200ResponseParams;
}
/**
 *
 * @export
 * @interface AuctionParams200ResponseParams
 */
export interface AuctionParams200ResponseParams {
  /**
   *
   * @type {string}
   * @memberof AuctionParams200ResponseParams
   */
  max_auction_duration?: string;
  /**
   *
   * @type {string}
   * @memberof AuctionParams200ResponseParams
   */
  bid_duration?: string;
  /**
   *
   * @type {string}
   * @memberof AuctionParams200ResponseParams
   */
  increment_surplus?: string;
  /**
   *
   * @type {string}
   * @memberof AuctionParams200ResponseParams
   */
  increment_debt?: string;
  /**
   *
   * @type {string}
   * @memberof AuctionParams200ResponseParams
   */
  increment_collateral?: string;
}
/**
 *
 * @export
 * @interface Balances200Response
 */
export interface Balances200Response {
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInnerCdpCollateral>}
   * @memberof Balances200Response
   */
  balances?: Array<CdpAll200ResponseCdpInnerCdpCollateral>;
}
/**
 *
 * @export
 * @interface BidderBids200Response
 */
export interface BidderBids200Response {
  /**
   *
   * @type {Array<BidderBids200ResponseBidsInner>}
   * @memberof BidderBids200Response
   */
  bids?: Array<BidderBids200ResponseBidsInner>;
}
/**
 *
 * @export
 * @interface BidderBids200ResponseBidsInner
 */
export interface BidderBids200ResponseBidsInner {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof BidderBids200ResponseBidsInner
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {string}
   * @memberof BidderBids200ResponseBidsInner
   */
  bidder?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof BidderBids200ResponseBidsInner
   */
  amount?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {boolean}
   * @memberof BidderBids200ResponseBidsInner
   */
  automatic_payment?: boolean;
  /**
   *
   * @type {string}
   * @memberof BidderBids200ResponseBidsInner
   */
  paid_amount?: string;
  /**
   *
   * @type {string}
   * @memberof BidderBids200ResponseBidsInner
   */
  bid_time?: string;
}
/**
 *
 * @export
 * @interface BidderBids200ResponseBidsInnerNftId
 */
export interface BidderBids200ResponseBidsInnerNftId {
  /**
   *
   * @type {string}
   * @memberof BidderBids200ResponseBidsInnerNftId
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof BidderBids200ResponseBidsInnerNftId
   */
  nft_id?: string;
}
/**
 *
 * @export
 * @interface Cdp200Response
 */
export interface Cdp200Response {
  /**
   *
   * @type {CdpAll200ResponseCdpInner}
   * @memberof Cdp200Response
   */
  cdp?: CdpAll200ResponseCdpInner;
}
/**
 *
 * @export
 * @interface CdpAll200Response
 */
export interface CdpAll200Response {
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInner>}
   * @memberof CdpAll200Response
   */
  cdp?: Array<CdpAll200ResponseCdpInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof CdpAll200Response
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface CdpAll200ResponseCdpInner
 */
export interface CdpAll200ResponseCdpInner {
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdp}
   * @memberof CdpAll200ResponseCdpInner
   */
  cdp?: CdpAll200ResponseCdpInnerCdp;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof CdpAll200ResponseCdpInner
   */
  collateral_value?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInner
   */
  collateralization_ratio?: string;
}
/**
 *
 * @export
 * @interface CdpAll200ResponseCdpInnerCdp
 */
export interface CdpAll200ResponseCdpInnerCdp {
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  type?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  collateral?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  principal?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  accumulated_fees?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  fees_updated?: string;
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInnerCdp
   */
  interest_factor?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CdpAll200ResponseCdpInnerCdpCollateral
 */
export interface CdpAll200ResponseCdpInnerCdpCollateral {
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInnerCdpCollateral
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof CdpAll200ResponseCdpInnerCdpCollateral
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface CdpParams200Response
 */
export interface CdpParams200Response {
  /**
   *
   * @type {CdpParams200ResponseParams}
   * @memberof CdpParams200Response
   */
  params?: CdpParams200ResponseParams;
}
/**
 *
 * @export
 * @interface CdpParams200ResponseParams
 */
export interface CdpParams200ResponseParams {
  /**
   *
   * @type {Array<CdpParams200ResponseParamsCollateralParamsInner>}
   * @memberof CdpParams200ResponseParams
   */
  collateral_params?: Array<CdpParams200ResponseParamsCollateralParamsInner>;
  /**
   *
   * @type {Array<CdpParams200ResponseParamsDebtParamsInner>}
   * @memberof CdpParams200ResponseParams
   */
  debt_params?: Array<CdpParams200ResponseParamsDebtParamsInner>;
}
/**
 *
 * @export
 * @interface CdpParams200ResponseParamsCollateralParamsInner
 */
export interface CdpParams200ResponseParamsCollateralParamsInner {
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  liquidation_ratio?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  debt_limit?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  stability_fee?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  auction_size?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  liquidation_penalty?: string;
  /**
   *
   * @type {number}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  prefix?: number;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  spot_market_id?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  liquidation_market_id?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  keeper_reward_percentage?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  check_collateralization_index_count?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsCollateralParamsInner
   */
  conversion_factor?: string;
}
/**
 *
 * @export
 * @interface CdpParams200ResponseParamsDebtParamsInner
 */
export interface CdpParams200ResponseParamsDebtParamsInner {
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  reference_asset?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  conversion_factor?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  debt_floor?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  global_debt_limit?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  debt_denom?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  surplus_auction_threshold?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  surplus_auction_lot?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  debt_auction_threshold?: string;
  /**
   *
   * @type {string}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  debt_auction_lot?: string;
  /**
   *
   * @type {boolean}
   * @memberof CdpParams200ResponseParamsDebtParamsInner
   */
  circuit_breaker?: boolean;
}
/**
 *
 * @export
 * @interface ClassAttributes200Response
 */
export interface ClassAttributes200Response {
  /**
   *
   * @type {ClassAttributes200ResponseClassAttributes}
   * @memberof ClassAttributes200Response
   */
  class_attributes?: ClassAttributes200ResponseClassAttributes;
}
/**
 *
 * @export
 * @interface ClassAttributes200ResponseClassAttributes
 */
export interface ClassAttributes200ResponseClassAttributes {
  /**
   *
   * @type {string}
   * @memberof ClassAttributes200ResponseClassAttributes
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof ClassAttributes200ResponseClassAttributes
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof ClassAttributes200ResponseClassAttributes
   */
  base_token_uri?: string;
  /**
   *
   * @type {string}
   * @memberof ClassAttributes200ResponseClassAttributes
   */
  minting_permission?: ClassAttributes200ResponseClassAttributesMintingPermissionEnum;
  /**
   *
   * @type {string}
   * @memberof ClassAttributes200ResponseClassAttributes
   */
  token_supply_cap?: string;
}

export const ClassAttributes200ResponseClassAttributesMintingPermissionEnum = {
  OnlyOwner: 'OnlyOwner',
  Anyone: 'Anyone',
} as const;

export type ClassAttributes200ResponseClassAttributesMintingPermissionEnum =
  typeof ClassAttributes200ResponseClassAttributesMintingPermissionEnum[keyof typeof ClassAttributes200ResponseClassAttributesMintingPermissionEnum];

/**
 *
 * @export
 * @interface ClassIdsByName200Response
 */
export interface ClassIdsByName200Response {
  /**
   *
   * @type {ClassIdsByName200ResponseClassNameIdList}
   * @memberof ClassIdsByName200Response
   */
  class_name_id_list?: ClassIdsByName200ResponseClassNameIdList;
}
/**
 *
 * @export
 * @interface ClassIdsByName200ResponseClassNameIdList
 */
export interface ClassIdsByName200ResponseClassNameIdList {
  /**
   *
   * @type {string}
   * @memberof ClassIdsByName200ResponseClassNameIdList
   */
  class_name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ClassIdsByName200ResponseClassNameIdList
   */
  class_id?: Array<string>;
}
/**
 *
 * @export
 * @interface ClassIdsByOwner200Response
 */
export interface ClassIdsByOwner200Response {
  /**
   *
   * @type {ClassIdsByOwner200ResponseOwningClassIdList}
   * @memberof ClassIdsByOwner200Response
   */
  owning_class_id_list?: ClassIdsByOwner200ResponseOwningClassIdList;
}
/**
 *
 * @export
 * @interface ClassIdsByOwner200ResponseOwningClassIdList
 */
export interface ClassIdsByOwner200ResponseOwningClassIdList {
  /**
   *
   * @type {string}
   * @memberof ClassIdsByOwner200ResponseOwningClassIdList
   */
  owner?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ClassIdsByOwner200ResponseOwningClassIdList
   */
  class_id?: Array<string>;
}
/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
  /**
   * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  key?: string;
  /**
   * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  offset?: string;
  /**
   * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  limit?: string;
  /**
   * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @type {boolean}
   * @memberof CosmosBaseQueryV1beta1PageRequest
   */
  count_total?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
  /**
   *
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageResponse
   */
  next_key?: string;
  /**
   *
   * @type {string}
   * @memberof CosmosBaseQueryV1beta1PageResponse
   */
  total?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
  /**
   *
   * @type {string}
   * @memberof CosmosBaseV1beta1Coin
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof CosmosBaseV1beta1Coin
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface DepositAll200Response
 */
export interface DepositAll200Response {
  /**
   *
   * @type {Array<DepositAll200ResponseDepositsInner>}
   * @memberof DepositAll200Response
   */
  deposits?: Array<DepositAll200ResponseDepositsInner>;
}
/**
 *
 * @export
 * @interface DepositAll200ResponseDepositsInner
 */
export interface DepositAll200ResponseDepositsInner {
  /**
   *
   * @type {string}
   * @memberof DepositAll200ResponseDepositsInner
   */
  cdp_id?: string;
  /**
   *
   * @type {string}
   * @memberof DepositAll200ResponseDepositsInner
   */
  depositor?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof DepositAll200ResponseDepositsInner
   */
  amount?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface EcosystemincentiveParams200Response
 */
export interface EcosystemincentiveParams200Response {
  /**
   *
   * @type {EcosystemincentiveParams200ResponseParams}
   * @memberof EcosystemincentiveParams200Response
   */
  params?: EcosystemincentiveParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface EcosystemincentiveParams200ResponseParams
 */
export interface EcosystemincentiveParams200ResponseParams {
  /**
   *
   * @type {Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>}
   * @memberof EcosystemincentiveParams200ResponseParams
   */
  reward_params?: Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>;
  /**
   *
   * @type {string}
   * @memberof EcosystemincentiveParams200ResponseParams
   */
  max_incentive_unit_id_len?: string;
  /**
   *
   * @type {string}
   * @memberof EcosystemincentiveParams200ResponseParams
   */
  max_subject_info_num_in_unit?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof GoogleProtobufAny
   */
  type_url?: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   * @type {string}
   * @memberof GoogleProtobufAny
   */
  value?: string;
}
/**
 *
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
  /**
   *
   * @type {string}
   * @memberof GrpcGatewayRuntimeError
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof GrpcGatewayRuntimeError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof GrpcGatewayRuntimeError
   */
  message?: string;
  /**
   *
   * @type {Array<AuctionAll200ResponseAuctionsInner>}
   * @memberof GrpcGatewayRuntimeError
   */
  details?: Array<AuctionAll200ResponseAuctionsInner>;
}
/**
 *
 * @export
 * @interface IncentiveParams200Response
 */
export interface IncentiveParams200Response {
  /**
   *
   * @type {IncentiveParams200ResponseParams}
   * @memberof IncentiveParams200Response
   */
  params?: IncentiveParams200ResponseParams;
}
/**
 *
 * @export
 * @interface IncentiveParams200ResponseParams
 */
export interface IncentiveParams200ResponseParams {
  /**
   *
   * @type {Array<IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner>}
   * @memberof IncentiveParams200ResponseParams
   */
  cdp_minting_reward_periods?: Array<IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner>;
  /**
   *
   * @type {Array<IncentiveParams200ResponseParamsClaimMultipliersInner>}
   * @memberof IncentiveParams200ResponseParams
   */
  claim_multipliers?: Array<IncentiveParams200ResponseParamsClaimMultipliersInner>;
  /**
   *
   * @type {string}
   * @memberof IncentiveParams200ResponseParams
   */
  claim_end?: string;
}
/**
 *
 * @export
 * @interface IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner
 */
export interface IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner {
  /**
   *
   * @type {boolean}
   * @memberof IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner
   */
  collateral_type?: string;
  /**
   *
   * @type {string}
   * @memberof IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner
   */
  start?: string;
  /**
   *
   * @type {string}
   * @memberof IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner
   */
  end?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner
   */
  rewards_per_second?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface IncentiveParams200ResponseParamsClaimMultipliersInner
 */
export interface IncentiveParams200ResponseParamsClaimMultipliersInner {
  /**
   *
   * @type {string}
   * @memberof IncentiveParams200ResponseParamsClaimMultipliersInner
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof IncentiveParams200ResponseParamsClaimMultipliersInner
   */
  months_lockup?: string;
  /**
   *
   * @type {string}
   * @memberof IncentiveParams200ResponseParamsClaimMultipliersInner
   */
  factor?: string;
}
/**
 *
 * @export
 * @interface IncentiveParamsDefaultResponse
 */
export interface IncentiveParamsDefaultResponse {
  /**
   *
   * @type {string}
   * @memberof IncentiveParamsDefaultResponse
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof IncentiveParamsDefaultResponse
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof IncentiveParamsDefaultResponse
   */
  message?: string;
  /**
   *
   * @type {Array<IncentiveParamsDefaultResponseDetailsInner>}
   * @memberof IncentiveParamsDefaultResponse
   */
  details?: Array<IncentiveParamsDefaultResponseDetailsInner>;
}
/**
 *
 * @export
 * @interface IncentiveParamsDefaultResponseDetailsInner
 */
export interface IncentiveParamsDefaultResponseDetailsInner {
  /**
   *
   * @type {string}
   * @memberof IncentiveParamsDefaultResponseDetailsInner
   */
  type_url?: string;
  /**
   *
   * @type {string}
   * @memberof IncentiveParamsDefaultResponseDetailsInner
   */
  value?: string;
}
/**
 *
 * @export
 * @interface IncentiveUnit200Response
 */
export interface IncentiveUnit200Response {
  /**
   *
   * @type {IncentiveUnit200ResponseIncentiveUnit}
   * @memberof IncentiveUnit200Response
   */
  incentive_unit?: IncentiveUnit200ResponseIncentiveUnit;
}
/**
 *
 * @export
 * @interface IncentiveUnit200ResponseIncentiveUnit
 */
export interface IncentiveUnit200ResponseIncentiveUnit {
  /**
   *
   * @type {string}
   * @memberof IncentiveUnit200ResponseIncentiveUnit
   */
  id?: string;
  /**
   *
   * @type {Array<IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner>}
   * @memberof IncentiveUnit200ResponseIncentiveUnit
   */
  subject_info_lists?: Array<IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner>;
}
/**
 *
 * @export
 * @interface IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner
 */
export interface IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner {
  /**
   *
   * @type {string}
   * @memberof IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner
   */
  subject_addr?: string;
  /**
   *
   * @type {string}
   * @memberof IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner
   */
  weight?: string;
}
/**
 *
 * @export
 * @interface ListedClass200Response
 */
export interface ListedClass200Response {
  /**
   *
   * @type {string}
   * @memberof ListedClass200Response
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClass200Response
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClass200Response
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClass200Response
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClass200Response
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClass200Response
   */
  urihash?: string;
  /**
   *
   * @type {Array<ListedClass200ResponseNftsInner>}
   * @memberof ListedClass200Response
   */
  nfts?: Array<ListedClass200ResponseNftsInner>;
  /**
   *
   * @type {string}
   * @memberof ListedClass200Response
   */
  nft_count?: string;
}
/**
 *
 * @export
 * @interface ListedClass200ResponseNftsInner
 */
export interface ListedClass200ResponseNftsInner {
  /**
   *
   * @type {string}
   * @memberof ListedClass200ResponseNftsInner
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClass200ResponseNftsInner
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof ListedClass200ResponseNftsInner
   */
  uri_hash?: string;
}
/**
 *
 * @export
 * @interface ListedClasses200Response
 */
export interface ListedClasses200Response {
  /**
   *
   * @type {Array<ListedClass200Response>}
   * @memberof ListedClasses200Response
   */
  classes?: Array<ListedClass200Response>;
}
/**
 *
 * @export
 * @interface ListedNfts200Response
 */
export interface ListedNfts200Response {
  /**
   *
   * @type {Array<ListedNfts200ResponseListingsInner>}
   * @memberof ListedNfts200Response
   */
  listings?: Array<ListedNfts200ResponseListingsInner>;
}
/**
 *
 * @export
 * @interface ListedNfts200ResponseListingsInner
 */
export interface ListedNfts200ResponseListingsInner {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof ListedNfts200ResponseListingsInner
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  listing_type?: ListedNfts200ResponseListingsInnerListingTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  state?: ListedNfts200ResponseListingsInnerStateEnum;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  bid_token?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  min_bid?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  bid_active_rank?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  started_at?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  end_at?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  full_payment_end_at?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  successful_bid_end_at?: string;
  /**
   *
   * @type {string}
   * @memberof ListedNfts200ResponseListingsInner
   */
  auto_relisted_count?: string;
}

export const ListedNfts200ResponseListingsInnerListingTypeEnum = {
  DirectAssetBorrow: 'DIRECT_ASSET_BORROW',
  SyntheticAssetCreation: 'SYNTHETIC_ASSET_CREATION',
  LateShipping: 'LATE_SHIPPING',
} as const;

export type ListedNfts200ResponseListingsInnerListingTypeEnum =
  typeof ListedNfts200ResponseListingsInnerListingTypeEnum[keyof typeof ListedNfts200ResponseListingsInnerListingTypeEnum];
export const ListedNfts200ResponseListingsInnerStateEnum = {
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  EndListing: 'END_LISTING',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type ListedNfts200ResponseListingsInnerStateEnum =
  typeof ListedNfts200ResponseListingsInnerStateEnum[keyof typeof ListedNfts200ResponseListingsInnerStateEnum];

/**
 *
 * @export
 * @interface Loan200Response
 */
export interface Loan200Response {
  /**
   *
   * @type {Loans200ResponseLoansInner}
   * @memberof Loan200Response
   */
  loan?: Loans200ResponseLoansInner;
  /**
   *
   * @type {string}
   * @memberof Loan200Response
   */
  borrowing_limit?: string;
}
/**
 *
 * @export
 * @interface Loans200Response
 */
export interface Loans200Response {
  /**
   *
   * @type {Array<Loans200ResponseLoansInner>}
   * @memberof Loans200Response
   */
  loans?: Array<Loans200ResponseLoansInner>;
}
/**
 *
 * @export
 * @interface Loans200ResponseLoansInner
 */
export interface Loans200ResponseLoansInner {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof Loans200ResponseLoansInner
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof Loans200ResponseLoansInner
   */
  loan?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface MarketAll200Response
 */
export interface MarketAll200Response {
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof MarketAll200Response
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof MarketAll200Response
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface MarketAll200ResponseMarketsInner
 */
export interface MarketAll200ResponseMarketsInner {
  /**
   *
   * @type {string}
   * @memberof MarketAll200ResponseMarketsInner
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof MarketAll200ResponseMarketsInner
   */
  base_asset?: string;
  /**
   *
   * @type {string}
   * @memberof MarketAll200ResponseMarketsInner
   */
  quote_asset?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MarketAll200ResponseMarketsInner
   */
  oracles?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof MarketAll200ResponseMarketsInner
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface NFTMinter200Response
 */
export interface NFTMinter200Response {
  /**
   *
   * @type {string}
   * @memberof NFTMinter200Response
   */
  minter?: string;
}
/**
 *
 * @export
 * @interface NftListing200Response
 */
export interface NftListing200Response {
  /**
   *
   * @type {ListedNfts200ResponseListingsInner}
   * @memberof NftListing200Response
   */
  listing?: ListedNfts200ResponseListingsInner;
}
/**
 *
 * @export
 * @interface NftmarketParams200Response
 */
export interface NftmarketParams200Response {
  /**
   *
   * @type {NftmarketParams200ResponseParams}
   * @memberof NftmarketParams200Response
   */
  params?: NftmarketParams200ResponseParams;
}
/**
 *
 * @export
 * @interface NftmarketParams200ResponseParams
 */
export interface NftmarketParams200ResponseParams {
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  min_staking_for_listing?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  default_bid_active_rank?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof NftmarketParams200ResponseParams
   */
  bid_tokens?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  auto_relisting_count_if_no_bid?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_delay_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_period_initial?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_cancel_fee_percentage?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_gap_time?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  bid_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  bid_token_disburse_seconds_after_cancel?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_full_payment_period?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_nft_delivery_period?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_creator_share_percentage?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  market_administrator?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_commission_fee?: string;
  /**
   *
   * @type {string}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_extend_seconds?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof NftmarketParams200ResponseParams
   */
  nft_listing_period_extend_fee_per_hour?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface NftmintParams200Response
 */
export interface NftmintParams200Response {
  /**
   *
   * @type {NftmintParams200ResponseParams}
   * @memberof NftmintParams200Response
   */
  params?: NftmintParams200ResponseParams;
}
/**
 *
 * @export
 * @interface NftmintParams200ResponseParams
 */
export interface NftmintParams200ResponseParams {
  /**
   *
   * @type {string}
   * @memberof NftmintParams200ResponseParams
   */
  MaxNFTSupplyCap?: string;
  /**
   *
   * @type {string}
   * @memberof NftmintParams200ResponseParams
   */
  MinClassNameLen?: string;
  /**
   *
   * @type {string}
   * @memberof NftmintParams200ResponseParams
   */
  MaxClassNameLen?: string;
  /**
   *
   * @type {string}
   * @memberof NftmintParams200ResponseParams
   */
  MinUriLen?: string;
  /**
   *
   * @type {string}
   * @memberof NftmintParams200ResponseParams
   */
  MaxUriLen?: string;
  /**
   *
   * @type {string}
   * @memberof NftmintParams200ResponseParams
   */
  MaxSymbolLen?: string;
  /**
   *
   * @type {string}
   * @memberof NftmintParams200ResponseParams
   */
  MaxDescriptionLen?: string;
}
/**
 *
 * @export
 * @interface OracleAll200Response
 */
export interface OracleAll200Response {
  /**
   *
   * @type {Array<string>}
   * @memberof OracleAll200Response
   */
  oracles?: Array<string>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof OracleAll200Response
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface PaymentStatus200Response
 */
export interface PaymentStatus200Response {
  /**
   *
   * @type {PaymentStatus200ResponsePaymentStatus}
   * @memberof PaymentStatus200Response
   */
  paymentStatus?: PaymentStatus200ResponsePaymentStatus;
}
/**
 *
 * @export
 * @interface PaymentStatus200ResponsePaymentStatus
 */
export interface PaymentStatus200ResponsePaymentStatus {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {string}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  bidder?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  amount?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {boolean}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  automatic_payment?: boolean;
  /**
   *
   * @type {string}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  paid_amount?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  bid_time?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  state?: PaymentStatus200ResponsePaymentStatusStateEnum;
  /**
   *
   * @type {boolean}
   * @memberof PaymentStatus200ResponsePaymentStatus
   */
  all_paid?: boolean;
}

export const PaymentStatus200ResponsePaymentStatusStateEnum = {
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  EndListing: 'END_LISTING',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type PaymentStatus200ResponsePaymentStatusStateEnum =
  typeof PaymentStatus200ResponsePaymentStatusStateEnum[keyof typeof PaymentStatus200ResponsePaymentStatusStateEnum];

/**
 *
 * @export
 * @interface Price200Response
 */
export interface Price200Response {
  /**
   *
   * @type {Price200ResponsePrice}
   * @memberof Price200Response
   */
  price?: Price200ResponsePrice;
}
/**
 *
 * @export
 * @interface Price200ResponsePrice
 */
export interface Price200ResponsePrice {
  /**
   *
   * @type {string}
   * @memberof Price200ResponsePrice
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof Price200ResponsePrice
   */
  price?: string;
}
/**
 *
 * @export
 * @interface PriceAll200Response
 */
export interface PriceAll200Response {
  /**
   *
   * @type {Array<Price200ResponsePrice>}
   * @memberof PriceAll200Response
   */
  prices?: Array<Price200ResponsePrice>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof PriceAll200Response
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface PricefeedParams200Response
 */
export interface PricefeedParams200Response {
  /**
   *
   * @type {PricefeedParams200ResponseParams}
   * @memberof PricefeedParams200Response
   */
  params?: PricefeedParams200ResponseParams;
}
/**
 *
 * @export
 * @interface PricefeedParams200ResponseParams
 */
export interface PricefeedParams200ResponseParams {
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof PricefeedParams200ResponseParams
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
}
/**
 *
 * @export
 * @interface RawPriceAll200Response
 */
export interface RawPriceAll200Response {
  /**
   *
   * @type {Array<RawPriceAll200ResponsePricesInner>}
   * @memberof RawPriceAll200Response
   */
  prices?: Array<RawPriceAll200ResponsePricesInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof RawPriceAll200Response
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface RawPriceAll200ResponsePricesInner
 */
export interface RawPriceAll200ResponsePricesInner {
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  oracle_address?: string;
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof RawPriceAll200ResponsePricesInner
   */
  expiry?: string;
}
/**
 *
 * @export
 * @interface RecordedIncentiveUnitId200Response
 */
export interface RecordedIncentiveUnitId200Response {
  /**
   *
   * @type {string}
   * @memberof RecordedIncentiveUnitId200Response
   */
  incentive_unit_id?: string;
}
/**
 *
 * @export
 * @interface Reward200Response
 */
export interface Reward200Response {
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof Reward200Response
   */
  reward?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
 */
export interface RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1 {
  /**
   *
   * @type {string}
   * @memberof RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
   */
  module_name?: string;
  /**
   *
   * @type {Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>}
   * @memberof RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1
   */
  reward_rate?: Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>;
}
/**
 *
 * @export
 * @interface RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
 */
export interface RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1 {
  /**
   * At first, we go with this one type. NFTMARKET_FRONTEND type reward will be disributed for the creators of frontend of UnUniFi\'s services.
   * @type {string}
   * @memberof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
   */
  reward_type?: RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum;
  /**
   *
   * @type {string}
   * @memberof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1
   */
  rate?: string;
}

export const RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum = {
  NftmarketFrontend: 'NFTMARKET_FRONTEND',
} as const;

export type RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum =
  typeof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum[keyof typeof RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1RewardTypeEnum];

/**
 *
 * @export
 * @interface Rewards200Response
 */
export interface Rewards200Response {
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInnerCdpCollateral>}
   * @memberof Rewards200Response
   */
  rewards?: Array<CdpAll200ResponseCdpInnerCdpCollateral>;
}
/**
 *
 * @export
 * @interface UnunifiAuctionParams
 */
export interface UnunifiAuctionParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiAuctionParams
   */
  max_auction_duration?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiAuctionParams
   */
  bid_duration?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiAuctionParams
   */
  increment_surplus?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiAuctionParams
   */
  increment_debt?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiAuctionParams
   */
  increment_collateral?: string;
}
/**
 *
 * @export
 * @interface UnunifiAuctionQueryAllAuctionResponse
 */
export interface UnunifiAuctionQueryAllAuctionResponse {
  /**
   *
   * @type {Array<AuctionAll200ResponseAuctionsInner>}
   * @memberof UnunifiAuctionQueryAllAuctionResponse
   */
  auctions?: Array<AuctionAll200ResponseAuctionsInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof UnunifiAuctionQueryAllAuctionResponse
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiAuctionQueryGetAuctionResponse
 */
export interface UnunifiAuctionQueryGetAuctionResponse {
  /**
   *
   * @type {AuctionAll200ResponseAuctionsInner}
   * @memberof UnunifiAuctionQueryGetAuctionResponse
   */
  auction?: AuctionAll200ResponseAuctionsInner;
}
/**
 *
 * @export
 * @interface UnunifiAuctionQueryParamsResponse
 */
export interface UnunifiAuctionQueryParamsResponse {
  /**
   *
   * @type {AuctionParams200ResponseParams}
   * @memberof UnunifiAuctionQueryParamsResponse
   */
  params?: AuctionParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiCdpAugmentedCdp
 */
export interface UnunifiCdpAugmentedCdp {
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdp}
   * @memberof UnunifiCdpAugmentedCdp
   */
  cdp?: CdpAll200ResponseCdpInnerCdp;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiCdpAugmentedCdp
   */
  collateral_value?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpAugmentedCdp
   */
  collateralization_ratio?: string;
}
/**
 *
 * @export
 * @interface UnunifiCdpCdp
 */
export interface UnunifiCdpCdp {
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCdp
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCdp
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCdp
   */
  type?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiCdpCdp
   */
  collateral?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiCdpCdp
   */
  principal?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiCdpCdp
   */
  accumulated_fees?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCdp
   */
  fees_updated?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCdp
   */
  interest_factor?: string;
}
/**
 *
 * @export
 * @interface UnunifiCdpCollateralParam
 */
export interface UnunifiCdpCollateralParam {
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  liquidation_ratio?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiCdpCollateralParam
   */
  debt_limit?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  stability_fee?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  auction_size?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  liquidation_penalty?: string;
  /**
   *
   * @type {number}
   * @memberof UnunifiCdpCollateralParam
   */
  prefix?: number;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  spot_market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  liquidation_market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  keeper_reward_percentage?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  check_collateralization_index_count?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpCollateralParam
   */
  conversion_factor?: string;
}
/**
 *
 * @export
 * @interface UnunifiCdpDebtParam
 */
export interface UnunifiCdpDebtParam {
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  reference_asset?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  conversion_factor?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  debt_floor?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiCdpDebtParam
   */
  global_debt_limit?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  debt_denom?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  surplus_auction_threshold?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  surplus_auction_lot?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  debt_auction_threshold?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDebtParam
   */
  debt_auction_lot?: string;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiCdpDebtParam
   */
  circuit_breaker?: boolean;
}
/**
 *
 * @export
 * @interface UnunifiCdpDeposit
 */
export interface UnunifiCdpDeposit {
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDeposit
   */
  cdp_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiCdpDeposit
   */
  depositor?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiCdpDeposit
   */
  amount?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface UnunifiCdpParams
 */
export interface UnunifiCdpParams {
  /**
   *
   * @type {Array<CdpParams200ResponseParamsCollateralParamsInner>}
   * @memberof UnunifiCdpParams
   */
  collateral_params?: Array<CdpParams200ResponseParamsCollateralParamsInner>;
  /**
   *
   * @type {Array<CdpParams200ResponseParamsDebtParamsInner>}
   * @memberof UnunifiCdpParams
   */
  debt_params?: Array<CdpParams200ResponseParamsDebtParamsInner>;
}
/**
 *
 * @export
 * @interface UnunifiCdpQueryAllAccountResponse
 */
export interface UnunifiCdpQueryAllAccountResponse {
  /**
   *
   * @type {Array<AuctionAll200ResponseAuctionsInner>}
   * @memberof UnunifiCdpQueryAllAccountResponse
   */
  accounts?: Array<AuctionAll200ResponseAuctionsInner>;
}
/**
 *
 * @export
 * @interface UnunifiCdpQueryAllCdpResponse
 */
export interface UnunifiCdpQueryAllCdpResponse {
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInner>}
   * @memberof UnunifiCdpQueryAllCdpResponse
   */
  cdp?: Array<CdpAll200ResponseCdpInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof UnunifiCdpQueryAllCdpResponse
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiCdpQueryAllDepositResponse
 */
export interface UnunifiCdpQueryAllDepositResponse {
  /**
   *
   * @type {Array<DepositAll200ResponseDepositsInner>}
   * @memberof UnunifiCdpQueryAllDepositResponse
   */
  deposits?: Array<DepositAll200ResponseDepositsInner>;
}
/**
 *
 * @export
 * @interface UnunifiCdpQueryGetCdpResponse
 */
export interface UnunifiCdpQueryGetCdpResponse {
  /**
   *
   * @type {CdpAll200ResponseCdpInner}
   * @memberof UnunifiCdpQueryGetCdpResponse
   */
  cdp?: CdpAll200ResponseCdpInner;
}
/**
 *
 * @export
 * @interface UnunifiCdpQueryParamsResponse
 */
export interface UnunifiCdpQueryParamsResponse {
  /**
   *
   * @type {CdpParams200ResponseParams}
   * @memberof UnunifiCdpQueryParamsResponse
   */
  params?: CdpParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveIncentiveUnit
 */
export interface UnunifiEcosystemincentiveIncentiveUnit {
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveIncentiveUnit
   */
  id?: string;
  /**
   *
   * @type {Array<IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner>}
   * @memberof UnunifiEcosystemincentiveIncentiveUnit
   */
  subject_info_lists?: Array<IncentiveUnit200ResponseIncentiveUnitSubjectInfoListsInner>;
}
/**
 * Params defines the parameters for the module.
 * @export
 * @interface UnunifiEcosystemincentiveParams
 */
export interface UnunifiEcosystemincentiveParams {
  /**
   *
   * @type {Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>}
   * @memberof UnunifiEcosystemincentiveParams
   */
  reward_params?: Array<RewardParamsDefinesWhichModuleHaveWhichRewardsTypeAndRateToMaintainTheCorrectnessOfTheFeeRateInAModuleEGIfNftmarketModuleHaveFrontendAndCollectionIncentiveTheCombinedThoseRatesForTheIncentiveCannotBeExceed1>;
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveParams
   */
  max_incentive_unit_id_len?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveParams
   */
  max_subject_info_num_in_unit?: string;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryAllRewardsResponse
 */
export interface UnunifiEcosystemincentiveQueryAllRewardsResponse {
  /**
   *
   * @type {AllRewards200ResponseRewards}
   * @memberof UnunifiEcosystemincentiveQueryAllRewardsResponse
   */
  rewards?: AllRewards200ResponseRewards;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryIncentiveUnitResponse
 */
export interface UnunifiEcosystemincentiveQueryIncentiveUnitResponse {
  /**
   *
   * @type {IncentiveUnit200ResponseIncentiveUnit}
   * @memberof UnunifiEcosystemincentiveQueryIncentiveUnitResponse
   */
  incentive_unit?: IncentiveUnit200ResponseIncentiveUnit;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryParamsResponse
 */
export interface UnunifiEcosystemincentiveQueryParamsResponse {
  /**
   *
   * @type {EcosystemincentiveParams200ResponseParams}
   * @memberof UnunifiEcosystemincentiveQueryParamsResponse
   */
  params?: EcosystemincentiveParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryRecordedIncentiveUnitIdResponse
 */
export interface UnunifiEcosystemincentiveQueryRecordedIncentiveUnitIdResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveQueryRecordedIncentiveUnitIdResponse
   */
  incentive_unit_id?: string;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveQueryRewardResponse
 */
export interface UnunifiEcosystemincentiveQueryRewardResponse {
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiEcosystemincentiveQueryRewardResponse
   */
  reward?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveRewardParams
 */
export interface UnunifiEcosystemincentiveRewardParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveRewardParams
   */
  module_name?: string;
  /**
   *
   * @type {Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>}
   * @memberof UnunifiEcosystemincentiveRewardParams
   */
  reward_rate?: Array<RewardRateDefinesTheRatioToTakeRewardForASpecificRewardTypeTheTotalSumOfRewardRateInAModuleCannotBeExceed1>;
}
/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveRewardRate
 */
export interface UnunifiEcosystemincentiveRewardRate {
  /**
   * At first, we go with this one type. NFTMARKET_FRONTEND type reward will be disributed for the creators of frontend of UnUniFi\'s services.
   * @type {string}
   * @memberof UnunifiEcosystemincentiveRewardRate
   */
  reward_type?: UnunifiEcosystemincentiveRewardRateRewardTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveRewardRate
   */
  rate?: string;
}

export const UnunifiEcosystemincentiveRewardRateRewardTypeEnum = {
  NftmarketFrontend: 'NFTMARKET_FRONTEND',
} as const;

export type UnunifiEcosystemincentiveRewardRateRewardTypeEnum =
  typeof UnunifiEcosystemincentiveRewardRateRewardTypeEnum[keyof typeof UnunifiEcosystemincentiveRewardRateRewardTypeEnum];

/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveRewardStore
 */
export interface UnunifiEcosystemincentiveRewardStore {
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveRewardStore
   */
  subject_addr?: string;
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInnerCdpCollateral>}
   * @memberof UnunifiEcosystemincentiveRewardStore
   */
  rewards?: Array<CdpAll200ResponseCdpInnerCdpCollateral>;
}
/**
 * At first, we go with this one type. NFTMARKET_FRONTEND type reward will be disributed for the creators of frontend of UnUniFi\'s services.
 * @export
 * @enum {string}
 */

export const UnunifiEcosystemincentiveRewardType = {
  NftmarketFrontend: 'NFTMARKET_FRONTEND',
} as const;

export type UnunifiEcosystemincentiveRewardType =
  typeof UnunifiEcosystemincentiveRewardType[keyof typeof UnunifiEcosystemincentiveRewardType];

/**
 *
 * @export
 * @interface UnunifiEcosystemincentiveSubjectInfo
 */
export interface UnunifiEcosystemincentiveSubjectInfo {
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveSubjectInfo
   */
  subject_addr?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiEcosystemincentiveSubjectInfo
   */
  weight?: string;
}
/**
 *
 * @export
 * @interface UnunifiIncentiveMultiplier
 */
export interface UnunifiIncentiveMultiplier {
  /**
   *
   * @type {string}
   * @memberof UnunifiIncentiveMultiplier
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIncentiveMultiplier
   */
  months_lockup?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIncentiveMultiplier
   */
  factor?: string;
}
/**
 *
 * @export
 * @interface UnunifiIncentiveParams
 */
export interface UnunifiIncentiveParams {
  /**
   *
   * @type {Array<IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner>}
   * @memberof UnunifiIncentiveParams
   */
  cdp_minting_reward_periods?: Array<IncentiveParams200ResponseParamsCdpMintingRewardPeriodsInner>;
  /**
   *
   * @type {Array<IncentiveParams200ResponseParamsClaimMultipliersInner>}
   * @memberof UnunifiIncentiveParams
   */
  claim_multipliers?: Array<IncentiveParams200ResponseParamsClaimMultipliersInner>;
  /**
   *
   * @type {string}
   * @memberof UnunifiIncentiveParams
   */
  claim_end?: string;
}
/**
 *
 * @export
 * @interface UnunifiIncentiveQueryParamsResponse
 */
export interface UnunifiIncentiveQueryParamsResponse {
  /**
   *
   * @type {IncentiveParams200ResponseParams}
   * @memberof UnunifiIncentiveQueryParamsResponse
   */
  params?: IncentiveParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiIncentiveRewardPeriod
 */
export interface UnunifiIncentiveRewardPeriod {
  /**
   *
   * @type {boolean}
   * @memberof UnunifiIncentiveRewardPeriod
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof UnunifiIncentiveRewardPeriod
   */
  collateral_type?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIncentiveRewardPeriod
   */
  start?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiIncentiveRewardPeriod
   */
  end?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiIncentiveRewardPeriod
   */
  rewards_per_second?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketListedNft
 */
export interface UnunifiNftmarketListedNft {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketListedNft
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketListedNft
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketListedNft
   */
  uri_hash?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const UnunifiNftmarketListingState = {
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  EndListing: 'END_LISTING',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type UnunifiNftmarketListingState = typeof UnunifiNftmarketListingState[keyof typeof UnunifiNftmarketListingState];

/**
 *
 * @export
 * @enum {string}
 */

export const UnunifiNftmarketListingType = {
  DirectAssetBorrow: 'DIRECT_ASSET_BORROW',
  SyntheticAssetCreation: 'SYNTHETIC_ASSET_CREATION',
  LateShipping: 'LATE_SHIPPING',
} as const;

export type UnunifiNftmarketListingType = typeof UnunifiNftmarketListingType[keyof typeof UnunifiNftmarketListingType];

/**
 *
 * @export
 * @interface UnunifiNftmarketLoan
 */
export interface UnunifiNftmarketLoan {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof UnunifiNftmarketLoan
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiNftmarketLoan
   */
  loan?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketNftBid
 */
export interface UnunifiNftmarketNftBid {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof UnunifiNftmarketNftBid
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftBid
   */
  bidder?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiNftmarketNftBid
   */
  amount?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiNftmarketNftBid
   */
  automatic_payment?: boolean;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftBid
   */
  paid_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftBid
   */
  bid_time?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketNftIdentifier
 */
export interface UnunifiNftmarketNftIdentifier {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftIdentifier
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftIdentifier
   */
  nft_id?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketNftListing
 */
export interface UnunifiNftmarketNftListing {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof UnunifiNftmarketNftListing
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  listing_type?: UnunifiNftmarketNftListingListingTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  state?: UnunifiNftmarketNftListingStateEnum;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  bid_token?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  min_bid?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  bid_active_rank?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  started_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  end_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  full_payment_end_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  successful_bid_end_at?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketNftListing
   */
  auto_relisted_count?: string;
}

export const UnunifiNftmarketNftListingListingTypeEnum = {
  DirectAssetBorrow: 'DIRECT_ASSET_BORROW',
  SyntheticAssetCreation: 'SYNTHETIC_ASSET_CREATION',
  LateShipping: 'LATE_SHIPPING',
} as const;

export type UnunifiNftmarketNftListingListingTypeEnum =
  typeof UnunifiNftmarketNftListingListingTypeEnum[keyof typeof UnunifiNftmarketNftListingListingTypeEnum];
export const UnunifiNftmarketNftListingStateEnum = {
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  EndListing: 'END_LISTING',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type UnunifiNftmarketNftListingStateEnum =
  typeof UnunifiNftmarketNftListingStateEnum[keyof typeof UnunifiNftmarketNftListingStateEnum];

/**
 *
 * @export
 * @interface UnunifiNftmarketParams
 */
export interface UnunifiNftmarketParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  min_staking_for_listing?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  default_bid_active_rank?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiNftmarketParams
   */
  bid_tokens?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  auto_relisting_count_if_no_bid?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_delay_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_period_initial?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_cancel_fee_percentage?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_gap_time?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  bid_cancel_required_seconds?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  bid_token_disburse_seconds_after_cancel?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_full_payment_period?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_nft_delivery_period?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_creator_share_percentage?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  market_administrator?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_commission_fee?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_extend_seconds?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiNftmarketParams
   */
  nft_listing_period_extend_fee_per_hour?: CdpAll200ResponseCdpInnerCdpCollateral;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketPaymentStatus
 */
export interface UnunifiNftmarketPaymentStatus {
  /**
   *
   * @type {BidderBids200ResponseBidsInnerNftId}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  nft_id?: BidderBids200ResponseBidsInnerNftId;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  bidder?: string;
  /**
   *
   * @type {CdpAll200ResponseCdpInnerCdpCollateral}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  amount?: CdpAll200ResponseCdpInnerCdpCollateral;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  automatic_payment?: boolean;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  paid_amount?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  bid_time?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  state?: UnunifiNftmarketPaymentStatusStateEnum;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiNftmarketPaymentStatus
   */
  all_paid?: boolean;
}

export const UnunifiNftmarketPaymentStatusStateEnum = {
  Listing: 'LISTING',
  Bidding: 'BIDDING',
  SellingDecision: 'SELLING_DECISION',
  Liquidation: 'LIQUIDATION',
  EndListing: 'END_LISTING',
  SuccessfulBid: 'SUCCESSFUL_BID',
} as const;

export type UnunifiNftmarketPaymentStatusStateEnum =
  typeof UnunifiNftmarketPaymentStatusStateEnum[keyof typeof UnunifiNftmarketPaymentStatusStateEnum];

/**
 *
 * @export
 * @interface UnunifiNftmarketQueryBidderBidsResponse
 */
export interface UnunifiNftmarketQueryBidderBidsResponse {
  /**
   *
   * @type {Array<BidderBids200ResponseBidsInner>}
   * @memberof UnunifiNftmarketQueryBidderBidsResponse
   */
  bids?: Array<BidderBids200ResponseBidsInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryListedClassResponse
 */
export interface UnunifiNftmarketQueryListedClassResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  urihash?: string;
  /**
   *
   * @type {Array<ListedClass200ResponseNftsInner>}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  nfts?: Array<ListedClass200ResponseNftsInner>;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryListedClassResponse
   */
  nft_count?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryListedClassesResponse
 */
export interface UnunifiNftmarketQueryListedClassesResponse {
  /**
   *
   * @type {Array<ListedClass200Response>}
   * @memberof UnunifiNftmarketQueryListedClassesResponse
   */
  classes?: Array<ListedClass200Response>;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryListedNftsResponse
 */
export interface UnunifiNftmarketQueryListedNftsResponse {
  /**
   *
   * @type {Array<ListedNfts200ResponseListingsInner>}
   * @memberof UnunifiNftmarketQueryListedNftsResponse
   */
  listings?: Array<ListedNfts200ResponseListingsInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryLoanResponse
 */
export interface UnunifiNftmarketQueryLoanResponse {
  /**
   *
   * @type {Loans200ResponseLoansInner}
   * @memberof UnunifiNftmarketQueryLoanResponse
   */
  loan?: Loans200ResponseLoansInner;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmarketQueryLoanResponse
   */
  borrowing_limit?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryLoansResponse
 */
export interface UnunifiNftmarketQueryLoansResponse {
  /**
   *
   * @type {Array<Loans200ResponseLoansInner>}
   * @memberof UnunifiNftmarketQueryLoansResponse
   */
  loans?: Array<Loans200ResponseLoansInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryNftBidsResponse
 */
export interface UnunifiNftmarketQueryNftBidsResponse {
  /**
   *
   * @type {Array<BidderBids200ResponseBidsInner>}
   * @memberof UnunifiNftmarketQueryNftBidsResponse
   */
  bids?: Array<BidderBids200ResponseBidsInner>;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryNftListingResponse
 */
export interface UnunifiNftmarketQueryNftListingResponse {
  /**
   *
   * @type {ListedNfts200ResponseListingsInner}
   * @memberof UnunifiNftmarketQueryNftListingResponse
   */
  listing?: ListedNfts200ResponseListingsInner;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryParamsResponse
 */
export interface UnunifiNftmarketQueryParamsResponse {
  /**
   *
   * @type {NftmarketParams200ResponseParams}
   * @memberof UnunifiNftmarketQueryParamsResponse
   */
  params?: NftmarketParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryPaymentStatusResponse
 */
export interface UnunifiNftmarketQueryPaymentStatusResponse {
  /**
   *
   * @type {PaymentStatus200ResponsePaymentStatus}
   * @memberof UnunifiNftmarketQueryPaymentStatusResponse
   */
  paymentStatus?: PaymentStatus200ResponsePaymentStatus;
}
/**
 *
 * @export
 * @interface UnunifiNftmarketQueryRewardsResponse
 */
export interface UnunifiNftmarketQueryRewardsResponse {
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInnerCdpCollateral>}
   * @memberof UnunifiNftmarketQueryRewardsResponse
   */
  rewards?: Array<CdpAll200ResponseCdpInnerCdpCollateral>;
}
/**
 *
 * @export
 * @interface UnunifiNftmintClassAttributes
 */
export interface UnunifiNftmintClassAttributes {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintClassAttributes
   */
  class_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintClassAttributes
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintClassAttributes
   */
  base_token_uri?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintClassAttributes
   */
  minting_permission?: UnunifiNftmintClassAttributesMintingPermissionEnum;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintClassAttributes
   */
  token_supply_cap?: string;
}

export const UnunifiNftmintClassAttributesMintingPermissionEnum = {
  OnlyOwner: 'OnlyOwner',
  Anyone: 'Anyone',
} as const;

export type UnunifiNftmintClassAttributesMintingPermissionEnum =
  typeof UnunifiNftmintClassAttributesMintingPermissionEnum[keyof typeof UnunifiNftmintClassAttributesMintingPermissionEnum];

/**
 *
 * @export
 * @interface UnunifiNftmintClassNameIdList
 */
export interface UnunifiNftmintClassNameIdList {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintClassNameIdList
   */
  class_name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiNftmintClassNameIdList
   */
  class_id?: Array<string>;
}
/**
 *
 * @export
 * @enum {string}
 */

export const UnunifiNftmintMintingPermission = {
  OnlyOwner: 'OnlyOwner',
  Anyone: 'Anyone',
} as const;

export type UnunifiNftmintMintingPermission = typeof UnunifiNftmintMintingPermission[keyof typeof UnunifiNftmintMintingPermission];

/**
 *
 * @export
 * @interface UnunifiNftmintOwningClassIdList
 */
export interface UnunifiNftmintOwningClassIdList {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintOwningClassIdList
   */
  owner?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiNftmintOwningClassIdList
   */
  class_id?: Array<string>;
}
/**
 *
 * @export
 * @interface UnunifiNftmintParams
 */
export interface UnunifiNftmintParams {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintParams
   */
  MaxNFTSupplyCap?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintParams
   */
  MinClassNameLen?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintParams
   */
  MaxClassNameLen?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintParams
   */
  MinUriLen?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintParams
   */
  MaxUriLen?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintParams
   */
  MaxSymbolLen?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintParams
   */
  MaxDescriptionLen?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftmintQueryClassAttributesResponse
 */
export interface UnunifiNftmintQueryClassAttributesResponse {
  /**
   *
   * @type {ClassAttributes200ResponseClassAttributes}
   * @memberof UnunifiNftmintQueryClassAttributesResponse
   */
  class_attributes?: ClassAttributes200ResponseClassAttributes;
}
/**
 *
 * @export
 * @interface UnunifiNftmintQueryClassIdsByNameResponse
 */
export interface UnunifiNftmintQueryClassIdsByNameResponse {
  /**
   *
   * @type {ClassIdsByName200ResponseClassNameIdList}
   * @memberof UnunifiNftmintQueryClassIdsByNameResponse
   */
  class_name_id_list?: ClassIdsByName200ResponseClassNameIdList;
}
/**
 *
 * @export
 * @interface UnunifiNftmintQueryClassIdsByOwnerResponse
 */
export interface UnunifiNftmintQueryClassIdsByOwnerResponse {
  /**
   *
   * @type {ClassIdsByOwner200ResponseOwningClassIdList}
   * @memberof UnunifiNftmintQueryClassIdsByOwnerResponse
   */
  owning_class_id_list?: ClassIdsByOwner200ResponseOwningClassIdList;
}
/**
 *
 * @export
 * @interface UnunifiNftmintQueryNFTMinterResponse
 */
export interface UnunifiNftmintQueryNFTMinterResponse {
  /**
   *
   * @type {string}
   * @memberof UnunifiNftmintQueryNFTMinterResponse
   */
  minter?: string;
}
/**
 *
 * @export
 * @interface UnunifiNftmintQueryParamsResponse
 */
export interface UnunifiNftmintQueryParamsResponse {
  /**
   *
   * @type {NftmintParams200ResponseParams}
   * @memberof UnunifiNftmintQueryParamsResponse
   */
  params?: NftmintParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedCurrentPrice
 */
export interface UnunifiPricefeedCurrentPrice {
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedCurrentPrice
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedCurrentPrice
   */
  price?: string;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedMarket
 */
export interface UnunifiPricefeedMarket {
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedMarket
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedMarket
   */
  base_asset?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedMarket
   */
  quote_asset?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiPricefeedMarket
   */
  oracles?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof UnunifiPricefeedMarket
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedParams
 */
export interface UnunifiPricefeedParams {
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof UnunifiPricefeedParams
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedPostedPrice
 */
export interface UnunifiPricefeedPostedPrice {
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  market_id?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  oracle_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  price?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiPricefeedPostedPrice
   */
  expiry?: string;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllMarketResponse
 */
export interface UnunifiPricefeedQueryAllMarketResponse {
  /**
   *
   * @type {Array<MarketAll200ResponseMarketsInner>}
   * @memberof UnunifiPricefeedQueryAllMarketResponse
   */
  markets?: Array<MarketAll200ResponseMarketsInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllMarketResponse
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllOracleResponse
 */
export interface UnunifiPricefeedQueryAllOracleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof UnunifiPricefeedQueryAllOracleResponse
   */
  oracles?: Array<string>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllOracleResponse
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllPriceResponse
 */
export interface UnunifiPricefeedQueryAllPriceResponse {
  /**
   *
   * @type {Array<Price200ResponsePrice>}
   * @memberof UnunifiPricefeedQueryAllPriceResponse
   */
  prices?: Array<Price200ResponsePrice>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllPriceResponse
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryAllRawPriceResponse
 */
export interface UnunifiPricefeedQueryAllRawPriceResponse {
  /**
   *
   * @type {Array<RawPriceAll200ResponsePricesInner>}
   * @memberof UnunifiPricefeedQueryAllRawPriceResponse
   */
  prices?: Array<RawPriceAll200ResponsePricesInner>;
  /**
   *
   * @type {AuctionAll200ResponsePagination}
   * @memberof UnunifiPricefeedQueryAllRawPriceResponse
   */
  pagination?: AuctionAll200ResponsePagination;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryGetPriceResponse
 */
export interface UnunifiPricefeedQueryGetPriceResponse {
  /**
   *
   * @type {Price200ResponsePrice}
   * @memberof UnunifiPricefeedQueryGetPriceResponse
   */
  price?: Price200ResponsePrice;
}
/**
 *
 * @export
 * @interface UnunifiPricefeedQueryParamsResponse
 */
export interface UnunifiPricefeedQueryParamsResponse {
  /**
   *
   * @type {PricefeedParams200ResponseParams}
   * @memberof UnunifiPricefeedQueryParamsResponse
   */
  params?: PricefeedParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifiUnunifidistParams
 */
export interface UnunifiUnunifidistParams {
  /**
   *
   * @type {boolean}
   * @memberof UnunifiUnunifidistParams
   */
  active?: boolean;
  /**
   *
   * @type {Array<UnunifidistParams200ResponseParamsPeriodsInner>}
   * @memberof UnunifiUnunifidistParams
   */
  periods?: Array<UnunifidistParams200ResponseParamsPeriodsInner>;
}
/**
 *
 * @export
 * @interface UnunifiUnunifidistPeriod
 */
export interface UnunifiUnunifidistPeriod {
  /**
   *
   * @type {string}
   * @memberof UnunifiUnunifidistPeriod
   */
  start?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiUnunifidistPeriod
   */
  end?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifiUnunifidistPeriod
   */
  inflation?: string;
}
/**
 *
 * @export
 * @interface UnunifiUnunifidistQueryGetBalancesResponse
 */
export interface UnunifiUnunifidistQueryGetBalancesResponse {
  /**
   *
   * @type {Array<CdpAll200ResponseCdpInnerCdpCollateral>}
   * @memberof UnunifiUnunifidistQueryGetBalancesResponse
   */
  balances?: Array<CdpAll200ResponseCdpInnerCdpCollateral>;
}
/**
 *
 * @export
 * @interface UnunifiUnunifidistQueryParamsResponse
 */
export interface UnunifiUnunifidistQueryParamsResponse {
  /**
   *
   * @type {UnunifidistParams200ResponseParams}
   * @memberof UnunifiUnunifidistQueryParamsResponse
   */
  params?: UnunifidistParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifidistParams200Response
 */
export interface UnunifidistParams200Response {
  /**
   *
   * @type {UnunifidistParams200ResponseParams}
   * @memberof UnunifidistParams200Response
   */
  params?: UnunifidistParams200ResponseParams;
}
/**
 *
 * @export
 * @interface UnunifidistParams200ResponseParams
 */
export interface UnunifidistParams200ResponseParams {
  /**
   *
   * @type {boolean}
   * @memberof UnunifidistParams200ResponseParams
   */
  active?: boolean;
  /**
   *
   * @type {Array<UnunifidistParams200ResponseParamsPeriodsInner>}
   * @memberof UnunifidistParams200ResponseParams
   */
  periods?: Array<UnunifidistParams200ResponseParamsPeriodsInner>;
}
/**
 *
 * @export
 * @interface UnunifidistParams200ResponseParamsPeriodsInner
 */
export interface UnunifidistParams200ResponseParamsPeriodsInner {
  /**
   *
   * @type {string}
   * @memberof UnunifidistParams200ResponseParamsPeriodsInner
   */
  start?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifidistParams200ResponseParamsPeriodsInner
   */
  end?: string;
  /**
   *
   * @type {string}
   * @memberof UnunifidistParams200ResponseParamsPeriodsInner
   */
  inflation?: string;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/cdp/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} subjectAddr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allRewards: async (subjectAddr: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'subjectAddr' is not null or undefined
      assertParamExists('allRewards', 'subjectAddr', subjectAddr);
      const localVarPath = `/ununifi/ecosystem_incentive/all_rewards/{subject_addr}`.replace(
        `{${'subject_addr'}}`,
        encodeURIComponent(String(subjectAddr)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('auction', 'id', id);
      const localVarPath = `/ununifi/auction/auctions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auctionAll: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/auction/auctions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auctionParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/auction/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balances: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/ununifidist/balances`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bidderBids: async (bidder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'bidder' is not null or undefined
      assertParamExists('bidderBids', 'bidder', bidder);
      const localVarPath = `/ununifi/nftmarket/bidder_bids/{bidder}`.replace(`{${'bidder'}}`, encodeURIComponent(String(bidder)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cDPsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftmarket/cdps_list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} owner
     * @param {string} collateralType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdp: async (owner: string, collateralType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'owner' is not null or undefined
      assertParamExists('cdp', 'owner', owner);
      // verify required parameter 'collateralType' is not null or undefined
      assertParamExists('cdp', 'collateralType', collateralType);
      const localVarPath = `/ununifi/cdp/cdps/owners/{owner}/collateral-types/{collateral_type}/cdp`
        .replace(`{${'owner'}}`, encodeURIComponent(String(owner)))
        .replace(`{${'collateral_type'}}`, encodeURIComponent(String(collateralType)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdpAll: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/cdp/cdps`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdpParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/cdp/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classAttributes: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('classAttributes', 'classId', classId);
      const localVarPath = `/ununifi/nftmint/class_owner/{class_id}`.replace(`{${'class_id'}}`, encodeURIComponent(String(classId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} className
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classIdsByName: async (className: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'className' is not null or undefined
      assertParamExists('classIdsByName', 'className', className);
      const localVarPath = `/ununifi/nftmint/class_ids_by_name/{class_name}`.replace(
        `{${'class_name'}}`,
        encodeURIComponent(String(className)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classIdsByOwner: async (owner: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'owner' is not null or undefined
      assertParamExists('classIdsByOwner', 'owner', owner);
      const localVarPath = `/ununifi/nftmint/class_ids_by_owner/{owner}`.replace(`{${'owner'}}`, encodeURIComponent(String(owner)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} owner
     * @param {string} collateralType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    depositAll: async (owner: string, collateralType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'owner' is not null or undefined
      assertParamExists('depositAll', 'owner', owner);
      // verify required parameter 'collateralType' is not null or undefined
      assertParamExists('depositAll', 'collateralType', collateralType);
      const localVarPath = `/ununifi/cdp/deposits/owners/{owner}/collateral-types/{collateral_type}`
        .replace(`{${'owner'}}`, encodeURIComponent(String(owner)))
        .replace(`{${'collateral_type'}}`, encodeURIComponent(String(collateralType)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ecosystemincentiveParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/ecosystem_incentive/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incentiveParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/incentive/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} incentiveUnitId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incentiveUnit: async (incentiveUnitId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'incentiveUnitId' is not null or undefined
      assertParamExists('incentiveUnit', 'incentiveUnitId', incentiveUnitId);
      const localVarPath = `/ununifi/ecosystem_incentive/incentive_unit/{incentive_unit_id}`.replace(
        `{${'incentive_unit_id'}}`,
        encodeURIComponent(String(incentiveUnitId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {number} nftLimit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClass: async (classId: string, nftLimit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('listedClass', 'classId', classId);
      // verify required parameter 'nftLimit' is not null or undefined
      assertParamExists('listedClass', 'nftLimit', nftLimit);
      const localVarPath = `/ununifi/nftmarket/listed_class/{class_id}/{nft_limit}`
        .replace(`{${'class_id'}}`, encodeURIComponent(String(classId)))
        .replace(`{${'nft_limit'}}`, encodeURIComponent(String(nftLimit)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClasses: async (nftLimit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftmarket/listed_classes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (nftLimit !== undefined) {
        localVarQueryParameter['nft_limit'] = nftLimit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [owner]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedNfts: async (owner?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftmarket/listed_nfts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loan: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('loan', 'classId', classId);
      // verify required parameter 'nftId' is not null or undefined
      assertParamExists('loan', 'nftId', nftId);
      const localVarPath = `/ununifi/nftmarket/loans/{class_id}/{nft_id}`
        .replace(`{${'class_id'}}`, encodeURIComponent(String(classId)))
        .replace(`{${'nft_id'}}`, encodeURIComponent(String(nftId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loans: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftmarket/loans`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketAll: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/pricefeed/markets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nFTMinter: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('nFTMinter', 'classId', classId);
      // verify required parameter 'nftId' is not null or undefined
      assertParamExists('nFTMinter', 'nftId', nftId);
      const localVarPath = `/ununifi/nftmint/nft_minter/{class_id}/{nft_id}`
        .replace(`{${'class_id'}}`, encodeURIComponent(String(classId)))
        .replace(`{${'nft_id'}}`, encodeURIComponent(String(nftId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftBids: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('nftBids', 'classId', classId);
      // verify required parameter 'nftId' is not null or undefined
      assertParamExists('nftBids', 'nftId', nftId);
      const localVarPath = `/ununifi/nftmarket/nft_bids/{class_id}/{nft_id}`
        .replace(`{${'class_id'}}`, encodeURIComponent(String(classId)))
        .replace(`{${'nft_id'}}`, encodeURIComponent(String(nftId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftListing: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('nftListing', 'classId', classId);
      // verify required parameter 'nftId' is not null or undefined
      assertParamExists('nftListing', 'nftId', nftId);
      const localVarPath = `/ununifi/nftmarket/nft_listing/{class_id}/{nft_id}`
        .replace(`{${'class_id'}}`, encodeURIComponent(String(classId)))
        .replace(`{${'nft_id'}}`, encodeURIComponent(String(nftId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftmarketParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftmarket/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftmintParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/nftmint/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oracleAll: async (
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'marketId' is not null or undefined
      assertParamExists('oracleAll', 'marketId', marketId);
      const localVarPath = `/ununifi/pricefeed/markets/{market_id}/oracles`.replace(
        `{${'market_id'}}`,
        encodeURIComponent(String(marketId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentStatus: async (classId: string, nftId: string, bidder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('paymentStatus', 'classId', classId);
      // verify required parameter 'nftId' is not null or undefined
      assertParamExists('paymentStatus', 'nftId', nftId);
      // verify required parameter 'bidder' is not null or undefined
      assertParamExists('paymentStatus', 'bidder', bidder);
      const localVarPath = `/ununifi/nftmarket/payment_status/{class_id}/{nft_id}/{bidder}`
        .replace(`{${'class_id'}}`, encodeURIComponent(String(classId)))
        .replace(`{${'nft_id'}}`, encodeURIComponent(String(nftId)))
        .replace(`{${'bidder'}}`, encodeURIComponent(String(bidder)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} marketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price: async (marketId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'marketId' is not null or undefined
      assertParamExists('price', 'marketId', marketId);
      const localVarPath = `/ununifi/pricefeed/markets/{market_id}/price`.replace(`{${'market_id'}}`, encodeURIComponent(String(marketId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    priceAll: async (
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/pricefeed/prices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricefeedParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/pricefeed/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rawPriceAll: async (
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'marketId' is not null or undefined
      assertParamExists('rawPriceAll', 'marketId', marketId);
      const localVarPath = `/ununifi/pricefeed/markets/{market_id}/raw_prices`.replace(
        `{${'market_id'}}`,
        encodeURIComponent(String(marketId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paginationKey !== undefined) {
        localVarQueryParameter['pagination.key'] = paginationKey;
      }

      if (paginationOffset !== undefined) {
        localVarQueryParameter['pagination.offset'] = paginationOffset;
      }

      if (paginationLimit !== undefined) {
        localVarQueryParameter['pagination.limit'] = paginationLimit;
      }

      if (paginationCountTotal !== undefined) {
        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordedIncentiveUnitId: async (classId: string, nftId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'classId' is not null or undefined
      assertParamExists('recordedIncentiveUnitId', 'classId', classId);
      // verify required parameter 'nftId' is not null or undefined
      assertParamExists('recordedIncentiveUnitId', 'nftId', nftId);
      const localVarPath = `/ununifi/ecosystem_incentive/recorded_incentive_unit_id/{class_id}/{nft_id}`
        .replace(`{${'class_id'}}`, encodeURIComponent(String(classId)))
        .replace(`{${'nft_id'}}`, encodeURIComponent(String(nftId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} subjectAddr
     * @param {string} denom
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reward: async (subjectAddr: string, denom: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'subjectAddr' is not null or undefined
      assertParamExists('reward', 'subjectAddr', subjectAddr);
      // verify required parameter 'denom' is not null or undefined
      assertParamExists('reward', 'denom', denom);
      const localVarPath = `/ununifi/ecosystem_incentive/reward/{subject_addr}/{denom}`
        .replace(`{${'subject_addr'}}`, encodeURIComponent(String(subjectAddr)))
        .replace(`{${'denom'}}`, encodeURIComponent(String(denom)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rewards: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('rewards', 'address', address);
      const localVarPath = `/ununifi/nftmarket/rewards/{address}`.replace(`{${'address'}}`, encodeURIComponent(String(address)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ununifidistParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ununifi/ununifidist/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountAll(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountAll(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} subjectAddr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async allRewards(
      subjectAddr: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllRewards200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.allRewards(subjectAddr, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async auction(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.auction(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async auctionAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuctionAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.auctionAll(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async auctionParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuctionParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.auctionParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async balances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balances200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.balances(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bidderBids(
      bidder: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidderBids200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bidderBids(bidder, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cDPsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cDPsList(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} owner
     * @param {string} collateralType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cdp(
      owner: string,
      collateralType: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cdp200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cdp(owner, collateralType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cdpAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdpAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cdpAll(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cdpParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdpParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cdpParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classAttributes(
      classId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassAttributes200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.classAttributes(classId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} className
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classIdsByName(
      className: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassIdsByName200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.classIdsByName(className, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classIdsByOwner(
      owner: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassIdsByOwner200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.classIdsByOwner(owner, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} owner
     * @param {string} collateralType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async depositAll(
      owner: string,
      collateralType: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.depositAll(owner, collateralType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ecosystemincentiveParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EcosystemincentiveParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ecosystemincentiveParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async incentiveParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncentiveParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.incentiveParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} incentiveUnitId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async incentiveUnit(
      incentiveUnitId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncentiveUnit200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.incentiveUnit(incentiveUnitId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {number} nftLimit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listedClass(
      classId: string,
      nftLimit: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedClass200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listedClass(classId, nftLimit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listedClasses(
      nftLimit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedClasses200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listedClasses(nftLimit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [owner]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listedNfts(
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedNfts200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listedNfts(owner, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loan(
      classId: string,
      nftId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loan200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loan(classId, nftId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loans(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loans200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loans(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async marketAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.marketAll(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nFTMinter(
      classId: string,
      nftId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NFTMinter200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nFTMinter(classId, nftId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nftBids(
      classId: string,
      nftId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidderBids200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nftBids(classId, nftId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nftListing(
      classId: string,
      nftId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftListing200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nftListing(classId, nftId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nftmarketParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftmarketParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nftmarketParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nftmintParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftmintParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nftmintParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oracleAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OracleAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oracleAll(
        marketId,
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentStatus(
      classId: string,
      nftId: string,
      bidder: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentStatus(classId, nftId, bidder, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} marketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async price(
      marketId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.price(marketId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async priceAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.priceAll(
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pricefeedParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricefeedParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pricefeedParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rawPriceAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawPriceAll200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rawPriceAll(
        marketId,
        paginationKey,
        paginationOffset,
        paginationLimit,
        paginationCountTotal,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recordedIncentiveUnitId(
      classId: string,
      nftId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordedIncentiveUnitId200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.recordedIncentiveUnitId(classId, nftId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} subjectAddr
     * @param {string} denom
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reward(
      subjectAddr: string,
      denom: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reward200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reward(subjectAddr, denom, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rewards(
      address: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rewards200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rewards(address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ununifidistParams(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnunifidistParams200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ununifidistParams(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = QueryApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAll(options?: any): AxiosPromise<AccountAll200Response> {
      return localVarFp.accountAll(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} subjectAddr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allRewards(subjectAddr: string, options?: any): AxiosPromise<AllRewards200Response> {
      return localVarFp.allRewards(subjectAddr, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auction(id: string, options?: any): AxiosPromise<Auction200Response> {
      return localVarFp.auction(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auctionAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<AuctionAll200Response> {
      return localVarFp
        .auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auctionParams(options?: any): AxiosPromise<AuctionParams200Response> {
      return localVarFp.auctionParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balances(options?: any): AxiosPromise<Balances200Response> {
      return localVarFp.balances(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bidderBids(bidder: string, options?: any): AxiosPromise<BidderBids200Response> {
      return localVarFp.bidderBids(bidder, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cDPsList(options?: any): AxiosPromise<object> {
      return localVarFp.cDPsList(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} owner
     * @param {string} collateralType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdp(owner: string, collateralType: string, options?: any): AxiosPromise<Cdp200Response> {
      return localVarFp.cdp(owner, collateralType, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdpAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<CdpAll200Response> {
      return localVarFp
        .cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cdpParams(options?: any): AxiosPromise<CdpParams200Response> {
      return localVarFp.cdpParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classAttributes(classId: string, options?: any): AxiosPromise<ClassAttributes200Response> {
      return localVarFp.classAttributes(classId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} className
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classIdsByName(className: string, options?: any): AxiosPromise<ClassIdsByName200Response> {
      return localVarFp.classIdsByName(className, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classIdsByOwner(owner: string, options?: any): AxiosPromise<ClassIdsByOwner200Response> {
      return localVarFp.classIdsByOwner(owner, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} owner
     * @param {string} collateralType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    depositAll(owner: string, collateralType: string, options?: any): AxiosPromise<DepositAll200Response> {
      return localVarFp.depositAll(owner, collateralType, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Parameters queries the parameters of the module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ecosystemincentiveParams(options?: any): AxiosPromise<EcosystemincentiveParams200Response> {
      return localVarFp.ecosystemincentiveParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incentiveParams(options?: any): AxiosPromise<IncentiveParams200Response> {
      return localVarFp.incentiveParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} incentiveUnitId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incentiveUnit(incentiveUnitId: string, options?: any): AxiosPromise<IncentiveUnit200Response> {
      return localVarFp.incentiveUnit(incentiveUnitId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {number} nftLimit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClass(classId: string, nftLimit: number, options?: any): AxiosPromise<ListedClass200Response> {
      return localVarFp.listedClass(classId, nftLimit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} [nftLimit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedClasses(nftLimit?: number, options?: any): AxiosPromise<ListedClasses200Response> {
      return localVarFp.listedClasses(nftLimit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [owner]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listedNfts(owner?: string, options?: any): AxiosPromise<ListedNfts200Response> {
      return localVarFp.listedNfts(owner, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loan(classId: string, nftId: string, options?: any): AxiosPromise<Loan200Response> {
      return localVarFp.loan(classId, nftId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loans(options?: any): AxiosPromise<Loans200Response> {
      return localVarFp.loans(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<MarketAll200Response> {
      return localVarFp
        .marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nFTMinter(classId: string, nftId: string, options?: any): AxiosPromise<NFTMinter200Response> {
      return localVarFp.nFTMinter(classId, nftId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftBids(classId: string, nftId: string, options?: any): AxiosPromise<BidderBids200Response> {
      return localVarFp.nftBids(classId, nftId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftListing(classId: string, nftId: string, options?: any): AxiosPromise<NftListing200Response> {
      return localVarFp.nftListing(classId, nftId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftmarketParams(options?: any): AxiosPromise<NftmarketParams200Response> {
      return localVarFp.nftmarketParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nftmintParams(options?: any): AxiosPromise<NftmintParams200Response> {
      return localVarFp.nftmintParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oracleAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<OracleAll200Response> {
      return localVarFp
        .oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {string} bidder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentStatus(classId: string, nftId: string, bidder: string, options?: any): AxiosPromise<PaymentStatus200Response> {
      return localVarFp.paymentStatus(classId, nftId, bidder, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} marketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price(marketId: string, options?: any): AxiosPromise<Price200Response> {
      return localVarFp.price(marketId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    priceAll(
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<PriceAll200Response> {
      return localVarFp
        .priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricefeedParams(options?: any): AxiosPromise<PricefeedParams200Response> {
      return localVarFp.pricefeedParams(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} marketId
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rawPriceAll(
      marketId: string,
      paginationKey?: string,
      paginationOffset?: string,
      paginationLimit?: string,
      paginationCountTotal?: boolean,
      options?: any,
    ): AxiosPromise<RawPriceAll200Response> {
      return localVarFp
        .rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} classId
     * @param {string} nftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordedIncentiveUnitId(classId: string, nftId: string, options?: any): AxiosPromise<RecordedIncentiveUnitId200Response> {
      return localVarFp.recordedIncentiveUnitId(classId, nftId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} subjectAddr
     * @param {string} denom
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reward(subjectAddr: string, denom: string, options?: any): AxiosPromise<Reward200Response> {
      return localVarFp.reward(subjectAddr, denom, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rewards(address: string, options?: any): AxiosPromise<Rewards200Response> {
      return localVarFp.rewards(address, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ununifidistParams(options?: any): AxiosPromise<UnunifidistParams200Response> {
      return localVarFp.ununifidistParams(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public accountAll(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .accountAll(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} subjectAddr
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public allRewards(subjectAddr: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .allRewards(subjectAddr, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary this line is used by starport scaffolding # 2
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public auction(id: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .auction(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public auctionAll(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public auctionParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .auctionParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary this line is used by starport scaffolding # 2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public balances(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .balances(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} bidder
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public bidderBids(bidder: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .bidderBids(bidder, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public cDPsList(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .cDPsList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary this line is used by starport scaffolding # 2
   * @param {string} owner
   * @param {string} collateralType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public cdp(owner: string, collateralType: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .cdp(owner, collateralType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public cdpAll(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public cdpParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .cdpParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public classAttributes(classId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .classAttributes(classId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} className
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public classIdsByName(className: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .classIdsByName(className, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} owner
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public classIdsByOwner(owner: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .classIdsByOwner(owner, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} owner
   * @param {string} collateralType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public depositAll(owner: string, collateralType: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .depositAll(owner, collateralType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Parameters queries the parameters of the module.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public ecosystemincentiveParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .ecosystemincentiveParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public incentiveParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .incentiveParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} incentiveUnitId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public incentiveUnit(incentiveUnitId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .incentiveUnit(incentiveUnitId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {number} nftLimit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public listedClass(classId: string, nftLimit: number, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .listedClass(classId, nftLimit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [nftLimit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public listedClasses(nftLimit?: number, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .listedClasses(nftLimit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [owner]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public listedNfts(owner?: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .listedNfts(owner, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {string} nftId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public loan(classId: string, nftId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .loan(classId, nftId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public loans(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .loans(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary this line is used by starport scaffolding # 2
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public marketAll(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {string} nftId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nFTMinter(classId: string, nftId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nFTMinter(classId, nftId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {string} nftId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nftBids(classId: string, nftId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nftBids(classId, nftId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {string} nftId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nftListing(classId: string, nftId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nftListing(classId, nftId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nftmarketParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nftmarketParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public nftmintParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .nftmintParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} marketId
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public oracleAll(
    marketId: string,
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {string} nftId
   * @param {string} bidder
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public paymentStatus(classId: string, nftId: string, bidder: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .paymentStatus(classId, nftId, bidder, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} marketId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public price(marketId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .price(marketId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public priceAll(
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public pricefeedParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .pricefeedParams(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} marketId
   * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
   * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
   * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
   * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public rawPriceAll(
    marketId: string,
    paginationKey?: string,
    paginationOffset?: string,
    paginationLimit?: string,
    paginationCountTotal?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} classId
   * @param {string} nftId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public recordedIncentiveUnitId(classId: string, nftId: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .recordedIncentiveUnitId(classId, nftId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} subjectAddr
   * @param {string} denom
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public reward(subjectAddr: string, denom: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .reward(subjectAddr, denom, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public rewards(address: string, options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .rewards(address, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public ununifidistParams(options?: AxiosRequestConfig) {
    return QueryApiFp(this.configuration)
      .ununifidistParams(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
